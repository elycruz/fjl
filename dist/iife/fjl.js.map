{"version":3,"file":"fjl.js","sources":["../../src/functionOps/curry.js","../../src/utils/utils.js","../../src/uncurried/jsPlatform/objectOpsUncurried.js","../../src/uncurried/objectOps/typeOf.js","../../src/uncurried/objectOps/is.js","../../src/uncurried/objectOps/assignDeep.js","../../src/uncurried/jsPlatform/functionOpsUncurried.js","../../src/uncurried/functionOps/apply.js","../../src/uncurried/objectOps/of.js","../../src/uncurried/jsPlatform/listOpsUncurried.js","../../src/uncurried/jsPlatform/arrayOpsUncurried.js","../../src/uncurried/functionOps/negate.js","../../src/functionOps/call.js","../../src/functionOps/apply.js","../../src/uncurried/functionOps/call.js","../../src/uncurried/functionOps/compose.js","../../src/uncurried/functionOps/curry.js","../../src/uncurried/functionOps/curry_.js","../../src/uncurried/functionOps/id.js","../../src/uncurried/functionOps/functionOpsUncurried.js","../../src/listOps/listOps.js","../../src/functionOps/compose.js","../../src/functionOps/negateP.js","../../src/functionOps/id.js","../../src/functionOps/flip.js","../../src/functionOps/until.js","../../src/functionOps/functionOps.js","../../src/booleanOps/is.js","../../src/booleanOps/booleanOps.js","../../src/objectOps/typeOf.js","../../src/objectOps/instanceOf.js","../../src/objectOps/is.js","../../src/objectOps/prop.js","../../src/objectOps/of.js","../../src/uncurried/listOps/listOpsUncurriedAggregation.js","../../src/uncurried/listOps/map.js","../../src/uncurried/listOps/listOpsUncurriedUtils.js","../../src/uncurried/listOps/listOpsUncurried.js","../../src/uncurried/objectOps/setTheoryOps.js","../../src/objectOps/objectOps.js","../../src/uncurried/jsPlatform/stringOpsUnCurried.js","../../src/stringOps/stringOps.js","../../generated-for-src/version.js","../../src/fjl.js"],"sourcesContent":["/**\r\n * @author elydelacruz\r\n * @created 12/6/2016.\r\n * @file fjl-curry/src/curry.js\r\n * @module curry {{curry: Function, curryN: Function, curry2: Function, curry3: Function, curry4: Function, curry5: Function, curry_: Function, curryN_: Function, curry2_: Function, curry3_: Function, curry4_: Function, curry5_: Function}}\r\n * @description Different curry implementations for modern javascript currying.\r\n * @todo Make code here more minimal (reuse small parts here).\r\n * @todo separate curry_ (and it's variants) into a separate file/module.\r\n */\r\n\r\n/**\r\n * PlaceHolder (__) constructor.\r\n * @constructor PlaceHolder\r\n * @private\r\n */\r\nconst PlaceHolder = function PlaceHolder() {},\r\n\r\n    /**\r\n     * Placeholder instance.\r\n     * @type {PlaceHolder}\r\n     */\r\n    placeHolderInstance = new PlaceHolder();\r\n\r\n/**\r\n * Curries a functionOps based on it's defined arity (argument's arrayOps expected length).\r\n * @functionOps curry\r\n * @param fn {Function}\r\n * @param argsToCurry {...*}\r\n * @returns {Function}\r\n */\r\nexport function curry (fn, ...argsToCurry) {\r\n    return (...args) => {\r\n        const concatedArgs = argsToCurry.concat(args);\r\n        return concatedArgs.length < fn.length ?\r\n            curry.apply(null, [fn].concat(concatedArgs)) :\r\n            fn.apply(null, concatedArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * Checks to see if value is a `PlaceHolder`.\r\n * @functionOps isPlaceHolder\r\n * @param instance {*}\r\n * @returns {boolean}\r\n */\r\nfunction isPlaceHolder (instance) {\r\n    return instance instanceof PlaceHolder;\r\n}\r\n\r\n/**\r\n * Replaces `placeholder` values in `listOps`.\r\n * @functionOps replacePlaceHolder\r\n * @param array {Array} - Array to replace placeholders in.\r\n * @param args {Array} - Args from to choose from to replace placeholders.\r\n * @returns {Array|*} - Returns passed in `listOps` with placeholders replaced by values in `args`.\r\n */\r\nfunction replacePlaceHolders (array, args) {\r\n    let out = array.map(element => {\r\n        if (!isPlaceHolder(element)) {\r\n            return element;\r\n        }\r\n        else if (args.length > 0) {\r\n            return args.shift();\r\n        }\r\n        return element;\r\n    });\r\n    return args.length > 0 ? out.concat(args) : out;\r\n}\r\n\r\n/**\r\n * Curries passed in functionOps up to given arguments length (can enforce arity via placeholder values (`__`)).\r\n * @functionOps curry_\r\n * @param fn {Function}\r\n * @param argsToCurry {...*}\r\n * @returns {Function}\r\n */\r\nexport function curry_ (fn, ...argsToCurry) {\r\n    return (...args) => {\r\n        let concatedArgs = replacePlaceHolders(argsToCurry, args),\r\n            placeHolders = concatedArgs.filter(isPlaceHolder),\r\n            canBeCalled = placeHolders.length === 0 &&\r\n                concatedArgs.length >= fn.length;\r\n        return canBeCalled ? fn.apply(null, concatedArgs) :\r\n            curry_.apply(null, [fn].concat(concatedArgs));\r\n    };\r\n}\r\n\r\n/**\r\n * Curries a functionOps up to given arity also enforces arity via placeholder values (`__`).\r\n * @functionOps curryN_\r\n * @param executeArity {Number}\r\n * @param fn {Function}\r\n * @param curriedArgs {...*} - Allows `Placeholder` (`__`) values.\r\n * @returns {Function} - Passed in functionOps wrapped in a functionOps for currying.\r\n */\r\nexport function curryN_ (executeArity, fn, ...curriedArgs) {\r\n    return (...args) => {\r\n        let concatedArgs = replacePlaceHolders(curriedArgs, args),\r\n            placeHolders = concatedArgs.filter(isPlaceHolder),\r\n            canBeCalled = (concatedArgs.length - placeHolders.length >= executeArity) || !executeArity;\r\n        return !canBeCalled ? curryN_.apply(null, [executeArity, fn].concat(concatedArgs)) :\r\n            fn.apply(null, concatedArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * Curries a functionOps up to a given arity.\r\n * @functionOps curryN\r\n * @param executeArity {Number}\r\n * @param fn {Function}\r\n * @param curriedArgs {...*}\r\n * @returns {Function}\r\n */\r\nexport function curryN (executeArity, fn, ...curriedArgs) {\r\n    return (...args) => {\r\n        let concatedArgs = curriedArgs.concat(args),\r\n            canBeCalled = (concatedArgs.length >= executeArity) || !executeArity;\r\n        return !canBeCalled ? curryN.apply(null, [executeArity, fn].concat(concatedArgs)) :\r\n            fn.apply(null, concatedArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * Place holder object (frozen) used by curry.\r\n * @type {PlaceHolder}\r\n */\r\nexport let __ = Object.freeze ? Object.freeze(placeHolderInstance) : placeHolderInstance,\r\n\r\n    /**\r\n     * Curries a functionOps up to an arity of 2 (takes into account placeholders `__` (arity enforcers)) (won't call functionOps until 2 or more args).\r\n     * @functionOps curry2_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry2_ = fn => curryN_(2, fn),\r\n\r\n    /**\r\n     * Curries a functionOps up to an arity of 3 (takes into account placeholders `__` (arity enforcers)) (won't call functionOps until 3 or more args).\r\n     * @functionOps curry3_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry3_ = fn => curryN_(3, fn),\r\n\r\n    /**\r\n     * Curries a functionOps up to an arity of 4 (takes into account placeholders `__` (arity enforcers))  (won't call functionOps until 4 or more args).\r\n     * @functionOps curry4_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry4_ = fn => curryN_(4, fn),\r\n\r\n    /**\r\n     * Curries a functionOps up to an arity of 5  (takes into account placeholders `__` (arity enforcers))  (won't call functionOps until 5 or more args).\r\n     * @functionOps curry5_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry5_ = fn => curryN_(5, fn),\r\n\r\n    /**\r\n     * Curries a functionOps up to an arity of 2 (won't call functionOps until 2 or more args).\r\n     * @functionOps curry2\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry2 = fn => curryN(2, fn),\r\n\r\n    /**\r\n     * Curries a functionOps up to an arity of 3 (won't call functionOps until 3 or more args).\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry3 = fn => curryN(3, fn),\r\n\r\n    /**\r\n     * Curries a functionOps up to an arity of 4 (won't call functionOps until 4 or more args).\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry4 = fn => curryN(4, fn),\r\n\r\n    /**\r\n     * Curries a functionOps up to an arity of 5 (won't call functionOps until 5 or more args).\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry5 = fn => curryN(5, fn);\r\n","/**\r\n * Created by elydelacruz on 7/22/2017.\r\n */\r\n\r\nimport {curry, curry2} from '../functionOps/curry';\r\n\r\nexport const\r\n\r\n    fPureTakesOne = name => (arg, f) => f[name](arg),\r\n\r\n    fPureTakes2 = name => (arg1, arg2, f) => f[name](arg1, arg2),\r\n\r\n    fPureTakesOneOrMore = name => (f, ...args) => f[name](...args),\r\n\r\n    fPureTakesOne_ = name => curry((arg, f) => f[name](arg)),\r\n\r\n    fPureTakes2_ = name => curry((arg1, arg2, f) => f[name](arg1, arg2)),\r\n\r\n    fPureTakesOneOrMore_ = name => curry2((f, ...args) => f[name](...args))\r\n;\r\n","/**\r\n * Created by elydelacruz on 9/6/2017.\r\n * Defines some of the platform methods for objects (the ones used within `fjl`) uncurried for use\r\n * throughout the library.  @note Doesn't include all methods for objects just the ones used in\r\n *  the library.\r\n * @todo change all files named '*UnCurried' to '*Uncurried'.\r\n */\r\n\r\nimport {fPureTakesOne} from '../../utils/utils';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns whether constructor has derived objectOps.\r\n     * @function module:jsPlatform.objectOpsUncurried.instanceOf\r\n     * @param instanceConstructor {Function} - Constructor.\r\n     * @param instance {*}\r\n     * @instance {*}\r\n     * @returns {Boolean}\r\n     */\r\n    instanceOf = (instanceConstructor, instance) =>\r\n        instance instanceof instanceConstructor,\r\n\r\n    /**\r\n     * @function module:jsPlatform.objectOpsUncurried.hasOwnProperty\r\n     * @param propName {*}\r\n     * @param typeInstance {*}\r\n     * @returns {Boolean}\r\n     */\r\n    hasOwnProperty = fPureTakesOne('hasOwnProperty'),\r\n\r\n    /**\r\n     * @function module:jsPlatform.objectOpsUncurried.length\r\n     * @param x {*}\r\n     * @returns {Number}\r\n     * @throws {Error} - Throws an error if value doesn't have a `length` property (\r\n     *  `null`, `undefined`, {Boolean}, Symbol, et. al.).\r\n     */\r\n    length = x => x.length,\r\n\r\n    /**\r\n     * @function module:jsPlatform.objectOpsUncurried.hasOwnProperty\r\n     * @param x {*}\r\n     * @returns {Number}\r\n     * @throws {Error} - Throws an error if value doesn't have a `toString`.\r\n     */\r\n    toString = x => x.toString(),\r\n\r\n    /**\r\n     * Gets own enumerable keys of passed in object (`Object.keys`).\r\n     * @function module:jsPlatform.objectOpsUncurried.keys\r\n     * @param obj {*}\r\n     * @returns {Array<String>}\r\n     */\r\n    keys = obj => Object.keys(obj),\r\n\r\n    /**\r\n     * Defined as `Object.assign` else is the same thing but shimmed.\r\n     * @function module:jsPlatform.objectOpsUncurried.assign\r\n     * @param obj0 {Object}\r\n     * @param objs {...{Object}}\r\n     * @returns {Object}\r\n     */\r\n    assign = (() =>\r\n        Object.assign ?\r\n            (obj0, ...objs) => Object.assign(obj0, ...objs) :\r\n            (obj0, ...objs) => objs.reduce((topAgg, obj) => {\r\n                return keys(obj).reduce((agg, key) => {\r\n                    agg[key] = obj[key];\r\n                    return agg;\r\n                }, topAgg);\r\n            }, obj0))();\r\n","/**\r\n * Created by elyde on 12/18/2016.\r\n */\r\nconst _Number = Number.name,\r\n    _NaN = 'NaN',\r\n    _Null = 'Null',\r\n    _Undefined = 'Undefined',\r\n    _undefined = 'undefined';\r\n\r\n/**\r\n * Returns the class name of an object from it's class stringOps.\r\n * @note Returns 'NaN' if value `isNaN` and value type is 'Number'.\r\n * @functionOps module:fjl.typeOf\r\n * @param value {*}\r\n * @returns {string} - Constructor's name property if not null or undefined (in which case a\r\n *  name representing those types is returned ('Null' and or 'Undefined' (es6 compliant))).\r\n */\r\nexport function typeOf (value) {\r\n    let retVal;\r\n    if (typeof value === _undefined) {\r\n        retVal = _Undefined;\r\n    }\r\n    else if (value === null) {\r\n        retVal = _Null;\r\n    }\r\n    else {\r\n        let constructorName = (value).constructor.name;\r\n        retVal = constructorName === _Number && isNaN(value) ?\r\n            _NaN : constructorName;\r\n    }\r\n    return retVal;\r\n}\r\n","/**\r\n * Created by elyde on 12/18/2016.\r\n * @module is\r\n * @todo remove `isset`, `isEmpty` and `notEmptyAndOfType`\r\n */\r\n\r\nimport {typeOf} from './typeOf';\r\n\r\nimport {instanceOf, length, keys, hasOwnProperty} from '../jsPlatform/objectOpsUncurried';\r\n\r\nlet _String = String.name,\r\n    _Number = Number.name,\r\n    _Object = Object.name,\r\n    _Boolean = Boolean.name,\r\n    _Function = Function.name,\r\n    _Array = Array.name,\r\n    _Symbol = 'Symbol',\r\n    _Map = 'Map',\r\n    _Set = 'Set',\r\n    _WeakMap = 'WeakMap',\r\n    _WeakSet = 'WeakSet',\r\n    _Null = 'Null',\r\n    _Undefined = 'Undefined';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns whether a value is a functionOps or not.\r\n     * @functionOps module:is.isFunction\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isFunction = value => instanceOf(Function, value),\r\n\r\n    /**\r\n     * Type checker.  Note** The `Type` passed in, if a constructor, should\r\n     * be a named constructor/functionOps-instance;  E.g.,\r\n     * ```\r\n     *  functionOps SomeName () {} // or\r\n     *  var SomeName = functionOps SomeName () {} // or\r\n     *  class SomeName {}\r\n     * ```\r\n     * @functionOps module:fjl.isType\r\n     * @param type {Function|String} - Constructor or constructor name\r\n     * @param obj {*}\r\n     * @return {Boolean}\r\n     */\r\n    isType = (type, obj) => typeOf(obj) === (isFunction(type) ? type.name : type),\r\n\r\n    /**\r\n     * Checks if `value` is an es2015 `class`.\r\n     * @functionOps module:is.isClass\r\n     * @param x {*}\r\n     * @returns {boolean}\r\n     */\r\n    isClass = x => x && /^\\s{0,3}class\\s{1,3}/.test(x.toString().substr(0, 10)),\r\n\r\n    /**\r\n     * Returns a booleanOps depicting whether a value is callable or not.\r\n     * @functionOps module:is.isCallable\r\n     * @tentative\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isCallable = x => isFunction(x) && !isClass(x),\r\n\r\n    /**\r\n     * Checks if value is an arrayOps.\r\n     * @functionOps module:is.isArray\r\n     * @param value {*}\r\n     * @returns {boolean}\r\n     */\r\n    isArray = value => isType(Array, value),\r\n\r\n    /**\r\n     * Checks whether value is an objectOps or not.\r\n     * @functionOps module:is.isObject\r\n     * @param value\r\n     * @returns {Boolean}\r\n     */\r\n    isObject = value => isType(_Object, value),\r\n\r\n    /**\r\n     * Checks if value is a booleanOps.\r\n     * @functionOps module:is.isBoolean\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isBoolean = value => isType(_Boolean, value),\r\n\r\n    /**\r\n     * Checks if value is a valid numberOps (also checks if isNaN so that you don't have to).\r\n     * @functionOps module:is.isNumber\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isNumber = value => isType(_Number, value),\r\n\r\n    /**\r\n     * Checks whether value is a stringOps or not.\r\n     * @functionOps module:is.isString\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isString = value => isType(_String, value),\r\n\r\n    /**\r\n     * Checks whether value is of `Map` or not.\r\n     * @functionOps module:is.isMap\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isMap = value => isType(_Map, value),\r\n\r\n    /**\r\n     * Checks whether value is of `Set` or not.\r\n     * @functionOps module:is.isSet\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isSet = value => isType(_Set, value),\r\n\r\n    /**\r\n     * Checks whether value is of `WeakMap` or not.\r\n     * @functionOps module:is.isWeakMap\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isWeakMap = value => isType(_WeakMap, value),\r\n\r\n    /**\r\n     * Checks whether value is of `WeakSet` or not.\r\n     * @functionOps module:is.isWeakSet\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isWeakSet = value => isType(_WeakSet, value),\r\n\r\n    /**\r\n     * Checks if value is undefined.\r\n     * @functionOps module:is.isUndefined\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isUndefined = value => isType(_Undefined, value),\r\n\r\n    /**\r\n     * Checks if value is null.\r\n     * @functionOps module:is.isNull\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isNull = value => isType(_Null, value),\r\n\r\n    /**\r\n     * Checks if value is a `Symbol`.\r\n     * @functionOps module:is.isSymbol\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isSymbol = value => isType(_Symbol, value),\r\n\r\n    /**\r\n     * @tentative\r\n     */\r\n    isPromise = value => isType('Promise', value),\r\n\r\n    /**\r\n     * Checks if given `x` is one of the four\r\n     * \"usable\" immutable JS primitives; I.e.,\r\n     *  One of [String, Boolean, Number, Symbol]\r\n     * @function module:is.isUsableImmutablePrimitive\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isUsableImmutablePrimitive = x => {\r\n        const typeOfX = typeOf(x);\r\n        return [_String, _Number, _Boolean, _Symbol]\r\n            .some(Type => Type === typeOfX);\r\n    },\r\n\r\n    /**\r\n     * Checks if !length.\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyList = x => length(x) === 0,\r\n\r\n    /**\r\n     * Checks if objectOps has own properties/enumerable-props or not.\r\n     * @param obj {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyObject = obj => isEmptyList(keys(obj)),\r\n\r\n    /**\r\n     * Checks if collection is empty or not (Map, WeakMap, WeakSet, Set etc.).\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyCollection = x => x.size === 0,\r\n\r\n    /**\r\n     * Checks to see if passed in argument is empty.\r\n     * @functionOps module:is.empty\r\n     * @param value {*} - Value to check.\r\n     * @returns {Boolean}\r\n     */\r\n    isEmpty = value => {\r\n        let typeOfValue = typeOf(value),\r\n            retVal;\r\n\r\n        if (!value) { // '', 0, `null`, `undefined` or `false` then is empty\r\n            retVal = true;\r\n        }\r\n        else if (typeOfValue === _Array || typeOfValue === _Function) {\r\n            retVal = isEmptyList(value);\r\n        }\r\n        else if (typeOfValue === _Number && value !== 0) {\r\n            retVal = false;\r\n        }\r\n        else if (typeOfValue === _Object) {\r\n            retVal = isEmptyObject(value);\r\n        }\r\n        else if (hasOwnProperty('size', value)) {\r\n            retVal = isEmptyCollection(value);\r\n        }\r\n        else {\r\n            retVal = !value;\r\n        }\r\n        return retVal;\r\n    },\r\n\r\n    /**\r\n     * Returns true if an element is not empty and is of type.\r\n     * @functionOps module:is.notEmptyAndOfType\r\n     * @param type {String|Function} - Type to check against (stringOps name or actual constructor).\r\n     * @param value {*} - Value to check.\r\n     * @returns {Boolean}\r\n     */\r\n    notEmptyAndOfType = (type, value) => !isEmpty(value) && isType(type, value),\r\n\r\n    /**\r\n     * Returns whether passed in values is defined and not null.\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isset = x => !isNull(x) && !isUndefined(x);\r\n","\r\nimport {isObject} from './is';\r\n\r\nimport {keys, hasOwnProperty} from '../jsPlatform/objectOpsUncurried';\r\n\r\nexport const\r\n    /**\r\n     * Merges all objects down into one.\r\n     * @function module:jsPlatform.objectOpsUncurried.assignDeep\r\n     * @param obj0 {Object}\r\n     * @param objs {...{Object}}\r\n     * @returns {Object}\r\n     */\r\n    assignDeep = (obj0, ...objs) =>\r\n        objs.reduce((topAgg, obj) =>\r\n                keys(obj).reduce((agg, key) => {\r\n                    let propDescription = Object.getOwnPropertyDescriptor(agg, key);\r\n                    // If property is not writable move to next item in collection\r\n                    if (hasOwnProperty(key, agg) && propDescription &&\r\n                        !(propDescription.get && propDescription.set) &&\r\n                        !propDescription.writable) {\r\n                        return agg;\r\n                    }\r\n                    if (isObject(agg[key]) && isObject(obj[key])) {\r\n                        assignDeep(agg[key], obj[key]);\r\n                    }\r\n                    else { agg[key] = obj[key]; }\r\n                    return agg;\r\n                }, topAgg)\r\n            , obj0);\r\n","/**\r\n * Created by elydelacruz on 9/7/2017.\r\n */\r\nexport const\r\n\r\n    /**\r\n     * Functional `apply` functionOps (takes no context).\r\n     * @function module:jsPlatform.functionOps.apply\r\n     * @param fn {Function}\r\n     * @param args {Array|*}\r\n     * @returns {*}\r\n     */\r\n    apply = (fn, args) => fn.apply(null, args),\r\n\r\n    /**\r\n     * Functional `call` functionOps (takes no context).\r\n     * @function module:fnOperators.call\r\n     * @param fn {Function}\r\n     * @param args ...{*}\r\n     * @returns {*}\r\n     */\r\n    call = (fn, ...args) => apply(fn, args);\r\n","/**\r\n * Created by elydelacruz on 7/22/2017.\r\n */\r\n\r\n/**\r\n * Functional `apply` functionOps (takes no context).\r\n * @functionOps module:functionOps.apply\r\n * @param fn {Function}\r\n * @param args {*}\r\n * @returns {*}\r\n */\r\nexport {apply} from '../jsPlatform/functionOpsUncurried';\r\n","import {isFunction, isUsableImmutablePrimitive, isset} from './is';\r\nimport {hasOwnProperty} from '../jsPlatform/objectOpsUncurried';\r\nimport {apply} from '../functionOps/apply';\r\n\r\nexport const of = (x, ...args) => {\r\n    if (!isset(x)) { return undefined; }\r\n    const constructor = x.constructor;\r\n    if (hasOwnProperty('of', constructor)) {\r\n        return apply(constructor.of, args);\r\n    }\r\n    else if (isUsableImmutablePrimitive(x)) {\r\n        return apply(constructor, args);\r\n    }\r\n    else if (isFunction(constructor)) {\r\n        return new constructor(...args);\r\n    }\r\n    return undefined;\r\n};\r\n","/**\r\n *  List operations that overlap (apart from globally overlapping props and functions like `length` and `toString`)\r\n *      on both strings and arrays.\r\n */\r\n\r\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from '../../utils/utils';\r\n\r\n// export {length, toString} from './objectOpsUnCurried';\r\n\r\nexport const\r\n\r\n    concat = fPureTakesOneOrMore('concat'),\r\n\r\n    slice = fPureTakes2('slice'),\r\n\r\n    includes = (() => 'includes' in Array.prototype ?\r\n            fPureTakesOne('includes') :\r\n            (value, xs) => xs.indexOf(value) > -1)(),\r\n\r\n    /**\r\n     * Searches list/list-like for given element `x`.\r\n     * @function module:jsPlatform.listOpsUncurried.indexOf\r\n     * @param x {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like to look in.\r\n     * @returns {Number} - `-1` if element not found else index at which it is found.\r\n     */\r\n    indexOf = fPureTakesOne('indexOf'),\r\n\r\n    lastIndexOf = fPureTakesOne('lastIndexOf')\r\n\r\n;\r\n","/**\r\n * Created by elyde on 7/20/2017.\r\n * Functional versions of common array methods (`map`, `filter`, etc.) (un-curried);\r\n * @todo updated doc blocks to list correct/updated module name.\r\n */\r\n\r\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from '../../utils/utils';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Array.prototype.reverse generator (generates a functionOps that calls the prototype version or a\r\n     * shimmed version if it doesn't exist).\r\n     * @returns {Function}\r\n     */\r\n    defineReverse = () =>\r\n        Array.prototype.reverse ? x => x.reverse() :\r\n            x => x.reduceRight((agg, item) => {\r\n                agg.push(item);\r\n                return agg;\r\n            }, []),\r\n\r\n    /**\r\n     * Maps a functionOps to functor (listOps etc.).\r\n     * @functionOps module:arrayOperators.map\r\n     * @param fn {Function}\r\n     * @param functor {Array|{map: {Function}}}\r\n     * @returns {Array|{map: {Function}}}\r\n     */\r\n    map = fPureTakesOne('map'),\r\n\r\n    /**\r\n     * Filters a functor (listOps etc.) with passed in functionOps.\r\n     * @functionOps module:arrayOperators.filter\r\n     * @param fn {Function}\r\n     * @param functor {Array|{filter: {Function}}}\r\n     * @returns {Array|{filter: {Function}}}\r\n     */\r\n    filter = fPureTakesOne('filter'),\r\n\r\n    /**\r\n     * Reduces a foldable (listOps etc.) with passed in functionOps.\r\n     * @functionOps module:arrayOperators.reduce\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduce: {Function}}}\r\n     * @returns {Array|{reduce: {Function}}}\r\n     */\r\n    reduce = fPureTakes2('reduce'),\r\n\r\n    /**\r\n     * Reduces a foldable (listOps etc.) from the right with passed in functionOps.\r\n     * @functionOps module:arrayOperators.reduceRight\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduceRight: {Function}}}\r\n     * @returns {Array|{reduceRight: {Function}}}\r\n     */\r\n    reduceRight = fPureTakes2('reduceRight'),\r\n\r\n    /**\r\n     * For each on functor (Array|Object|etc.).\r\n     * @param fn {Function}\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type of objectOps you pass in unless it doesn't have a `forEach` method.\r\n     * @throws {Error} - When passed in functor doesn't have a `forEach` method.\r\n     */\r\n    forEach = fPureTakesOne('forEach'),\r\n\r\n    /**\r\n     * Returns `true` if `fn` (predicate) returns true for at least one item\r\n     * in functor else returns `false`.\r\n     * @param fn {Function} - Predicate.\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in objectOps doesn't have a `some` method.\r\n     */\r\n    some = fPureTakesOne('some'),\r\n\r\n    /**\r\n     * Returns `true` if `fn` (predicate) returns true for all items in functor else returns `false`.\r\n     * @param fn {Function} - Predicate.\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in objectOps doesn't have an `every` method.\r\n     */\r\n    every = fPureTakesOne('every'),\r\n\r\n    /**\r\n     * Concats/appends all functors onto the end of first functor.\r\n     * Note:  functors passed in after the first one must be of the same type.\r\n     * @param functor {Array|Object|*}\r\n     * @param ...functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in objectOps doesn't have an `every` method.\r\n     */\r\n    concat = fPureTakesOneOrMore('concat'),\r\n\r\n    /**\r\n     * Array.prototype.join\r\n     * @functionOps module:listPrelude.join\r\n     * @param separator {String|RegExp}\r\n     * @param arr {Array}\r\n     * @returns {String}\r\n     */\r\n    join = fPureTakesOne('join'),\r\n\r\n    /**\r\n     * Same as Array.prototype.slice\r\n     * @param separator {String|RegExp}\r\n     * @param arr{Array}\r\n     * @returns {Array}\r\n     */\r\n    slice = fPureTakes2('slice'),\r\n\r\n    /**\r\n     * Same as Array.prototype.push\r\n     * @param item {*}\r\n     * @param arr {Array}\r\n     * @returns {Number}\r\n     */\r\n    push = fPureTakesOneOrMore('push'),\r\n\r\n    /**\r\n     * Reverses an listOps (shimmed if not exists).\r\n     * @functionOps module:listPrelude.reverse\r\n     * @return {Array}\r\n     */\r\n    reverse = defineReverse();\r\n","/**\r\n * @module negate\r\n */\r\n\r\nimport {apply} from './apply';\r\n\r\nimport {reverse} from '../jsPlatform/arrayOpsUncurried';\r\n\r\nexport const\r\n\r\n    negateF = fn => (a, b) => !fn(a, b),\r\n\r\n    negateF3 = fn => (a, b, c) => !fn(a, b, c),\r\n\r\n    negateF4 = fn => (a, b, c, d) => !fn(a, b, c, d),\r\n\r\n    negateF5 = fn => (a, b, c, d, e) => !fn(a, b, c, d, e),\r\n\r\n    /**\r\n     * Negates a javascript-'generic' predicate; `Function<element, index, list>`.\r\n     * @function module:functionOps.negateP\r\n     * @param fn {Function}\r\n     * @returns {Function} - Negated predicate\r\n     */\r\n    negateP = negateF3,\r\n\r\n    /**\r\n     * Returns a new function which is the dual of `fn` (or the negated version of `fn`).\r\n     * @function module:functionOpsUncurried.negateFMany\r\n     * @param fn {Function}\r\n     * @returns {Function<...args>}\r\n     */\r\n    negateFMany = fn => (...args) => !apply(fn, reverse(args));\r\n","/**\r\n * Created by elydelacruz on 7/22/2017.\r\n */\r\nimport {curry2} from './curry';\r\n\r\nimport {call as pureCall} from '../uncurried/jsPlatform/functionOpsUncurried';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Functional `call` functionOps (takes no context).\r\n     * @functionOps module:fnOperators.call\r\n     * @param fn {Function}\r\n     * @param args {*}\r\n     * @returns {*}\r\n     */\r\n    call = curry2(pureCall);\r\n","/**\r\n * Created by elydelacruz on 7/22/2017.\r\n */\r\nimport {curry} from './curry';\r\n\r\nimport {apply as pureApply} from '../uncurried/jsPlatform/functionOpsUncurried';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Functional `apply` functionOps (takes no context).\r\n     * @functionOps module:fnOperators.apply\r\n     * @param fn {Function}\r\n     * @param args {*}\r\n     * @returns {*}\r\n     */\r\n    apply = curry(pureApply);\r\n","/**\r\n * Created by elydelacruz on 7/22/2017.\r\n */\r\n\r\n/**\r\n * Functional `call` functionOps (takes no context).\r\n * @functionOps module:functionOps.call\r\n * @param fn {Function}\r\n * @param args {*}\r\n * @returns {*}\r\n */\r\nexport {call} from '../jsPlatform/functionOpsUncurried';\r\n","import {reduceRight} from '../jsPlatform/arrayOpsUncurried';\r\n\r\n/**\r\n * Composes all functions passed in from right to left passing each functions return value to\r\n * the functionOps on the left of itself.\r\n * @function module:fjl.compose\r\n * @type {Function}\r\n * @param args {...Function}\r\n * @returns {Function}\r\n */\r\nexport const compose = (...args) => arg0 => reduceRight((value, fn) => fn(value), arg0, args);\r\n","/**\r\n * @author elydelacruz\r\n * @created 12/6/2016.\r\n * @module curry\r\n * @description Curry strict and curry arbitrarily functions `curry` and `curryN`.\r\n */\r\n\r\nimport {apply} from './apply';\r\n\r\nimport {append, length} from '../listOps/listOpsUncurried';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Curries a functionOps based on it's defined arity (argument's arrayOps expected length).\r\n     * @functionOps curry\r\n     * @param fn {Function}\r\n     * @param argsToCurry {...*}\r\n     * @returns {Function}\r\n     */\r\n    curry = (fn, ...argsToCurry) => {\r\n        return (...args) => {\r\n            const concatedArgs = append(argsToCurry, args);\r\n            return length(concatedArgs) < length(fn) ?\r\n                apply(curry, append([fn], concatedArgs)) :\r\n                apply(fn, concatedArgs);\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Curries a functionOps up to a given arity.\r\n     * @functionOps curryN\r\n     * @param executeArity {Number}\r\n     * @param fn {Function}\r\n     * @param curriedArgs {...*}\r\n     * @returns {Function}\r\n     */\r\n    curryN = (executeArity, fn, ...curriedArgs) => {\r\n        return (...args) => {\r\n            let concatedArgs = append(curriedArgs, args),\r\n                canBeCalled = (length(concatedArgs) >= executeArity) || !executeArity;\r\n            return !canBeCalled ? apply(curryN, append([executeArity, fn], concatedArgs)) :\r\n                apply(fn, concatedArgs);\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Curries a functionOps up to an arity of 2 (won't call functionOps until 2 or more args).\r\n     * @functionOps curry2\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry2 = fn => curryN(2, fn),\r\n\r\n    /**\r\n     * Curries a functionOps up to an arity of 3 (won't call functionOps until 3 or more args).\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry3 = fn => curryN(3, fn),\r\n\r\n    /**\r\n     * Curries a functionOps up to an arity of 4 (won't call functionOps until 4 or more args).\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry4 = fn => curryN(4, fn),\r\n\r\n    /**\r\n     * Curries a functionOps up to an arity of 5 (won't call functionOps until 5 or more args).\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry5 = fn => curryN(5, fn);\r\n","/**\r\n * @author elydelacruz\r\n * @created 12/6/2016.\r\n * @file fjl-curry/src/curry.js\r\n * @module curry {{curry: Function, curryN: Function, curry2: Function, curry3: Function, curry4: Function, curry5: Function, curry_: Function, curryN_: Function, curry2_: Function, curry3_: Function, curry4_: Function, curry5_: Function}}\r\n * @description Different curry implementations for modern javascript currying.\r\n * @todo Make code here more minimal (reuse small parts here).\r\n */\r\n\r\nimport {apply} from './apply';\r\n\r\nimport {append, map, filter, length} from '../listOps/listOpsUncurried';\r\n\r\n/**\r\n * PlaceHolder (__) constructor.\r\n * @constructor PlaceHolder\r\n * @private\r\n */\r\nconst PlaceHolder = function PlaceHolder() {},\r\n\r\n    /**\r\n     * Placeholder instance.\r\n     * @type {PlaceHolder}\r\n     */\r\n    placeHolderInstance = new PlaceHolder();\r\n\r\n/**\r\n * Checks to see if value is a `PlaceHolder`.\r\n * @functionOps isPlaceHolder\r\n * @param instance {*}\r\n * @returns {boolean}\r\n */\r\nfunction isPlaceHolder (instance) {\r\n    return instance instanceof PlaceHolder;\r\n}\r\n\r\n/**\r\n * Replaces `placeholder` values in `listOps`.\r\n * @functionOps replacePlaceHolder\r\n * @param array {Array} - Array to replace placeholders in.\r\n * @param args {Array} - Args from to choose from to replace placeholders.\r\n * @returns {Array|*} - Returns passed in `listOps` with placeholders replaced by values in `args`.\r\n */\r\nfunction replacePlaceHolders (array, args) {\r\n    let out = map(element => {\r\n            if (!isPlaceHolder(element)) { return element; }\r\n            else if (length(args)) { return args.shift(); }\r\n            return element;\r\n        }, array);\r\n    return length(args) ? append(out, args) : out;\r\n}\r\n\r\n/**\r\n * Curries passed in functionOps up to given arguments length (can enforce arity via placeholder values (`__`)).\r\n * @functionOps curry_\r\n * @param fn {Function}\r\n * @param argsToCurry {...*}\r\n * @returns {Function}\r\n */\r\nexport function curry_ (fn, ...argsToCurry) {\r\n    return (...args) => {\r\n        let concatedArgs = replacePlaceHolders(argsToCurry, args),\r\n            placeHolders = filter(isPlaceHolder, concatedArgs),\r\n            canBeCalled = length(placeHolders) === 0 &&\r\n                length(concatedArgs) >= length(fn);\r\n        return canBeCalled ? apply(fn, concatedArgs) :\r\n            apply(curry_, append([fn], concatedArgs));\r\n    };\r\n}\r\n\r\n/**\r\n * Curries a functionOps up to given arity also enforces arity via placeholder values (`__`).\r\n * @functionOps curryN_\r\n * @param executeArity {Number}\r\n * @param fn {Function}\r\n * @param curriedArgs {...*} - Allows `Placeholder` (`__`) values.\r\n * @returns {Function} - Passed in functionOps wrapped in a functionOps for currying.\r\n */\r\nexport function curryN_ (executeArity, fn, ...curriedArgs) {\r\n    return (...args) => {\r\n        let concatedArgs = replacePlaceHolders(curriedArgs, args),\r\n            placeHolders = filter(isPlaceHolder, concatedArgs),\r\n            canBeCalled = (length(concatedArgs) - length(placeHolders) >= executeArity) || !executeArity;\r\n        return !canBeCalled ?\r\n            apply(curryN_, append([executeArity, fn], concatedArgs)) :\r\n            apply(fn, concatedArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * Place holder object (frozen) used by curry.\r\n * @type {PlaceHolder}\r\n */\r\nexport let __ = Object.freeze ? Object.freeze(placeHolderInstance) : placeHolderInstance,\r\n\r\n    /**\r\n     * Curries a functionOps up to an arity of 2 (takes into account placeholders `__` (arity enforcers)) (won't call functionOps until 2 or more args).\r\n     * @functionOps curry2_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry2_ = fn => curryN_(2, fn),\r\n\r\n    /**\r\n     * Curries a functionOps up to an arity of 3 (takes into account placeholders `__` (arity enforcers)) (won't call functionOps until 3 or more args).\r\n     * @functionOps curry3_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry3_ = fn => curryN_(3, fn),\r\n\r\n    /**\r\n     * Curries a functionOps up to an arity of 4 (takes into account placeholders `__` (arity enforcers))  (won't call functionOps until 4 or more args).\r\n     * @functionOps curry4_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry4_ = fn => curryN_(4, fn),\r\n\r\n    /**\r\n     * Curries a functionOps up to an arity of 5  (takes into account placeholders `__` (arity enforcers))  (won't call functionOps until 5 or more args).\r\n     * @functionOps curry5_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry5_ = fn => curryN_(5, fn)\r\n\r\n;\r\n","/**\r\n * @module id\r\n */\r\n\r\n/**\r\n * Returns passed in parameter.\r\n * @param x {*}\r\n * @returns {*}\r\n */\r\nexport const id = x => x;\r\n","/**\r\n * @module functionOpsUncurried\r\n */\r\nexport * from './apply';\r\nexport * from './call';\r\nexport * from './compose';\r\nexport * from './curry';\r\nexport * from './curry_';\r\nexport * from './flip';\r\nexport * from './id';\r\nexport * from './negate';\r\nexport * from './until';\r\n","/**\r\n * Array operators module.\r\n * @module listOps\r\n * @todo decide whether to throw errors where functions cannot function without a specific type or to return undefined (and also determine which cases are ok for just returning undefined).\r\n * @todo code un-performant shorthand in `listOps`\r\n */\r\n\r\n/**\r\n * List operators.\r\n * @module listOps\r\n * @todo decide whether to throw errors where functions cannot function without a specific type or to\r\n *  return undefined (and also determine which cases are ok for just returning undefined).\r\n * @todo code unperformant shorthand in `listOps`\r\n * @todo rename monoid functions to normal functions since we are not really defining methods for monoids here.\r\n */\r\nimport {\r\n    curry, curry2\r\n}\r\n    from '../uncurried/functionOps/functionOpsUncurried';\r\n\r\n// Uncurried methods import\r\nimport {\r\n    append as _append, appendMany as _appendMany, all as _all, and as _and, or as _or, any as _any, find as _find,\r\n    findIndex as _findIndex, findIndices as _findIndices, zip as _zip, zipN as _zipN, zipWith as _zipWith,\r\n    unzip as _unzip, unzipN as _unzipN, map as _map, mapAccumL as _mapAccumL, mapAccumR as _mapAccumR, zipWithN as _zipWithN,\r\n    elem as _elem, notElem as _notElem, elemIndex as _elemIndex, elemIndices as _elemIndices, lookup as _lookup,\r\n    head as _head, last as _last, init as _init, tail as _tail, uncons as _uncons, length as _length,\r\n    reverse as _reverse, intersperse as _intersperse, intercalate as _intercalate, transpose as _transpose,\r\n    subsequences as _subsequences, permutations as _permutations, isEmpty as _isEmpty, iterate as _iterate,\r\n    repeat as _repeat, replicate as _replicate, cycle as _cycle, take as _take, drop as _drop, splitAt as _splitAt,\r\n    foldl as _foldl, foldl1 as _foldl1, foldr as _foldr, foldr1 as _foldr1, unfoldr as _unfoldr, concat as _concat,\r\n    concatMap as _concatMap, takeWhile as _takeWhile, dropWhile as _dropWhile, dropWhileEnd as _dropWhileEnd,\r\n    partition as _partition, at as _at, span as _span, breakOnList as _breakOnList, stripPrefix as _stripPrefix,\r\n    group as _group, inits as _inits, tails as _tails, isPrefixOf as _isPrefixOf, isSuffixOf as _isSuffixOf,\r\n    isInfixOf as _isInfixOf, isSubsequenceOf as _isSubsequenceOf, filter as _filter, sum as _sum, product as _product,\r\n    maximum as _maximum, maximumBy as _maximumBy, minimum as _minimum, minimumBy as _minimumBy, nub as _nub,\r\n    remove as _remove, insert as _insert, insertBy as _insertBy, nubBy as _nubBy, removeBy as _removeBy,\r\n    removeFirstsBy as _removeFirstsBy, unionBy as _unionBy, sort as _sort, sortOn as _sortOn, sortBy as _sortBy,\r\n    complement as _complement, difference as _difference, union as _union, intersect as _intersect,\r\n    intersectBy as _intersectBy, groupBy as _groupBy\r\n}\r\n    from '../uncurried/listOps/listOpsUncurried';\r\n\r\n// Single arity methods (and single or more arg functions)\r\nexport {\r\n    and, or, zipN, unzip, unzipN, head, last, init, tail, uncons, isEmpty, concat, length, reverse, transpose, subsequences,\r\n    permutations, group, inits, tails, sum, product, maximum, minimum, sort, nub\r\n}\r\n    from '../uncurried/listOps/listOpsUncurried';\r\n\r\n// Uncurried methods export\r\nexport {\r\n    _append, _appendMany, _all, _and, _or, _any, _find, _findIndex, _findIndices, _zip, _zipN, _zipWith,\r\n    _unzip, _unzipN, _map, _mapAccumL, _mapAccumR, _elem, _notElem, _elemIndex, _elemIndices, _lookup,\r\n    _head, _last, _init, _tail, _uncons, _length, _reverse, _intersperse, _intercalate, _transpose,\r\n    _subsequences, _permutations, _isEmpty, _iterate, _repeat, _replicate, _cycle, _take,\r\n    _drop, _splitAt, _foldl, _foldl1, _foldr, _foldr1, _unfoldr, _concat, _concatMap, _takeWhile, _dropWhile,\r\n    _dropWhileEnd, _partition, _at, _span, _breakOnList, _stripPrefix, _group, _inits, _tails, _isPrefixOf,\r\n    _isSuffixOf, _isInfixOf, _isSubsequenceOf, _filter, _sum, _product, _maximum, _maximumBy, _minimum, _minimumBy,\r\n    _nub, _remove, _insert, _insertBy, _nubBy, _removeBy, _removeFirstsBy, _unionBy, _sort, _sortOn, _sortBy,\r\n    _complement, _difference, _union, _intersect, _intersectBy, _groupBy\r\n};\r\n\r\n// Exported internals\r\nexport const\r\n\r\n    /**\r\n     * Append two lists, i.e.,\r\n     * ```\r\n     * append([x1, ..., xm], [y1, ..., yn]) // outputs: [x1, ..., xm, y1, ..., yn]\r\n     * append([x1, ..., xm], [y1, ...]) // outputs: [x1, ..., xm, y1, ...]\r\n     * ```\r\n     * If the first list is not finite, the result is the first list.\r\n     * @haskellType `append :: List a => a -> a -> a`\r\n     * @function module:listOps.append\r\n     * @param xs1 {Array|String|*} - list or list like.\r\n     * @param xs2 {Array|String|*} - list or list like.\r\n     * @returns {Array|String|*} - Same type as list like passed in.\r\n     */\r\n    append = curry(_append),\r\n\r\n    /**\r\n     * Append two or more lists, i.e., same as `append` but for two ore more lists.\r\n     * @haskellType `appendMany :: List a => a -> [a] -> a\r\n     * @note In `@haskellType` we wrote `[a]` only to keep the haskell type valid though note in javascript\r\n     *  this is actually different since the function converts the zero ore more parameters into an array containing such for us.\r\n     * @function module:listOps.appendMany\r\n     * @param x {Array|String|*}\r\n     * @param args ...{Array|String|*} - Lists or lists likes.\r\n     * @returns {Array|String|*} - Same type as first list or list like passed in.\r\n     */\r\n    appendMany = curry2(_appendMany),\r\n\r\n    /**\r\n     * Map a function over all the elements of a container and concatenate the resulting lists.\r\n     * @haskellType `concatMap :: Foldable t => (a -> [b]) -> t a -> [b]`\r\n     * @function module:listOps.concatMap\r\n     * @param fn {Function}\r\n     * @param foldableOfA {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    concatMap = curry2(_concatMap),\r\n\r\n    /**\r\n     * @function module:listOps.map\r\n     * @param fn {Function} - Function to map on functor item(s).\r\n     * @param xs {Array|String|*} - Functor.\r\n     * @returns {Array|String|*} - Functor type that is passed in.\r\n     */\r\n    map = curry(_map),\r\n\r\n    /**\r\n     * Takes an element and a list and `intersperses' that element between the elements of the list. For example\r\n     * @function module:listOps.intersperse\r\n     * @note In our version of the function javascript is loosely typed so, so is our function (to much overhead to make\r\n     *  it typed) so `between` can be any value.\r\n     * @param between {*} - Should be of the same type of elements contained in list.\r\n     * @param arr {Array|String|*} - List.\r\n     * @returns {Array|String|*}\r\n     */\r\n    intersperse = curry(_intersperse),\r\n\r\n    /**\r\n     * `intercalate xs xss` is equivalent to (concat (intersperse xs xss)). It inserts the list xs in between the lists in xss and concatenates the result.\r\n     * @haskellType `intercalate :: [a] -> [[a]] -> [a]`\r\n     * @function module:listOps.intercalate\r\n     * @param xs {Array|String|*}\r\n     * @param xss {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    intercalate = curry(_intercalate),\r\n\r\n    foldl = curry(_foldl),\r\n\r\n    foldr = curry(_foldr),\r\n\r\n    foldl1 = curry(_foldl1),\r\n\r\n    foldr1 = curry(_foldr1),\r\n\r\n    /**\r\n     * Performs a map then a reduce all in one (from left-to-right). Returns a tuple\r\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\r\n     * @function module:listOps.mapAccumL\r\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\r\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\r\n     * @param xs {Array|String|*} - list type.\r\n     * @return {Array} - [aggregated, list]\r\n     */\r\n    mapAccumL = curry(_mapAccumL),\r\n\r\n    /**\r\n     * Performs a map and a reduce all in one (from right-to-left). Returns a tuple\r\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\r\n     * @function module:listOps.mapAccumR\r\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\r\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\r\n     * @param xs {Array|String|*} - list type.\r\n     * @return {Array} - [aggregated, list]\r\n     */\r\n    mapAccumR = curry(_mapAccumR),\r\n\r\n    iterate = curry(_iterate),\r\n\r\n    repeat = curry(_repeat),\r\n\r\n    replicate = repeat,\r\n\r\n    cycle = curry(_cycle),\r\n\r\n    /**\r\n     * Unfolds a value into a list of somethings.\r\n     * @haskellType `unfoldr :: (b -> Maybe (a, b)) -> b -> [a]`\r\n     * @function module:listOps.unfoldr\r\n     * @param op {Function} - Operation to perform (should return a two component tuple (item to aggregate and item to unfold in next iteration).\r\n     * @param x {*} - Starting parameter to unfold from.\r\n     * @returns {Array} - An array of whatever you return from `op` yielded.\r\n     */\r\n    unfoldr = curry(_unfoldr),\r\n\r\n    /**\r\n     * Finds index in string or list (alias for `findIndex`).\r\n     * @function module:listOps.findIndex\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    findIndex = curry(_findIndex),\r\n\r\n    /**\r\n     * @function module:listOps.findIndices\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {Array|undefined}\r\n     */\r\n    findIndices = curry(_findIndices),\r\n\r\n    /**\r\n     * @function module:listOps.elemIndex\r\n     * @param x {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    elemIndex = curry(_elemIndex),\r\n\r\n    /**\r\n     * @function module:listOps.elemIndices\r\n     * @param value {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    elemIndices = curry(_elemIndices),\r\n\r\n    /**\r\n     * Takes `n` items from start of list to `limit` (exclusive).\r\n     * @function module:listOps.take\r\n     * @param list {Array|String}\r\n     * @param limit {Number}\r\n     * @returns {String|Array} - Passed in type's type\r\n     */\r\n    take = curry(_take),\r\n\r\n    /**\r\n     * Drops `n` items from start of list to `count` (exclusive).\r\n     * @function module:listOps.take\r\n     * @param list {Array|String}\r\n     * @param count {Number}\r\n     * @returns {String|Array} - Passed in type's type\r\n     */\r\n    drop = curry(_drop),\r\n\r\n    /**\r\n     * Splits `x` in two at given `index` (exclusive (includes element/character at\r\n     * given index in second part of returned list)).\r\n     * @function module:listOps.splitAt\r\n     * @param ind {Number} - Index to split at.\r\n     * @param list {Array|String|*} - functor (list or string) to split.\r\n     * @returns {Array} - Array of whatever type `x` was when passed in\r\n     */\r\n    splitAt = curry(_splitAt),\r\n\r\n    /**\r\n     * Gives an list with passed elements while predicate was true.\r\n     * @function module:listOps.takeWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @returns {Array}\r\n     */\r\n    takeWhile = curry(_takeWhile),\r\n\r\n    /**\r\n     * Returns an list without elements that match predicate.\r\n     * @function module:listOps.dropWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @refactor\r\n     * @returns {Array|String}\r\n     */\r\n    dropWhile = curry(_dropWhile),\r\n\r\n    /**\r\n     * @function module:listOps.dropWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @refactor\r\n     * @returns {Array|String}\r\n     */\r\n    dropWhileEnd = curry(_dropWhileEnd),\r\n\r\n    /**\r\n     * Gives a span such that the first list (in returned tuple) is the span of items matching upto `not predicate` and\r\n     * the second list in the tuple is a list of the remaining elements in the given list.\r\n     * **@Note: Not the same as `partition`.  Read descriptions closely!!!\r\n     * @function module:listOps.partition\r\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\r\n     * @param list {Array|String|*} - Predicate<item, index, originalArrayOrString>\r\n     * @returns {Array|String|*} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\r\n     */\r\n    span = curry(_span),\r\n\r\n    breakOnList = curry(_breakOnList),\r\n\r\n    /**\r\n     * @function module:listOps.at\r\n     * @param ind {Number} - Index.\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    at = curry(_at),\r\n\r\n    /**\r\n     * @function module:listOps.find\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    find = curry(_find),\r\n\r\n    filter = curry(_filter),\r\n\r\n    /**\r\n     * Partitions a list on a predicate;  Items that match predicate are in first list in tuple;  Items that\r\n     * do not match the tuple are in second list in the returned tuple.\r\n     *  Essentially `[filter(p, xs), filter(negateP(p), xs)]`.\r\n     * @function module:listOps.partition\r\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\r\n     * @param list {Array|String|*}\r\n     * @returns {Array|String} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\r\n     */\r\n    partition = curry(_partition),\r\n\r\n    elem = curry(_elem),\r\n\r\n    notElem = curry2(_notElem),\r\n\r\n    lookup = at,\r\n\r\n    isPrefixOf = curry(_isPrefixOf),\r\n\r\n    isSuffixOf = curry(_isSuffixOf),\r\n\r\n    isInfixOf = curry(_isInfixOf),\r\n\r\n    isSubsequenceOf = curry(_isSubsequenceOf),\r\n\r\n    /**\r\n     * Allows you to group items in a list based on your supplied equality check.\r\n     * @note Sames `group` but allows you to specify equality operation.\r\n     * @haskellType `groupBy :: (a -> a -> Bool) -> [a] -> [[a]]`\r\n     * @function module:listOpsUncurried.groupBy\r\n     * @param equalityOp {Function}\r\n     * @param xs {Array|String|*}\r\n     * @returns {*}\r\n     */\r\n    groupBy = curry(_groupBy),\r\n\r\n    stripPrefix = curry(_stripPrefix),\r\n\r\n    /**\r\n     * zip takes two lists and returns a list of corresponding pairs.\r\n     * If one input list is short, excess elements of the longer list are discarded.\r\n     * @haskellType `zip :: [a] -> [b] -> [(a, b)]`\r\n     * @function module:listOps.zip\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip = curry(_zip),\r\n\r\n    /**\r\n     * zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\r\n     * zipWith generalises zip by zipping with the function given as the\r\n     * first argument, instead of a function tupling function (function that returns a tuple). For example,\r\n     * zipWith (+) is applied to two lists to produce the list of corresponding sums.\r\n     * @note `_|_` means bottom or perpetual (@see\r\n     *  - https://wiki.haskell.org/Bottom\r\n     *  - https://stackoverflow.com/questions/19794681/what-does-this-syntax-mean-in-haskell-or\r\n     *  )\r\n     * @example\r\n     * ```\r\n     * zipWith f [] _|_ = []\r\n     * ```\r\n     * @haskellType `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`\r\n     * @function module:listOps.zipWith\r\n     * @param op {Function} - Takes two parts of a tuple and returns a tuple.\r\n     *  E.g., ` op :: a -> b -> (a, b)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith = curry(_zipWith),\r\n\r\n    /**\r\n     * Zips all given lists with tupling function. Note: Haskell types do not have\r\n     *  a way (that I know of) to show one or more for params in a function so `@haskellType` below\r\n     *  is left there for general purpose not for exactness as is told by aforementioned.\r\n     * @haskellType `zipWithN :: (a -> b -> c) -> [a] -> [b] -> [c]` - Where `N` is the number\r\n     *  of lists to zip.\r\n     * @function module:listOps.zipWithN\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\r\n     * @param lists ...{Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWithN = curry2(_zipWithN),\r\n\r\n    /**\r\n     * Zips 3 lists with tupling function.\r\n     * @haskellType `zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]`\r\n     * @function module:listOps.zipWith3\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @param xs3 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith3 = zipWithN,\r\n\r\n    /**\r\n     * Zips 4 lists with tupling function.\r\n     * @haskellType `zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c]  -> [d] -> [e]`\r\n     * @function module:listOps.zipWith4\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> d -> (a, b, c, d)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @param xs3 {Array|String|*}\r\n     * @param xs4 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith4 = zipWithN,\r\n\r\n    /**\r\n     * Zips 5 lists.\r\n     * @haskellType `zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c]  -> [d] -> [e] -> [f]`\r\n     * @function module:listOps.zipWith5\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> d -> e -> (a, b, c, d, e)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @param xs3 {Array|String|*}\r\n     * @param xs4 {Array|String|*}\r\n     * @param xs5 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith5 = zipWithN,\r\n\r\n    any = curry(_any),\r\n\r\n    all = curry(_all),\r\n\r\n    maximumBy = curry(_maximumBy),\r\n\r\n    minimumBy = curry(_minimumBy),\r\n\r\n    scanl = () => null,\r\n\r\n    scanl1 = () => null,\r\n\r\n    scanr = () => null,\r\n\r\n    scanr1 = () => null,\r\n\r\n    remove = curry(_remove),\r\n\r\n    sortOn = curry(_sortOn),\r\n\r\n    sortBy = curry(_sortBy),\r\n\r\n    insert = curry(_insert),\r\n\r\n    /**\r\n     * A version of `insert` that allows you to specify the ordering of the inserted\r\n     * item;  Before/at, or after\r\n     * @function module:listOpsUncurried.insertBy\r\n     * @haskellType `insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]`\r\n     * @note `Ordering` === // something that is order-able\r\n     * @todo Optimize and work the logic of this function;  Think about the types that will be\r\n     *  operated on by this functions logic.\r\n     * @param orderingFn {Function} - A function that returns `-1`, `0`, or 1`.\r\n     * @param x {*} - Value to insert.\r\n     * @param xs {Array|String|*} - List to insert into (note new list is returned)\r\n     * @returns {Array|String|*} - New list.\r\n     */\r\n    insertBy = curry(_insertBy),\r\n\r\n    nubBy = curry(_nubBy),\r\n\r\n    removeBy = curry(_removeBy),\r\n\r\n    removeFirstsBy = curry(_removeFirstsBy),\r\n\r\n    /**\r\n     * Returns the union on elements matching boolean check passed in.\r\n     * @function module:listOps.unionBy\r\n     * @param pred {Function} - `pred :: a -> a -> Bool`\r\n     * @param arr1 {Array|String|*}\r\n     * @param arr2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    unionBy = curry(_unionBy),\r\n\r\n    /**\r\n     * Creates a union on matching elements from array1.\r\n     * @function module:listOps.union\r\n     * @param arr1 {Array|String|*}\r\n     * @param arr2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    union = curry(_union),\r\n\r\n    /**\r\n     * Performs an intersection on list 1 with  elements from list 2.\r\n     * @function module:listOps.intersect\r\n     * @param arr1 {Array|String|*}\r\n     * @param arr2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    intersect = curry(_intersect),\r\n\r\n    /**\r\n     * Returns an intersection by predicate.\r\n     * @function module:listOps.intersectBy\r\n     * @param pred {Function} - `pred :: a -> b -> Bool`\r\n     * @param list1 {Array|String|*}\r\n     * @param list2 {Array|String|*}\r\n     * @return {Array|String|*}\r\n     */\r\n    intersectBy = curry(_intersectBy),\r\n\r\n    /**\r\n     * Returns the difference of list 1 from list 2.\r\n     * @note The `difference` operation here is non-associative;  E.g., `a - b` is not equal to `b - a`;\r\n     * @function module:listOps.difference\r\n     * @param array1 {Array|String|*}\r\n     * @param array2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    difference = curry(_difference),\r\n\r\n    /**\r\n     * Returns the complement of list 0 and the reset of the passed in arrays.\r\n     * @function module:listOps.complement\r\n     * @param arr0 {Array}\r\n     * @param arrays {...Array}\r\n     * @returns {Array}\r\n     */\r\n    complement = curry2(_complement);\r\n","import {foldr} from '../listOps/listOps';\r\n\r\n/**\r\n * Composes all functions passed in from right to left passing each functions return value to\r\n * the functionOps on the left of itself.\r\n * @functionOps module:fjl.compose\r\n * @type {Function}\r\n * @param args {...Function}\r\n * @returns {Function}\r\n */\r\nexport const compose = (...args) => arg0 => foldr((value, fn) => fn(value), arg0, args);\r\n","/**\r\n * @module negate\r\n */\r\n\r\n/**\r\n * Negates a predicate function.\r\n * @function module:functionOps.negateP\r\n * @param fn {Function}\r\n * @returns {Function} - Negated predicate\r\n */\r\nexport const negateP = fn => (x, ind, xs) => !fn(x, ind, xs);\r\n","/**\r\n * @module id\r\n */\r\n\r\n/**\r\n * Returns passed in parameter.\r\n * @param x {*}\r\n * @returns {*}\r\n */\r\nexport const id = x => x;\r\n","import {reverse} from '../listOps/listOps';\r\nimport {curry, curry3} from './curry';\r\nimport {apply} from './apply';\r\nimport {call} from './call';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Flips a functions arguments order and returns a new functionOps requiring such (arguments in reverse order).\r\n     * @functionOps module:fnOperators.flipN\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    flipN = fn => curry3((...args) => apply(fn, reverse(args))),\r\n\r\n    /**\r\n     * Flips a functionOps's first and second arguments and and returns a new functionOps requiring said arguments in reverse.\r\n     * @functionOps module:fnOperators.flip\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    flip = fn => curry((b, a) => call(fn, a, b));\r\n","import {curry} from './curry';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Run `operation` until predicate returns `true`.\r\n     * @function module:function.until\r\n     * @param predicate {Function} :: a -> Boolean\r\n     * @param operation {Function} :: a -> a\r\n     * @param typeInstance {*} :: * - A monoidal zero or some starting point.\r\n     * @returns {*} - What ever type `typeInstance` is\r\n     */\r\n    until = curry((predicate, operation, typeInstance) => {\r\n        let result = typeInstance;\r\n        while (!predicate(result)) {\r\n            result = operation(result);\r\n        }\r\n        return result;\r\n    });\r\n","/**\r\n * Function operations: `\r\n * @module function\r\n */\r\nexport {call} from './call';\r\n\r\nexport {apply} from './apply';\r\n\r\nexport {compose} from './compose';\r\n\r\nexport {curry, curryN, curry2, curry3, curry4, curry5,\r\n    __, curry_, curryN_, curry2_, curry3_, curry4_, curry5_} from './curry';\r\n\r\nexport {negateP} from './negateP';\r\n\r\nexport {id} from './id';\r\n\r\nexport {flip, flipN} from './flip';\r\n\r\nexport {until} from './until';\r\n","\r\nexport const\r\n\r\n    isTruthy = value => !!value,\r\n\r\n    isFalsy = value => !value;\r\n","/**\r\n * Created by elyde on 7/15/2017.\r\n * @module booleanOps\r\n */\r\n\r\nimport {curry2} from '../functionOps/curry';\r\n\r\nexport {isTruthy, isFalsy} from './is';\r\n\r\nexport const\r\n\r\n    alwaysTrue = () => true,\r\n\r\n    alwaysFalse = () => false,\r\n\r\n    /**\r\n     * Returns whether both values are truthy or not.\r\n     * @function module:booleanOps.and\r\n     * @param a {*}\r\n     * @param b {*}\r\n     * @returns {Boolean}\r\n     */\r\n    bAnd = curry2((a, b) => a && b),\r\n\r\n    /**\r\n     * Returns whether one of the two passed in values\r\n     *  are truthy or not.\r\n     * @function module:booleanOps.or\r\n     * @param a {*}\r\n     * @param b {*}\r\n     * @returns {Boolean}\r\n     */\r\n    bOr = curry2((a, b) => a || b),\r\n\r\n    /**\r\n     * Returns whether passed in value is truthy or not.\r\n     * @function module:booleanOps.not\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    bNot = x => !x,\r\n\r\n    /**\r\n     * Returns `true` - Makes code more readable in places.\r\n     * @tentative\r\n     * @function module:booleanOps.otherwise\r\n     * @returns {Boolean} - Always true\r\n     */\r\n    bOtherwise = alwaysTrue,\r\n\r\n    /**\r\n     * Returns whether both values passed in are equal or not.\r\n     * @function module:booleanOps.equal\r\n     * @param a {*}\r\n     * @param b {*}\r\n     * @returns {Boolean}\r\n     */\r\n    bEqual = curry2((a, b) => a === b);\r\n","/**\r\n * Created by elyde on 12/18/2016.\r\n */\r\nconst _Number = Number.name,\r\n    _NaN = 'NaN',\r\n    _Null = 'Null',\r\n    _Undefined = 'Undefined',\r\n    _undefined = 'undefined';\r\n\r\n/**\r\n * Returns the class name of an object from it's class stringOps.\r\n * @note Returns 'NaN' if value `isNaN` and value type is 'Number'.\r\n * @functionOps module:fjl.typeOf\r\n * @param value {*}\r\n * @returns {string} - Constructor's name property if not null or undefined (in which case a\r\n *  name representing those types is returned ('Null' and or 'Undefined' (es6 compliant))).\r\n */\r\nexport function typeOf (value) {\r\n    let retVal;\r\n    if (typeof value === _undefined) {\r\n        retVal = _Undefined;\r\n    }\r\n    else if (value === null) {\r\n        retVal = _Null;\r\n    }\r\n    else {\r\n        let constructorName = (value).constructor.name;\r\n        retVal = constructorName === _Number && isNaN(value) ?\r\n            _NaN : constructorName;\r\n    }\r\n    return retVal;\r\n}\r\n","/**\r\n * Created by elydelacruz on 7/22/2017.\r\n */\r\n\r\nimport {curry} from '../functionOps/curry';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns whether constructor has derived objectOps.\r\n     * @instanceConstructor {Function|Class}\r\n     * @instance {*}\r\n     * @returns {Boolean}\r\n     */\r\n    instanceOf = curry((instanceConstructor, instance) =>\r\n        instance instanceof instanceConstructor);\r\n","/**\r\n * Created by elyde on 12/18/2016.\r\n * @module is\r\n * @todo remove `isset`, `isEmpty` and `notEmptyAndOfType`\r\n */\r\nimport {curry} from '../functionOps/curry';\r\nimport {typeOf} from './typeOf';\r\nimport {instanceOf} from './instanceOf';\r\nimport {length, keys, hasOwnProperty} from '../uncurried/jsPlatform/objectOpsUncurried';\r\n\r\nlet _String = String.name,\r\n    _Number = Number.name,\r\n    _Object = Object.name,\r\n    _Boolean = Boolean.name,\r\n    _Function = Function.name,\r\n    _Array = Array.name,\r\n    _Symbol = 'Symbol',\r\n    _Map = 'Map',\r\n    _Set = 'Set',\r\n    _WeakMap = 'WeakMap',\r\n    _WeakSet = 'WeakSet',\r\n    _Null = 'Null',\r\n    _Undefined = 'Undefined';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns whether a value is a functionOps or not.\r\n     * @functionOps module:is.isFunction\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isFunction = instanceOf(Function),\r\n\r\n    /**\r\n     * Type checker.  Note** The `Type` passed in, if a constructor, should\r\n     * be a named constructor/functionOps-instance;  E.g.,\r\n     * ```\r\n     *  functionOps SomeName () {} // or\r\n     *  var SomeName = functionOps SomeName () {} // or\r\n     *  class SomeName {}\r\n     * ```\r\n     * @functionOps module:fjl.isType\r\n     * @param Type {Function|String} - Constructor or constructor name\r\n     * @param value {*}\r\n     * @return {Boolean}\r\n     */\r\n    isType = curry((type, obj) => typeOf(obj) === (isFunction(type) ? type.name : type)),\r\n\r\n    /**\r\n     * Checks if `value` is an es2015 `class`.\r\n     * @functionOps module:is.isClass\r\n     * @param x {*}\r\n     * @returns {boolean}\r\n     */\r\n    isClass = x => x && /^\\s{0,3}class\\s{1,3}/.test(x.toString().substr(0, 10)),\r\n\r\n    /**\r\n     * Returns a booleanOps depicting whether a value is callable or not.\r\n     * @functionOps module:is.isCallable\r\n     * @tentative\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isCallable = x => isFunction(x) && !isClass(x),\r\n\r\n    /**\r\n     * Checks if value is an arrayOps.\r\n     * @functionOps module:is.isArray\r\n     * @param value {*}\r\n     * @returns {boolean}\r\n     */\r\n    isArray = isType(Array),\r\n\r\n    /**\r\n     * Checks whether value is an objectOps or not.\r\n     * @functionOps module:is.isObject\r\n     * @param value\r\n     * @returns {Boolean}\r\n     */\r\n    isObject = isType(_Object),\r\n\r\n    /**\r\n     * Checks if value is a booleanOps.\r\n     * @functionOps module:is.isBoolean\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isBoolean = isType(_Boolean),\r\n\r\n    /**\r\n     * Checks if value is a valid numberOps (also checks if isNaN so that you don't have to).\r\n     * @functionOps module:is.isNumber\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isNumber = isType(_Number),\r\n\r\n    /**\r\n     * Checks whether value is a stringOps or not.\r\n     * @functionOps module:is.isString\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isString = isType(_String),\r\n\r\n    /**\r\n     * Checks whether value is of `Map` or not.\r\n     * @functionOps module:is.isMap\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isMap = isType(_Map),\r\n\r\n    /**\r\n     * Checks whether value is of `Set` or not.\r\n     * @functionOps module:is.isSet\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isSet = isType(_Set),\r\n\r\n    /**\r\n     * Checks whether value is of `WeakMap` or not.\r\n     * @functionOps module:is.isWeakMap\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isWeakMap = isType(_WeakMap),\r\n\r\n    /**\r\n     * Checks whether value is of `WeakSet` or not.\r\n     * @functionOps module:is.isWeakSet\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isWeakSet = isType(_WeakSet),\r\n\r\n    /**\r\n     * Checks if value is undefined.\r\n     * @functionOps module:is.isUndefined\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isUndefined = isType(_Undefined),\r\n\r\n    /**\r\n     * Checks if value is null.\r\n     * @functionOps module:is.isNull\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isNull = isType(_Null),\r\n\r\n    /**\r\n     * Checks if value is a `Symbol`.\r\n     * @functionOps module:is.isSymbol\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isSymbol = isType(_Symbol),\r\n\r\n    /**\r\n     * @tentative\r\n     */\r\n    isPromise = isType('Promise'),\r\n\r\n    /**\r\n     * Checks if given `x` is one of the four\r\n     * \"usable\" immutable JS primitives; I.e.,\r\n     *  One of [String, Boolean, Number, Symbol]\r\n     * @function module:is.isUsableImmutablePrimitive\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isUsableImmutablePrimitive = x => {\r\n        const typeOfX = typeOf(x);\r\n        return [_String, _Number, _Boolean, _Symbol]\r\n            .some(Type => Type === typeOfX);\r\n    },\r\n\r\n    /**\r\n     * Checks if !length.\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyList = x => length(x) === 0,\r\n\r\n    /**\r\n     * Checks if objectOps has own properties/enumerable-props or not.\r\n     * @param obj {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyObject = obj => isEmptyList(keys(obj)),\r\n\r\n    /**\r\n     * Checks if collection is empty or not (Map, WeakMap, WeakSet, Set etc.).\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyCollection = x => x.size === 0,\r\n\r\n    /**\r\n     * Checks to see if passed in argument is empty.\r\n     * @functionOps module:is.empty\r\n     * @param value {*} - Value to check.\r\n     * @returns {Boolean}\r\n     */\r\n    isEmpty = value => {\r\n        let typeOfValue = typeOf(value),\r\n            retVal;\r\n\r\n        if (!value) { // '', 0, `null`, `undefined` or `false` then is empty\r\n            retVal = true;\r\n        }\r\n        else if (typeOfValue === _Array || typeOfValue === _Function) {\r\n            retVal = isEmptyList(value);\r\n        }\r\n        else if (typeOfValue === _Number && value !== 0) {\r\n            retVal = false;\r\n        }\r\n        else if (typeOfValue === _Object) {\r\n            retVal = isEmptyObject(value);\r\n        }\r\n        else if (hasOwnProperty('size', value)) {\r\n            retVal = isEmptyCollection(value);\r\n        }\r\n        else {\r\n            retVal = !value;\r\n        }\r\n        return retVal;\r\n    },\r\n\r\n    /**\r\n     * Returns true if an element is not empty and is of type.\r\n     * @functionOps module:is.notEmptyAndOfType\r\n     * @param type {String|Function} - Type to check against (stringOps name or actual constructor).\r\n     * @param value {*} - Value to check.\r\n     * @returns {Boolean}\r\n     */\r\n    notEmptyAndOfType = curry((type, value) => !isEmpty(value) && isType(type, value)),\r\n\r\n    /**\r\n     * Returns whether passed in values is defined and not null.\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isset = x => !isNull(x) && !isUndefined(x);\r\n","/**\r\n *\r\n */\r\n\r\nimport {curry} from '../functionOps/curry';\r\n\r\nexport const prop = curry((name, obj) => obj[name]);\r\n","import {isFunction, isUsableImmutablePrimitive, isset} from './is';\r\nimport {hasOwnProperty} from '../uncurried/jsPlatform/objectOpsUncurried';\r\nimport {apply} from '../functionOps/apply';\r\n\r\nexport const of = (x, ...args) => {\r\n    if (!isset(x)) { return undefined; }\r\n    const constructor = x.constructor;\r\n    if (hasOwnProperty('of', constructor)) {\r\n        return apply(constructor.of, args);\r\n    }\r\n    else if (isUsableImmutablePrimitive(x)) {\r\n        return apply(constructor, args);\r\n    }\r\n    else if (isFunction(constructor)) {\r\n        return new constructor(...args);\r\n    }\r\n    return undefined;\r\n};\r\n","import {typeOf} from '../../objectOps/typeOf';\r\n\r\nexport const\r\n\r\n    aggregateStr = (agg, item) => agg + item,\r\n\r\n    aggregateArr = (agg, item) => {\r\n        agg.push(item);\r\n        return agg;\r\n    },\r\n\r\n    aggregateObj = (agg, item, ind) => {\r\n        agg[ind] = item;\r\n        return agg;\r\n    },\r\n\r\n    aggregatorByType = x => {\r\n        switch (typeOf(x)) {\r\n            case 'String': return aggregateStr;\r\n            case 'Array': return aggregateArr;\r\n            case 'Object':\r\n            default: return aggregateObj;\r\n        }\r\n    };\r\n","import {of} from '../../objectOps/of';\r\n\r\nimport {aggregatorByType}   from './listOpsUncurriedAggregation';\r\n\r\nimport {length}              from '../jsPlatform/objectOpsUncurried';\r\n\r\n/**\r\n * @function module:listOps.map\r\n * @param fn {Function} - Function to map on functor item(s).\r\n * @param xs {Array|String|*} - Functor.\r\n * @returns {Array|String|*} - Functor type that is passed in.\r\n */\r\nexport const map = (fn, xs) => {\r\n    let ind = 0,\r\n        limit = length(xs),\r\n        out = of(xs),\r\n        aggregate = aggregatorByType(xs);\r\n    if (!limit) { return out; }\r\n    for (; ind < limit; ind += 1) {\r\n        out = aggregate(out, fn(xs[ind], ind, xs), ind, xs);\r\n    }\r\n    return out;\r\n};\r\n","/**\r\n * Array operators module.\r\n * @module listOpsUtils\r\n */\r\nimport {apply}              from '../jsPlatform/functionOpsUncurried';  // un-curried version\r\nimport {slice}              from '../jsPlatform/listOpsUncurried';      // un-curried version good for both strings and arrays\r\nimport {length}             from '../jsPlatform/objectOpsUncurried';\r\nimport {alwaysFalse}        from '../../booleanOps/booleanOps';\r\nimport {map}                from './map';\r\n\r\nexport * from './listOpsUncurriedAggregation';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns a slice of the given list from `startInd` to the end of the list.\r\n     * @param startInd {Number}\r\n     * @param arr {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    sliceFrom = (startInd, arr) => slice(startInd, length(arr), arr),\r\n\r\n    /**\r\n     * Slices from index `0` to given index.\r\n     * @module module:listOpsUncurried.sliceTo\r\n     * @param toInd {Number}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    sliceTo = (toInd, xs) => slice(0, toInd, xs),\r\n\r\n    /**\r\n     * Slices a copy of list.\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    copy = xs => sliceFrom(0, xs),\r\n\r\n    genericAscOrdering = (a, b) => {\r\n        if (a > b) { return 1; }\r\n        else if (a < b) { return -1; }\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * Returns length of all passed lists in list.\r\n     * @param lists ...{Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    lengths = (...lists) => length(lists) ? map(length, lists) : [],\r\n\r\n    lengthsToSmallest = (...lists) => {\r\n        const listLengths = apply(lengths, lists),\r\n            smallLen = Math.min.apply(Math, listLengths);\r\n        return map((list, ind) => listLengths[ind] > smallLen ?\r\n            sliceTo(smallLen, list) : copy(list), lists);\r\n    },\r\n\r\n    reduceUntil = (pred, op, agg, arr) => {\r\n        const limit = length(arr);\r\n        if (!limit) { return agg; }\r\n        let ind = 0,\r\n            result = agg;\r\n        for (; ind < limit; ind++) {\r\n            if (pred(arr[ind], ind, arr)) { break; }\r\n            result = op(result, arr[ind], ind, arr);\r\n        }\r\n        return result;\r\n    },\r\n\r\n    reduceRightUntil = (pred, op, agg, arr) => {\r\n        const limit = length(arr);\r\n        if (!limit) { return agg; }\r\n        let ind = limit - 1,\r\n            result = agg;\r\n        for (; ind >= 0; ind--) {\r\n            if (pred(arr[ind], ind, arr)) { break; }\r\n            result = op(result, arr[ind], ind, arr);\r\n        }\r\n        return result;\r\n    },\r\n\r\n    reduce = (operation, agg, arr) =>\r\n        reduceUntil(\r\n            alwaysFalse,            // predicate\r\n            operation,              // operation\r\n            agg,                    // aggregator\r\n            arr),                   // list\r\n\r\n    reduceRight = (operation, agg, arr) =>\r\n        reduceRightUntil(\r\n            alwaysFalse,            // predicate\r\n            operation,              // operation\r\n            agg,                    // aggregator\r\n            arr),                   // list\r\n\r\n    /**\r\n     * Gets last index of a list/list-like (Array|String|Function etc.).\r\n     * @function module:listOps.lastIndex\r\n     * @param x {Array|String|*} - list like or list.\r\n     * @returns {Number} - `-1` if no element found.\r\n     */\r\n    lastIndex = x => { const len = length(x); return len ? len - 1 : 0; },\r\n\r\n    /**\r\n     * Finds index in string or list.\r\n     * @function module:listOps.findIndexWhere\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    findIndexWhere = (pred, arr) => {\r\n        let ind = -1,\r\n            predicateFulfilled = false;\r\n        const limit = length(arr);\r\n        while (ind < limit && !predicateFulfilled) {\r\n            predicateFulfilled = pred(arr[++ind], ind, arr);\r\n        }\r\n        return ind;\r\n    },\r\n\r\n    /**\r\n     * Finds index in list from right to left.\r\n     * @function module:listOps.findIndexWhereRight\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    findIndexWhereRight = (pred, arr) => {\r\n        const limit = length(arr);\r\n        let ind = limit,\r\n            predicateFulfilled = false;\r\n        for (; ind >= 0 && !predicateFulfilled; --ind) {\r\n            predicateFulfilled = pred(arr[ind], ind, arr);\r\n        }\r\n        return ind;\r\n    },\r\n\r\n    /**\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {Array|undefined}\r\n     */\r\n    findIndicesWhere = (pred, xs) => {\r\n        const limit = length(xs);\r\n        if (!limit) { return undefined; }\r\n        let ind = 0,\r\n            out = [];\r\n        for (; ind < limit; ind++) {\r\n            if (pred(xs[ind], ind, xs)) { out.push(ind); }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * @function module:listOps.find\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    findWhere = (pred, xs) => {\r\n        let ind = 0,\r\n            limit = length(xs);\r\n        if (!limit) { return; }\r\n        for (; ind < limit; ind++) {\r\n            let elm = xs[ind];\r\n            if (pred(elm, ind, xs)) { return elm; }\r\n        }\r\n    }\r\n;\r\n","/**\r\n * 'Uncurried' list operators.\r\n * @module listOpsUncurried\r\n * @todo decide whether to throw errors where functions cannot function without a specific type or to return undefined (and also determine which cases are ok for just returning undefined).\r\n * @todo code unperformant shorthand in `listOps`\r\n * @todo rename monoid functions to normal functions since we are not really defining methods for monoids here.\r\n */\r\nimport { concat as listAppend,\r\n    indexOf, slice, includes } from '../jsPlatform/listOpsUncurried';\r\nimport {apply}              from '../jsPlatform/functionOpsUncurried';\r\nimport {negateF}  from '../functionOps/negate';\r\nimport {length}             from '../jsPlatform/objectOpsUncurried';\r\nimport {negateP}            from '../../functionOps/functionOps';\r\nimport {isTruthy, isFalsy}  from '../../booleanOps/booleanOps';\r\nimport {isString, isset}    from '../../objectOps/is';\r\nimport {prop}               from '../../objectOps/prop';\r\nimport {of}                 from '../../objectOps/of';\r\nimport {map}                from './map';\r\n\r\nimport {\r\n    sliceFrom, sliceTo, lengths,\r\n    lengthsToSmallest, aggregateArr, aggregatorByType,\r\n    reduceUntil, reduce, reduceRight, lastIndex,\r\n    findIndexWhere, findIndexWhereRight, findIndicesWhere,\r\n    findWhere, copy, genericAscOrdering } from './listOpsUncurriedUtils';\r\n\r\n// import {log} from '../../tests/for-server/helpers';\r\n\r\n// Exported imports\r\nexport {length, map};\r\n\r\n// Exported internals\r\nexport const\r\n\r\n    /**\r\n     * Append two lists, i.e.,\r\n     * ```\r\n     * append([x1, ..., xm], [y1, ..., yn]) // outputs: [x1, ..., xm, y1, ..., yn]\r\n     * append([x1, ..., xm], [y1, ...]) // outputs: [x1, ..., xm, y1, ...]\r\n     * ```\r\n     * If the first list is not finite, the result is the first list.\r\n     * @haskellType `append :: List a => a -> a -> a`\r\n     * @function module:listOps.append\r\n     * @param xs1 {Array|String|*} - list or list like.\r\n     * @param xs2 {Array|String|*} - list or list like.\r\n     * @returns {Array|String|*} - Same type as list like passed in.\r\n     */\r\n    append = listAppend,\r\n\r\n    /**\r\n     * Append two or more lists, i.e., same as `append` but for two ore more lists.\r\n     * @haskellType `appendMany :: List a => a -> [a] -> a\r\n     * @note In `@haskellType` we wrote `[a]` only to keep the haskell type valid though note in javascript\r\n     *  this is actually different since the function converts the zero ore more parameters into an array containing such for us.\r\n     * @function module:listOps.appendMany\r\n     * @param x {Array|String|*}\r\n     * @param args ...{Array|String|*} - Lists or lists likes.\r\n     * @returns {Array|String|*} - Same type as first list or list like passed in.\r\n     */\r\n    appendMany = (x, ...args) => {\r\n        const lenArgs = length(args);\r\n        if (!isset(x)) { return []; }\r\n        if (!lenArgs) { return sliceFrom(0, x); }\r\n        return listAppend(x, ...args);\r\n    },\r\n\r\n    /**\r\n     * Returns head of list (first item of list).\r\n     * @haskellType `head :: [a] -> a`\r\n     * @function module:listOps.head\r\n     * @param x {Array|String}\r\n     * @returns {*} - First item from list\r\n     */\r\n    head = x => x[0],\r\n\r\n    /**\r\n     * Returns last item of list.\r\n     * @haskellType `last :: [a] -> a`\r\n     * @function module:listOps.last\r\n     * @param xs {Array|String}\r\n     * @returns {*}\r\n     */\r\n    last = xs => xs[lastIndex(xs)],\r\n\r\n    /**\r\n     * Returns tail part of list (everything after the first item as new list).\r\n     * @haskelType `tail :: [a] -> [a]`\r\n     * @function module:listOps.tail\r\n     * @param xs {Array}\r\n     * @returns {Array}\r\n     */\r\n    tail = xs => sliceFrom(1, xs),\r\n\r\n    /**\r\n     * Returns everything except last item of list as new list.\r\n     * @haskellType `init :: [a] -> [a]`\r\n     * @function module:listOps.init\r\n     * @param xs {Array|String}\r\n     * @returns {Array|String}\r\n     */\r\n    init = xs => sliceTo(lastIndex(xs), xs),\r\n\r\n    /**\r\n     * Returns `head` and `tail` of passed in list/string in a tuple.\r\n     * @haskellType `uncons :: [a] -> Maybe (a, [a])`\r\n     * @function module:listOps.uncons\r\n     * @param xs {Array|String}\r\n     * @returns {Array|String|*|undefined}\r\n     */\r\n    uncons = xs => {\r\n        if (!xs) { return; }\r\n        if (length(xs) === 0) { return undefined; }\r\n        return [head(xs), tail(xs)];\r\n    },\r\n\r\n    /**\r\n     * Returns `tail` and `head` of passed in list/string in a tuple.\r\n     * @haskellType `unconsr :: [a] -> Maybe ([a], a)`\r\n     * @function module:listOps.unconsr\r\n     * @param xs {Array|String}\r\n     * @returns {Array|String|*|undefined}\r\n     */\r\n    unconsr = xs => {\r\n        if (!xs) { return; }\r\n        if (length(xs) === 0) { return undefined; }\r\n        return [init(xs), last(xs)];\r\n    },\r\n\r\n    /**\r\n     * Returns whether a list is empty or not.\r\n     * @note not to be mistaken with module:objectOps.isEmpty;\r\n     *  `objectOps.isEmpty` Checks any passed in type for empty;\r\n     *  `listOps.isEmpty` only checks if length on passed in\r\n     *  value is not truthy.\r\n     *  In typed languages this would be all we\r\n     *  need do due to assuming that only lists make it into our\r\n     *  function but in javascript this is loose and in order\r\n     *  to the function to perform well under load and\r\n     *  for it to follow the specification we are not allowed\r\n     *  to type check in it.\r\n     * @note Will keep it like this for now.\r\n     * @function module:listOps.isEmpty\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmpty = x => !length(x),\r\n\r\n    /**\r\n     * Concatenates all the elements of a container of lists.\r\n     * @haskellType `concat :: Foldable t => t [a] -> [a]`\r\n     * @function module:listOps.concat\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    concat = xs => appendMany(...xs),\r\n\r\n    /**\r\n     * Map a function over all the elements of a container and concatenate the resulting lists.\r\n     * @haskellType `concatMap :: Foldable t => (a -> [b]) -> t a -> [b]`\r\n     * @function module:listOps.concatMap\r\n     * @param fn {Function}\r\n     * @param foldableOfA {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    concatMap = (fn, foldableOfA) => concat(map(fn, foldableOfA)),\r\n\r\n    /**\r\n     * Returns a copy of the passed in list reverses.\r\n     * @haskellType `reverse :: [a] -> [a]`\r\n     * @function module:listOps.reverse\r\n     * @param x {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    reverse = x => {\r\n        const aggregator = aggregatorByType(x);\r\n        return reduceRight(\r\n            (agg, item, ind) => aggregator(agg, item, ind),\r\n            of(x), x\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Takes an element and a list and `intersperses' that element between the elements of the list. For example\r\n     * @function module:listOps.intersperse\r\n     * @note In our version of the function javascript is loosely typed so, so is our function (to much overhead to make\r\n     *  it typed) so `between` can be any value.\r\n     * @param between {*} - Should be of the same type of elements contained in list.\r\n     * @param arr {Array|String|*} - List.\r\n     * @returns {Array|String|*}\r\n     */\r\n    intersperse = (between, arr) => {\r\n        const limit = length(arr),\r\n            lastInd = limit - 1,\r\n            aggregator = of(arr),\r\n            aggregatorOp = aggregatorByType(arr);\r\n        if (!limit) { return aggregator; }\r\n        return reduce((agg, item, ind) => {\r\n            return ind === lastInd ?\r\n                aggregatorOp(agg, item) :\r\n                aggregatorOp(\r\n                    aggregatorOp(agg, item),\r\n                    between\r\n                );\r\n        }, aggregator, arr);\r\n    },\r\n\r\n    /**\r\n     * `intercalate xs xss` is equivalent to (concat (intersperse xs xss)). It inserts the list xs in between the lists in xss and concatenates the result.\r\n     * @haskellType `intercalate :: [a] -> [[a]] -> [a]`\r\n     * @function module:listOps.intercalate\r\n     * @param xs {Array|String|*}\r\n     * @param xss {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    intercalate = (xs, xss) => {\r\n        const result = intersperse(xs, xss);\r\n        return isString(result) ? result : concat(result);\r\n    },\r\n\r\n    /**\r\n     * Transposes rows and columns into lists by index;  E.g.,\r\n     * Haskell example:\r\n     * ```\r\n     *  transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]\r\n     *\r\n     *  -- Notice the shorter arrays are ignored after their last index is copied over:\r\n     *  transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]\r\n     * ```\r\n     * @note from columns to rows.\r\n     * @note Empty lists are ignored.\r\n     * @todo upgrade this function to support lists of strings.\r\n     * @haskellType `transpose :: [[a]] -> [[a]]`\r\n     * @function module:listOps.transpose\r\n     * @param xss {Array}\r\n     * @returns {Array}\r\n     */\r\n    transpose = xss => {\r\n        let numLists = length(xss),\r\n            ind = 0, ind2;\r\n        if (!numLists) { return of(xss); }\r\n        const listLengths = apply(lengths, xss),\r\n            longestListLen = maximum(listLengths),\r\n            outLists = [];\r\n        for (; ind < longestListLen; ind += 1) {\r\n            const outList = [];\r\n            for (ind2 = 0; ind2 < numLists; ind2 += 1) {\r\n                if (listLengths[ind2] < ind + 1) { continue; }\r\n                outList.push(xss[ind2][ind]);\r\n            }\r\n            outLists.push(outList);\r\n        }\r\n        return filter(x => length(x), outLists);\r\n    },\r\n\r\n    /**\r\n     * Generates 2^n sub-sequences for passed in sequence (string/list) (`n` is\r\n     * the length of the passed in sequence so: 2^length(xs)).\r\n     * Note: The return value doubles per index/character passed in so use with caution!\r\n     *  Also note that for 2^16 (or for a sequence of 16 characters) this algorithm\r\n     *  will generate 65536 sub-sequences!  So caution should be taken to not\r\n     *  use this with sequences above a certain length on certain platform (the browser thread in specific).\r\n     * @function module:listOps.subsequences\r\n     * @param xs {Array|String}\r\n     * @returns {Array}\r\n     */\r\n    subsequences = xs => {\r\n        const len = Math.pow(2, length(xs)),\r\n            out = [];\r\n        for (let i = 0; i < len; i += 1) {\r\n            const entry = [];\r\n            for (let j = 0; j < len; j += 1) {\r\n                if (i & (1 << j)) {\r\n                    entry.push(xs[j]);\r\n                }\r\n            }\r\n            out.push(entry);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    permutations = xs => [xs],\r\n\r\n    foldl = reduce,\r\n\r\n    foldr = reduceRight,\r\n\r\n    foldl1 = (op, xs) => {\r\n        const parts = uncons(xs);\r\n        if (!parts) { return of (xs); }\r\n        return reduce (op, parts[0], parts[1]);\r\n    },\r\n\r\n    foldr1 = (op, xs) => {\r\n        const parts = unconsr(xs);\r\n        if (!parts) { return of (xs); }\r\n        return reduceRight (op, parts[1], parts[0]);\r\n    },\r\n\r\n    /**\r\n     * Performs a map then a reduce all in one (from left-to-right). Returns a tuple\r\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\r\n     * @function module:listOps.mapAccumL\r\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\r\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\r\n     * @param xs {Array|String|*} - list type.\r\n     * @return {Array} - [aggregated, list]\r\n     */\r\n    mapAccumL = (op, zero, xs) => {\r\n        const list = sliceFrom(0, xs),\r\n            limit = length(xs);\r\n        if (!limit) { return [zero, list]; }\r\n        let ind = 0,\r\n            agg = zero,\r\n            mapped = of(xs),\r\n            tuple;\r\n        for (; ind < limit; ind++) {\r\n            tuple = op(agg, list[ind], ind);\r\n            agg = tuple[0];\r\n            mapped = tuple[1];\r\n        }\r\n        return [agg, mapped];\r\n    },\r\n\r\n    /**\r\n     * Performs a map and a reduce all in one (from right-to-left). Returns a tuple\r\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\r\n     * @function module:listOps.mapAccumR\r\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\r\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\r\n     * @param xs {Array|String|*} - list type.\r\n     * @return {Array} - [aggregated, list]\r\n     */\r\n    mapAccumR = (op, zero, xs) => {\r\n        const list = sliceFrom(0, xs),\r\n            limit = length(xs);\r\n        if (!limit) { return [zero, list]; }\r\n        let ind = limit - 1,\r\n            agg = zero,\r\n            mapped = of(xs),\r\n            tuple;\r\n        for (; ind >= 0; ind--) {\r\n            tuple = op(agg, list[ind], ind);\r\n            agg = tuple[0];\r\n            mapped = tuple[1];\r\n        }\r\n        return [agg, mapped];\r\n    },\r\n\r\n    iterate = (limit, op, x) => {\r\n        let ind = 0,\r\n            out = x;\r\n        for (; ind < limit; ind += 1) {\r\n            out = op(out, ind);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    repeat = (limit, x) =>\r\n        iterate(limit, agg => { agg.push(x); return agg; }, []),\r\n\r\n    replicate = repeat,\r\n\r\n    cycle = (limit, xs) => concat(replicate(limit, xs)),\r\n\r\n    /**\r\n     * Unfolds a value into a list of somethings.\r\n     * @haskellType `unfoldr :: (b -> Maybe (a, b)) -> b -> [a]`\r\n     * @function module:listOps.unfoldr\r\n     * @param op {Function} - Operation to perform (should return a two component tuple (item to aggregate and item to unfold in next iteration).\r\n     * @param x {*} - Starting parameter to unfold from.\r\n     * @returns {Array} - An array of whatever you return from `op` yielded.\r\n     */\r\n    unfoldr = (op, x) => {\r\n        let ind = 0,\r\n            out = [],\r\n            resultTuple = op(x, ind, out);\r\n        while (resultTuple) {\r\n            out.push(resultTuple[0]);\r\n            resultTuple = op(resultTuple[1], ++ind, out);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Finds index in string or list (alias for `findIndex`).\r\n     * @function module:listOps.findIndex\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    findIndex = findIndexWhere,\r\n\r\n    /**\r\n     * @function module:listOps.findIndices\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {Array|undefined}\r\n     */\r\n    findIndices =  findIndicesWhere,\r\n\r\n    /**\r\n     * @function module:listOps.elemIndex\r\n     * @param x {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    elemIndex = (x, xs) => {\r\n        const foundInd = indexOf(x, xs);\r\n        return foundInd !== -1 ? foundInd : undefined;\r\n    },\r\n\r\n    /**\r\n     * @function module:listOps.elemIndices\r\n     * @param value {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    elemIndices = (value, xs) => findIndices(x => x === value, xs),\r\n\r\n    /**\r\n     * Takes `n` items from start of list to `limit` (exclusive).\r\n     * @function module:listOps.take\r\n     * @param list {Array|String}\r\n     * @param limit {Number}\r\n     * @returns {String|Array} - Passed in type's type\r\n     */\r\n    take = (limit, list) => sliceTo(limit, list),\r\n\r\n    /**\r\n     * Drops `n` items from start of list to `count` (exclusive).\r\n     * @function module:listOps.take\r\n     * @param list {Array|String}\r\n     * @param count {Number}\r\n     * @returns {String|Array} - Passed in type's type\r\n     */\r\n    drop = (count, list) => sliceFrom(count, list),\r\n\r\n    /**\r\n     * Splits `x` in two at given `index` (exclusive (includes element/character at\r\n     * given index in second part of returned list)).\r\n     * @function module:listOps.splitAt\r\n     * @param ind {Number} - Index to split at.\r\n     * @param list {Array|String|*} - functor (list or string) to split.\r\n     * @returns {Array} - Array of whatever type `x` was when passed in\r\n     */\r\n    splitAt = (ind, list) => [\r\n        sliceTo(ind, list),\r\n        sliceFrom(ind, list)\r\n    ],\r\n\r\n    /**\r\n     * Gives an list with passed elements while predicate was true.\r\n     * @function module:listOps.takeWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @returns {Array}\r\n     */\r\n    takeWhile = (pred, list) => {\r\n        let zero =  of(list);\r\n        const operation = aggregatorByType(list);\r\n        return reduceUntil (\r\n            negateP(pred),  // predicate\r\n            operation,      // operation\r\n            zero,           // aggregator\r\n            list\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Returns an list without elements that match predicate.\r\n     * @function module:listOps.dropWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @refactor\r\n     * @returns {Array|String}\r\n     */\r\n    dropWhile = (pred, list) => {\r\n        const limit = length(list),\r\n            splitPoint =\r\n                findIndexWhere((item, ind, list2) =>\r\n                    !pred(list[ind], ind, list2), list);\r\n\r\n        return splitPoint === -1 ?\r\n            sliceTo(limit, list) :\r\n            slice(splitPoint, limit, list);\r\n    },\r\n\r\n    /**\r\n     * @function module:listOps.dropWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @refactor\r\n     * @returns {Array|String}\r\n     */\r\n    dropWhileEnd = (pred, list) => {\r\n        const limit = length(list),\r\n            splitPoint =\r\n                findIndexWhereRight((item, ind, list2) =>\r\n                    !pred(list[ind], ind, list2), list);\r\n\r\n        return splitPoint === -1 ?\r\n            sliceTo(limit, list) :\r\n            sliceTo(splitPoint + 1, list);\r\n    },\r\n\r\n    /**\r\n     * Gives a span such that the first list (in returned tuple) is the span of items matching upto `not predicate` and\r\n     * the second list in the tuple is a list of the remaining elements in the given list.\r\n     * **@Note: Not the same as `partition`.  Read descriptions closely!!!\r\n     * @function module:listOps.partition\r\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\r\n     * @param list {Array|String|*} - Predicate<item, index, originalArrayOrString>\r\n     * @returns {Array|String|*} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\r\n     */\r\n    span = (pred, list) => {\r\n        const splitPoint = findIndexWhere(negateP(pred), list);\r\n        return splitPoint === -1 ?\r\n            splitAt(0, list) : splitAt(splitPoint, list);\r\n    },\r\n\r\n    breakOnList = (pred, list) => {\r\n        const splitPoint = findIndexWhere(pred, list);\r\n        return splitPoint === -1 ?\r\n            splitAt(0, list) : splitAt(splitPoint, list);\r\n    },\r\n\r\n    /**\r\n     * @function module:listOps.at\r\n     * @param ind {Number} - Index.\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    at = prop,\r\n\r\n    /**\r\n     * @function module:listOps.find\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    find = findWhere,\r\n\r\n    filter = (pred, xs) => {\r\n        let ind = 0,\r\n            limit = length(xs),\r\n            aggregator = aggregatorByType(xs),\r\n            out = of(xs);\r\n        if (!limit) { return out; }\r\n        for (; ind < limit; ind++) {\r\n            if (pred(xs[ind], ind, xs)) {\r\n                out = aggregator(out, xs[ind]);\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Partitions a list on a predicate;  Items that match predicate are in first list in tuple;  Items that\r\n     * do not match the tuple are in second list in the returned tuple.\r\n     *  Essentially `[filter(p, xs), filter(negateP(p), xs)]`.\r\n     * @function module:listOps.partition\r\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\r\n     * @param list {Array|String|*}\r\n     * @returns {Array|String} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\r\n     */\r\n    partition = (pred, list) => {\r\n        if (!length(list)) { return [of(list), of(list)]; }\r\n        return [filter(pred, list), filter(negateP(pred), list)];\r\n    },\r\n\r\n    elem = includes,\r\n\r\n    notElem = negateF(includes),\r\n\r\n    lookup = at,\r\n\r\n    isPrefixOf = (xs1, xs2) => {\r\n        const limit1 = length(xs1),\r\n            limit2 = length(xs2);\r\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\r\n            return false;\r\n        }\r\n        let ind = 0;\r\n        for (; ind < limit1; ind++) {\r\n            if (xs1[ind] !== xs2[ind]) { return false; }\r\n        }\r\n        return true;\r\n    },\r\n\r\n    isSuffixOf = (xs1, xs2) => {\r\n        const limit1 = length(xs1),\r\n            limit2 = length(xs2);\r\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\r\n            return false;\r\n        }\r\n        let ind1 = limit1 - 1,\r\n            ind2 = limit2 - 1;\r\n        for (; ind1 >= 0; ind1--) {\r\n            if (xs1[ind1] !== xs2[ind2]) { return false; }\r\n            ind2 -= 1;\r\n        }\r\n        return true;\r\n    },\r\n\r\n    isInfixOf = (xs1, xs2) => {\r\n        const limit1 = length(xs1),\r\n            limit2 = length(xs2);\r\n        if (limit2 < limit1 || !limit1 || !limit2) {\r\n            return false;\r\n        }\r\n        let ind1,\r\n            foundLen,\r\n            ind = 0;\r\n        for (; ind < limit2; ind += 1) {\r\n            foundLen = 0;\r\n            for (ind1 = 0; ind1 < limit1; ind1 += 1) {\r\n                if (xs2[ind1 + ind] === xs1[ind1]) { foundLen += 1; }\r\n                if (foundLen === limit1) { return true; }\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    isSubsequenceOf = (xs1, xs2) => {\r\n        const len = Math.pow(2, length(xs2)),\r\n            lenXs1 = length(xs1);\r\n        let foundLen,\r\n            i;\r\n        for (i = 0; i < len; i += 1) {\r\n            foundLen = 0;\r\n            for (let j = 0; j < len; j += 1) {\r\n                if (i & (1 << j) && indexOf(xs2[j], xs1) > -1) { foundLen += 1; }\r\n                if (foundLen === lenXs1) { return true; }\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * The group function takes a list and returns a list of lists such that\r\n     *  the concatenation of the result is equal to the argument. Moreover, each\r\n     *  sublist in the result contains only equal elements. For example,\r\n     * `group \"Mississippi\" = [\"M\",\"i\",\"ss\",\"i\",\"ss\",\"i\",\"pp\",\"i\"]`\r\n     * It is a special case of groupBy, which allows the programmer to supply\r\n     *  their own equality test.\r\n     * @haskellType `group :: Eq a => [a] -> [[a]]`\r\n     * @function module:listOpsUncurried.group\r\n     * @param xs {Array|String|*}\r\n     * @returns {(Array|*)<Array|String|*>}\r\n     */\r\n    group = xs => groupBy((a, b) => a === b, xs),\r\n\r\n    /**\r\n     * Allows you to group items in a list based on your supplied equality check.\r\n     * @note Sames `group` but allows you to specify equality operation.\r\n     * @haskellType `groupBy :: (a -> a -> Bool) -> [a] -> [[a]]`\r\n     * @function module:listOpsUncurried.groupBy\r\n     * @param equalityOp {Function}\r\n     * @param xs {Array|String|*}\r\n     * @returns {*}\r\n     */\r\n    groupBy = (equalityOp, xs) => {\r\n        const limit = length(xs);\r\n        if (!limit) { return sliceFrom(0, xs); }\r\n        let ind = 0,\r\n            prevItem,\r\n            item,\r\n            predOp = x => {\r\n                if (equalityOp(x, prevItem)) { ind++; }\r\n                if (equalityOp(x, item)) { prevItem = x; return true; }\r\n                return false;\r\n            },\r\n            agg = [];\r\n        for (; ind < limit; ind += 1) {\r\n            item = xs[ind];\r\n            agg.push( takeWhile (predOp, slice(ind, limit, xs)) );\r\n        }\r\n        return agg;\r\n    },\r\n\r\n    inits = xs => {\r\n        let limit = length(xs),\r\n            ind = 0,\r\n            agg = [];\r\n        if (!limit) { return []; }\r\n        for (; ind <= limit; ind += 1) {\r\n            agg = aggregateArr(agg, sliceTo(ind, xs));\r\n        }\r\n        return agg;\r\n    }, //map(list => init(list), xs),\r\n\r\n    tails = xs => {\r\n        let limit = length(xs),\r\n            ind = 0,\r\n            agg = [];\r\n        if (!limit) { return []; }\r\n        for (; ind <= limit; ind += 1) {\r\n            agg = aggregateArr(agg, slice(ind, limit, xs));\r\n        }\r\n        return agg;\r\n    }, //map(list => tail(list), xs),\r\n\r\n    stripPrefix = (prefix, list) =>\r\n        isPrefixOf(prefix, list) ?\r\n            splitAt(length(prefix), list)[1] :\r\n            sliceFrom(0, list),\r\n\r\n    /**\r\n     * zip takes two lists and returns a list of corresponding pairs.\r\n     * If one input list is short, excess elements of the longer list are discarded.\r\n     * @haskellType `zip :: [a] -> [b] -> [(a, b)]`\r\n     * @function module:listOps.zip\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip = (arr1, arr2) => {\r\n        if (!length(arr1) || !length(arr2)) { return of(arr1); }\r\n        const [a1, a2] = lengthsToSmallest(arr1, arr2);\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArr(agg, [item, a2[ind]]),\r\n            [], a1);\r\n    },\r\n\r\n    /**\r\n     * zipN takes one or more lists and returns a list containing lists of all indices\r\n     * at a given index, index by index.\r\n     * If one input list is short, excess elements of the longer list are discarded.\r\n     * @function module:listOps.zipN\r\n     * @param lists {...<Array|String>}\r\n     * @returns {Array}\r\n     */\r\n    zipN = (...lists) => {\r\n        const trimmedLists = apply(lengthsToSmallest, filter(length, lists)),\r\n            lenOfTrimmed = length(trimmedLists);\r\n        if (!lenOfTrimmed) { return []; }\r\n        else if (lenOfTrimmed === 1) {\r\n            return sliceTo(length(trimmedLists[0]), trimmedLists[0]);\r\n        }\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArr(agg, map(xs => xs[ind], trimmedLists)),\r\n            [], trimmedLists[0]);\r\n    },\r\n\r\n    /**\r\n     * @haskellType `zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]`\r\n     * @function module:listOps.zip3\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip3 = zipN,\r\n\r\n    /**\r\n     * @haskellType `zip3 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]`\r\n     * @function module:listOps.zip4\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @param arr4 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip4 = zipN,\r\n\r\n    /**\r\n     * @haskellType `zip3 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]`\r\n     * @function module:listOps.zip5\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @param arr4 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip5 = zipN,\r\n\r\n    /**\r\n     * zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\r\n     * zipWith generalises zip by zipping with the function given as the\r\n     * first argument, instead of a function tupling function (function that returns a tuple). For example,\r\n     * zipWith (+) is applied to two lists to produce the list of corresponding sums.\r\n     * @note `_|_` means bottom or perpetual (@see\r\n     *  - https://wiki.haskell.org/Bottom\r\n     *  - https://stackoverflow.com/questions/19794681/what-does-this-syntax-mean-in-haskell-or\r\n     *  )\r\n     * @example\r\n     * ```\r\n     * zipWith f [] _|_ = []\r\n     * ```\r\n     * @haskellType `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`\r\n     * @function module:listOps.zipWith\r\n     * @param op {Function} - Takes two parts of a tuple and returns a tuple.\r\n     *  E.g., ` op :: a -> b -> (a, b)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith = (op, xs1, xs2) => {\r\n        if (!length(xs1) || !length(xs2)) { return of(xs1); }\r\n        const [a1, a2] = lengthsToSmallest(xs1, xs2);\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArr(agg, op(item, a2[ind])),\r\n            [], a1);\r\n    },\r\n\r\n    /**\r\n     * Zips all given lists with tupling function. Note: Haskell types do not have\r\n     *  a way (that I know of) to show one or more for params in a function so `@haskellType` below\r\n     *  is left there for general purpose not for exactness as is told by aforementioned.\r\n     * @haskellType `zipWithN :: (a -> b -> c) -> [a] -> [b] -> [c]` - Where `N` is the number\r\n     *  of lists to zip.\r\n     * @function module:listOps.zipWithN\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\r\n     * @param lists ...{Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWithN = (op, ...lists) => {\r\n        const trimmedLists = apply(lengthsToSmallest, lists),\r\n            lenOfTrimmed = length(trimmedLists);\r\n        if (!lenOfTrimmed) { return []; }\r\n        else if (lenOfTrimmed === 1) {\r\n            return sliceTo(length(trimmedLists[0]), trimmedLists[0]);\r\n        }\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArr(agg, apply(op, map(xs => xs[ind], trimmedLists))),\r\n            [], trimmedLists[0]);\r\n    },\r\n\r\n    /**\r\n     * Zips 3 lists with tupling function.\r\n     * @haskellType `zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]`\r\n     * @function module:listOps.zipWith3\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @param xs3 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith3 = zipWithN,\r\n\r\n    /**\r\n     * Zips 4 lists with tupling function.\r\n     * @haskellType `zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c]  -> [d] -> [e]`\r\n     * @function module:listOps.zipWith4\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> d -> (a, b, c, d)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @param xs3 {Array|String|*}\r\n     * @param xs4 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith4 = zipWithN,\r\n\r\n    /**\r\n     * Zips 5 lists.\r\n     * @haskellType `zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c]  -> [d] -> [e] -> [f]`\r\n     * @function module:listOps.zipWith5\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> d -> e -> (a, b, c, d, e)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @param xs3 {Array|String|*}\r\n     * @param xs4 {Array|String|*}\r\n     * @param xs5 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith5 = zipWithN,\r\n\r\n    /**\r\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\r\n     * @haskellType `unzip :: [(a, b)] -> ([a], [b])`\r\n     * @todo Should support other list types (should not have `push` hard coded instead should use `mappend` (if available)).\r\n     * @function module:listOps.unzip\r\n     * @param arr {Array|*}\r\n     * @returns {Array|*}\r\n     */\r\n    unzip = arr =>\r\n        foldl((agg, item) => {\r\n            agg[0].push(item[0]);\r\n            agg[1].push(item[1]);\r\n            return agg;\r\n        }, [[], []], arr),\r\n\r\n    /**\r\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\r\n     * @sudoHaskellType `unzipN :: [(a, b, ...x)] -> ([a], [b], ...[x])`\r\n     * @todo Should support other list types (should not have `push` hard coded instead should use `mappend` (if available)).\r\n     * @function module:listOps.unzip\r\n     * @param list {Array|*} - List of tuples (lists).\r\n     * @returns {Array|*}\r\n     */\r\n    unzipN = list => {\r\n        if (!length(list)) { return []; }\r\n        const lenItem0 = length(list[0]);\r\n        let zero = lenItem0 ?\r\n            unfoldr(numLists => numLists-- ? [[], numLists] : undefined, lenItem0) :\r\n            [];\r\n        return foldl((agg, item) => {\r\n            agg.forEach((outList, ind) => outList.push(item[ind]));\r\n            return agg;\r\n        }, zero, list);\r\n    },\r\n\r\n    any = (p, xs) => {\r\n        let ind = 0,\r\n            limit = length(xs);\r\n        if (!limit) { return false; }\r\n        for (; ind < limit; ind += 1) {\r\n            if (p(xs[ind])) { return true; }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    all = (p, xs) => {\r\n        const limit = length(xs);\r\n        let ind = 0;\r\n        if (limit === 0) {\r\n            return false;\r\n        }\r\n        for (; ind < limit; ind++) {\r\n            if (!p(xs[ind], ind, xs)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n\r\n    and = xs => all(isTruthy, xs),\r\n\r\n    or = xs => any(isTruthy, xs),\r\n\r\n    not = xs => all(isFalsy, xs),\r\n\r\n    sum = list => foldl((agg, x) => agg + x, 0, list),\r\n\r\n    product = arr => foldl((agg, x) => agg * x, 1, arr),\r\n\r\n    maximum = list => maximumBy(genericAscOrdering, list),\r\n\r\n    minimum = list => minimumBy(genericAscOrdering, list),\r\n\r\n    maximumBy = (ordering, xs) => last(sortBy(ordering, xs)),\r\n\r\n    minimumBy = (ordering, xs) => head(sortBy(ordering, xs)),\r\n\r\n    scanl = () => null,\r\n\r\n    scanl1 = () => null,\r\n\r\n    scanr = () => null,\r\n\r\n    scanr1 = () => null,\r\n\r\n    nub = list => nubBy((a, b) => a === b, list),\r\n\r\n    remove = (x, list) => removeBy((a, b) => a === b, x, list),\r\n\r\n    sort = xs => sortBy(genericAscOrdering, xs),\r\n\r\n    sortOn = (valueFn, xs) =>\r\n\r\n        // Un-decorate\r\n        map(decorated => decorated[1],\r\n\r\n            // Decorate and sort\r\n            sortBy(\r\n\r\n                // Ordering\r\n                (a1, b1) => {\r\n                    let a = a1[0],\r\n                        b = b1[0];\r\n                    if (a > b) { return 1; }\r\n                    else if (a < b) { return -1; }\r\n                    return 0;\r\n                },\r\n\r\n                // Decorate\r\n                map(item => [valueFn(item), item], xs)\r\n            )\r\n        ),\r\n\r\n    sortBy = (orderingFn, xs) => copy(xs).sort(orderingFn),\r\n\r\n    insert = (x, xs) => {\r\n        if (isEmpty(xs)) { return aggregatorByType(xs)(copy(xs), x, 0); }\r\n        let out = of(xs),\r\n            foundIndex = findIndex(item => x <= item, xs);\r\n        return foundIndex === -1 ? append(sliceFrom(0, out), x) :\r\n            concat(intersperse([x], splitAt(foundIndex, xs)));\r\n    },\r\n\r\n    /**\r\n     * A version of `insert` that allows you to specify the ordering of the inserted\r\n     * item;  Before/at, or after\r\n     * @function module:listOpsUncurried.insertBy\r\n     * @haskellType `insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]`\r\n     * @note `Ordering` === // something that is order-able\r\n     * @todo Optimize and work the logic of this function;  Think about the types that will be\r\n     *  operated on by this functions logic.\r\n     * @param orderingFn {Function} - A function that returns `-1`, `0`, or 1`.\r\n     * @param x {*} - Value to insert.\r\n     * @param xs {Array|String|*} - List to insert into (note new list is returned)\r\n     * @returns {Array|String|*} - New list.\r\n     */\r\n    insertBy = (orderingFn, x, xs) => {\r\n        const limit = length(xs),\r\n            aggregator =  aggregatorByType(xs),\r\n            out = of(xs);\r\n        if (isEmpty(xs)) { return aggregator(out, x, 0); }\r\n        let ind = 0;\r\n        for (; ind < limit; ind += 1) {\r\n            if (orderingFn(x, xs[ind]) <= 0) {\r\n                const parts = splitAt(ind, xs);\r\n                // Fold parts[0], [x], parts[1] into `out` and `concat`\r\n                return concat(foldl(aggregator, out, [parts[0], [x], parts[1]]));\r\n            }\r\n        }\r\n        return aggregator(copy(xs), x);\r\n    },\r\n\r\n    nubBy = (pred, list) => {\r\n        if (isEmpty(list)) { return of(list); }\r\n        const limit = length(list);\r\n        let ind = 0,\r\n            currItem,\r\n            out = of(list),\r\n            anyOp = storedItem => pred(currItem, storedItem);\r\n        for (; ind < limit; ind += 1) {\r\n            currItem = list[ind];\r\n            if (any(anyOp, out)) { continue; }\r\n            out = append(out, currItem);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    removeBy = (pred, x, list) => { // @todo optimize this implementation\r\n        const foundIndex = findIndex(item => pred(x, item), list),\r\n            parts = splitAt(foundIndex > -1 ? foundIndex : 0, list); // @todo correct this implementation\r\n        return append(parts[0], tail(parts[1]));\r\n    },\r\n\r\n    removeFirstsBy = (pred, xs1, xs2) =>\r\n        foldl((agg, item) => removeBy(pred, item, agg), xs1, xs2),\r\n\r\n    /**\r\n     * Returns the union on elements matching boolean check passed in.\r\n     * @function module:listOps.unionBy\r\n     * @param pred {Function} - `pred :: a -> a -> Bool`\r\n     * @param arr1 {Array|String|*}\r\n     * @param arr2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    unionBy = (pred, arr1, arr2) => {\r\n        const aggregator = aggregatorByType(arr1);\r\n        return foldl((agg, b) => {\r\n            const alreadyAdded = any(a => pred(a, b), agg);\r\n            return !alreadyAdded ? aggregator(agg, b) : agg;\r\n        }, copy(arr1), arr2);\r\n    },\r\n\r\n    /**\r\n     * Creates a union on matching elements from array1.\r\n     * @function module:listOps.union\r\n     * @param arr1 {Array|String|*}\r\n     * @param arr2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    union = (arr1, arr2) =>\r\n        append(arr1,\r\n            filter(elm => !includes(elm, arr1), arr2)),\r\n\r\n    /**\r\n     * Performs an intersection on list 1 with  elements from list 2.\r\n     * @function module:listOps.intersect\r\n     * @param arr1 {Array|String|*}\r\n     * @param arr2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    intersect = (arr1, arr2) =>\r\n        !arr1 || !arr2 || (!arr1 && !arr2) ? [] :\r\n            filter(elm => includes(elm, arr2), arr1),\r\n\r\n    /**\r\n     * Returns an intersection by predicate.\r\n     * @function module:listOps.intersectBy\r\n     * @param pred {Function} - `pred :: a -> b -> Bool`\r\n     * @param list1 {Array|String|*}\r\n     * @param list2 {Array|String|*}\r\n     * @return {Array|String|*}\r\n     */\r\n    intersectBy = (pred, list1, list2) => {\r\n        const aggregator = aggregatorByType(list1);\r\n        return foldl((agg, a) =>\r\n                any(b => pred(a, b), list2) ? aggregator(agg, a) : agg\r\n            , [], list1);\r\n    },\r\n\r\n    /**\r\n     * Returns the difference of list 1 from list 2.\r\n     * @note The `difference` operation here is non-associative;  E.g., `a - b` is not equal to `b - a`;\r\n     * @function module:listOps.difference\r\n     * @param array1 {Array|String|*}\r\n     * @param array2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    difference = (array1, array2) => { // augment this with max length and min length ordering on op\r\n        if (array1 && !array2) { return sliceFrom(0, array1); }\r\n        else if (!array1 && array2 || (!array1 && !array2)) { return []; }\r\n        const aggregator = aggregatorByType(array1);\r\n        return reduce((agg, elm) =>\r\n            !includes(elm, array2) ? aggregator(agg, elm) : agg\r\n            , [], array1);\r\n    },\r\n\r\n    /**\r\n     * Returns the complement of list 0 and the reset of the passed in arrays.\r\n     * @function module:listOps.complement\r\n     * @param arr0 {Array}\r\n     * @param arrays {...Array}\r\n     * @returns {Array}\r\n     */\r\n    complement = (arr0, ...arrays) =>\r\n        reduce((agg, arr) => append(agg, difference(arr, arr0)), [], arrays);\r\n","import {assignDeep} from './assignDeep';\r\nimport {hasOwnProperty, keys} from '../jsPlatform/objectOpsUncurried';\r\nimport {foldl} from '../listOps/listOpsUncurried';\r\n\r\nexport const\r\n\r\n    objUnion = (obj1, obj2) => assignDeep(obj1, obj2),\r\n\r\n    objIntersect = (obj1, obj2) => foldl((agg, key) => {\r\n        if (hasOwnProperty(key, obj2)) {\r\n            agg[key] = obj2[key];\r\n        }\r\n        return agg;\r\n    }, {}, keys(obj1)),\r\n\r\n    objDifference = (obj1, obj2) => foldl((agg, key) => {\r\n        if (!hasOwnProperty(key, obj2)) {\r\n            agg[key] = obj1[key];\r\n        }\r\n        return agg;\r\n    }, {}, keys(obj1)),\r\n\r\n    objComplement = (obj0, ...objs) => foldl((agg, obj) =>\r\n        assignDeep(agg, objDifference(obj, obj0)), {}, objs);\r\n","import {curry, curry2} from '../functionOps/curry';\r\n\r\nimport {\r\n    instanceOf as pureInstanceOf,\r\n    hasOwnProperty as pureHasOwnProperty,\r\n    assign as pureAssign\r\n} from '../uncurried/jsPlatform/objectOpsUncurried';\r\n\r\nimport {assignDeep as pureAssignDeep} from '../uncurried/objectOps/assignDeep';\r\n\r\nexport {length, toString, keys} from '../uncurried/jsPlatform/objectOpsUncurried';\r\n\r\nexport const\r\n\r\n    instanceOf = curry(pureInstanceOf),\r\n\r\n    hasOwnProperty = curry(pureHasOwnProperty),\r\n\r\n    assign = curry2(pureAssign),\r\n\r\n    assignDeep = curry2(pureAssignDeep);\r\n\r\nexport * from './../uncurried/objectOps/typeOf';\r\n\r\nexport * from './../uncurried/objectOps/is';\r\n\r\nexport * from './../uncurried/objectOps/of';\r\n\r\nexport * from './../uncurried/objectOps/setTheoryOps';\r\n","/**\r\n * Created by elydelacruz on 9/6/2017.\r\n */\r\n\r\nimport {fPureTakesOne} from '../../utils/utils';\r\n\r\n/**\r\n * Functional version of `String.prototype.split`.\r\n * @functionOps module:stringOpsUnCurried.split\r\n * @param separator {String|RegExp}\r\n * @param str {String}\r\n * @returns {Array}\r\n */\r\nexport const split = fPureTakesOne('split');\r\n","/**\r\n * Contains functions for operating strings.\r\n * @author elyde\r\n * @created 7/9/2017.\r\n */\r\nimport {intercalate} from '../listOps/listOps';\r\n\r\nimport {curry} from '../functionOps/curry';\r\n\r\nimport {split as pureSplit} from '../uncurried/jsPlatform/stringOpsUnCurried';\r\n\r\n/**\r\n * Functional version of `String.prototype.split`.\r\n * @param separator {String|RegExp}\r\n * @param str {String}\r\n * @returns {Array}\r\n */\r\nconst split = curry(pureSplit);\r\n\r\nexport const\r\n\r\n    /**\r\n     * Splits a stringOps on all '\\n', '\\r', '\\n\\r', or '\\r\\n' characters.\r\n     * @functionOps module:stringOps.lines\r\n     * @param str {String}\r\n     * @returns {Array}\r\n     */\r\n    lines = split(/[\\n\\r]/gm),\r\n\r\n    /**\r\n     * Splits a stringOps on all '\\s' and/or all '\\t' characters.\r\n     * @functionOps module:stringOps.words\r\n     * @param str{String}\r\n     * @returns {Array}\r\n     */\r\n    words = split(/[\\s\\t]/gm),\r\n\r\n    /**\r\n     * Intersperse an array of strings with '\\s' and then concats them.\r\n     * @functionOps module:stringOps.unwords\r\n     * @param arr {String}\r\n     * @returns {Array}\r\n     */\r\n    unwords = intercalate(' '),\r\n\r\n    /**\r\n     * Intersperses a '\\n' character into a list of strings and then concats it.\r\n     * @functionOps module:stringOps.unlines\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    unlines = intercalate('\\n');\r\n","/**\n * Content generated by '{project-root}/node-scripts/VersionNumberReadStream.js'.\n * Generated Sat Sep 16 2017 17:47:07 GMT-0400 (Eastern Daylight Time) \n */\n\nexport let version = '0.14.34';\n\nexport default version;\n\n","/**\r\n * Created by elyde on 12/6/2016.\r\n * @file fjl.js\r\n * @goal to include everything from haskell's Prelude where it makes sense in order to create\r\n *  a subset of functions which can make the javascript developer more efficient and make his/her\r\n *  code more concise (and functional).\r\n * @description Includes operations from haskell's Prelude.\r\n * @motivation preludejs, lodash/fp, RamdaJs, Haskell.\r\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html\r\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-List.html\r\n * @todo any cross importing between packages should be done from the package object (package file: E.g., './src/functionOps/functionOps.js').\r\n * @todo decide how to include 'uncurried' members in the main export of the library.\r\n * @module fjl\r\n */\r\n\r\nexport * from './objectOps/objectOps';\r\nexport * from './booleanOps/booleanOps';\r\nexport * from './functionOps/functionOps';\r\nexport * from './listOps/listOps';\r\n// export * from './numberOps/numberOps';\r\nexport * from './stringOps/stringOps';\r\n// export * from './compoundedOps/compoundedOps';\r\n\r\nexport {version} from '../generated-for-src/version';\r\n"],"names":["PlaceHolder","placeHolderInstance","curry","fn","argsToCurry","args","concatedArgs","concat","length","apply","isPlaceHolder","instance","replacePlaceHolders","array","out","map","element","shift","curry_","placeHolders","filter","canBeCalled","curryN_","executeArity","curriedArgs","curryN","__","Object","freeze","curry2_","curry3_","curry4_","curry5_","curry2","curry3","curry4","curry5","fPureTakesOne","arg","f","name","fPureTakes2","arg1","arg2","fPureTakesOneOrMore","instanceOf","instanceConstructor","hasOwnProperty","x","toString","keys","obj","assign","obj0","objs","reduce","topAgg","agg","key","_Number","Number","_NaN","_Null","_Undefined","_undefined","typeOf","value","retVal","constructorName","constructor","isNaN","_String","String","_Object","_Boolean","Boolean","_Function","Function","_Array","Array","_Symbol","_Map","_Set","_WeakMap","_WeakSet","isFunction","isType","type","isClass","test","substr","isCallable","isArray","isObject","isBoolean","isNumber","isString","isMap","isSet","isWeakMap","isWeakSet","isUndefined","isNull","isSymbol","isPromise","isUsableImmutablePrimitive","typeOfX","some","Type","isEmptyList","isEmptyObject","isEmptyCollection","size","isEmpty","typeOfValue","notEmptyAndOfType","isset","assignDeep","propDescription","getOwnPropertyDescriptor","get","set","writable","call","of","undefined","slice","includes","prototype","xs","indexOf","lastIndexOf","reduceRight","forEach","every","join","push","negateF","a","b","pureCall","pureApply","append","_append","appendMany","_appendMany","concatMap","_concatMap","_map","intersperse","_intersperse","intercalate","_intercalate","foldl","_foldl","foldr","_foldr","foldl1","_foldl1","foldr1","_foldr1","mapAccumL","_mapAccumL","mapAccumR","_mapAccumR","iterate","_iterate","repeat","_repeat","replicate","cycle","_cycle","unfoldr","_unfoldr","findIndex","_findIndex","findIndices","_findIndices","elemIndex","_elemIndex","elemIndices","_elemIndices","take","_take","drop","_drop","splitAt","_splitAt","takeWhile","_takeWhile","dropWhile","_dropWhile","dropWhileEnd","_dropWhileEnd","span","_span","breakOnList","_breakOnList","at","_at","find","_find","_filter","partition","_partition","elem","_elem","notElem","_notElem","lookup","isPrefixOf","_isPrefixOf","isSuffixOf","_isSuffixOf","isInfixOf","_isInfixOf","isSubsequenceOf","_isSubsequenceOf","groupBy","_groupBy","stripPrefix","_stripPrefix","zip","_zip","zipWith","_zipWith","zipWithN","_zipWithN","zipWith3","zipWith4","zipWith5","any","_any","all","_all","maximumBy","_maximumBy","minimumBy","_minimumBy","scanl","scanl1","scanr","scanr1","remove","_remove","sortOn","_sortOn","sortBy","_sortBy","insert","_insert","insertBy","_insertBy","nubBy","_nubBy","removeBy","_removeBy","removeFirstsBy","_removeFirstsBy","unionBy","_unionBy","union","_union","intersect","_intersect","intersectBy","_intersectBy","difference","_difference","complement","_complement","compose","arg0","negateP","ind","id","flipN","reverse","flip","until","predicate","operation","typeInstance","result","isTruthy","isFalsy","alwaysTrue","alwaysFalse","bAnd","bOr","bNot","bOtherwise","bEqual","prop","aggregateStr","item","aggregateArr","aggregateObj","aggregatorByType","limit","aggregate","sliceFrom","startInd","arr","sliceTo","toInd","copy","genericAscOrdering","lengths","lists","lengthsToSmallest","listLengths","smallLen","Math","min","list","reduceUntil","pred","op","reduceRightUntil","lastIndex","len","findIndexWhere","predicateFulfilled","findIndexWhereRight","findIndicesWhere","findWhere","elm","listAppend","lenArgs","head","last","tail","init","uncons","unconsr","foldableOfA","aggregator","between","lastInd","aggregatorOp","xss","transpose","numLists","ind2","longestListLen","maximum","outLists","outList","subsequences","pow","i","entry","j","permutations","parts","zero","mapped","tuple","resultTuple","foundInd","count","splitPoint","list2","xs1","xs2","limit1","limit2","ind1","foundLen","lenXs1","group","equalityOp","prevItem","predOp","inits","tails","prefix","arr1","arr2","a1","a2","zipN","trimmedLists","lenOfTrimmed","unzip","unzipN","lenItem0","p","and","or","sum","product","minimum","ordering","nub","sort","valueFn","decorated","b1","orderingFn","foundIndex","currItem","anyOp","storedItem","alreadyAdded","list1","array1","array2","arr0","arrays","objUnion","obj1","obj2","objIntersect","objDifference","objComplement","pureInstanceOf","pureHasOwnProperty","pureAssign","pureAssignDeep","split","pureSplit","lines","words","unwords","unlines","version"],"mappings":"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"}