{"version":3,"file":"fjl.js","sources":["../../src/function/curry.js","../../src/utils.js","../../src/jsPlatform/array.js","../../src/jsPlatform/function.js","../../src/function/flip.js","../../src/jsPlatform/object.js","../../src/object/typeOf.js","../../src/object/is.js","../../src/object/lookup.js","../../src/object/of.js","../../src/object/copy.js","../../src/object/searchObj.js","../../src/errorThrowing.js","../../src/object/defineProp.js","../../src/object/assignDeep.js","../../src/jsPlatform/list.js","../../src/boolean.js","../../src/list/map.js","../../src/list/aggregation.js","../../src/list/utils.js","../../src/object/setTheory.js","../../src/object/console.js","../../src/object/jsonClone.js","../../src/object/assocList.js","../../src/object/toArray.js","../../src/function/compose.js","../../src/function/id.js","../../src/function/negate.js","../../src/function/until.js","../../src/function/fnOrError.js","../../src/function/noop.js","../../src/function/trampoline.js","../../src/function/toFunction.js","../../src/list/range.js","../../src/jsPlatform/string.js","../../src/jsPlatform.js","../../src/list.js","../../src/string.js","../../src/fjl.js"],"sourcesContent":["/**\n * @author elydelacruz\n * @created 12/6/2016.\n * @memberOf function\n * @description \"Curry strict\" and \"curry arbitrarily\" functions (`curry`, `curryN`).\n */\n\n/**\n * @private\n * @type {string}\n */\nconst\n\n    /**\n     * Returns curried function.\n     * @private\n     * @param executeArity {Number}\n     * @param unmetArityNum {Number}\n     * @param fn {Function}\n     * @param argsToCurry {...*}\n     * @returns {Function} - Curried function.\n     */\n    returnCurried = (executeArity, unmetArityNum, fn, argsToCurry) => {\n        switch (unmetArityNum) {\n            case 1:\n                /* eslint-disable */\n                return function func(x) {\n                /* eslint-enable */\n                    return executeAsCurriedFunc(fn, executeArity, unmetArityNum, Array.from(arguments), argsToCurry);\n                };\n            case 2:\n                /* eslint-disable */\n                return function func(a, b) {\n                /* eslint-enable */\n                    return executeAsCurriedFunc(fn, executeArity, unmetArityNum, Array.from(arguments), argsToCurry);\n                };\n            case 3:\n                /* eslint-disable */\n                return function func(a, b, c) {\n                /* eslint-enable */\n                    return executeAsCurriedFunc(fn, executeArity, unmetArityNum, Array.from(arguments), argsToCurry);\n                };\n            case 4:\n                /* eslint-disable */\n                return function func(a, b, c, d) {\n                /* eslint-enable */\n                    return executeAsCurriedFunc(fn, executeArity, unmetArityNum, Array.from(arguments), argsToCurry);\n                };\n            case 5:\n                /* eslint-disable */\n                return function func(a, b, c, d, e) {\n                /* eslint-enable */\n                    return executeAsCurriedFunc(fn, executeArity, unmetArityNum, Array.from(arguments), argsToCurry);\n                };\n            default:\n                return (...args) => executeAsCurriedFunc(fn, executeArity, unmetArityNum, args, argsToCurry);\n        }\n    },\n\n    /**\n     * Returns curried function if unmetArity is not met else returns result of executing\n     * final function.\n     * @private\n     * @param fn {Function}\n     * @param executeArity {Number}\n     * @param unmetArity {Number}\n     * @param args {Array<*>}\n     * @param argsToCurry {Array<*>}\n     * @returns {Function|*} - Curried function or result of 'finally' executed function.\n     */\n    executeAsCurriedFunc = (fn, executeArity, unmetArity, args, argsToCurry) => {\n        let concatedArgs = argsToCurry.concat(args),\n            canBeCalled = (concatedArgs.length >= executeArity) || !executeArity,\n            newExpectedArity = executeArity - concatedArgs.length;\n        return !canBeCalled ?\n            returnCurried(executeArity, newExpectedArity, fn, concatedArgs) :\n            fn(...concatedArgs);\n    }\n;\n\nexport const\n\n    /**\n     * Curries a function up to a given arity.\n     * @function module:function.curryN\n     * @param executeArity {Number}\n     * @param fn {Function}\n     * @param argsToCurry {...*}\n     * @returns {Function}\n     * @throws {Error} - When `fn` is not a function.\n     */\n    curryN = (executeArity, fn, ...argsToCurry) => {\n        if (!fn || !(fn instanceof Function)) {\n            throw new Error(`\\`curry*\\` functions expect first parameter to be of type \\`Function\\` though received ${fn}?`);\n        }\n        return returnCurried(executeArity, executeArity - argsToCurry.length, fn, argsToCurry);\n    },\n\n    /**\n     * Curries a function based on it's defined arity (note: rest args param (`...rest`) are not counted in arity).\n     * @function module:function.curry\n     * @param fn {Function}\n     * @param argsToCurry {...*}\n     * @returns {Function}\n     */\n    curry = (fn, ...argsToCurry) => curryN((fn || {}).length, fn, ...argsToCurry),\n\n    /**\n     * Curries a function up to an arity of 2 (won't call function until 2 or more args).\n     * @function module:function.curry2\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry2 = fn => curryN(2, fn),\n\n    /**\n     * Curries a function up to an arity of 3 (won't call function until 3 or more args).\n     * @function module:function.curry3\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry3 = fn => curryN(3, fn),\n\n    /**\n     * Curries a function up to an arity of 4 (won't call function until 4 or more args).\n     * @function module:function.curry4\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry4 = fn => curryN(4, fn),\n\n    /**\n     * Curries a function up to an arity of 5 (won't call function until 5 or more args).\n     * @function module:function.curry5\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry5 = fn => curryN(5, fn);\n","/**\n * @module utils\n */\nimport {curry, curry2} from './function/curry';\n\nexport const\n\n    /**\n     * Returns a function that takes an argument and an object on which to execute 'method name'\n     * with said parameters.\n     * @function module:utils.fPureTakesOne\n     * @param name {String}\n     * @returns {Function}\n     */\n    fPureTakesOne = name => curry((arg, f) => f[name](arg)),\n\n    /**\n     * Returns a function that takes 2 arguments and an object on which to execute 'method name'\n     * with said parameters.\n     * @function module:utils.fPureTakes2\n     * @param name {String}\n     * @returns {Function}\n     */\n    fPureTakes2 = name => curry((arg1, arg2, f) => f[name](arg1, arg2)),\n\n    /**\n     * Returns a function that takes 3 arguments and an object on which to execute 'method name'\n     * with said parameters.\n     * @function module:utils.fPureTakes3\n     * @param name {String}\n     * @returns {Function}\n     */\n    fPureTakes3 = name => curry((arg1, arg2, arg3, f) => f[name](arg1, arg2, arg3)),\n\n    /**\n     * Returns a function that takes 4 arguments and an object on which to execute 'method name'\n     * with said parameters.\n     * @function module:utils.fPureTakes4\n     * @param name {String}\n     * @returns {Function}\n     */\n    fPureTakes4 = name => curry((arg1, arg2, arg3, arg4, f) => f[name](arg1, arg2, arg3, arg4)),\n\n    /**\n     * Returns a function that takes 5 arguments and an object on which to execute 'method name'\n     * with said parameters.\n     * @function module:utils.fPureTakes5\n     * @param name {String}\n     * @returns {Function}\n     */\n    fPureTakes5 = name => curry((arg1, arg2, arg3, arg4, arg5, f) => f[name](arg1, arg2, arg3, arg4, arg5)),\n\n    /**\n     * Returns a function that takes an object and one or more arguments on which to execute 'method name'\n     * with said parameters.\n     * @function module:utils.fPureTakesOneOrMore\n     * @param name {String}\n     * @returns {Function}\n     */\n    fPureTakesOneOrMore = name => curry2((f, ...args) => f[name](...args))\n\n;\n","/**\n * Created by elyde on 7/20/2017.\n * Functional versions of common array methods (`map`, `filter`, etc.) (un-curried);\n */\n\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from '../utils';\n\nconst\n    /**\n     * Array.prototype.reverse generator (generates a function that calls the prototype version or a\n     * shimmed version if it doesn't exist).\n     * @returns {Function}\n     */\n    defineReverse = () =>\n        Array.prototype.reverse ? x => x.reverse() :\n            x => x.reduceRight((agg, item) => {\n                agg.push(item);\n                return agg;\n            }, [])\n;\n\nexport const\n\n    /**\n     * Maps a function to functor (list etc.).\n     * @function module:jsPlatform.map\n     * @param fn {Function}\n     * @param functor {Array|{map: {Function}}}\n     * @returns {Array|{map: {Function}}}\n     */\n    map = fPureTakesOne('map'),\n\n    /**\n     * Filters a functor (list etc.) with passed in function.\n     * @function module:jsPlatform.filter\n     * @param fn {Function}\n     * @param functor {Array|{filter: {Function}}}\n     * @returns {Array|{filter: {Function}}}\n     */\n    filter = fPureTakesOne('filter'),\n\n    /**\n     * Reduces a foldable (list etc.) with passed in function.\n     * @function module:jsPlatform.reduce\n     * @param fn {Function}\n     * @param functor {Array|{reduce: {Function}}}\n     * @returns {Array|{reduce: {Function}}}\n     */\n    reduce = fPureTakes2('reduce'),\n\n    /**\n     * Reduces a foldable (list etc.) from the right with passed in function.\n     * @function module:jsPlatform.reduceRight\n     * @param fn {Function}\n     * @param functor {Array|{reduceRight: {Function}}}\n     * @returns {Array|{reduceRight: {Function}}}\n     */\n    reduceRight = fPureTakes2('reduceRight'),\n\n    /**\n     * For each on functor (Array|Object|etc.).\n     * @function module:jsPlatform.forEach\n     * @param fn {Function}\n     * @param functor {Array|Object|*}\n     * @return {*|Array|Object} - The type of object you pass in unless it doesn't have a `forEach` method.\n     * @throws {Error} - When passed in functor doesn't have a `forEach` method.\n     */\n    forEach = fPureTakesOne('forEach'),\n\n    /**\n     * Returns `true` if `fn` (predicate) returns true for at least one item\n     * in functor else returns `false`.\n     * @param fn {Function} - Predicate.\n     * @param functor {Array|Object|*}\n     * @return {*|Array|Object} - The type passed.\n     * @throws {Error} - When passed in object doesn't have a `some` method.\n     */\n    some = fPureTakesOne('some'),\n\n    /**\n     * Returns `true` if `fn` (predicate) returns true for all items in functor else returns `false`.\n     * @function module:jsPlatform.every\n     * @param fn {Function} - Predicate.\n     * @param functor {Array|Object|*}\n     * @return {*|Array|Object} - The type passed.\n     * @throws {Error} - When passed in object doesn't have an `every` method.\n     */\n    every = fPureTakesOne('every'),\n\n    /**\n     * Array.prototype.join\n     * @function module:jsPlatform.join\n     * @param separator {String|RegExp}\n     * @param arr {Array}\n     * @returns {String}\n     */\n    join = fPureTakesOne('join'),\n\n    /**\n     * Same as Array.prototype.push\n     * @function module:jsPlatform.push\n     * @param item {*}\n     * @param arr {Array}\n     * @returns {Number}\n     */\n    push = fPureTakesOneOrMore('push'),\n\n    /**\n     * Reverses an list (shimmed if not exists).\n     * @function module:jsPlatform.reverse\n     * @param x {Array<any>}\n     * @return {Array}\n     */\n    reverse = defineReverse();\n","import {curry, curry2} from '../function/curry';\n\n/**\n * Created by elydelacruz on 9/7/2017.\n */\nexport const\n\n    /**\n     * Functional `apply` function (takes no context).\n     * @function module:function.apply\n     * @param fn {Function}\n     * @param args {Array|*}\n     * @returns {*}\n     */\n    apply = curry((fn, args) => fn.apply(null, args)),\n\n    /**\n     * Functional `call` function (takes no context).\n     * @function module:function.call\n     * @param fn {Function}\n     * @param args {...*}\n     * @returns {*}\n     */\n    call = curry2((fn, ...args) => fn.call(null, ...args));\n","import {reverse} from '../jsPlatform/array';\nimport {apply, call} from '../jsPlatform/function';\nimport {curry, curry2} from './curry';\n\nexport const\n\n    /**\n     * Returns a curried function requiring given functions arguments in reverse\n     * (returned function expects 2 or more variables (curried at 2 or more args)).\n     * @function module:function.flipN\n     * @param fn {Function}\n     * @returns {Function}\n     * @curried\n     */\n    flipN = fn => curry2((...args) => apply(fn, reverse(args))),\n\n    /**\n     * Flips a function's first and second arguments and and returns a new function requiring said arguments in reverse.\n     * @function module:function.flip\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    flip = fn => curry((b, a) => call(fn, a, b)),\n\n    /**\n     * Same as `flip` except returns a flipped function of arity 3.\n     * @function module:function.flip3\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    flip3 = fn => curry((c, b, a) => call(fn, a, b, c)),\n\n    /**\n     * Same as `flip` except returns a flipped function of arity 4.\n     * @function module:function.flip4\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    flip4 = fn => curry((d, c, b, a) => call(fn, a, b, c, d)),\n\n    /**\n     * Same as `flip` except returns a flipped function of arity 5.\n     * @function module:function.flip5\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    flip5 = fn => curry((e, d, c, b, a) => call(fn, a, b, c, d, e));\n","/**\n * @description Defines some of the platform methods for objects (the ones used within `fjl`).\n */\n\nimport {fPureTakesOne} from '../utils';\nimport {curry, curry2} from '../function/curry';\nimport {flip, flip3, flip4, flip5} from '../function/flip';\n\nexport const\n\n    /**\n     * Returns whether constructor has derived object.\n     * @function module:object.instanceOf\n     * @param instanceConstructor {Function} - Constructor.\n     * @param instance {*}\n     * @instance {*}\n     * @returns {Boolean}\n     */\n    instanceOf = curry((instanceConstructor, instance) =>\n        instance instanceof instanceConstructor),\n\n    /**\n     * @function module:object.hasOwnProperty\n     * @param propName {*}\n     * @param typeInstance {*}\n     * @returns {Boolean}\n     * @deprecated - Use property directly instead.\n     */\n    hasOwnProperty = fPureTakesOne('hasOwnProperty'),\n\n    /**\n     * @function module:object.length\n     * @param x {*}\n     * @returns {Number}\n     * @throws {Error} - Throws an error if value doesn't have a `length` property (\n     *  `null`, `undefined`, {Boolean}, Symbol, et. al.).\n     */\n    length = x => x.length,\n\n    /**\n     * Contains all the static functions from `Object` but curried and flipped;\n     * @example\n     * // E.g., `Object.defineProperties(obj, descriptor)` can now be used like\n     * import {defineProperties} from 'fjl'\n     * defineProperties(descriptor, someObj),\n     * // Et. al.\n     * @memberOf module:object\n     * @type {{...Object}}\n     */\n    native = Object.getOwnPropertyNames(Object).reduce((agg, key) => {\n        if (typeof Object[key] !== 'function') {\n            return agg;\n        }\n        const operation = Object[key];\n        switch (operation.length) {\n            case 2:\n                agg[key] = flip(operation);\n                break;\n            case 3:\n                agg[key] = flip3(operation);\n                break;\n            case 4:\n                agg[key] = flip4(operation);\n                break;\n            case 5:\n                agg[key] = flip5(operation);\n                break;\n            default:\n                agg[key] = Object[key];\n                break;\n        }\n        return agg;\n    }, {}),\n\n    /**\n     * Gets passed in object's own enumerable keys (same as `Object.keys`).\n     * @function module:object.keys\n     * @param obj {*}\n     * @returns {Array<String>}\n     */\n    {keys} = native,\n\n    /**\n     * Defined as `Object.assign` else is the same thing but shimmed.\n     * @function module:object.assign\n     * @param obj0 {Object}\n     * @param objs {...{Object}}\n     * @returns {Object}\n     */\n    assign = (() => Object.assign ?\n            (obj0, ...objs) => Object.assign(obj0, ...objs) :\n            curry2((obj0, ...objs) => objs.reduce((topAgg, obj) => {\n                return Object.keys(obj).reduce((agg, key) => {\n                    agg[key] = obj[key];\n                    return agg;\n                }, topAgg);\n            }, obj0))\n        )();\n","/**\n * Created by elyde on 12/18/2016.\n * @memberOf object\n */\nconst _Number = Number.name,\n    _NaN = 'NaN',\n    _Null = 'Null',\n    _Undefined = 'Undefined';\n\n/**\n * Returns the constructor/class/type name of a value.\n * @note Returns 'NaN' if value is of type `Number` and value is `isNaN`.\n * @note Returns 'Undefined' if value is `undefined`\n * @note Returns 'Null' if value is `null`\n * For values that have no concrete constructors and/or casters\n * (null, NaN, and undefined) we returned normalized names for them ('Null', 'NaN', 'Number')\n * @function module:object.typeOf\n * @param value {*}\n * @returns {string} - Constructor's name or derived name (in the case of `null`, `undefined`, or `NaN` (whose\n *  normalized names are 'Null', 'Undefined', 'NaN' respectively).\n */\nexport function typeOf (value) {\n    let retVal;\n    if (value === undefined) {\n        retVal = _Undefined;\n    }\n    else if (value === null) {\n        retVal = _Null;\n    }\n    else {\n        let constructorName = (value).constructor.name;\n        retVal = constructorName === _Number && isNaN(value) ?\n            _NaN : constructorName;\n    }\n    return retVal;\n}\n","/**\n * Created by elyde on 12/18/2016.\n * @memberOf object\n */\n\nimport {typeOf} from './typeOf';\nimport {instanceOf, length, keys} from '../jsPlatform/object';\nimport {curry} from '../function/curry';\n\nlet _String = String.name,\n    _Number = Number.name,\n    _Object = Object.name,\n    _Boolean = Boolean.name,\n    _Symbol = 'Symbol',\n    _Map = 'Map',\n    _Set = 'Set',\n    _WeakMap = 'WeakMap',\n    _WeakSet = 'WeakSet',\n    _Null = 'Null',\n    _Undefined = 'Undefined';\n\nexport const\n\n    /**\n     * Resolves/normalizes a type name from either a string or a constructor.\n     * @function module:object.toTypeRef\n     * @param type {Function|String} - String or function representing a type.\n     * @returns {String}\n     * @todo write tests for this function.\n     */\n    toTypeRef = type => {\n        if (!type) {\n            return typeOf(type);\n        }\n        else if (type.constructor === String || (type instanceof Function)) {\n            return type;\n        }\n        return typeOf(type);\n    },\n\n    /**\n     * Returns an array of type refs from possible type refs (converts null, undefined, NaN, and other values into\n     * type refs (either constructor name or constructor name based on whether value(s) is a string, a constructor, or not).\n     * @function module:object.toTypeRefs\n     * @param types {...(TypeRef|*)}\n     * @returns {Array<TypeRef>}\n     * @todo Ensure tests are written for this function.\n     */\n    toTypeRefs = (...types) => types.map(toTypeRef),\n\n    /**\n     * Returns possible Type's TypeRef name.\n     * @function module:object.toTypeRefName\n     * @param Type {(TypeRef|*)}\n     * @returns {String}\n     * @todo Ensure tests are written for this function.\n     */\n    toTypeRefName = Type => {\n        const ref = toTypeRef(Type);\n        return ref instanceof Function ? ref.name : ref;\n    },\n\n    /**\n     * Returns possible Types' TypeRef names.\n     * @function module:object.toTypeRefNames\n     * @param types {...(TypeRef|*)}\n     * @returns {String[]}\n     * @todo Ensure tests are written for this function.\n     */\n    toTypeRefNames = (...types) => types.map(toTypeRefName),\n\n    /**\n     * Returns whether a value is a function or not.\n     * @function module:object.isFunction\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isFunction = instanceOf(Function),\n\n    /**\n     * Strict type checker.  Checks if given value is a direct instance of given type;  E.g.,\n     * @example\n     *   isType(String, 'abcdefg')  === true // true\n     *   isType(String.name, 'abcdefg') === true\n     *   isType(Number, NaN) === false\n     *   isType(Number, 99) === true\n     *   isType('Null', 99) === false // though, for `null` and `undefined` checks\n     *                                // @see `isset`, in this module, instead\n     *   isType('Undefined', undefined) === true // true\n     *\n     * @note Useful where absolute types, or some semblance thereof, are required.\n     * @function module:object.isType\n     * @param type {Function|ObjectConstructor|String} - Constructor or constructor name\n     * @param obj {*}\n     * @return {Boolean}\n     */\n    isType = curry((type, obj) => typeOf(obj) === toTypeRefName(type)),\n\n    /**\n     * Synonym for `isType` (or just a more accurate name for `isType`).\n     * @function module:object.isStrictly\n     * @param type {Function|ObjectConstructor|String} - Constructor or constructor name\n     * @param obj {*}\n     * @return {Boolean}\n     */\n    isStrictly = isType,\n\n    /**\n     * Loose type checker;  E.g., If `type` is not a constructor, but a constructor name, does a type check on\n     * constructor names, else if first check fails and `type` is a constructor, performs an `instanceof` check\n     * on value with constructor.\n     * @note Use care when checking for `Array` since it is an `instanceof` Object.\n     * @note For `null` and `undefined` their class cased names can be used for type checks\n     * `isOfType('Null', null) === true (passes strict type check)` (or better yet @link `module:object.isset` can be used).\n     * @throwsafe - Doesn't throw on `null` or `undefined` `obj` values.\n     * @example\n     * isOfType(Number, 99) === true        // true  (passes strict type check (numbers are not instances of `Number`\n     *                                      //        constructor)\n     * isOfType('Number', 99) === true      // true  (passes strict type check)\n     * isOfType(Number, NaN) === true       // true. (passes instance of check)\n     *                                      //        If you want \"true\" strict type checking use `isType`\n     * isOfType(Object, []) === true        // true  (passes instance of check)\n     * isOfType(Array, []) === true         // true  (passes instance of check)\n     * isOfType(Object, {}) === true        // true  (passes instance of check)\n     * isOfType(Object.name, {}) === true   // true  (Passes strict type check)\n     * class Abc extends String {}\n     * isOfType(String, new Abc('abcd')) // true (passes instanceof check)\n     *\n     * @function module:object.isOfType\n     * @param type {Function|String} - Type reference (constructor or `constructor.name`).\n     * @param x {*} - Value to check.\n     * @returns {Boolean}\n     */\n    isOfType = curry((type, x) => isType(type, x) || instanceOf(type, x)),\n\n    /**\n     * Synonym for `isOfType` (or just a more accurate name).\n     * @function module:object.isLoosely\n     * @param type {Function|String} - Type reference (constructor or `constructor.name`).\n     * @param x {*} - Value to check.\n     * @returns {Boolean}\n     */\n    isLoosely = isOfType,\n\n    /**\n     * Checks if `value` is an es2015 `class`.\n     * @function module:object.isClass\n     * @param x {*}\n     * @returns {boolean}\n     */\n    isClass = x => x && /^\\s{0,3}class\\s{1,3}/.test((x + '').substr(0, 10)),\n\n    /**\n     * Returns a boolean depicting whether a value is callable or not.\n     * @function module:object.isCallable\n     * @tentative\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isCallable = x => isFunction(x) && !isClass(x),\n\n    /**\n     * Checks if value is an array (same as `Array.isArray`).\n     * @function module:object.isArray\n     * @param value {*}\n     * @returns {boolean}\n     */\n    {isArray} = Array,\n\n    /**\n     * Checks whether value is an object or not.\n     * @function module:object.isObject\n     * @param value\n     * @returns {Boolean}\n     */\n    isObject = isType(_Object),\n\n    /**\n     * Checks if value is a boolean.\n     * @function module:object.isBoolean\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isBoolean = isType(_Boolean),\n\n    /**\n     * Checks if value is a valid number (also checks if isNaN so that you don't have to).\n     * @function module:object.isNumber\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isNumber = isType(_Number),\n\n    /**\n     * Checks whether value is a string or not.\n     * @function module:object.isString\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isString = isType(_String),\n\n    /**\n     * Checks whether value is of `Map` or not.\n     * @function module:object.isMap\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isMap = isType(_Map),\n\n    /**\n     * Checks whether value is of `Set` or not.\n     * @function module:object.isSet\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isSet = isType(_Set),\n\n    /**\n     * Checks whether value is of `WeakMap` or not.\n     * @function module:object.isWeakMap\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isWeakMap =isType(_WeakMap),\n\n    /**\n     * Checks whether value is of `WeakSet` or not.\n     * @function module:object.isWeakSet\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isWeakSet = isType(_WeakSet),\n\n    /**\n     * Checks if value is undefined.\n     * @function module:object.isUndefined\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isUndefined = isType(_Undefined),\n\n    /**\n     * Checks if value is null.\n     * @function module:object.isNull\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isNull = isType(_Null),\n\n    /**\n     * Checks if value is a `Symbol`.\n     * @function module:object.isSymbol\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isSymbol = isType(_Symbol),\n\n    /**\n     * Checks if given `x` is set and of one of\n     *  [String, Boolean, Number, Symbol] (null and undefined are immutable\n     *  but are not \"usable\" (usually not what we want to operate on).\n     * @function module:object.isUsableImmutablePrimitive\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isUsableImmutablePrimitive = x => {\n        const typeOfX = typeOf(x);\n        return isset(x) &&\n            [_String, _Number, _Boolean, _Symbol]\n                .some(Type => Type === typeOfX);\n    },\n\n    /**\n     * Checks if !length.\n     * @function module:object.isEmptyList\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isEmptyList = x => !length(x),\n\n    /**\n     * Checks if object has own properties/enumerable-props or not.\n     * @function module:object.isEmptyObject\n     * @param obj {*}\n     * @returns {Boolean}\n     */\n    isEmptyObject = obj => isEmptyList(keys(obj)),\n\n    /**\n     * Checks if collection is empty or not (Map, WeakMap, WeakSet, Set etc.).\n     * @function module:object.isEmptyCollection\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isEmptyCollection = x => x.size === 0,\n\n    /**\n     * Checks to see if passed in value is empty;  I.e.,\n     *  check for one of '', 0, `null`, `undefined`, `NaN`, `false`, empty array, empty object, ~~empty function (zero arity)~~,\n     *  or empty collection (es6 collection: Map, Set, WeakMap, or WeakSet etc.) (`!value.size`).\n     * @function module:object.isEmpty\n     * @param x {*} - Value to check.\n     * @returns {Boolean}\n     */\n    isEmpty = x => {\n        if (!x) { // if '', 0, `null`, `undefined`, `NaN`, or `false` then is empty\n            return true;\n        }\n        if (isNumber(x) || isFunction(x)) {\n            return false;\n        }\n        if (isArray(x)) { // takes care of 'instances of Array'\n            return !x.length;\n        }\n        if (x.size !== undefined && !instanceOf(Function, x.size)) {\n            return !x.size;\n        }\n        if (isObject(x)) {\n            return !keys(x).length;\n        }\n        return false;\n    },\n\n    /**\n     * Returns whether passed in values is defined and not null or not.\n     * @function module:object.isset\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isset = x => x !== null && x !== undefined,\n\n    /**\n     * Checks to see if `x` is of one of the given type refs;  Strict type check (not-instanceof check).\n     * @function object.isOneOf\n     * @param x {*}\n     * @param types {...(TypeRef|*)}\n     * @returns {boolean}\n     * @deprecated - Instead use @link module:isStrictlyOneOf\n     * @todo write tests for this function.\n     */\n    isOneOf = (x, ...types) => {\n        const typeName = typeOf(x);\n        return toTypeRefNames(types).some(name => typeName === name);\n    },\n\n    /**\n     * Checks if given value is strictly one of given types.\n     * @function module:object.isStrictlyOneOf\n     * @param x {*}\n     * @param types {...TypeRef}\n     * @returns {boolean}\n     */\n    isStrictlyOneOf = isOneOf,\n\n    /**\n     * Checks if given value is either strictly one of given types or is\n     * an `instanceof` one of given types.\n     * @function module:object.isLooselyOneOf\n     * @param x {*}\n     * @param types {...TypeRef}\n     * @returns {boolean}\n     */\n    isLooselyOneOf = (x, ...types) =>\n        types.some(type => isType(type, x) || instanceOf(x, type)),\n\n    /**\n     * Checks if given value is instance of one of the types given.\n     * @function module:object.instanceOfOne\n     * @param x {*}\n     * @param types {...TypeRef}\n     * @returns {boolean}\n     */\n    instanceOfOne = (x, ...types) => types.some(instanceOf(x)),\n\n    /**\n     * Checks if value qualifies (has `map` method) as a functor.\n     * @function module:object.isFunctor\n     * @param x {*}\n     * @returns {bool}\n     */\n    isFunctor = x => x && x.map && instanceOf(Function, x.map)\n\n;\n","/**\n * @memberOf object\n */\n\nimport {isset} from './is';\nimport {curry} from '../function/curry';\n\n/**\n * Looks up property and returns it's value; Else `undefined`.\n * Method is null safe (will not throw on `null` or `undefined`).\n * @function module:object.lookup\n * @param key {String} - Key to search on `obj`\n * @param obj {Object} - Object to search `name` on.\n * @returns {*}\n */\nexport const lookup = curry((key, obj) => isset(obj) ? obj[key] : undefined);\n","import {isFunction, isset, isUsableImmutablePrimitive} from './is';\nimport {apply} from '../jsPlatform/function';\n\n/**\n * Creates a value `of` given type;  Checks for one of the following construction strategies (in order listed):\n * @example\n * // - If exists `(value).constructor.of` uses this.\n * // - If value is of one String, Boolean, Symbol, or Number types calls it's\n * //      constructor as a function (in cast form;  E.g., `constructor(...args)` )\n * // - Else if constructor is a function, thus far, then calls constructor using\n * //      the `new` keyword (with any passed in args).\n\n * @function module:object.of\n * @param x {*} - Value to derive returned value's type from.\n * @param [args] {...*} - Any args to pass in to matched construction strategy.\n * @returns {*|undefined} - New value of given value's type else `undefined`.\n */\nexport const of = (x, ...args) => {\n    if (!isset(x)) { return undefined; }\n    const constructor = x.constructor;\n    if (constructor.hasOwnProperty('of')) {\n        return apply(constructor.of, args);\n    }\n    else if (isUsableImmutablePrimitive(x)) {\n        return apply(constructor, args);\n    }\n    else if (isFunction(constructor)) {\n        return new constructor(...args);\n    }\n    return undefined;\n};\n","import {typeOf} from './typeOf';\nimport {of} from './of';\n\nexport const\n\n    /**\n     * Make a copy of a value or optionally copy incoming value onto an outgoing value (second parameter).\n     * @note If incoming thing is an immmutable primitive (string, number, symbol, null, undefined, boolean)\n     *  it is returned as is.\n     * @function module:object.copy\n     * @param x {*} - Thing to copy.\n     * @param [out = undefined] {*} - Optional value to copy on to.  Not required.\n     * @returns {*} - Copied thing or optionally outgoing value copied onto.\n     */\n    copy = (x, out) => {\n        // if `null`, `undefined`, `''`, `0`, `false` return\n        if (!x) { return x; }\n        switch (typeOf(x)) {\n            case Array.name:\n                return !out ? x.slice(0) : Object.assign(out, x);\n\n            // If immutable primitive, return it\n            case Symbol.name:\n            case Boolean.name:\n            case String.name:\n            case Number.name:\n            case Promise.name:\n            case Function.name:\n            case 'NaN':\n            case 'Null':\n            case 'Undefined':\n                return x;\n\n            case 'Map':\n            case 'Set':\n            case 'WeakMap':\n            case 'WeakSet':\n                return new x.constructor(Array.from(x));\n\n            // Else make copy\n            default:\n                return Object.assign(!out ? of(x) : out, x);\n        }\n    }\n;\n\nexport default copy;\n","import {isset} from './is';\nimport {curry} from '../function/curry';\n\nexport const\n\n    /**\n     * Gives you value at key/namespace-key within `obj`;  E.g.,\n     * searchObj('all.your.base', {all: {your: {base: 99}}}) === 99 // `true`\n     * @note If key is unreachable (undefined) returns `undefined`.\n     *  Useful in cases where we do not want to check each key along the way before getting/checking value;  E.g.,\n     * @example\n     * ```\n     * if (obj && obj.all && obj.all.your && obj.all.your.base) {\n     *   // Thing we want to do\n     * }\n     *\n     * // So with our function becomes\n     * if (searchObj('all.your.base', obj)) {\n     *   // Thing we want to do\n     * }\n     * ```\n     * @function module:object.searchObj\n     * @param nsString {String}\n     * @param obj {*}\n     * @returns {*}\n     */\n    searchObj = curry((nsString, obj) => {\n        if (!obj) { return obj; }\n        if (nsString.indexOf('.') === -1) {\n            return obj[nsString];\n        }\n        const parts = nsString.split('.'),\n            limit = parts.length;\n        let ind = 0,\n            parent = obj;\n        for (; ind < limit; ind += 1) {\n            const node = parent[parts[ind]];\n            if (!isset(node)) {\n                return node;\n            }\n            parent = node;\n        }\n        return parent;\n    })\n;\n","/**\n * @module errorThrowing\n * @description Contains error throwing facilities for when a value doesn't match a type.\n */\nimport {typeOf} from './object/typeOf';\nimport {isArray, toTypeRef, toTypeRefName, isOfType} from './object/is';\nimport {curry} from './function/curry';\n\nexport const\n\n    /**\n     * Pretty prints an array of types/type-strings for use by error messages;\n     * Outputs \"`SomeTypeName`, ...\" from [SomeType, 'SomeTypeName', etc...]\n     * @function module:errorThrowing.typeRefsToStringOrError\n     * @param types {Array|TypesArray}\n     * @return {String}\n     * @private\n     */\n    typeRefsToStringOrError = types => types.length ?\n        types.map(type => `\\`${toTypeRefName(type)}\\``).join(', ') : '',\n\n    /**\n     * Prints a message from an object.  Object signature:\n     * {contextName, valueName, value, expectedTypeName, foundTypeName, messageSuffix}\n     * @function module:errorThrowing.defaultErrorMessageCall\n     * @param tmplContext {Object|TemplateContext} - Object to use in error template.\n     * @returns {string}\n     * @private\n     */\n    defaultErrorMessageCall = tmplContext => {\n        const {\n                contextName, valueName, value, expectedTypeName,\n                foundTypeName, messageSuffix\n            } = tmplContext,\n            isMultiTypeNames = isArray(expectedTypeName),\n            typesCopy = isMultiTypeNames ? 'of type' : 'of one of the types',\n            typesToMatchCopy = isMultiTypeNames ? typeRefsToStringOrError(expectedTypeName) : expectedTypeName;\n        return (contextName ? `\\`${contextName}.` : '`') +\n            `${valueName}\\` is not ${typesCopy}: ${typesToMatchCopy}.  ` +\n            `Type received: ${foundTypeName}.  Value: ${value};` +\n            `${messageSuffix ?  '  ' + messageSuffix + ';' : ''}`;\n    },\n\n    /**\n     * Gets the error message thrower seeded with passed in errorMessage template call.\n     * @function module:errorThrowing.getErrorIfNotTypeThrower$\n     * @param errorMessageCall {Function|ErrorMessageCall}\n     * @param typeChecker {Function|TypeChecker} - Function<Type, value>:Boolean\n     * @returns {Function|ErrorIfNotType}\n     * @private\n     */\n    _getErrorIfNotTypeThrower = (errorMessageCall, typeChecker = isOfType) =>\n        (ValueType, contextName, valueName, value, messageSuffix = null) => {\n            const expectedTypeName = toTypeRef(ValueType),\n                foundTypeName = typeOf(value);\n            if (typeChecker(ValueType, value)) { return value; } // Value matches type\n            throw new Error(errorMessageCall(\n                {contextName, valueName, value, expectedTypeName, foundTypeName, messageSuffix}\n            ));\n        },\n\n    /**\n     * Gets the error message thrower seeded with passed in errorMessage template call.\n     * @function module:errorThrowing.getErrorIfNotTypesThrower$\n     * @param errorMessageCall {Function|ErrorMessageCall}\n     * @param typeChecker {Function|TypeChecker} - Function<Type, value>:Boolean\n     * @returns {Function|ErrorIfNotTypes}\n     * @private\n     */\n    _getErrorIfNotTypesThrower = (errorMessageCall, typeChecker = isOfType) =>\n        (valueTypes, contextName, valueName, value, messageSuffix = null) => {\n            const expectedTypeNames = valueTypes.map(toTypeRef),\n                matchFound = valueTypes.some(ValueType => typeChecker(ValueType, value)),\n                foundTypeName = typeOf(value);\n            if (matchFound) { return value; }\n            throw new Error(\n                errorMessageCall({\n                    contextName, valueName, value,\n                    expectedTypeName: expectedTypeNames, foundTypeName,\n                    messageSuffix\n                })\n            );\n        },\n\n    /**\n     * Checks that passed in `value` is of given `type`.  Throws an error if value\n     * is not of given `type`.  This is the un-curried version.  For the curried version\n     * see `module:errorThrowing.errorIfNotType`.\n     * @function module:errorThrowing.errorIfNotType$\n     * @param type {String|Function} - Type's name or type itself.\n     * @param contextName {String} - Name of context to attribute errors if thrown.\n     * @param valueName {String} - String rep of value.\n     * @param value {*}\n     * @param [messageSuffix=null] {String} - Optional.\n     * @returns {*} - Given `value` if `value` matches passed in type.\n     * @private\n     */\n    _errorIfNotType = _getErrorIfNotTypeThrower(defaultErrorMessageCall),\n\n    /**\n     * Checks that passed in `value` is of one of the given `types`.  Throws an error if value\n     *  is not of one of the given `types`.  This is the un-curried version.  For the curried version\n     * see `module:errorThrowing.errorIfNotTypes`.\n     * @type {Function|module:errorThrowing.errorIfNotTypes}\n     * @function module:errorThrowing.errorIfNotTypes$\n     * @param types {Array} - Array of one or more types or type names themselves.\n     * @param contextName {String} - Name of context to attribute errors if thrown.\n     * @param valueName {String} - String rep of value.\n     * @param value {*}\n     * @returns {*} - Given `value` if `value` matches passed in type.\n     * @private\n     */\n    _errorIfNotTypes = _getErrorIfNotTypesThrower(defaultErrorMessageCall),\n\n    /**\n     * Returns a function that can be used to ensure that values are of a given type.\n     *   Also throws informative error messages containing the value types, names, expected type names,\n     *   etc.\n     * @function module:errorThrowing.getErrorIfNotTypeThrower\n     * @param errorMessageCall {Function|ErrorMessageCall} - Template function (takes an info-object and returns a printed string).\n     * @returns {Function|ErrorIfNotType} - Returns a function with the same signature as `errorIfNotType` though curried.\n     */\n    getErrorIfNotTypeThrower = errorMessageCall => curry(_getErrorIfNotTypeThrower(errorMessageCall)),\n\n    /**\n     * Returns a function that can be used to ensure that a value is of one or more given types.\n     *   The returned function is used in cases where informative error messages\n     *   containing the value types, names, expected type names, are-required/should-be-used etc.\n     * @function module:errorThrowing.getErrorIfNotTypesThrower\n     * @param errorMessageCall {Function|ErrorMessageCall} - Template function (takes an info-object and returns a printed string).\n     * @returns {Function|ErrorIfNotTypes} - Returns a function with the same signature as `errorIfNotTypes` though curried.\n     */\n    getErrorIfNotTypesThrower = errorMessageCall => curry(_getErrorIfNotTypesThrower(errorMessageCall)),\n\n    /**\n     * Checks that passed in `value` is of given `type`.  Throws an error if value\n     * is not of given `type`.  Curried.\n     * @function module:errorThrowing.errorIfNotType\n     * @param type {String|Function} - Type's name or type itself.\n     * @param contextName {String} - Name of context to attribute errors if thrown.\n     * @param valueName {String} - String rep of value.\n     * @param value {*}\n     * @param [messageSuffix=null] {String} - Optional.\n     * @returns {*} - Given `value` if `value` matches passed in type.\n     * @curried\n     */\n    errorIfNotType = curry(_errorIfNotType),\n\n    /**\n     * Checks that passed in `value` is of one of the given `types`.  Throws an error if value\n     *  is not of one of the given `types`.  Curried.\n     * @function module:errorThrowing.errorIfNotTypes\n     * @param types {Array} - Array of one or more types or type names themselves.\n     * @param contextName {String} - Name of context to attribute errors if thrown.\n     * @param valueName {String} - String rep of value.\n     * @param value {*}\n     * @returns {*} - Given `value` if `value` matches passed in type.\n     * @curried\n     */\n    errorIfNotTypes = curry(_errorIfNotTypes)\n;\n\n/**\n * @typedef {*} Any - Synonym for 'any value'.\n */\n\n/**\n * @typedef {String|Function} TypeRef\n * @description Type reference.  Type itself or Type's name;  E.g., `Type.name`;\n */\n\n/**\n * @typedef {Object<value, valueName, expectedTypeName, foundTypeName, messageSuffix>} TemplateContext\n * @description Template context used for error message renderers (functions that take a context obj and return a string).\n * @property value {*}\n * @property valueName {String}\n * @property expectedTypeName {String} - Expected name of constructor of `value`;  E.g., usually `SomeConstructor.name`;\n * @property foundTypeName {String} - Found types name;  E.g., `FoundConstructor.name`;\n * @property [messageSuffix=null] {*} - Message suffix (sometimes an extra hint or instructions for\n *  directing user to fix where his/her error has occurred).  Optional.\n */\n\n/**\n * @typedef {Array<(String|Function)>} TypesArray\n */\n\n/**\n * @typedef {Function} TypeChecker\n * @description Checks whether a value is of given type.\n * @param Type {TypeRef} - a Type or it's name;  E.g., `Type.name`.\n * @param value {*}\n * @returns {Boolean}\n */\n\n/**\n * @typedef {Function} ErrorMessageCall\n * @description Error message template function.\n * @param tmplContext {TemplateContext}\n * @returns {String}\n */\n\n/**\n * @typedef {Function} ErrorIfNotType\n * @description Used to ensure value matches passed in type.\n * @param type {TypeRef} - Constructor name or constructor.\n * @param contextName {String}\n * @param valueName {String}\n * @param value {*}\n * @throws {Error} - If value doesn't match type.\n * @returns {*} - What ever value is.\n */\n\n/**\n * @typedef {Function} ErrorIfNotTypes\n * @description Used to ensure a value matches one of one or more types passed in.\n * @param valueTypes {TypesArray} - Array of constructor names or constructors.\n * @param contextName {String}\n * @param valueName {String}\n * @param value {*}\n * @throws {Error} - If value doesn't match type.\n * @returns {*} - Whatever value is.\n */\n","/**\n * @module object\n * @note Custom jsdoc type definitions defined toward end of file.\n */\nimport {curry} from '../function/curry';\nimport {apply} from '../jsPlatform/function';\nimport {errorIfNotType} from '../errorThrowing';\nimport {isUndefined, isType} from './is';\n\n/**\n * Creates `defineProps` and `defineEnumProps` methods based on `{enumerable}` param.\n * @param {{enumerable: Boolean}}\n * @returns {function(*, *)|PropsDefinerCall}\n * @private\n */\nfunction createDefinePropsMethod ({enumerable}) {\n    const operation = enumerable ? defineEnumProp : defineProp;\n    return (argTuples, target) => {\n        argTuples.forEach(argTuple => {\n            const [TypeRef, propName, defaultValue] = argTuple;\n            apply(operation, [TypeRef, target, propName, defaultValue]);\n        });\n        return target;\n    };\n}\n\nexport const\n\n    /**\n     * Creates a descriptor for a property which is settable but throws\n     * errors when the `Type` is disobeyed.\n     * @function module:object.createTypedDescriptor\n     * @param Type {TypeRef} - {String|Function}\n     * @param target {*}\n     * @param propName {String}\n     * @returns {Descriptor} - Property descriptor with just getter and setter.\n     */\n    createTypedDescriptor = (Type, target, propName) => {\n        let _value;\n        return {\n            get: function () {\n                return _value;\n            },\n            set: function (value) {\n                _value = errorIfNotType(Type, propName, target, value);\n            }\n        };\n    },\n\n    /**\n     * Returns a target-descriptor tuple whose 'descriptor' will be set to\n     *  enumerable (`enumerable: true`).\n     * @function module:object.toEnumerableDescriptor\n     * @param {TargetDescriptorTuple} - [target, descriptor] tuple.\n     * @returns {TargetDescriptorTuple} - Array of target and descriptor.\n     */\n    toEnumerableDescriptor = ([target, descriptor]) => {\n        descriptor.enumerable = true;\n        return [target, descriptor];\n    },\n\n    /**\n     * Returns an target and descriptor tuple from given.\n     * @function module:object.toTargetDescriptorTuple\n     * @param targetOrTargetDescriptorTuple {(*|Array<*, *>)} - Target object or tuple of target and descriptor.\n     * @returns {(Array<*>|Array<*,*>)}\n     */\n    toTargetDescriptorTuple = targetOrTargetDescriptorTuple =>\n        isType('Array', targetOrTargetDescriptorTuple) ? // Strict type check for array\n            targetOrTargetDescriptorTuple : [targetOrTargetDescriptorTuple],\n\n    /**\n     * Allows you to define a \"typed\" property on given `target`.\n     * @function module:object.defineProp\n     * @param Type {TypeRef} - {String|Function}\n     * @param target {TargetDescriptorTuple} - Target or array of target and descriptor ([target, descriptor]).\n     * @param propName {String}\n     * @param [defaultValue=undefined] {*}\n     * @returns {TargetDescriptorTuple}\n     */\n    defineProp = (Type, target, propName, defaultValue = undefined) => {\n        const [_target, _descriptor] = toTargetDescriptorTuple(target),\n            descriptor = _descriptor || createTypedDescriptor(Type, _target, propName);\n        Object.defineProperty(_target, propName, descriptor);\n        if (!isUndefined(defaultValue)) {\n            _target[propName] = defaultValue;\n        }\n        return [_target, descriptor];\n    },\n\n    /**\n     * Allows you to define a \"typed\", enumerated property on `target`.\n     * @function module:object.defineEnumProp\n     * @param Type {TypeRef} - {String|Function}\n     * @param target {TargetDescriptorTuple} - Target or array of target and descriptor ([target, descriptor]).\n     * @param propName {String}\n     * @param [defaultValue=undefined] {*}\n     * @returns {TargetDescriptorTuple}\n     */\n    defineEnumProp = (Type, target, propName, defaultValue = undefined) => {\n        const [_target, _descriptor] = toTargetDescriptorTuple(target),\n            descriptor = _descriptor || createTypedDescriptor(Type, _target, propName);\n        return defineProp(\n            Type,\n            toEnumerableDescriptor([_target, descriptor]),\n            propName,\n            defaultValue\n        );\n    },\n\n    /**\n     * Allows you to define multiple enum props at once on target.\n     * @function module:object.defineEnumProps\n     * @param argsTuple {Array.<DefinePropArgsTuple>} - Array of argArrays for `defineEnumProp`.\n     * @param [target = undefined] {Target} - Target to use in internal calls if one is not provided but encountered 'argArray'.\n     * @returns {Array.<TargetDescriptorTuple>} - Results of each call to `defineEnumProp`.\n     */\n    defineEnumProps = curry(createDefinePropsMethod({enumerable: true})),\n\n    /**\n     * Allows you to define multiple props at once on target.\n     * @function module:object.defineProps\n     * @param argsTuple {Array.<DefinePropArgsTuple>} - Array of argArrays for `defineProp`.\n     * @param [target = undefined] {Target} - Target to use in internal calls if one is not provided but encountered 'argArray'.\n     * @returns {Array.<TargetDescriptorTuple>} - Results of each call to `defineProp`.\n     * @curried\n     */\n    defineProps = curry(createDefinePropsMethod({enumerable: false}))\n\n;\n\n/** ============================================================= */\n/** Type definitions:                                             */\n/** ============================================================= */\n\n/**\n * @typedef {*} Target\n */\n\n/**\n * @typedef {Object} Descriptor\n */\n\n/**\n * @typedef {Array<Target, Descriptor>} TargetDescriptorTuple\n */\n\n/**\n * @typedef {Array.<TypeRef, TargetDescriptorTuple, String, *>}  DefinePropArgsTuple\n * @description Arguments list for `defineProp` and/or `defineEnumProp` (note: some\n *  parts of array/tuple are options (namely the last two args));  E.g.,\n *  ```\n *  [String, [someTarget], 'somePropName', 'someDefaultValue] // ...\n *  ```\n */\n\n/**\n * @typedef {Function} PropsDefinerCall\n * @description Same type as `defineProp` and `defineEnumProp`\n * @param argsTuple {DefinePropArgsTuple}\n * @param target {Target}\n * @returns {Array.<TargetDescriptorTuple>}\n */\n","\nimport {isObject} from './is';\nimport {keys} from '../jsPlatform/object';\nimport {curry2} from '../function/curry';\n\nexport const\n    /**\n     * Merges all objects down into one (takes two or more args).\n     * @function module:object.assignDeep\n     * @param obj0 {Object}\n     * @param [objs] {...{Object}} - One or more objects to merge onto `obj0`.\n     * @returns {Object}\n     */\n    assignDeep = curry2((obj0, ...objs) =>\n        !obj0 ? obj0 : objs.reduce((topAgg, obj) =>\n            !obj ? topAgg : keys(obj).reduce((agg, key) => {\n                let propDescription = Object.getOwnPropertyDescriptor(agg, key);\n                // If property is not writable move to next item in collection\n                if (agg.hasOwnProperty(key) && propDescription &&\n                    !(propDescription.get && propDescription.set) &&\n                    !propDescription.writable) {\n                    return agg;\n                }\n                if (isObject(agg[key]) && isObject(obj[key])) {\n                    assignDeep(agg[key], obj[key]);\n                }\n                else { agg[key] = obj[key]; }\n                return agg;\n            }, topAgg)\n        , obj0));\n","/**\n *  List operations that overlap (apart from globally overlapping props and functions like `length`)\n *      on both strings and arrays.\n */\n\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from '../utils';\n\nexport const\n\n    /**\n     * Concats/appends all functors onto the end of first functor.\n     * Note:  functors passed in after the first one must be of the same type.\n     * @function module:jsPlatform.concat\n     * @param functor {Array|Object|*}\n     * @param ...functor {Array|Object|*}\n     * @return {*|Array|Object} - The type passed.\n     * @throws {Error} - When passed in object doesn't have an `every` method.\n     */\n    concat = fPureTakesOneOrMore('concat'),\n\n    /**\n     * Same as Array.prototype.slice\n     * @function module:list.slice\n     * @param separator {String|RegExp}\n     * @param arr{Array}\n     * @returns {Array}\n     */\n    slice = fPureTakes2('slice'),\n\n    /**\n     * `Array.prototype.includes` or shim.\n     * @function module:list.includes\n     * @param value {*}\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    includes = (() => 'includes' in Array.prototype ?\n            fPureTakesOne('includes') :\n            (value, xs) => xs.indexOf(value) > -1)(),\n\n    /**\n     * Searches list/list-like for given element `x`.\n     * @function module:list.indexOf\n     * @param x {*} - Element to search for.\n     * @param xs {Array|String|*} - list or list like to look in.\n     * @returns {Number} - `-1` if element not found else index at which it is found.\n     */\n    indexOf = fPureTakesOne('indexOf'),\n\n    /**\n     * Last index of (`Array.prototype.lastIndexOf`).\n     * @function module:list.lastIndexOf\n     * @param x {*} - Element to search for.\n     * @param xs {Array|String|*} - list or list like to look in.\n     * @returns {Number} - `-1` if element not found else index at which it is found.\n     */\n    lastIndexOf = fPureTakesOne('lastIndexOf')\n\n;\n","/**\n * @module boolean\n * @description Contains functional version of 'always-true', 'always-false', 'is-truthy', and 'is-falsy'.\n */\nimport {curry, curry2} from './function/curry';\n\nexport const\n\n    /**\n     * Returns whether `value` is 'truthy' or not\n     * @function module:boolean.isTruthy\n     * @param value\n     * @returns {Boolean}\n     */\n    isTruthy = value => !!value,\n\n    /**\n     * Returns whether `value` is 'falsy' or not\n     * @function module:boolean.isFalsy\n     * @param value\n     * @returns {Boolean}\n     */\n    isFalsy = value => !value,\n\n    /**\n     * Returns `true`.\n     * @function module:boolean.alwaysTrue\n     * @returns {Boolean}\n     */\n    alwaysTrue = () => true,\n\n    /**\n     * Returns `false`.\n     * @function module:boolean.alwaysFalse\n     * @returns {Boolean}\n     */\n    alwaysFalse = () => false,\n\n    /**\n     * Equality operator.\n     * @function module:boolean.equal\n     * @param a {*}\n     * @param b {*}\n     * @returns {boolean}\n     */\n    equal = curry((a, b) => a === b),\n\n    /**\n     * Equality operator for all.\n     * @function module:boolean.equalAll\n     * @param a {*} - Item `0`.\n     * @param args {...*} - Others\n     * @returns {boolean}\n     */\n    equalAll = curry2((a, ...args) => args.every(b => equal(a, b)))\n\n;\n","import {length} from '../jsPlatform/object';\nimport {curry} from '../function/curry';\nimport {typeOf} from '../object/typeOf';\nimport {of} from '../object/of';\nimport {isFunctor, isset} from '../object/is';\n\n/**\n * Maps a function onto a List (string or array) or a functor (value containing a map method).\n * @function module:list.map\n * @param fn {Function} - Function to map on given value.\n * @param xs {Array|String|*}\n * @returns {Array|String|*}\n */\nconst map = curry((fn, xs) =>  {\n    if (!isset(xs)) { return xs; }\n    let out = of(xs),\n        limit,\n        i = 0;\n    switch (typeOf(xs)) {\n        case 'Array':\n            limit = length(xs);\n            if (!limit) { return out; }\n            for (; i < limit; i += 1) {\n                out.push(fn(xs[i], i, xs));\n            }\n            return out;\n        case 'String':\n            limit = length(xs);\n            if (!xs) { return out; }\n            for (; i < limit; i += 1) {\n                out += fn(xs[i], i, xs);\n            }\n            return out;\n        default:\n            if (isFunctor(xs)) { return xs.map(fn); }\n\n            // Other objects\n            return Object.keys(xs).reduce((agg, key) => {\n                out[key] = fn(xs[key], key, xs);\n                return out;\n            }, out);\n    }\n});\n\nexport default map;\n","\nexport const\n\n    /**\n     * Pushes incoming `item` onto given array and returns said array.\n     * @private\n     * @param agg {Array}\n     * @param item {*}\n     * @returns {Array}\n     */\n    aggregateArray = (agg, item) => {\n        agg.push(item);\n        return agg;\n    }\n\n;\n","/**\n * List operator utils module.\n * @module listUtils\n */\nimport {apply}          from '../jsPlatform/function';  // un-curried version\nimport {slice}          from '../jsPlatform/list';      // un-curried version good for both strings and arrays\nimport {length}         from '../jsPlatform/object';\nimport {alwaysFalse}    from '../boolean';\nimport map              from './map';\nimport {curry, curry2}  from '../function/curry';\n\nexport * from './aggregation';\n\nexport const\n\n    /**\n     * Returns a slice of the given list from `startInd` to the end of the list.\n     * @function module:listUtils.sliceFrom\n     * @param startInd {Number}\n     * @param xs {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    sliceFrom = curry((startInd, xs) => slice(startInd, undefined, xs)),\n\n    /**\n     * Slices from index `0` to given index.\n     * @function module:listUtils.sliceTo\n     * @param toInd {Number}\n     * @param xs {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    sliceTo = curry((toInd, xs) => slice(0, toInd, xs)),\n\n    /**\n     * Slices a copy of list.\n     * @function listUtils.sliceCopy\n     * @param xs {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    sliceCopy = sliceFrom(0),\n\n    /**\n     * Generic 'ascending order' ordering function (use by the likes of `list.sort` etc.)\n     * @function module:listUtils.genericAscOrdering\n     * @param a {*}\n     * @param b {*}\n     * @returns {number}\n     */\n    genericAscOrdering = curry((a, b) => {\n        if (a > b) { return 1; }\n        else if (a < b) { return -1; }\n        return 0;\n    }),\n\n    /**\n     * Returns length of all passed lists in list.\n     * @function module:listUtils.lengths\n     * @param lists ...{Array|String|*}\n     * @returns {Array|String|*}\n     */\n    lengths = curry2((...lists) => map(length, lists)),\n\n    /**\n     * Returns a list of lists trimmed to the shortest length in given list of lists.   @background This method is used by the `zip*` functions to achieve their\n     *  'slice to smallest' functionality.\n     * @function module:listUtils.toShortest\n     * @param lists {...(Array|String|*)}\n     * @returns {Array|String|*}\n     */\n    toShortest = curry2((...lists) => {\n        const listLengths = apply(lengths, lists),\n            smallLen = Math.min.apply(Math, listLengths);\n        return map((list, ind) => listLengths[ind] > smallLen ?\n            sliceTo(smallLen, list) : sliceCopy(list), lists);\n    }),\n\n    /**\n     * Reduces until predicate.\n     * @function module:listUtils.reduceUntil\n     * @param pred {Function} - `(item, index, list) => Boolean(...)`\n     * @param op {Function} - Operation - `(agg, item, index, list) => agg`\n     * @param agg {*} - Zero value.\n     * @param xs {Array|String|*} - List.\n     * @returns {*}\n     */\n    reduceUntil = curry((pred, op, agg, xs) => {\n        const limit = length(xs);\n        if (!limit) { return agg; }\n        let ind = 0,\n            result = agg;\n        for (; ind < limit; ind++) {\n            if (pred(xs[ind], ind, xs)) { break; }\n            result = op(result, xs[ind], ind, xs);\n        }\n        return result;\n    }),\n\n    /**\n     * Reduces until predicate (from right to left).\n     * @function module:listUtils.reduceUntilRight\n     * @param pred {Function} - `(item, index, list) => Boolean(...)`\n     * @param op {Function} - Operation - `(agg, item, index, list) => agg`\n     * @param agg {*} - Zero value.\n     * @param xs {Array|String|*} - List.\n     * @returns {*}\n     */\n    reduceUntilRight = curry((pred, op, agg, arr) => {\n        const limit = length(arr);\n        if (!limit) { return agg; }\n        let ind = limit - 1,\n            result = agg;\n        for (; ind >= 0; ind--) {\n            if (pred(arr[ind], ind, arr)) { break; }\n            result = op(result, arr[ind], ind, arr);\n        }\n        return result;\n    }),\n\n    /**\n     * Reduces a list with given operation (`op`) function.\n     * @function module:listUtils.reduce\n     * @param op {Function} - Operation - `(agg, item, index, list) => agg`\n     * @param agg {*} - Zero value.\n     * @param xs {Array|String|*} - List.\n     * @returns {*}\n     */\n    reduce = reduceUntil(alwaysFalse),\n\n    /**\n     * Reduces a list with given operation (`op`) function (from right-to-left).\n     * @function module:listUtils.reduceRight\n     * @param op {Function} - Operation - `(agg, item, index, list) => agg`\n     * @param agg {*} - Zero value.\n     * @param xs {Array|String|*} - List.\n     * @returns {*}\n     */\n    reduceRight = reduceUntilRight(alwaysFalse),\n\n    /**\n     * Gets last index of a list/list-like (Array|String|Function etc.).\n     * @function module:listUtils.lastIndex\n     * @param x {Array|String|*} - list like or list.\n     * @returns {Number} - `-1` if no element found.\n     */\n    lastIndex = x => { const len = length(x); return len ? len - 1 : 0; },\n\n    /**\n     * Finds index in string or list.\n     * @function module:listUtils.findIndexWhere\n     * @param pred {Function} - Predicate<element, index, arr>.\n     * @param arr {Array|String}\n     * @returns {Number} - `-1` if predicate not matched else `index` found\n     */\n    findIndexWhere = curry((pred, arr) => {\n        let ind = 0;\n        const limit = length(arr);\n        for (; ind < limit; ind += 1) {\n            const predicateFulfilled = !!pred(arr[ind], ind, arr);\n            if (predicateFulfilled) {\n                return ind;\n            }\n        }\n        return -1;\n    }),\n\n    /**\n     * Finds index in list from right to left.\n     * @function module:listUtils.findIndexWhereRight\n     * @param pred {Function} - Predicate<element, index, arr>.\n     * @param arr {Array|String}\n     * @returns {Number} - `-1` if predicate not matched else `index` found\n     */\n    findIndexWhereRight = curry((pred, arr) => {\n        let ind = length(arr) - 1;\n        for (; ind >= 0; ind -= 1) {\n            const predicateFulfilled = !!pred(arr[ind], ind, arr);\n            if (predicateFulfilled) {\n                return ind;\n            }\n        }\n        return -1;\n    }),\n\n    /**\n     * @function module:listUtils.findIndicesWhere\n     * @param pred {Function}\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {Array|undefined}\n     */\n    findIndicesWhere = curry((pred, xs) => {\n        const limit = length(xs);\n        let ind = 0,\n            out = [];\n        for (; ind < limit; ind++) {\n            if (pred(xs[ind], ind, xs)) { out.push(ind); }\n        }\n        return out.length ? out : undefined;\n    }),\n\n    /**\n     * @function module:listUtils.findWhere\n     * @param pred {Function}\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {*}\n     */\n    findWhere = curry((pred, xs) => {\n        let ind = 0,\n            limit = length(xs);\n        if (!limit) { return; }\n        for (; ind < limit; ind++) {\n            let elm = xs[ind];\n            if (pred(elm, ind, xs)) { return elm; }\n        }\n        return undefined;\n    })\n\n;\n","import {assignDeep} from './assignDeep';\nimport {keys} from '../jsPlatform/object';\nimport {reduce} from '../list/utils';\nimport {curry, curry2} from '../function/curry';\n\nexport const\n\n    objUnion = curry((obj1, obj2) => assignDeep(obj1, obj2)),\n\n    objIntersect = curry((obj1, obj2) => reduce((agg, key) => {\n        if (obj2.hasOwnProperty(key)) {\n            agg[key] = obj2[key];\n        }\n        return agg;\n    }, {}, keys(obj1))),\n\n    objDifference = curry((obj1, obj2) => reduce((agg, key) => {\n        if (!obj2.hasOwnProperty(key)) {\n            agg[key] = obj1[key];\n        }\n        return agg;\n    }, {}, keys(obj1))),\n\n    objComplement = curry2((obj0, ...objs) => reduce((agg, obj) =>\n        assignDeep(agg, objDifference(obj, obj0)), {}, objs));\n","/**\n * @module console\n * @description Console exports.\n */\nexport const\n\n    /**\n     * `Console.log` method.\n     * @function module:console.log\n     * @params args {...*}\n     * @returns {void}\n     */\n    log = console.log.bind(console),\n\n    /**\n     * `Console.error` method.\n     * @function module:console.error\n     * @params args {...*}\n     * @returns {void}\n     */\n    error = console.error.bind(console),\n\n    /**\n     * Peeks (console.log) at incoming value(s) and returns the last value.\n     * @function module:console.peek\n     * @param args {...*}\n     * @returns {*} Last given value (if one or more values) else first value.\n     */\n    peek = (...args) => (log(...args), args.pop()),\n\n    /**\n     * `Console.warn`.\n     * @function module:console.warn\n     * @param args {...*}\n     * @returns {void}\n     */\n    warn = console.warn.bind(console)\n\n;\n","export const\n\n    /**\n     * Clones and object or array using `JSON.parse(JSON.stringify(...))` pattern.\n     * @function module:object.jsonClone\n     * @param x {*}\n     * @returns {*}\n     */\n    jsonClone = x => JSON.parse(JSON.stringify(x))\n\n;\n","import {isArray, isType} from './is';\nimport {keys} from '../jsPlatform/object';\n\nexport const\n\n    /**\n     * Returns an associated list from given object.\n     * @note Useful for working with plain javascript objects.\n     * @function module:object.toAssocList\n     * @param obj {(Object|Array|*)}\n     * @returns {Array.<*, *>}\n     */\n    toAssocList = obj => keys(obj).map(key => [key, obj[key]]),\n\n    /**\n     * Returns an associated list from given object (deeply (on incoming object's type)).\n     * @note Does deep conversion on all values of passed in type's type.\n     * @function module:object.toAssocListDeep\n     * @param obj {*}\n     * @param [TypeConstraint = Object] {(Constructor|Function)} - Type constraint to convert on.\n     * @returns {*}\n     */\n    toAssocListDeep = (obj, TypeConstraint = Object) => keys(obj).map(key =>\n        TypeConstraint && isType(TypeConstraint, obj[key]) ?\n            [key, toAssocListDeep(obj[key], TypeConstraint)] :\n            [key, obj[key]]\n    ),\n\n    /**\n     * From associated list to object.\n     * @function module:object.fromAssocList\n     * @param xs {Array.<Array>} - Associated list.\n     * @param [OutType = Object] {Constructor|Function} - Output type.  Default `Object`.\n     * @returns {*} - Default is `Object`\n     */\n    fromAssocList = (xs, OutType = Object) => xs.reduce((agg, [key, value]) => {\n        agg[key] = value;\n        return agg;\n    }, new OutType()),\n\n    /**\n     * From associated list to object (deep conversion on associative lists (array of 2 value arrays)).\n     * @note Considers array of arrays associated lists.\n     * @function module:object.fromAssocListDeep\n     * @param xs {Array.<Array>} - Associated list.\n     * @param [OutType = Object] {Constructor|Function} - Output type.  Default `Object`.\n     * @returns {*} - Default is `Object`\n     */\n    fromAssocListDeep = (xs, OutType = Object) => xs.reduce((agg, [key, value]) => {\n        if (isArray(value) && isArray(value[0]) && value[0].length === 2) {\n            agg[key] = fromAssocListDeep(value, OutType);\n            return agg;\n        }\n        agg[key] = value;\n        return agg;\n    }, new OutType())\n;\n","import {typeOf} from './typeOf';\nimport {toAssocList} from './assocList';\n\nexport const\n\n    /**\n     * Converts incoming value to an array.\n     * @note For `WeakMap`, `WeakSet`, `Map` and `Set` result is the same as calling `Array.from` on such.\n     * @note For `null`, `undefined`, `NaN`, `Number{}`, `Symbol{}`, `Boolean{}` returns an empty array.\n     * @note Method does a shallow conversion;\n     * @function module:object.toArray\n     * @param x {*} - Thing to convert from.\n     * @returns {Array}\n     */\n    toArray = x => {\n        switch (typeOf(x)) {\n            case 'Null':\n            case 'Undefined':\n                return [];\n            case String.name:\n            case Array.name:\n            case 'WeakMap':\n            case 'WeakSet':\n            case 'Map':\n            case 'Set':\n                return Array.from(x);\n            case Object.name:\n            default:\n                return toAssocList(x);\n        }\n    }\n\n;\n","import {reduceRight} from '../jsPlatform/array';\n\n/**\n * Composes all functions passed in from right to left passing each functions return value to\n * the function on the left of itself.\n * @function module:function.compose\n * @type {Function}\n * @param args {...{Function}}\n * @returns {Function}\n */\nexport const compose = (...args) =>\n        arg0 => reduceRight((value, fn) => fn(value), arg0, args);\n","/**\n * @memberOf function\n */\n\n/**\n * Returns passed in parameter.\n * @haskellType `id :: a -> a`\n * @function module:function.id\n * @param x {*}\n * @returns {*}\n */\nexport const id = x => x;\n","/**\n * @memberOf function\n */\n\nimport {apply} from '../jsPlatform/function';\nimport {curry, curry2} from './curry';\n\nexport const\n\n    /**\n     * Negates a function that takes one/no argument.\n     * @function module:function.negateF\n     * @param fn {Function}\n     * @returns {function(*=): boolean}\n     */\n    negateF = fn => x => !fn(x),\n\n    /**\n     * Takes a function that takes two parameters and returns a negated version of given\n     * function.\n     * @function module:_negate.negateF2\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    negateF2 = fn => curry((a, b) => !fn(a, b)),\n\n    /**\n     * Takes a function that takes three parameters and returns a\n     * negated version of given function.\n     * @function module:_negate.negateF3\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    negateF3 = fn => curry((a, b, c) => !fn(a, b, c)),\n\n    /**\n     * Returns a negated version of given function.\n     * Returned function is variadiac (takes one or more arguments).\n     * @note function returned is uncurried.\n     * @uncurried\n     * @function module:function.negateFN\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    negateFN = fn => curry2((...args) => !apply(fn, args));\n","import {curry} from './curry';\n\nexport const\n\n    /**\n     * Run `operation` until predicate returns `true` (like a functional\n     *  version of a while loop).\n     * @function module:function.until\n     * @param predicate {Function} :: a -> Boolean\n     * @param operation {Function} :: a -> a\n     * @param typeInstance {*} :: * - A monoidal zero or some starting point.\n     * @returns {*} - What ever type `typeInstance` is\n     */\n    until = curry((predicate, operation, typeInstance) => {\n        let result = typeInstance;\n        while (!predicate(result)) {\n            result = operation(result);\n        }\n        return result;\n    });\n","import {typeOf} from '../object/typeOf';\n\nexport const\n\n    /**\n     * Returns a function or throws an error if given `f` is not a function.\n     * @function module:function.fnOrError\n     * @param symbolName {String} - Error message prefix.\n     * @param f {Function|*} - Expected function.\n     * @returns {Function}\n     * @throws {Error} - Error if `f` is not of `function`\n     */\n    fnOrError = (symbolName, f) => {\n        if (!f || !(f instanceof Function)) {\n            throw new Error(`${symbolName} should be a function. ` +\n                `Type received: ${typeOf(f)};  Value received: ${f}.`);\n        }\n        return f;\n    }\n\n;\n","/**\n * No-op ('op' as in 'operation') - Performs no operation 'always' (good for places where\n * a value should always be a function etc.).\n * @function module:function.noop\n * @returns {undefined}\n */\nexport const noop = () => undefined;\n","/**\n * Trampolines function calls in order to avoid stack overflow errors\n * on recursive function calls; Tail recursion replacement.\n * @example\n * // Instead of ... (which is prone to stack-overflow in\n * //   non-tail-call optimized environments (es5-es3))\n * const factorial = n => n > 1 ? n * factorial(n - 1) : 1;\n *\n * // We do\n * const\n *\n *  factorialProcess = (n, agg = 1) => {\n *      n > 1 ? () => factorialProcess(n - 1, agg * n) : agg,\n *  },\n *\n *  factorial = trampoline(factorialProcess)\n *  // will not overflow as we are performing tail call elimination\n *  // by returning thunks from factorial process which run in `while` loop\n *  // within `trampoline`.\n *\n *  ;\n *\n * @note function returned by trampoline is not curried (for convenience)!\n * @function module:function.trampoline\n * @param fn {Function} - Function to trampoline.\n * @param [fnName=undefined] {String} - Optionally restrict trampolining only to function with specific name.\n * @returns {*} - Finally returned value.\n */\nexport const trampoline = (fn, fnName) => {\n    return (...args) => {\n        let result = fn.apply(null, args);\n        while (typeof result === 'function' &&\n            (!fnName || (result.name === fnName))) {\n            result = result();\n        }\n        return result;\n    };\n};\n","import {isFunction} from '../object/is';\n\nexport const\n\n    /**\n     * If given value is not a function, wraps it an 'identity' function (function that returns given value untouched) else returns given value. (useful in\n     * functional composition).\n     * @function module:function.toFunction\n     * @param x {Function|any}\n     * @returns {function(): any}\n     */\n    toFunction = x => isFunction(x) ? x : () => x;\n","/**\n * @module object\n */\nimport {curry} from '../function/curry';\n\n/**\n * Normalizes step for `from` and `to` combination.\n * @function module:list.normalizeStep\n * @param from {Number}\n * @param to {Number}\n * @param [step = 1] {Number}\n * @returns {Number}\n * @private\n */\nconst normalizeStep = (from, to, step) => {\n    if (from > to) {\n        return step > 0 ? -step : step; // make step negative\n    }\n    return step < 0 ? -1 * step : step; // make step positive\n};\n\nexport const\n\n    /**\n     * Range function - gives you an array contain numbers in given range.\n     * @note normalizes `step` to be valid if range numbers given are invalid\n     *  (forces `step` to be negative if range required is in the negative direction\n     *  and forces `step` to be positive if range required is in the other direction).\n     * @function module:list.range\n     * @param from {Number}\n     * @param to {Number}\n     * @param [step = 1] {Number}\n     * @returns {Array.<Number>}\n     */\n    range = curry((from, to, step = 1) => {\n        let i = from;\n        const out = [];\n        step = normalizeStep(from, to, step);\n        if (step === 0 || from === to) { return [from]; }\n        for (; (to - i) * step >= 0; i += step) { out.push(i); }\n        return out;\n    })\n;\n","/**\n * Created by elydelacruz on 9/6/2017.\n */\n\nimport {fPureTakesOne} from '../utils';\n\n/**\n * Functional version of `String.prototype.split`.\n * @function module:jsPlatform.split\n * @param separator {String|RegExp}\n * @param str {String}\n * @returns {Array}\n */\nexport const split = fPureTakesOne('split');\n","/**\n * @module jsPlatform\n */\nexport * from './jsPlatform/object';\nexport * from './jsPlatform/array';\nexport * from './jsPlatform/list';\nexport * from './jsPlatform/string';\nexport * from './jsPlatform/function';\n","/**\n * List operations module.\n * @module list\n */\nimport {concat as listAppend, indexOf, slice, includes} from './jsPlatform/list';\nimport {apply} from './jsPlatform/function';\nimport {length} from './jsPlatform/object';\nimport {negateF3, negateF2} from './function/negate';\nimport {curry, curry2, curry3} from './function/curry';\nimport {isTruthy, isFalsy} from './boolean';\nimport {lookup} from './object/lookup';\nimport {of} from './object/of';\nimport {isset, isString} from './object/is';\nimport {typeOf} from './object/typeOf';\nimport map from './list/map';\n\nimport {\n    sliceFrom, sliceTo, lengths,\n    toShortest, aggregateArray,\n    reduceUntil, reduce, reduceRight, lastIndex,\n    findIndexWhere, findIndexWhereRight, findIndicesWhere,\n    findWhere, sliceCopy, genericAscOrdering\n}\n    from './list/utils';\n\nexport * from './list/range';\n\nexport * from './list/utils';\n\nexport {map};\n\nexport {slice, includes, indexOf, lastIndexOf, push} from './jsPlatform';\n\nexport const\n\n    /**\n     * Append two, or more, lists, i.e.,\n     * @example\n     * expectEqual(append(take(13, alphabetString), drop(13, alphabetString)), alphabetString); // true\n     *\n     * // Another example\n     * const result = append(\n     *   alphabetStr.split(''),\n     *   alphabetStr.split('')\n     * ),\n     * expected = repeat(2, alphabetStr).split('');\n     *\n     * shallowEquals(result, expected) === true // `true`\n     *\n     * @function module:list.append\n     * @param [args] {...(Array|String|*)} - One or more lists or list likes (strings etc.).\n     * @returns {(Array|String|*)} - Same type as list like passed in.\n     * @curried - Curried at upto 2 arguments.\n     */\n    append = curry2((...args) => apply(listAppend, args)),\n\n    /**\n     * Returns head of list (first item of list).\n     * @haskellType `head :: [a] -> a`\n     * @function module:list.head\n     * @param x {Array|String}\n     * @returns {*} - First item from list\n     */\n    head = x => x[0],\n\n    /**\n     * Returns last item of list.\n     * @haskellType `last :: [a] -> a`\n     * @function module:list.last\n     * @param xs {Array|String}\n     * @returns {*}\n     */\n    last = xs => xs[lastIndex(xs)],\n\n    /**\n     * Returns tail part of list (everything after the first item as new list).\n     * @haskelType `tail :: [a] -> [a]`\n     * @function module:list.tail\n     * @param xs {Array|String}\n     * @returns {Array|String}\n     */\n    tail = xs => sliceFrom(1, xs),\n\n    /**\n     * Returns everything except last item of list as new list.\n     * @haskellType `init :: [a] -> [a]`\n     * @function module:list.init\n     * @param xs {Array|String}\n     * @returns {Array|String}\n     */\n    init = xs => sliceTo(lastIndex(xs), xs),\n\n    /**\n     * Returns `head` and `tail` of passed in list/string in a tuple.\n     * @haskellType `uncons :: [a] -> Maybe (a, [a])`\n     * @function module:list.uncons\n     * @param xs {Array|String}\n     * @returns {Array|undefined}\n     */\n    uncons = xs => !xs || length(xs) === 0 ? undefined : [head(xs), tail(xs)],\n\n    /**\n     * Returns `tail` and `head` of passed in list/string in a tuple.\n     * @haskellType `unconsr :: [a] -> Maybe ([a], a)`\n     * @function module:list.unconsr\n     * @param xs {Array|String}\n     * @returns {Array|String|*|undefined}\n     */\n    unconsr = xs => !xs || length(xs) === 0 ? undefined : [init(xs), last(xs)],\n\n    /**\n     * Concatenates all the elements of a container of lists.\n     * @haskellType `concat :: Foldable t => t [a] -> [a]`\n     * @function module:list.concat\n     * @param xs {Array}\n     * @returns {Array}\n     */\n    concat = xs => {\n        switch (length(xs)) {\n            case undefined:\n            case 0:\n                return [];\n            case 1:\n                const item0 = xs[0];\n                return item0 && item0.slice ? sliceCopy(item0) : item0;\n            case 2:\n            default:\n                return apply(append, xs);\n        }\n    },\n\n    /**\n     * Map a function over all the elements of a container and concatenate the resulting lists.\n     * @haskellType `concatMap :: Foldable t => (a -> [b]) -> t a -> [b]`\n     * @function module:list.concatMap\n     * @param fn {Function}\n     * @param foldableOfA {Array}\n     * @returns {Array}\n     */\n    concatMap = curry((fn, foldableOfA) => concat(map(fn, foldableOfA))),\n\n    /**\n     * Returns a copy of the passed in list reverses.\n     * @haskellType `reverse :: [a] -> [a]`\n     * @function module:list.reverse\n     * @param xs {Array|String}\n     * @returns {Array|String}\n     */\n    reverse = xs => {\n        if (!isset(xs) || !xs.length) {\n            return xs;\n        }\n        let out = of(xs),\n            i = xs.length - 1;\n        switch (typeOf(xs)) {\n            case 'String':\n                for (; i >= 0; i -= 1) {\n                    out += xs[i];\n                }\n                return out;\n            default:\n                for (; i >= 0; i -= 1) {\n                    out.push(xs[i]);\n                }\n                return out;\n        }\n    },\n\n    /**\n     * Takes an element and a list and `intersperses' that element between the\n     *  elements of the list.\n     * @function module:list.intersperse\n     * @note In our version of the function javascript is loosely typed so,\n     *  so is our function (to much overhead to make it typed) so `between` can be any value.\n     * @param between {*} - Should be of the same type of elements contained in list.\n     * @param arr {Array|String} - List.\n     * @returns {Array|String}\n     */\n    intersperse = curry((between, xs) => {\n        if (!xs || !xs.length) {\n            return xs;\n        }\n        const limit = xs.length,\n            lastInd = limit - 1;\n        let out = of(xs),\n            i = 0;\n        if (isString(xs)) {\n            for (; i < limit; i += 1) {\n                out += i === lastInd ?\n                    xs[i] : xs[i] + between;\n            }\n            return out;\n        }\n        for (; i < limit; i += 1) {\n            if (i === lastInd) {\n                out.push(xs[i]);\n            } else {\n                out.push(xs[i], between);\n            }\n        }\n        return out;\n    }),\n\n    /**\n     * `intercalate xs xss` is equivalent to (concat (intersperse xs xss)). It inserts the list xs in between the lists in xss and concatenates the result.\n     * @haskellType `intercalate :: [a] -> [[a]] -> [a]`\n     * @function module:list.intercalate\n     * @param xs {Array|String}\n     * @param xss {Array|String}\n     * @returns {Array|String}\n     */\n    intercalate = curry((xs, xss) => {\n        if (isString(xss)) {\n            return intersperse(xs, xss);\n        }\n        return concat(intersperse(xs, xss));\n    }),\n\n    /**\n     * Transposes rows and columns into lists by index;  E.g.,\n     * Haskell example:\n     * ```\n     *  transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]\n     *\n     *  -- Notice the shorter arrays are ignored after their last index is copied over:\n     *  transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]\n     * ```\n     * @note from columns to rows.\n     * @note Empty lists are ignored.\n     * @haskellType `transpose :: [[a]] -> [[a]]`\n     * @function module:list.transpose\n     * @param xss {Array}\n     * @returns {Array}\n     */\n    transpose = xss => {\n        let numLists = length(xss),\n            ind = 0, ind2;\n        if (!numLists) {\n            return [];\n        }\n        const listLengths = apply(lengths, xss),\n            longestListLen = maximum(listLengths),\n            outLists = [];\n        for (; ind < longestListLen; ind += 1) {\n            const outList = [];\n            for (ind2 = 0; ind2 < numLists; ind2 += 1) {\n                if (listLengths[ind2] < ind + 1) {\n                    continue;\n                }\n                outList.push(xss[ind2][ind]);\n            }\n            outLists.push(outList);\n        }\n        return filter(x => length(x) > 0, outLists);\n    },\n\n    /**\n     * Generates 2^n sub-sequences for passed in sequence (string/list) (`n` is\n     * the length of the passed in sequence so: 2^length(xs)).\n     * Note: The return value doubles per index/character passed in so use with caution!\n     *  Also note that for 2^16 (or for a sequence of 16 characters) this algorithm\n     *  will generate 65536 sub-sequences!  So caution should be taken to not\n     *  use this with sequences above a certain length on certain platform (the browser thread in specific).\n     * @function module:list.subsequences\n     * @jsperftest https://jsperf.com/subsequences\n     * @param xs {Array|String}\n     * @returns {Array.<Array>}\n     */\n    subsequences = xs => {\n        const listLen = length(xs),\n            len = Math.pow(2, listLen),\n            out = [];\n        for (let i = 0; i < len; i += 1) {\n            let entry = [];\n            for (let j = 0; j < listLen; j += 1) {\n                if (i & (1 << j)) {\n                    entry.push(xs[j]);\n                }\n            }\n            out.push(entry);\n        }\n        return out;\n    },\n\n    /**\n     * Returns an array with the given indices swapped.\n     * @function module:list.swapped\n     * @param ind1 {Number}\n     * @param ind2 {Number}\n     * @param list {Array}\n     * @returns {Array} - Copy of incoming with swapped values at indices.\n     */\n    swapped = curry((ind1, ind2, list) => {\n        const out = sliceCopy(list),\n            tmp = out[ind1];\n        out[ind1] = out[ind2];\n        out[ind2] = tmp;\n        return out;\n    }),\n\n    /**\n     * Returns a list of permutations for passed in list.\n     *  Use caution with lists above a length of 15 (will take long due to nature of\n     *  algorithm).\n     * @function module:list.permutations\n     * @param xs {Array} - List.\n     * @returns {Array<Array|String|*>} - Array of permutations.\n     */\n    permutations = xs => {\n        const limit = length(xs);\n\n        if (!limit || limit === 1) {\n            return [xs];\n        }\n\n        let list = sliceCopy(xs),\n            c = repeat(limit, 0),\n            i = 0;\n\n        const out = [list];\n\n        for (; i < limit; i++) {\n            if (c[i] < i) {\n                list = swapped(i % 2 === 0 ? 0 : c[i], i, list);\n                out.push(list);\n                c[i] += 1;\n                i = 0;\n                continue;\n            }\n            c[i] = 0;\n        }\n\n        return out;\n    },\n\n    /**\n     * Left associative fold.  Reduces a container of elements down by the given operation (same as [].reduce).\n     * @function module:list.foldl\n     * @param fn {Function}\n     * @param zero {*} - Aggregator.\n     * @param functor {Array}\n     * @returns {*} - Whatever type is lastly returned from `fn`.\n     */\n    foldl = reduce,\n\n    /**\n     * Right associative fold.  Reduces a container of elements down by the given operation (same as [].reduceRight).\n     * @function module:list.foldr\n     * @param fn {Function}\n     * @param zero {*} - Aggregator.\n     * @param functor {Array}\n     * @returns {*} - Whatever type is lastly returned from `fn`.\n     */\n    foldr = reduceRight,\n\n    /**\n     * A variant of `foldl` except that this one doesn't require the starting point.  The starting point/value will be pulled\n     * out from a copy of the container.\n     * @function module:list.foldl1\n     * @param op {Function}\n     * @param xs {Array}\n     * @returns {*} - Whatever type is lastly returned from `op`.\n     */\n    foldl1 = curry((op, xs) => {\n        const parts = uncons(xs);\n        return !parts ? [] : reduce(op, parts[0], parts[1]);\n    }),\n\n    /**\n     * A variant of `foldr` except that this one doesn't require the starting point/value.  The starting point/value will be pulled\n     * out from a copy of the container.\n     * @function module:list.foldr1\n     * @param op {Function}\n     * @param xs {Array}\n     * @returns {*} - Whatever type is lastly returned from `op`.\n     */\n    foldr1 = curry((op, xs) => {\n        const parts = unconsr(xs);\n        return !parts ? [] : reduceRight(op, parts[1], parts[0]);\n    }),\n\n    /**\n     * Performs a map then a reduce all in one (from left-to-right). Returns a tuple\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\n     * @function module:list.mapAccumL\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\n     * @param zero {*} - An instance of the passed in list type used to aggregateArray on.\n     * @param xs {Array} - list type.\n     * @return {Array} - [aggregated, list]\n     */\n    mapAccumL = curry((op, zero, xs) => {\n        const list = sliceCopy(xs),\n            limit = length(xs);\n        if (!limit) {\n            return [zero, list];\n        }\n        let ind = 0,\n            agg = zero,\n            mapped = [],\n            tuple;\n        for (; ind < limit; ind++) {\n            tuple = op(agg, list[ind], ind);\n            agg = tuple[0];\n            mapped = tuple[1];\n        }\n        return [agg, mapped];\n    }),\n\n    /**\n     * Performs a map and a reduce all in one (from right-to-left). Returns a tuple\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\n     * @function module:list.mapAccumR\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\n     * @param zero {*} - An instance of the passed in list type used to aggregateArray on.\n     * @param xs {Array} - list type.\n     * @return {Array} - [aggregated, list]\n     */\n    mapAccumR = curry((op, zero, xs) => {\n        const list = sliceCopy(xs),\n            limit = length(xs);\n        if (!limit) {\n            return [zero, list];\n        }\n        let ind = limit - 1,\n            agg = zero,\n            mapped = [],\n            tuple;\n        for (; ind >= 0; ind--) {\n            tuple = op(agg, list[ind], ind);\n            agg = tuple[0];\n            mapped = tuple[1];\n        }\n        return [agg, mapped];\n    }),\n\n    /**\n     * iterate f x returns an infinite list of repeated applications of f to x.\n     * @function module:list.iterate\n     * @example `iterate(5, f, x) == [x, f(x), f(f(x)), ...]`\n     * @param limit {Number}\n     * @param op {Function} - Operation.\n     * @param x {*} - Starting point.\n     * @returns {*}\n     */\n    iterate = curry((limit, op, x) => {\n        let ind = 0,\n            out = [],\n            lastX = x;\n        for (; ind < limit; ind += 1) {\n            out.push(lastX);\n            lastX = op(lastX, ind);\n        }\n        return out;\n    }),\n\n    /**\n     * Repeats `x` `limit` number of times.\n     * @function module:list.repeat\n     * @param limit {Number}\n     * @param x {*}\n     * @return {Array}\n     */\n    repeat = curry((limit, x) => iterate(limit, a => a, x)),\n\n    /**\n     * Same as `repeat` due to the nature of javascript (see haskell version for usage).\n     * @function module:list.replicate\n     * @param limit {Number}\n     * @param x {*}\n     * @return {Array}\n     */\n    replicate = repeat,\n\n    /**\n     * Replicates a list `limit` number of times and appends the results (concat)\n     * @function module:list.cycle\n     * @param limit {Number}\n     * @param xs {Array}\n     * @returns {Array}\n     */\n    cycle = curry((limit, xs) => concat(replicate(limit, xs))),\n\n    /**\n     * Unfolds a value into a list of somethings.\n     * @haskellType `unfoldr :: (b -> Maybe (a, b)) -> b -> [a]`\n     * @function module:list.unfoldr\n     * @param op {Function} - Operation to perform (should return a two component tuple (item to aggregateArray and item to unfold in next iteration).\n     * @param x {*} - Starting parameter to unfold from.\n     * @returns {Array} - An array of whatever you return from `op` yielded.\n     */\n    unfoldr = curry((op, x) => {\n        let ind = 0,\n            out = [],\n            resultTuple = op(x, ind, out);\n        while (resultTuple) {\n            out.push(resultTuple[0]);\n            resultTuple = op(resultTuple[1], ++ind, out);\n        }\n        return out;\n    }),\n\n    /**\n     * Finds index in string or list (alias for `findIndex`).\n     * @function module:list.findIndex\n     * @param pred {Function} - Predicate<element, index, arr>.\n     * @param arr {Array|String}\n     * @returns {Number} - `-1` if predicate not matched else `index` found\n     */\n    findIndex = findIndexWhere,\n\n    /**\n     * @function module:list.findIndices\n     * @param pred {Function}\n     * @param xs {Array} - list or list like.\n     * @returns {Array|undefined}\n     */\n    findIndices = findIndicesWhere,\n\n    /**\n     * @function module:list.elemIndex\n     * @param x {*} - Element to search for.\n     * @param xs {Array} - list or list like.\n     * @returns {*}\n     */\n    elemIndex = curry((x, xs) => {\n        const foundInd = indexOf(x, xs);\n        return foundInd !== -1 ? foundInd : undefined;\n    }),\n\n    /**\n     * @function module:list.elemIndices\n     * @param value {*} - Element to search for.\n     * @param xs {Array} - list or list like.\n     * @returns {*}\n     */\n    elemIndices = curry((value, xs) => findIndices(x => x === value, xs)),\n\n    /**\n     * Takes `n` items from start of list to `limit` (exclusive).\n     * @function module:list.take\n     * @param list {Array|String}\n     * @param limit {Number}\n     * @returns {String|Array} - Passed in type's type\n     */\n    take = sliceTo,\n\n    /**\n     * Drops `n` items from start of list to `count` (exclusive).\n     * @function module:list.drop\n     * @param list {Array|String}\n     * @param count {Number}\n     * @returns {String|Array} - Passed in type's type\n     */\n    drop = sliceFrom,\n\n    /**\n     * Splits `x` in two at given `index` (exclusive (includes element/character at\n     * given index in second part of returned list)).\n     * @function module:list.splitAt\n     * @param ind {Number} - Index to split at.\n     * @param list {Array|String} - functor (list or string) to split.\n     * @returns {Array|String} - List like type passed\n     */\n    splitAt = (ind, list) => [sliceTo(ind, list), sliceFrom(ind, list)],\n\n    /**\n     * Gives an list with passed elements while predicate was true.\n     * @function module:list.takeWhile\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @returns {Array}\n     */\n    takeWhile = curry((pred, list) =>\n        reduceUntil(\n            negateF3(pred),     // predicate\n            isString(list) ?\n                (agg, x) => agg + x :\n                aggregateArray, // operation\n            of(list),           // aggregate\n            list\n        )),\n\n    /**\n     * Returns an list without elements that match predicate.\n     * @function module:list.dropWhile\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @refactor\n     * @returns {Array|String}\n     */\n    dropWhile = curry((pred, list) => {\n        const limit = length(list),\n            splitPoint =\n                findIndexWhere(\n                    (x, i, xs) => !pred(x, i, xs),\n                    list\n                );\n\n        return splitPoint === -1 ?\n            sliceFrom(limit, list) :\n            slice(splitPoint, limit, list);\n    }),\n\n    /**\n     * @function module:list.dropWhileEnd\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @refactor\n     * @returns {Array|String}\n     */\n    dropWhileEnd = curry((pred, list) => {\n        const splitPoint =\n            findIndexWhereRight(\n                (x, i, xs) => !pred(x, i, xs),\n                list\n            );\n        if (splitPoint === -1) {\n            return of(list);\n        }\n        return sliceTo(splitPoint + 1, list);\n    }),\n\n    /**\n     * Gives you the `span` of items matching predicate\n     * and items not matching predicate;  E.g., Gives an\n     * array of arrays;  E.g., [[matching-items], [non-matching-items]]\n     * @function list.span\n     * @param pred {Function} - List predicate (`(x, i, list) => bool`)\n     * @param list {Array|String}\n     * @returns {(Array<Array<*>>|Array<String>)}\n     * @type {Function}\n     */\n    span = curry((pred, list) => {\n        const splitPoint = findIndexWhere(negateF3(pred), list);\n        return splitPoint === -1 ?\n            [sliceFrom(0, list), of(list)] :\n            splitAt(splitPoint, list);\n    }),\n\n    /**\n     * breakOnList, applied to a predicate p and a list xs, returns a tuple\n     * where first element is longest prefix (possibly empty) of xs of elements\n     * that do not satisfy p and second element is the remainder of the list:\n     * @haskellExample\n     * Replace `break` with `breakOnList` for our version.\n     * ```\n     * breakOnList (> 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])\n     * breakOnList (< 9) [1,2,3] == ([],[1,2,3])\n     * breakOnList (> 9) [1,2,3] == ([1,2,3],[])\n     * ```\n     * @function module:list.breakOnList\n     * @param pred {Function}\n     * @param list {Array|String|*}\n     * @returns {Array}\n     */\n    breakOnList = curry((pred, list) => {\n        const splitPoint = findIndexWhere(negateF3(pred), list);\n        return splitPoint === -1 ?\n            [of(list), sliceFrom(0, list)] : reverse(splitAt(splitPoint, list));\n    }),\n\n    /**\n     * Gets item at index.\n     * @function module:list.at\n     * @param ind {Number} - Index.\n     * @param xs {Array} - list or list like.\n     * @returns {*|undefined} - Item or `undefined`.\n     */\n    at = lookup,\n\n    /**\n     * Find an item in structure of elements based on given predicate (`pred`).\n     * @function module:list.find\n     * @param pred {Function}\n     * @param xs {Array} - list or list like.\n     * @returns {*} - Found item.\n     */\n    find = findWhere,\n\n    /**\n     * For each function (same as `[].forEach` except in functional format).\n     * @function module:list.forEach\n     * @param fn {Function} - Operation (`(element, index, list) => {...}`, etc.)\n     * @param xs {(Array|String)}\n     * @returns {void}\n     */\n    forEach = curry((fn, list) => {\n        const limit = length(list);\n        if (!limit) {\n            return;\n        }\n        let ind = 0;\n        for (; ind < limit; ind += 1) {\n            fn(list[ind], ind, list);\n        }\n    }),\n\n    /**\n     * Filters a structure of elements using given predicate (`pred`) (same as `[].filter`).\n     * @function module:list.filter\n     * @param pred {Function}\n     * @param xs {Array} - list or list like.\n     * @returns {Array} - Structure of filtered elements.\n     */\n    filter = curry((pred, xs) => {\n        let ind = 0,\n            limit = length(xs),\n            out = [];\n        if (!limit) {\n            return out;\n        }\n        for (; ind < limit; ind++) {\n            if (pred(xs[ind], ind, xs)) {\n                out.push(xs[ind]);\n            }\n        }\n        return out;\n    }),\n\n    /**\n     * Partitions a list on a predicate;  Items that match predicate are in first list in tuple;  Items that\n     * do not match the tuple are in second list in the returned tuple.\n     *  Essentially `[filter(p, xs), filter(negateF3(p), xs)]`.\n     * @function module:list.partition\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\n     * @param list {Array}\n     * @returns {Array|String} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\n     */\n    partition = curry((pred, list) =>\n        !length(list) ?\n            [[], []] :\n            [filter(pred, list), filter(negateF3(pred), list)]),\n\n    /**\n     * Returns a boolean indicating whether an element exists in given structure of elements.\n     * @function module:list.elem\n     * @param element {*}\n     * @param xs {Array}\n     * @returns {Boolean}\n     */\n    elem = includes,\n\n    /**\n     * The opposite of `elem` - Returns a boolean indicating whether an element exists in given list.\n     * @function module:list.notElem\n     * @param element {*}\n     * @param xs {Array}\n     * @returns {Boolean}\n     */\n    notElem = negateF2(includes),\n\n    /**\n     * Checks if list `xs1` is a prefix of list `xs2`\n     * @function module:list.isPrefixOf\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @returns {boolean}\n     */\n    isPrefixOf = curry((xs1, xs2) => {\n        const limit1 = length(xs1),\n            limit2 = length(xs2);\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\n            return false;\n        }\n        let ind = 0;\n        for (; ind < limit1; ind++) {\n            if (xs1[ind] !== xs2[ind]) {\n                return false;\n            }\n        }\n        return true;\n    }),\n\n    /**\n     * Checks if list `xs1` is a suffix of list `xs2`\n     * @function module:list.isSuffixOf\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @returns {boolean}\n     */\n    isSuffixOf = curry((xs1, xs2) => {\n        const limit1 = length(xs1),\n            limit2 = length(xs2);\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\n            return false;\n        }\n        let ind1 = limit1 - 1,\n            ind2 = limit2 - 1;\n        for (; ind1 >= 0; ind1--) {\n            if (xs1[ind1] !== xs2[ind2]) {\n                return false;\n            }\n            ind2 -= 1;\n        }\n        return true;\n    }),\n\n    /**\n     * Checks if list `xs1` is an infix of list `xs2`\n     * @function module:list.isInfixOf\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @returns {boolean}\n     */\n    isInfixOf = curry((xs1, xs2) => {\n        const limit1 = length(xs1),\n            limit2 = length(xs2);\n        if (limit2 < limit1 || !limit1 || !limit2) {\n            return false;\n        }\n        let ind1,\n            foundLen,\n            ind = 0;\n        for (; ind < limit2; ind += 1) {\n            foundLen = 0;\n            for (ind1 = 0; ind1 < limit1; ind1 += 1) {\n                if (xs2[ind1 + ind] === xs1[ind1]) {\n                    foundLen += 1;\n                }\n                if (foundLen === limit1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }),\n\n    /**\n     * Checks if list `xs1` is a sub-sequence of list `xs2`\n     * @function module:list.isSubsequenceOf\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @returns {boolean}\n     */\n    isSubsequenceOf = curry((xs1, xs2) => {\n        const len = Math.pow(2, length(xs2)),\n            lenXs1 = length(xs1);\n        let foundLen,\n            i;\n        for (i = 0; i < len; i += 1) {\n            foundLen = 0;\n            for (let j = 0; j < len; j += 1) {\n                if (i & (1 << j) && indexOf(xs2[j], xs1) > -1) {\n                    foundLen += 1;\n                }\n                if (foundLen === lenXs1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }),\n\n    /**\n     * The group function takes a list and returns a list of lists such that\n     *  the concatenation of the result is equal to the argument. Moreover, each\n     *  sublist in the result contains only equal elements. For example,\n     * `group \"Mississippi\" = [\"M\",\"i\",\"ss\",\"i\",\"ss\",\"i\",\"pp\",\"i\"]`\n     * It is a special case of groupBy, which allows the programmer to supply\n     *  their own equality test.\n     * @haskellType `group :: Eq a => [a] -> [[a]]`\n     * @function module:list.group\n     * @param xs {Array|String}\n     * @returns {Array<Array|String|*>|*}\n     */\n    group = xs => groupBy((a, b) => a === b, xs),\n\n    /**\n     * Allows you to group items in a list based on your supplied equality check.\n     * @note Sames `group` but allows you to specify equality operation.\n     * @haskellType `groupBy :: (a -> a -> Bool) -> [a] -> [[a]]`\n     * @function module:list.groupBy\n     * @param equalityOp {Function}\n     * @param xs {Array}\n     * @returns {*}\n     */\n    groupBy = curry((equalityOp, xs) => {\n        const limit = length(xs);\n        if (!limit) {\n            return sliceCopy(xs);\n        }\n        let ind = 0,\n            prevItem,\n            item,\n            predOp = x => {\n                if (equalityOp(x, prevItem)) {\n                    ind++;\n                }\n                if (equalityOp(x, item)) {\n                    prevItem = x;\n                    return true;\n                }\n                return false;\n            },\n            agg = [];\n        for (; ind < limit; ind += 1) {\n            item = xs[ind];\n            agg.push(takeWhile(predOp, slice(ind, limit, xs)));\n        }\n        return agg;\n    }),\n\n    /**\n     * The inits function returns all initial segments of the argument, shortest first. For example,\n     * ```\n     * shallowEquals(inits('abc'), ['','a','ab','abc'])\n     * ```\n     * @function module:list.inits\n     * @haskellType `inits :: [a] -> [[a]]`\n     * @param xs {Array}\n     * @returns {Array}\n     */\n    inits = xs => {\n        let limit = length(xs),\n            ind = 0,\n            agg = [];\n        if (!limit) {\n            return [];\n        }\n        for (; ind <= limit; ind += 1) {\n            agg.push(sliceTo(ind, xs));\n        }\n        return agg;\n    }, //map(list => init(list), xs),\n\n    /**\n     * The inits function returns all initial segments of the argument, shortest first. For example,\n     * ```\n     * shallowEquals(tails('abc'), ['abc', 'bc', 'c',''])\n     * ```\n     * @function module:list.tails\n     * @haskellType `tails :: [a] -> [[a]]`\n     * @param xs {Array}\n     * @returns {Array}\n     */\n    tails = xs => {\n        let limit = length(xs),\n            ind = 0,\n            agg = [];\n        if (!limit) {\n            return [];\n        }\n        for (; ind <= limit; ind += 1) {\n            agg.push(slice(ind, limit, xs));\n        }\n        return agg;\n    }, //map(list => tail(list), xs),\n\n    /**\n     * Strips prefix list from given list\n     * @function module:list.stripPrefix\n     * @param prefix {Array|String|*}\n     * @param list {Array|string|*}\n     * @returns {Array|*}\n     */\n    stripPrefix = curry((prefix, list) =>\n        isPrefixOf(prefix, list) ?\n            splitAt(length(prefix), list)[1] :\n            sliceCopy(list)),\n\n    /**\n     * zip takes two lists and returns a list of corresponding pairs.\n     * If one input list is short, excess elements of the longer list are discarded.\n     * @haskellType `zip :: [a] -> [b] -> [(a, b)]`\n     * @function module:list.zip\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip = curry((arr1, arr2) => {\n        if (!length(arr1) || !length(arr2)) {\n            return [];\n        }\n        const [a1, a2] = toShortest(arr1, arr2);\n        return reduce((agg, item, ind) =>\n                aggregateArray(agg, [item, a2[ind]]),\n            [], a1);\n    }),\n\n    /**\n     * zipN takes one or more lists and returns a list containing lists of all indices\n     * at a given index, index by index.\n     * If one input list is short, excess elements of the longer list are discarded.\n     * @function module:list.zipN\n     * @param lists {Array|String} - One ore more lists of the same type.\n     * @returns {Array}\n     */\n    zipN = curry2((...lists) => {\n        const trimmedLists = apply(toShortest, lists);\n        return reduce((agg, item, ind) =>\n                aggregateArray(agg, map(xs => xs[ind], trimmedLists)),\n            [], trimmedLists[0]);\n    }),\n\n    /**\n     * @haskellType `zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]`\n     * @function module:list.zip3\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @param arr3 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip3 = curry((arr1, arr2, arr3) => zipN(arr1, arr2, arr3)),\n\n    /**\n     * @haskellType `zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]`\n     * @function module:list.zip4\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @param arr3 {Array}\n     * @param arr4 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip4 = curry((arr1, arr2, arr3, arr4) => zipN(arr1, arr2, arr3, arr4)),\n\n    /**\n     * @haskellType `zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]`\n     * @function module:list.zip5\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @param arr3 {Array}\n     * @param arr4 {Array}\n     * @param arr5 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip5 = curry((arr1, arr2, arr3, arr4, arr5) => zipN(arr1, arr2, arr3, arr4, arr5)),\n\n    /**\n     * zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\n     * zipWith generalises zip by zipping with the function given as the\n     * first argument, instead of a function tupling function (function that returns a tuple). For example,\n     * zipWith (+) is applied to two lists to produce the list of corresponding sums.\n     * @note `_|_` means bottom or perpetual (@see\n     *  - https://wiki.haskell.org/Bottom\n     *  - https://stackoverflow.com/questions/19794681/what-does-this-syntax-mean-in-haskell-or\n     *  )\n     * @example\n     * ```\n     * zipWith f [] _|_ = []\n     * ```\n     * @haskellType `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`\n     * @function module:list.zipWith\n     * @param op {Function} - Takes two parts of a tuple and returns a tuple.\n     *  E.g., ` op :: a -> b -> (a, b)`\n     * @param xs1 {Array}\n     * @param xs2 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith = curry((op, xs1, xs2) => {\n        if (!length(xs1) || !length(xs2)) {\n            return [];\n        }\n        const [a1, a2] = toShortest(xs1, xs2);\n        return reduce((agg, item, ind) =>\n                aggregateArray(agg, op(item, a2[ind])),\n            [], a1);\n    }),\n\n    /**\n     * Zips all given lists with tupling function. Note: Haskell types do not have\n     *  a way (that I know of) to show one or more for params in a function so `@haskellType` below\n     *  is left there for general purpose not for exactness as is told by aforementioned.\n     * @haskellType `zipWithN :: (a -> b -> c) -> [a] -> [b] -> [c]` - Where `N` is the number\n     *  of lists to zip.\n     * @function module:list.zipWithN\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\n     * @param lists ...{Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWithN = curry3((op, ...lists) => {\n        const trimmedLists = apply(toShortest, lists),\n            lenOfTrimmed = length(trimmedLists);\n        if (!lenOfTrimmed) {\n            return [];\n        }\n        else if (lenOfTrimmed === 1) {\n            return sliceTo(length(trimmedLists[0]), trimmedLists[0]);\n        }\n        return reduce((agg, item, ind) =>\n                aggregateArray(agg, apply(op, map(xs => xs[ind], trimmedLists))),\n            [], trimmedLists[0]);\n    }),\n\n    /**\n     * Zips 3 lists with tupling function.\n     * @haskellType `zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]`\n     * @function module:list.zipWith3\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\n     * @param xs1 {Array}\n     * @param xs2 {Array}\n     * @param xs3 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith3 = curry((op, xs1, xs2, xs3) => zipWithN(op, xs1, xs2, xs3)),\n\n    /**\n     * Zips 4 lists with tupling function.\n     * @haskellType `zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c]  -> [d] -> [e]`\n     * @function module:list.zipWith4\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> d -> (a, b, c, d)`\n     * @param xs1 {Array}\n     * @param xs2 {Array}\n     * @param xs3 {Array}\n     * @param xs4 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith4 = curry((op, xs1, xs2, xs3, xs4) => zipWithN(op, xs1, xs2, xs3, xs4)),\n\n    /**\n     * Zips 5 lists.\n     * @haskellType `zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c]  -> [d] -> [e] -> [f]`\n     * @function module:list.zipWith5\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> d -> e -> (a, b, c, d, e)`\n     * @param xs1 {Array}\n     * @param xs2 {Array}\n     * @param xs3 {Array}\n     * @param xs4 {Array}\n     * @param xs5 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith5 = curry((op, xs1, xs2, xs3, xs4, xs5) => zipWithN(op, xs1, xs2, xs3, xs4, xs5)),\n\n    /**\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\n     * @haskellType `unzip :: [(a, b)] -> ([a], [b])`\n     * @function module:list.unzip\n     * @param arr {Array|*}\n     * @returns {Array|*}\n     */\n    unzip = foldl((agg, item) => {\n        agg[0].push(item[0]);\n        agg[1].push(item[1]);\n        return agg;\n    }, [[], []]),\n\n    /**\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\n     * @sudoHaskellType `unzipN :: [(a, b, ...x)] -> ([a], [b], ...[x])`\n     * @function module:list.unzipN\n     * @param list {Array|*} - List of tuples (lists).\n     * @returns {Array|*}\n     */\n    unzipN = list => {\n        if (!length(list)) {\n            return [];\n        }\n        const lenItem0 = length(list[0]);\n        let zero = lenItem0 ?\n            unfoldr(numLists => numLists-- ? [[], numLists] : undefined, lenItem0) :\n            [];\n        return foldl((agg, item) => {\n            agg.forEach((outList, ind) => outList.push(item[ind]));\n            return agg;\n        }, zero, list);\n    },\n\n    /**\n     * Returns true if any item in container passes predicate `p`.\n     * @function module:list.any\n     * @param p {Function} - Predicate.\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    any = curry((p, xs) => {\n        let ind = 0,\n            limit = length(xs);\n        if (!limit) {\n            return false;\n        }\n        for (; ind < limit; ind += 1) {\n            if (p(xs[ind])) {\n                return true;\n            }\n        }\n        return false;\n    }),\n\n    /**\n     * Returns true if all items in container pass predicate `p`.\n     * @function module:list.all\n     * @param p {Function} - Predicate.\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    all = curry((p, xs) => {\n        const limit = length(xs);\n        let ind = 0;\n        if (!limit) {\n            return false;\n        }\n        for (; ind < limit; ind++) {\n            if (!p(xs[ind], ind, xs)) {\n                return false;\n            }\n        }\n        return true;\n    }),\n\n    /**\n     * Conjuction of container of bools (or truthy and/or falsy values);  Returns\n     * `true` if all in container are 'truthy' else returns `false`\n     * @function module:list.and\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    and = xs => all(isTruthy, xs),\n\n    /**\n     * Returns a boolean indicating whether any item in container is 'truthy' or not.\n     * **Note** The haskell type for this function only takes two items, but here\n     * we allow the passing of more than one item (may change later to adhere to the haskell type).\n     * @function module:list.or\n     * @haskellType `or :: Bool -> Bool -> Bool`\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    or = xs => any(isTruthy, xs),\n\n    /**\n     * Returns a boolean indicating whether all items in container are 'falsy' or not.\n     * **Note** The haskell type for this function only takes two items, but here\n     * we allow the passing of more than one item (may change later to adhere to the haskell type).\n     * @function module:list.not\n     * @haskellType `not :: Bool -> Bool`\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    not = xs => all(isFalsy, xs),\n\n    /**\n     * Computes the sum of the numbers of a structure.\n     * @function module:list.sum\n     * @haskellType `sum :: (List t, Num a) => t a -> a`\n     * @param list {Array|String}\n     * @returns {Number}\n     */\n    sum = list => foldl((agg, x) => agg + x, 0, list),\n\n    /**\n     * Computes the product of the numbers of a structure.\n     * @function module:list.product\n     * @haskellType `product :: (List t, Num a) => t a -> a`\n     * @param list {Array|String}\n     * @returns {Number}\n     */\n    product = list => foldl((agg, x) => agg * x, 1, list),\n\n    /**\n     * Returns the largest element in a non-empty structure of elements.\n     * @function module:list.maximum\n     * @haskellType `maximum :: forall a . Ord a => t a -> a`\n     * @param list {Array|String}\n     * @returns {*} - Whatever type the array is made of (if any).\n     */\n    maximum = list => last(sortBy(genericAscOrdering, list)),\n\n    /**\n     * Returns the smallest element in a non-empty structure of elements.\n     * @function module:list.minimum\n     * @haskellType `minimum :: forall a . Ord a => t a -> a`\n     * @param list {Array|String}\n     * @returns {*} - Whatever type the array is made of (if any).\n     */\n    minimum = list => head(sortBy(genericAscOrdering, list)),\n\n    /**\n     * scanl is similar to foldl, but returns a list of successive reduced values from the left:\n     * ```\n     * scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]\n     * ```\n     * Also note that:\n     * ```\n     * last (scanl f z xs) == foldl f z xs.\n     * ```\n     * @function module:list.scanl\n     * @param fn {Function}\n     * @param zero {*}\n     * @param xs {Array}\n     * @returns {Array|*}\n     */\n    scanl = curry((fn, zero, xs) => {\n        if (!xs || !length(xs)) {\n            return [];\n        }\n        const limit = length(xs);\n        let ind = 0,\n            result = zero,\n            out = [];\n        while (ind < limit) {\n            result = fn(result, xs[ind], ind, xs);\n            out.push(result);\n            ind++;\n        }\n        return out;\n    }),\n\n    /**\n     * `scanl1` is a variant of `scanl` that has no starting value argument:\n     * `shallowCompare(scanl1(fn, [x1, x2, ...]), [x1, fn(x1, x2), ...]) // true`\n     * @function module:list.scanl1\n     * @param fn {Function}\n     * @param xs {Array}\n     * @returns {Array|*}\n     */\n    scanl1 = curry((fn, xs) => {\n        if (!xs || !xs.length) {\n            return [];\n        }\n        return scanl(fn, head(xs), tail(xs));\n    }),\n\n    /**\n     * Same as `scanl` but from the right (similiar to `foldr`'s relationship to 'foldl').\n     * Note also `scanr`'s relationship ot `foldr`:\n     * `head (scanr(fn, z, xs)) === foldr(fn, z, xs).\n     * @function module:list.scanr\n     * @param fn {Function}\n     * @param zero {*}\n     * @param xs {Array}\n     * @returns {Array|*}\n     */\n    scanr = curry((fn, zero, xs) => {\n        if (!xs || !length(xs)) {\n            return [];\n        }\n        const limit = length(xs);\n        let ind = limit - 1,\n            result = xs[0],\n            out = [];\n        while (ind > -1) {\n            result = fn(result, xs[ind], ind, xs);\n            out.push(result);\n            ind--;\n        }\n        return out;\n    }),\n\n    /**\n     * Same as `scanr` but takes no zero/accumulator value.\n     * @function module:list.scanr1\n     * @param fn {Function}\n     * @param xs {Array}\n     * @returns {Array|*}\n     */\n    scanr1 = curry((fn, xs) => {\n        if (!xs || !xs.length) {\n            return [];\n        }\n        return scanr(fn, last(xs), init(xs));\n    }),\n\n    /**\n     * The nub function removes duplicate elements from a list.\n     * In particular, it keeps only the first occurrence of each element.\n     * (The name nub means `essence'.) It is a special case of nubBy, which\n     * allows the programmer to supply their own equality test.\n     * ```shallowCompare( nub ([1,2,3,4,3,2,1,2,4,3,5]), [1,2,3,4,5] )```\n     * @function module:list.nub\n     * @param list {Array|String|*}\n     * @returns {Array}\n     */\n    nub = list => nubBy((a, b) => a === b, list),\n\n    /**\n     * `remove(x, xs)` removes the first occurrence of `x` from `xs`.\n     * For example, `remove('a', 'banana') === 'bnana';`\n     * @function module:list.remove\n     * @param x {*}\n     * @param list {Array|String|*}\n     * @returns {Array}\n     */\n    remove = curry((x, list) => removeBy((a, b) => a === b, x, list)),\n\n    /**\n     * The sort function implements a stable sorting algorithm.\n     * It is a special case of sortBy, which allows the programmer\n     * to supply their own comparison function.\n     * ```shallowCompare(sort ([1,6,4,3,2,5]), [1,2,3,4,5,6]) // true```\n     * @function module:list.sort\n     * @param xs {Array|String|*}\n     * @returns {Array}\n     */\n    sort = xs => sortBy(genericAscOrdering, xs),\n\n    /**\n     * Sort a list by comparing the results of a key function applied to each\n     * element. sortOn f is equivalent to sortBy (comparing f), but has the\n     * performance advantage of only evaluating f once for each element in the\n     * input list. This is called the decorate-sort-undecorate paradigm, or\n     * Schwartzian transform.\n     *\n     * Elements are arranged from from lowest to highest, keeping duplicates\n     * in the order they appeared in the input.\n     *\n     * Ex:\n     * ```\n     * shallowEquals(\n     *  sortOn (head, [[2, \"world\"], [4, \"!\"], [1, \"Hello\"]]),\n     *  [[1,\"Hello\"],[2,\"world\"],[4,\"!\"]]\n     * ) // true\n     * ```\n     * @function module:list.sortOn\n     * @param valueFn {Function}\n     * @param xs {Array|String|*}\n     * @returns {Array}\n     */\n    sortOn = curry((valueFn, xs) =>\n\n        // Un-decorate\n        map(decorated => decorated[1],\n\n            // Decorate and sort\n            sortBy(\n                // Ordering\n                ([a0], [b0]) => genericAscOrdering(a0, b0),\n\n                // Decorate\n                map(item => [valueFn(item), item], xs)\n            )\n        )\n    ),\n\n    /**\n     * The sortBy function is the non-overloaded (in haskell terms) version of sort.\n     * @haskellExample ```\n     *  >>> sortBy (\\(a,_) (b,_) -> compare a b) [(2, \"world\"), (4, \"!\"), (1, \"Hello\")]\n     *  [(1,\"Hello\"),(2,\"world\"),(4,\"!\")]\n     * ```\n     * @function module:list.sortBy\n     * @param orderingFn {Function}\n     * @param xs {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    sortBy = curry((orderingFn, xs) => sliceCopy(xs).sort(orderingFn || genericAscOrdering)),\n\n    /**\n     * The insert function takes an element and a list and inserts the element\n     * into the list at the first position where it is less than or equal to the\n     * next element. In particular, if the list is sorted before the call, the\n     * result will also be sorted. It is a special case of insertBy, which allows\n     * the programmer to supply their own comparison function.\n     * @function module:list.insert\n     * @param x {*}\n     * @param xs {Array|*}\n     * @returns {Array}\n     */\n    insert = curry((x, xs) => {\n        if (!xs.length) {\n            return of(xs, x);\n        }\n        const foundIndex = findIndex(item => x <= item, xs);\n        return foundIndex === -1 ? concat([xs, of(xs, x)]) :\n            concat(intersperse(of(xs, x), splitAt(foundIndex, xs)));\n    }),\n\n    /**\n     * A version of `insert` that allows you to specify the ordering of the inserted\n     * item;  Before/at, or after\n     * @function module:list.insertBy\n     * @haskellType `insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]`\n     * @note `Ordering` means 'something that is order-able'\n     *  operated on by this functions logic.\n     * @param orderingFn {Function} - A function that returns `-1`, `0`, or 1`.\n     * @param x {*} - Value to insert.\n     * @param xs {Array} - List to insert into (note new list is returned)\n     * @returns {Array} - New list.\n     */\n    insertBy = curry((orderingFn, x, xs) => {\n        const limit = length(xs);\n        if (!limit) {\n            return [x];\n        }\n        let ind = 0;\n        for (; ind < limit; ind += 1) {\n            if (orderingFn(x, xs[ind]) <= 0) {\n                const parts = splitAt(ind, xs);\n                return concat([parts[0], [x], parts[1]]);\n            }\n        }\n        return aggregateArray(sliceCopy(xs), x);\n    }),\n\n    /**\n     * The nubBy function behaves just like nub, except it uses a user-supplied equality predicate.\n     * @function module:list.nubBy\n     * @param pred {Function}\n     * @param list {Array|String|*}\n     * @returns {Array}\n     */\n    nubBy = curry((pred, list) => {\n        if (!length(list)) {\n            return [];\n        }\n        const limit = length(list);\n        let ind = 0,\n            currItem,\n            out = [],\n            anyOp = storedItem => pred(currItem, storedItem);\n        for (; ind < limit; ind += 1) {\n            currItem = list[ind];\n            if (any(anyOp, out)) {\n                continue;\n            }\n            out.push(currItem);\n        }\n        return out;\n    }),\n\n    /**\n     * Behaves the same as `remove`, but takes a user-supplied equality predicate.\n     * @function module:list.removeBy\n     * @param pred {Function} - Equality predicate `(a, b) => bool`\n     * @param x {*}\n     * @param list {Array|String|*}\n     * @returns {Array}\n     */\n    removeBy = curry((pred, x, list) => {\n        const foundIndex = findIndex(item => pred(x, item), list);\n        if (foundIndex > -1) {\n            const parts = splitAt(foundIndex, list);\n            return append(parts[0], tail(parts[1]));\n        }\n        return sliceCopy(list);\n    }),\n\n    /**\n     * The `removeFirstsBy` function takes a predicate and two lists and returns the first list with the first\n     * occurrence of each element of the second list removed.\n     * @function module:list.removeFirstBy\n     * @param pred {Function}\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @returns {Array}\n     */\n    removeFirstsBy = curry((pred, xs1, xs2) =>\n        foldl((agg, x) => removeBy(pred, x, agg), xs1, xs2)),\n\n    /**\n     * Returns the union on elements matching boolean check passed in.\n     * @function module:list.unionBy\n     * @param pred {Function} - `pred :: a -> a -> Bool`\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @returns {Array}\n     */\n    unionBy = curry((pred, arr1, arr2) =>\n        foldl((agg, b) => {\n                const alreadyAdded = any(a => pred(a, b), agg);\n                return !alreadyAdded ? (agg.push(b), agg) : agg;\n            }, sliceCopy(arr1), arr2\n        )),\n\n    /**\n     * Creates a union on matching elements from array1.\n     * @function module:list.union\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @returns {Array}\n     */\n    union = curry((arr1, arr2) =>\n        append(arr1,\n            filter(elm => !includes(elm, arr1), arr2))),\n\n    /**\n     * Performs an intersection on list 1 with  elements from list 2.\n     * @function module:list.intersect\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @returns {Array}\n     */\n    intersect = curry((arr1, arr2) =>\n        !arr1 || !arr2 || (!arr1 && !arr2) ? [] :\n            filter(elm => includes(elm, arr2), arr1)),\n\n    /**\n     * Returns an intersection by predicate.\n     * @function module:list.intersectBy\n     * @param pred {Function} - `pred :: a -> b -> Bool`\n     * @param list1 {Array}\n     * @param list2 {Array}\n     * @return {Array}\n     */\n    intersectBy = curry((pred, list1, list2) =>\n        foldl((agg, a) =>\n                any(b => pred(a, b), list2) ? (agg.push(a), agg) : agg\n            , [], list1)),\n\n    /**\n     * Returns the difference of list 1 from list 2.\n     * @note The `difference` operation here is non-associative;  E.g., `a - b` is not equal to `b - a`;\n     * @function module:list.difference\n     * @param array1 {Array}\n     * @param array2 {Array}\n     * @returns {Array}\n     */\n    difference = curry((array1, array2) => { // augment this with max length and min length ordering on op\n        if (array1 && !array2) {\n            return sliceCopy(array1);\n        }\n        else if (!array1 && array2 || (!array1 && !array2)) {\n            return [];\n        }\n        return reduce((agg, elm) =>\n                !includes(elm, array2) ? (agg.push(elm), agg) : agg\n            , [], array1);\n    }),\n\n    /**\n     * Returns the complement of list 0 and the reset of the passed in arrays.\n     * @function module:list.complement\n     * @param arr0 {Array}\n     * @param arrays {...Array}\n     * @returns {Array}\n     */\n    complement = curry2((arr0, ...arrays) =>\n        reduce((agg, arr) => append(agg, difference(arr, arr0)), [], arrays));\n","/**\n * @module string\n * @description Contains functions for strings.\n */\nimport {intercalate, map, filter} from './list';\nimport {split} from './jsPlatform/string';\nimport {compose} from './function/compose';\nimport {join} from './jsPlatform/array';\nimport {_errorIfNotType} from './errorThrowing';\n\nexport {split};\n\nexport const\n\n    /**\n     * Splits a string on all '\\n', '\\r', '\\n\\r', or '\\r\\n' characters.\n     * @function module:string.lines\n     * @param str {String}\n     * @returns {Array}\n     */\n    lines = split(/[\\n\\r]/gm),\n\n    /**\n     * Splits a string on all '\\s' and/or all '\\t' characters.\n     * @function module:string.words\n     * @param str{String}\n     * @returns {Array}\n     */\n    words = split(/[\\s\\t]/gm),\n\n    /**\n     * Intersperse an array of strings with '\\s' and then concats them.\n     * @function module:string.unwords\n     * @param arr {String}\n     * @returns {Array}\n     */\n    unwords = intercalate(' '),\n\n    /**\n     * Intersperses a '\\n' character into a list of strings and then concats it.\n     * @function module:string.unlines\n     * @param list {Array|String|*}\n     * @returns {Array}\n     */\n    unlines = intercalate('\\n'),\n\n    /**\n     * Lower cases first character of a non-empty string.\n     * @function module:string.lcaseFirst\n     * @param xs {String}\n     * @returns {string}\n     * @throws {Error} - Throws error if receiving anything that is not a string.\n     */\n    lcaseFirst = xs => {\n        _errorIfNotType(String, 'lcaseFirst', 'xs', xs);\n        return xs[0].toLowerCase() + xs.substring(1);\n    },\n\n    /**\n     * Upper cases first character of a non-empty string.\n     * @function module:string.ucaseFirst\n     * @param xs {String}\n     * @returns {string}\n     * @throws {Error} - Throws error if receiving anything that is not a string.\n     */\n    ucaseFirst = xs => {\n        _errorIfNotType(String, 'ucaseFirst', 'xs', xs);\n        return xs[0].toUpperCase() + xs.substring(1);\n    },\n\n    /**\n     * Camel cases (class case) a string.\n     * @function module:string.camelCase\n     * @param xs {String}\n     * @param [pattern=/[^a-z\\d/i]/] {RegExp} - Pattern to split on.  Optional.\n     * @throws {Error} - Throws error if param `xs` is not a string.\n     * @returns {string}\n     * @curried\n     */\n    camelCase = (xs, pattern = /[^a-z\\d]/i) => compose(\n            join(''),\n            map(str => ucaseFirst(str.toLowerCase())),\n            filter(x => !!x),\n            split(pattern)\n        )(_errorIfNotType(String, 'camelCase', 'xs', xs)),\n\n    /**\n     * Class cases a string.  Uses pattern /[^a-z\\d/i]/ to split on.\n     * If you require a different pattern use `string.camelCase(str, pattern)`\n     * and then upper case first character (`ucaseFirst`).\n     * @function module:string.classCase\n     * @param xs {String}\n     * @returns {string}\n     * @throws {Error} - Throws error if `xs` is not a string (via `camelCase` call).\n     */\n    classCase = compose(ucaseFirst, camelCase)\n\n;\n\n/**\n * Functional version of `String.prototype.split`.\n * @function module:string.split\n * @param separator {String|RegExp}\n * @param str {String}\n * @returns {Array}\n */\n","/**\n * @module fjl\n * @description Exports all module methods (object, list, string modules etc.).\n * @goal to include everything from haskell's Prelude where it makes sense in order to create\n *  a subset of functions which can make the javascript developer more efficient and make his/her\n *  code more concise (and functional).\n * @motivation preludejs, lodash/fp, RamdaJs, Haskell.\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-List.html\n */\nexport * from './object';\nexport * from './boolean';\nexport * from './function';\nexport * from './list';\nexport * from './string';\nexport * from './utils';\nexport * from './errorThrowing';\n\nimport * as _jsPlatform from './jsPlatform';\n\nexport const jsPlatform = _jsPlatform;\n\n/**\n * @typedef {String|Function|ArrayBufferConstructor|ArrayConstructor|BooleanConstructor|MapConstructor|NumberConstructor|SetConstructor|WeakMapConstructor|WeakSetConstructor} TypeRef\n * @description Type reference.  Either actual type or type's name;  E.g., `Type.name`\n * Also note: Class cased names are use for values that do not have `name` properties;  Namely: 'Null', 'NaN' and 'Undefined' (for their respective values respectively).\n */\n"],"names":["returnCurried","executeArity","unmetArityNum","fn","argsToCurry","func","x","executeAsCurriedFunc","Array","from","arguments","a","b","c","d","e","args","unmetArity","concatedArgs","concat","canBeCalled","length","newExpectedArity","curryN","Function","Error","curry","curry2","curry3","curry4","curry5","fPureTakesOne","name","arg","f","fPureTakes2","arg1","arg2","fPureTakes3","arg3","fPureTakes4","arg4","fPureTakes5","arg5","fPureTakesOneOrMore","defineReverse","prototype","reverse","reduceRight","agg","item","push","map","filter","reduce","forEach","some","every","join","apply","call","flipN","flip","flip3","flip4","flip5","instanceOf","instanceConstructor","instance","hasOwnProperty","native","Object","getOwnPropertyNames","key","operation","keys","assign","obj0","objs","topAgg","obj","_Number","Number","_NaN","_Null","_Undefined","typeOf","value","retVal","undefined","constructorName","constructor","isNaN","_String","String","_Object","_Boolean","Boolean","_Symbol","_Map","_Set","_WeakMap","_WeakSet","toTypeRef","type","toTypeRefs","types","toTypeRefName","Type","ref","toTypeRefNames","isFunction","isType","isStrictly","isOfType","isLoosely","isClass","test","substr","isCallable","isArray","isObject","isBoolean","isNumber","isString","isMap","isSet","isWeakMap","isWeakSet","isUndefined","isNull","isSymbol","isUsableImmutablePrimitive","typeOfX","isset","isEmptyList","isEmptyObject","isEmptyCollection","size","isEmpty","isOneOf","typeName","isStrictlyOneOf","isLooselyOneOf","instanceOfOne","isFunctor","lookup","of","copy","out","slice","Symbol","Promise","searchObj","nsString","indexOf","parts","split","limit","ind","parent","node","typeRefsToStringOrError","defaultErrorMessageCall","tmplContext","contextName","valueName","expectedTypeName","foundTypeName","messageSuffix","isMultiTypeNames","typesCopy","typesToMatchCopy","_getErrorIfNotTypeThrower","errorMessageCall","typeChecker","ValueType","_getErrorIfNotTypesThrower","valueTypes","expectedTypeNames","matchFound","_errorIfNotType","_errorIfNotTypes","getErrorIfNotTypeThrower","getErrorIfNotTypesThrower","errorIfNotType","errorIfNotTypes","createDefinePropsMethod","enumerable","defineEnumProp","defineProp","argTuples","target","argTuple","TypeRef","propName","defaultValue","createTypedDescriptor","_value","get","set","toEnumerableDescriptor","descriptor","toTargetDescriptorTuple","targetOrTargetDescriptorTuple","_target","_descriptor","defineProperty","defineEnumProps","defineProps","assignDeep","propDescription","getOwnPropertyDescriptor","writable","includes","xs","lastIndexOf","isTruthy","isFalsy","alwaysTrue","alwaysFalse","equal","equalAll","i","aggregateArray","sliceFrom","startInd","sliceTo","toInd","sliceCopy","genericAscOrdering","lengths","lists","toShortest","listLengths","smallLen","Math","min","list","reduceUntil","pred","op","result","reduceUntilRight","arr","lastIndex","len","findIndexWhere","predicateFulfilled","findIndexWhereRight","findIndicesWhere","findWhere","elm","objUnion","obj1","obj2","objIntersect","objDifference","objComplement","log","console","bind","error","peek","pop","warn","jsonClone","JSON","parse","stringify","toAssocList","toAssocListDeep","TypeConstraint","fromAssocList","OutType","fromAssocListDeep","toArray","compose","arg0","id","negateF","negateF2","negateF3","negateFN","until","predicate","typeInstance","fnOrError","symbolName","noop","trampoline","fnName","toFunction","normalizeStep","to","step","range","append","listAppend","head","last","tail","init","uncons","unconsr","item0","concatMap","foldableOfA","intersperse","between","lastInd","intercalate","xss","transpose","numLists","ind2","longestListLen","maximum","outLists","outList","subsequences","listLen","pow","entry","j","swapped","ind1","tmp","permutations","repeat","foldl","foldr","foldl1","foldr1","mapAccumL","zero","mapped","tuple","mapAccumR","iterate","lastX","replicate","cycle","unfoldr","resultTuple","findIndex","findIndices","elemIndex","foundInd","elemIndices","take","drop","splitAt","takeWhile","dropWhile","splitPoint","dropWhileEnd","span","breakOnList","at","find","partition","elem","notElem","isPrefixOf","xs1","xs2","limit1","limit2","isSuffixOf","isInfixOf","foundLen","isSubsequenceOf","lenXs1","group","groupBy","equalityOp","prevItem","predOp","inits","tails","stripPrefix","prefix","zip","arr1","arr2","a1","a2","zipN","trimmedLists","zip3","arr3","zip4","arr4","zip5","arr5","zipWith","zipWithN","lenOfTrimmed","zipWith3","xs3","zipWith4","xs4","zipWith5","xs5","unzip","unzipN","lenItem0","any","p","all","and","or","not","sum","product","sortBy","minimum","scanl","scanl1","scanr","scanr1","nub","nubBy","remove","removeBy","sort","sortOn","valueFn","decorated","a0","b0","orderingFn","insert","foundIndex","insertBy","currItem","anyOp","storedItem","removeFirstsBy","unionBy","alreadyAdded","union","intersect","intersectBy","list1","list2","difference","array1","array2","complement","arr0","arrays","lines","words","unwords","unlines","lcaseFirst","toLowerCase","substring","ucaseFirst","toUpperCase","camelCase","pattern","str","classCase","jsPlatform","_jsPlatform"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;;;;;;;EAOA;;;;EAIA;EAEI;;;;;;;;;EASAA,aAAa,GAAG,SAAhBA,aAAgB,CAACC,YAAD,EAAeC,aAAf,EAA8BC,EAA9B,EAAkCC,WAAlC,EAAkD;EAC9D,UAAQF,aAAR;EACI,SAAK,CAAL;EACI;EACA,aAAO,SAASG,IAAT,CAAcC,CAAd,EAAiB;EACxB;EACI,eAAOC,oBAAoB,CAACJ,EAAD,EAAKF,YAAL,EAAmBC,aAAnB,EAAkCM,KAAK,CAACC,IAAN,CAAWC,SAAX,CAAlC,EAAyDN,WAAzD,CAA3B;EACH,OAHD;;EAIJ,SAAK,CAAL;EACI;EACA,aAAO,SAASC,IAAT,CAAcM,CAAd,EAAiBC,CAAjB,EAAoB;EAC3B;EACI,eAAOL,oBAAoB,CAACJ,EAAD,EAAKF,YAAL,EAAmBC,aAAnB,EAAkCM,KAAK,CAACC,IAAN,CAAWC,SAAX,CAAlC,EAAyDN,WAAzD,CAA3B;EACH,OAHD;;EAIJ,SAAK,CAAL;EACI;EACA,aAAO,SAASC,IAAT,CAAcM,CAAd,EAAiBC,CAAjB,EAAoBC,CAApB,EAAuB;EAC9B;EACI,eAAON,oBAAoB,CAACJ,EAAD,EAAKF,YAAL,EAAmBC,aAAnB,EAAkCM,KAAK,CAACC,IAAN,CAAWC,SAAX,CAAlC,EAAyDN,WAAzD,CAA3B;EACH,OAHD;;EAIJ,SAAK,CAAL;EACI;EACA,aAAO,SAASC,IAAT,CAAcM,CAAd,EAAiBC,CAAjB,EAAoBC,CAApB,EAAuBC,CAAvB,EAA0B;EACjC;EACI,eAAOP,oBAAoB,CAACJ,EAAD,EAAKF,YAAL,EAAmBC,aAAnB,EAAkCM,KAAK,CAACC,IAAN,CAAWC,SAAX,CAAlC,EAAyDN,WAAzD,CAA3B;EACH,OAHD;;EAIJ,SAAK,CAAL;EACI;EACA,aAAO,SAASC,IAAT,CAAcM,CAAd,EAAiBC,CAAjB,EAAoBC,CAApB,EAAuBC,CAAvB,EAA0BC,CAA1B,EAA6B;EACpC;EACI,eAAOR,oBAAoB,CAACJ,EAAD,EAAKF,YAAL,EAAmBC,aAAnB,EAAkCM,KAAK,CAACC,IAAN,CAAWC,SAAX,CAAlC,EAAyDN,WAAzD,CAA3B;EACH,OAHD;;EAIJ;EACI,aAAO;EAAA,0CAAIY,IAAJ;EAAIA,UAAAA,IAAJ;EAAA;;EAAA,eAAaT,oBAAoB,CAACJ,EAAD,EAAKF,YAAL,EAAmBC,aAAnB,EAAkCc,IAAlC,EAAwCZ,WAAxC,CAAjC;EAAA,OAAP;EAhCR;EAkCH,CA9CL;;EAgDI;;;;;;;;;;;EAWAG,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACJ,EAAD,EAAKF,YAAL,EAAmBgB,UAAnB,EAA+BD,IAA/B,EAAqCZ,WAArC,EAAqD;EACxE,MAAIc,YAAY,GAAGd,WAAW,CAACe,MAAZ,CAAmBH,IAAnB,CAAnB;EAAA,MACII,WAAW,GAAIF,YAAY,CAACG,MAAb,IAAuBpB,YAAxB,IAAyC,CAACA,YAD5D;EAAA,MAEIqB,gBAAgB,GAAGrB,YAAY,GAAGiB,YAAY,CAACG,MAFnD;EAGA,SAAO,CAACD,WAAD,GACHpB,aAAa,CAACC,YAAD,EAAeqB,gBAAf,EAAiCnB,EAAjC,EAAqCe,YAArC,CADV,GAEHf,EAAE,MAAF,4BAAMe,YAAN,EAFJ;EAGH,CAlEL;;AAqEA;EAEI;;;;;;;;;EASAK,MAAM,GAAG,SAATA,MAAS,CAACtB,YAAD,EAAeE,EAAf,EAAsC;EAC3C,MAAI,CAACA,EAAD,IAAO,EAAEA,EAAE,YAAYqB,QAAhB,CAAX,EAAsC;EAClC,UAAM,IAAIC,KAAJ,8FAAoGtB,EAApG,OAAN;EACH;;EAH0C,qCAAhBC,WAAgB;EAAhBA,IAAAA,WAAgB;EAAA;;EAI3C,SAAOJ,aAAa,CAACC,YAAD,EAAeA,YAAY,GAAGG,WAAW,CAACiB,MAA1C,EAAkDlB,EAAlD,EAAsDC,WAAtD,CAApB;EACH,CAhBE;;EAkBH;;;;;;;EAOAsB,KAAK,GAAG,SAARA,KAAQ,CAACvB,EAAD;EAAA,qCAAQC,WAAR;EAAQA,IAAAA,WAAR;EAAA;;EAAA,SAAwBmB,MAAM,MAAN,UAAO,CAACpB,EAAE,IAAI,EAAP,EAAWkB,MAAlB,EAA0BlB,EAA1B,SAAiCC,WAAjC,EAAxB;EAAA,CAzBL;;EA2BH;;;;;;EAMAuB,MAAM,GAAG,SAATA,MAAS,CAAAxB,EAAE;EAAA,SAAIoB,MAAM,CAAC,CAAD,EAAIpB,EAAJ,CAAV;EAAA,CAjCR;;EAmCH;;;;;;EAMAyB,MAAM,GAAG,SAATA,MAAS,CAAAzB,EAAE;EAAA,SAAIoB,MAAM,CAAC,CAAD,EAAIpB,EAAJ,CAAV;EAAA,CAzCR;;EA2CH;;;;;;EAMA0B,MAAM,GAAG,SAATA,MAAS,CAAA1B,EAAE;EAAA,SAAIoB,MAAM,CAAC,CAAD,EAAIpB,EAAJ,CAAV;EAAA,CAjDR;;EAmDH;;;;;;EAMA2B,MAAM,GAAG,SAATA,MAAS,CAAA3B,EAAE;EAAA,SAAIoB,MAAM,CAAC,CAAD,EAAIpB,EAAJ,CAAV;EAAA,CAzDR;;EChFP;;;AAGA;EAII;;;;;;;EAOA4B,aAAa,GAAG,SAAhBA,aAAgB,CAAAC,IAAI;EAAA,SAAIN,KAAK,CAAC,UAACO,GAAD,EAAMC,CAAN;EAAA,WAAYA,CAAC,CAACF,IAAD,CAAD,CAAQC,GAAR,CAAZ;EAAA,GAAD,CAAT;EAAA,CATjB;;EAWH;;;;;;;EAOAE,WAAW,GAAG,SAAdA,WAAc,CAAAH,IAAI;EAAA,SAAIN,KAAK,CAAC,UAACU,IAAD,EAAOC,IAAP,EAAaH,CAAb;EAAA,WAAmBA,CAAC,CAACF,IAAD,CAAD,CAAQI,IAAR,EAAcC,IAAd,CAAnB;EAAA,GAAD,CAAT;EAAA,CAlBf;;EAoBH;;;;;;;EAOAC,WAAW,GAAG,SAAdA,WAAc,CAAAN,IAAI;EAAA,SAAIN,KAAK,CAAC,UAACU,IAAD,EAAOC,IAAP,EAAaE,IAAb,EAAmBL,CAAnB;EAAA,WAAyBA,CAAC,CAACF,IAAD,CAAD,CAAQI,IAAR,EAAcC,IAAd,EAAoBE,IAApB,CAAzB;EAAA,GAAD,CAAT;EAAA,CA3Bf;;EA6BH;;;;;;;EAOAC,WAAW,GAAG,SAAdA,WAAc,CAAAR,IAAI;EAAA,SAAIN,KAAK,CAAC,UAACU,IAAD,EAAOC,IAAP,EAAaE,IAAb,EAAmBE,IAAnB,EAAyBP,CAAzB;EAAA,WAA+BA,CAAC,CAACF,IAAD,CAAD,CAAQI,IAAR,EAAcC,IAAd,EAAoBE,IAApB,EAA0BE,IAA1B,CAA/B;EAAA,GAAD,CAAT;EAAA,CApCf;;EAsCH;;;;;;;EAOAC,WAAW,GAAG,SAAdA,WAAc,CAAAV,IAAI;EAAA,SAAIN,KAAK,CAAC,UAACU,IAAD,EAAOC,IAAP,EAAaE,IAAb,EAAmBE,IAAnB,EAAyBE,IAAzB,EAA+BT,CAA/B;EAAA,WAAqCA,CAAC,CAACF,IAAD,CAAD,CAAQI,IAAR,EAAcC,IAAd,EAAoBE,IAApB,EAA0BE,IAA1B,EAAgCE,IAAhC,CAArC;EAAA,GAAD,CAAT;EAAA,CA7Cf;;EA+CH;;;;;;;EAOAC,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAAZ,IAAI;EAAA,SAAIL,MAAM,CAAC,UAACO,CAAD;EAAA,sCAAOlB,IAAP;EAAOA,MAAAA,IAAP;EAAA;;EAAA,WAAgBkB,CAAC,CAACF,IAAD,CAAD,OAAAE,CAAC,EAAUlB,IAAV,CAAjB;EAAA,GAAD,CAAV;EAAA,CAtDvB;;ECLP;;;;AAKA;EAEA;EACI;;;;;EAKA6B,aAAa,GAAG,SAAhBA,aAAgB;EAAA,SACZrC,KAAK,CAACsC,SAAN,CAAgBC,OAAhB,GAA0B,UAAAzC,CAAC;EAAA,WAAIA,CAAC,CAACyC,OAAF,EAAJ;EAAA,GAA3B,GACI,UAAAzC,CAAC;EAAA,WAAIA,CAAC,CAAC0C,WAAF,CAAc,UAACC,GAAD,EAAMC,IAAN,EAAe;EAC9BD,MAAAA,GAAG,CAACE,IAAJ,CAASD,IAAT;EACA,aAAOD,GAAP;EACH,KAHI,EAGF,EAHE,CAAJ;EAAA,GAFO;EAAA,CANpB;;AAcA;EAEI;;;;;;;EAOAG,GAAG,GAAGrB,aAAa,CAAC,KAAD,CAThB;;EAWH;;;;;;;EAOAsB,MAAM,GAAGtB,aAAa,CAAC,QAAD,CAlBnB;;EAoBH;;;;;;;EAOAuB,MAAM,GAAGnB,WAAW,CAAC,QAAD,CA3BjB;;EA6BH;;;;;;;EAOAa,WAAW,GAAGb,WAAW,CAAC,aAAD,CApCtB;;EAsCH;;;;;;;;EAQAoB,OAAO,GAAGxB,aAAa,CAAC,SAAD,CA9CpB;;EAgDH;;;;;;;;EAQAyB,IAAI,GAAGzB,aAAa,CAAC,MAAD,CAxDjB;;EA0DH;;;;;;;;EAQA0B,KAAK,GAAG1B,aAAa,CAAC,OAAD,CAlElB;;EAoEH;;;;;;;EAOA2B,IAAI,GAAG3B,aAAa,CAAC,MAAD,CA3EjB;;EA6EH;;;;;;;EAOAoB,IAAI,GAAGP,mBAAmB,CAAC,MAAD,CApFvB;;EAsFH;;;;;;EAMAG,OAAO,GAAGF,aAAa,EA5FpB;;ECnBP;;;;AAGA;EAEI;;;;;;;EAOAc,KAAK,GAAGjC,KAAK,CAAC,UAACvB,EAAD,EAAKa,IAAL;EAAA,SAAcb,EAAE,CAACwD,KAAH,CAAS,IAAT,EAAe3C,IAAf,CAAd;EAAA,CAAD,CATV;;EAWH;;;;;;;EAOA4C,IAAI,GAAGjC,MAAM,CAAC,UAACxB,EAAD;EAAA,oCAAQa,IAAR;EAAQA,IAAAA,IAAR;EAAA;;EAAA,SAAiBb,EAAE,CAACyD,IAAH,OAAAzD,EAAE,GAAM,IAAN,SAAea,IAAf,EAAnB;EAAA,CAAD,CAlBV;;;ECCH;;;;;;;;EAQA6C,KAAK,GAAG,SAARA,KAAQ,CAAA1D,EAAE;EAAA,SAAIwB,MAAM,CAAC;EAAA,sCAAIX,IAAJ;EAAIA,MAAAA,IAAJ;EAAA;;EAAA,WAAa2C,KAAK,CAACxD,EAAD,EAAK4C,OAAO,CAAC/B,IAAD,CAAZ,CAAlB;EAAA,GAAD,CAAV;EAAA,CAVP;;EAYH;;;;;;EAMA8C,IAAI,GAAG,SAAPA,IAAO,CAAA3D,EAAE;EAAA,SAAIuB,KAAK,CAAC,UAACd,CAAD,EAAID,CAAJ;EAAA,WAAUiD,IAAI,CAACzD,EAAD,EAAKQ,CAAL,EAAQC,CAAR,CAAd;EAAA,GAAD,CAAT;EAAA,CAlBN;;EAoBH;;;;;;EAMAmD,KAAK,GAAG,SAARA,KAAQ,CAAA5D,EAAE;EAAA,SAAIuB,KAAK,CAAC,UAACb,CAAD,EAAID,CAAJ,EAAOD,CAAP;EAAA,WAAaiD,IAAI,CAACzD,EAAD,EAAKQ,CAAL,EAAQC,CAAR,EAAWC,CAAX,CAAjB;EAAA,GAAD,CAAT;EAAA,CA1BP;;EA4BH;;;;;;EAMAmD,KAAK,GAAG,SAARA,KAAQ,CAAA7D,EAAE;EAAA,SAAIuB,KAAK,CAAC,UAACZ,CAAD,EAAID,CAAJ,EAAOD,CAAP,EAAUD,CAAV;EAAA,WAAgBiD,IAAI,CAACzD,EAAD,EAAKQ,CAAL,EAAQC,CAAR,EAAWC,CAAX,EAAcC,CAAd,CAApB;EAAA,GAAD,CAAT;EAAA,CAlCP;;EAoCH;;;;;;EAMAmD,KAAK,GAAG,SAARA,KAAQ,CAAA9D,EAAE;EAAA,SAAIuB,KAAK,CAAC,UAACX,CAAD,EAAID,CAAJ,EAAOD,CAAP,EAAUD,CAAV,EAAaD,CAAb;EAAA,WAAmBiD,IAAI,CAACzD,EAAD,EAAKQ,CAAL,EAAQC,CAAR,EAAWC,CAAX,EAAcC,CAAd,EAAiBC,CAAjB,CAAvB;EAAA,GAAD,CAAT;EAAA,CA1CP;;ECJP;;;AAIA;EAMI;;;;;;;;AAQA,MAAAmD,UAAU,GAAGxC,KAAK,CAAC,UAACyC,mBAAD,EAAsBC,QAAtB;EAAA,SACfA,QAAQ,YAAYD,mBADL;EAAA,CAAD,CAAlB;EAAA,IAUAE,cAVA,GAUiBtC,aAAa,CAAC,gBAAD,CAV9B;EAAA,IAmBAV,MAnBA,GAmBS,SAATA,MAAS,CAAAf,CAAC;EAAA,SAAIA,CAAC,CAACe,MAAN;EAAA,CAnBV;EAAA,IA+BAiD,OA/BA,GA+BSC,MAAM,CAACC,mBAAP,CAA2BD,MAA3B,EAAmCjB,MAAnC,CAA0C,UAACL,GAAD,EAAMwB,GAAN,EAAc;EAC7D,MAAI,OAAOF,MAAM,CAACE,GAAD,CAAb,KAAuB,UAA3B,EAAuC;EACnC,WAAOxB,GAAP;EACH;;EACD,MAAMyB,SAAS,GAAGH,MAAM,CAACE,GAAD,CAAxB;;EACA,UAAQC,SAAS,CAACrD,MAAlB;EACI,SAAK,CAAL;EACI4B,MAAAA,GAAG,CAACwB,GAAD,CAAH,GAAWX,IAAI,CAACY,SAAD,CAAf;EACA;;EACJ,SAAK,CAAL;EACIzB,MAAAA,GAAG,CAACwB,GAAD,CAAH,GAAWV,KAAK,CAACW,SAAD,CAAhB;EACA;;EACJ,SAAK,CAAL;EACIzB,MAAAA,GAAG,CAACwB,GAAD,CAAH,GAAWT,KAAK,CAACU,SAAD,CAAhB;EACA;;EACJ,SAAK,CAAL;EACIzB,MAAAA,GAAG,CAACwB,GAAD,CAAH,GAAWR,KAAK,CAACS,SAAD,CAAhB;EACA;;EACJ;EACIzB,MAAAA,GAAG,CAACwB,GAAD,CAAH,GAAWF,MAAM,CAACE,GAAD,CAAjB;EACA;EAfR;;EAiBA,SAAOxB,GAAP;EACH,CAvBQ,EAuBN,EAvBM,CA/BT;EAAA,IA8DC0B,IA9DD,GA8DSL,OA9DT,CA8DCK,IA9DD;EAAA,IAuEAC,MAvEA,GAuEU;EAAA,SAAML,MAAM,CAACK,MAAP,GACR,UAACC,IAAD;EAAA,sCAAUC,IAAV;EAAUA,MAAAA,IAAV;EAAA;;EAAA,WAAmBP,MAAM,CAACK,MAAP,OAAAL,MAAM,GAAQM,IAAR,SAAiBC,IAAjB,EAAzB;EAAA,GADQ,GAERnD,MAAM,CAAC,UAACkD,IAAD;EAAA,uCAAUC,IAAV;EAAUA,MAAAA,IAAV;EAAA;;EAAA,WAAmBA,IAAI,CAACxB,MAAL,CAAY,UAACyB,MAAD,EAASC,GAAT,EAAiB;EACnD,aAAOT,MAAM,CAACI,IAAP,CAAYK,GAAZ,EAAiB1B,MAAjB,CAAwB,UAACL,GAAD,EAAMwB,GAAN,EAAc;EACzCxB,QAAAA,GAAG,CAACwB,GAAD,CAAH,GAAWO,GAAG,CAACP,GAAD,CAAd;EACA,eAAOxB,GAAP;EACH,OAHM,EAGJ8B,MAHI,CAAP;EAIH,KALyB,EAKvBF,IALuB,CAAnB;EAAA,GAAD,CAFJ;EAAA,CAAD,EAvET;;EClBJ;;;;EAIA,IAAMI,OAAO,GAAGC,MAAM,CAAClD,IAAvB;EAAA,IACImD,IAAI,GAAG,KADX;EAAA,IAEIC,KAAK,GAAG,MAFZ;EAAA,IAGIC,UAAU,GAAG,WAHjB;EAKA;;;;;;;;;;;;;AAYA,EAAO,SAASC,MAAT,CAAiBC,KAAjB,EAAwB;EAC3B,MAAIC,MAAJ;;EACA,MAAID,KAAK,KAAKE,SAAd,EAAyB;EACrBD,IAAAA,MAAM,GAAGH,UAAT;EACH,GAFD,MAGK,IAAIE,KAAK,KAAK,IAAd,EAAoB;EACrBC,IAAAA,MAAM,GAAGJ,KAAT;EACH,GAFI,MAGA;EACD,QAAIM,eAAe,GAAIH,KAAD,CAAQI,WAAR,CAAoB3D,IAA1C;EACAwD,IAAAA,MAAM,GAAGE,eAAe,KAAKT,OAApB,IAA+BW,KAAK,CAACL,KAAD,CAApC,GACLJ,IADK,GACEO,eADX;EAEH;;EACD,SAAOF,MAAP;EACH;;ECnCD;;;;AAKA,EAIA,IAAIK,OAAO,GAAGC,MAAM,CAAC9D,IAArB;EAAA,IACIiD,SAAO,GAAGC,MAAM,CAAClD,IADrB;EAAA,IAEI+D,OAAO,GAAGxB,MAAM,CAACvC,IAFrB;EAAA,IAGIgE,QAAQ,GAAGC,OAAO,CAACjE,IAHvB;EAAA,IAIIkE,OAAO,GAAG,QAJd;EAAA,IAKIC,IAAI,GAAG,KALX;EAAA,IAMIC,IAAI,GAAG,KANX;EAAA,IAOIC,QAAQ,GAAG,SAPf;EAAA,IAQIC,QAAQ,GAAG,SARf;EAAA,IASIlB,OAAK,GAAG,MATZ;EAAA,IAUIC,YAAU,GAAG,WAVjB;;EAcI;;;;;;;AAOA,MAAAkB,SAAS,GAAG,SAAZA,SAAY,CAAAC,IAAI,EAAI;EAChB,MAAI,CAACA,IAAL,EAAW;EACP,WAAOlB,MAAM,CAACkB,IAAD,CAAb;EACH,GAFD,MAGK,IAAIA,IAAI,CAACb,WAAL,KAAqBG,MAArB,IAAgCU,IAAI,YAAYhF,QAApD,EAA+D;EAChE,WAAOgF,IAAP;EACH;;EACD,SAAOlB,MAAM,CAACkB,IAAD,CAAb;EACH,CARD;EAAA,IAkBAC,UAlBA,GAkBa,SAAbA,UAAa;EAAA,oCAAIC,KAAJ;EAAIA,IAAAA,KAAJ;EAAA;;EAAA,SAAcA,KAAK,CAACtD,GAAN,CAAUmD,SAAV,CAAd;EAAA,CAlBb;EAAA,IA2BAI,aA3BA,GA2BgB,SAAhBA,aAAgB,CAAAC,IAAI,EAAI;EACpB,MAAMC,GAAG,GAAGN,SAAS,CAACK,IAAD,CAArB;EACA,SAAOC,GAAG,YAAYrF,QAAf,GAA0BqF,GAAG,CAAC7E,IAA9B,GAAqC6E,GAA5C;EACH,CA9BD;EAAA,IAuCAC,cAvCA,GAuCiB,SAAjBA,cAAiB;EAAA,qCAAIJ,KAAJ;EAAIA,IAAAA,KAAJ;EAAA;;EAAA,SAAcA,KAAK,CAACtD,GAAN,CAAUuD,aAAV,CAAd;EAAA,CAvCjB;EAAA,IA+CAI,UA/CA,GA+Ca7C,UAAU,CAAC1C,QAAD,CA/CvB;EAAA,IAkEAwF,MAlEA,GAkEStF,KAAK,CAAC,UAAC8E,IAAD,EAAOxB,GAAP;EAAA,SAAeM,MAAM,CAACN,GAAD,CAAN,KAAgB2B,aAAa,CAACH,IAAD,CAA5C;EAAA,CAAD,CAlEd;EAAA,IA2EAS,UA3EA,GA2EaD,MA3Eb;EAAA,IAuGAE,QAvGA,GAuGWxF,KAAK,CAAC,UAAC8E,IAAD,EAAOlG,CAAP;EAAA,SAAa0G,MAAM,CAACR,IAAD,EAAOlG,CAAP,CAAN,IAAmB4D,UAAU,CAACsC,IAAD,EAAOlG,CAAP,CAA1C;EAAA,CAAD,CAvGhB;EAAA,IAgHA6G,SAhHA,GAgHYD,QAhHZ;EAAA,IAwHAE,OAxHA,GAwHU,SAAVA,OAAU,CAAA9G,CAAC;EAAA,SAAIA,CAAC,IAAI,uBAAuB+G,IAAvB,CAA4B,CAAC/G,CAAC,GAAG,EAAL,EAASgH,MAAT,CAAgB,CAAhB,EAAmB,EAAnB,CAA5B,CAAT;EAAA,CAxHX;EAAA,IAiIAC,UAjIA,GAiIa,SAAbA,UAAa,CAAAjH,CAAC;EAAA,SAAIyG,UAAU,CAACzG,CAAD,CAAV,IAAiB,CAAC8G,OAAO,CAAC9G,CAAD,CAA7B;EAAA,CAjId;EAAA,IAyICkH,OAzID,GAyIYhH,KAzIZ,CAyICgH,OAzID;EAAA,IAiJAC,QAjJA,GAiJWT,MAAM,CAACjB,OAAD,CAjJjB;EAAA,IAyJA2B,SAzJA,GAyJYV,MAAM,CAAChB,QAAD,CAzJlB;EAAA,IAiKA2B,QAjKA,GAiKWX,MAAM,CAAC/B,SAAD,CAjKjB;EAAA,IAyKA2C,QAzKA,GAyKWZ,MAAM,CAACnB,OAAD,CAzKjB;EAAA,IAiLAgC,KAjLA,GAiLQb,MAAM,CAACb,IAAD,CAjLd;EAAA,IAyLA2B,KAzLA,GAyLQd,MAAM,CAACZ,IAAD,CAzLd;EAAA,IAiMA2B,SAjMA,GAiMWf,MAAM,CAACX,QAAD,CAjMjB;EAAA,IAyMA2B,SAzMA,GAyMYhB,MAAM,CAACV,QAAD,CAzMlB;EAAA,IAiNA2B,WAjNA,GAiNcjB,MAAM,CAAC3B,YAAD,CAjNpB;EAAA,IAyNA6C,MAzNA,GAyNSlB,MAAM,CAAC5B,OAAD,CAzNf;EAAA,IAiOA+C,QAjOA,GAiOWnB,MAAM,CAACd,OAAD,CAjOjB;EAAA,IA2OAkC,0BA3OA,GA2O6B,SAA7BA,0BAA6B,CAAA9H,CAAC,EAAI;EAC9B,MAAM+H,OAAO,GAAG/C,MAAM,CAAChF,CAAD,CAAtB;EACA,SAAOgI,KAAK,CAAChI,CAAD,CAAL,IACH,CAACuF,OAAD,EAAUZ,SAAV,EAAmBe,QAAnB,EAA6BE,OAA7B,EACK1C,IADL,CACU,UAAAoD,IAAI;EAAA,WAAIA,IAAI,KAAKyB,OAAb;EAAA,GADd,CADJ;EAGH,CAhPD;EAAA,IAwPAE,WAxPA,GAwPc,SAAdA,WAAc,CAAAjI,CAAC;EAAA,SAAI,CAACe,MAAM,CAACf,CAAD,CAAX;EAAA,CAxPf;EAAA,IAgQAkI,aAhQA,GAgQgB,SAAhBA,aAAgB,CAAAxD,GAAG;EAAA,SAAIuD,WAAW,CAAC5D,IAAI,CAACK,GAAD,CAAL,CAAf;EAAA,CAhQnB;EAAA,IAwQAyD,iBAxQA,GAwQoB,SAApBA,iBAAoB,CAAAnI,CAAC;EAAA,SAAIA,CAAC,CAACoI,IAAF,KAAW,CAAf;EAAA,CAxQrB;EAAA,IAkRAC,OAlRA,GAkRU,SAAVA,OAAU,CAAArI,CAAC,EAAI;EACX,MAAI,CAACA,CAAL,EAAQ;EAAE;EACN,WAAO,IAAP;EACH;;EACD,MAAIqH,QAAQ,CAACrH,CAAD,CAAR,IAAeyG,UAAU,CAACzG,CAAD,CAA7B,EAAkC;EAC9B,WAAO,KAAP;EACH;;EACD,MAAIkH,OAAO,CAAClH,CAAD,CAAX,EAAgB;EAAE;EACd,WAAO,CAACA,CAAC,CAACe,MAAV;EACH;;EACD,MAAIf,CAAC,CAACoI,IAAF,KAAWjD,SAAX,IAAwB,CAACvB,UAAU,CAAC1C,QAAD,EAAWlB,CAAC,CAACoI,IAAb,CAAvC,EAA2D;EACvD,WAAO,CAACpI,CAAC,CAACoI,IAAV;EACH;;EACD,MAAIjB,QAAQ,CAACnH,CAAD,CAAZ,EAAiB;EACb,WAAO,CAACqE,IAAI,CAACrE,CAAD,CAAJ,CAAQe,MAAhB;EACH;;EACD,SAAO,KAAP;EACH,CAnSD;EAAA,IA2SAiH,KA3SA,GA2SQ,SAARA,KAAQ,CAAAhI,CAAC;EAAA,SAAIA,CAAC,KAAK,IAAN,IAAcA,CAAC,KAAKmF,SAAxB;EAAA,CA3ST;EAAA,IAsTAmD,OAtTA,GAsTU,SAAVA,OAAU,CAACtI,CAAD,EAAiB;EACvB,MAAMuI,QAAQ,GAAGvD,MAAM,CAAChF,CAAD,CAAvB;;EADuB,qCAAVoG,KAAU;EAAVA,IAAAA,KAAU;EAAA;;EAEvB,SAAOI,cAAc,CAACJ,KAAD,CAAd,CAAsBlD,IAAtB,CAA2B,UAAAxB,IAAI;EAAA,WAAI6G,QAAQ,KAAK7G,IAAjB;EAAA,GAA/B,CAAP;EACH,CAzTD;EAAA,IAkUA8G,eAlUA,GAkUkBF,OAlUlB;EAAA,IA4UAG,cA5UA,GA4UiB,SAAjBA,cAAiB,CAACzI,CAAD;EAAA,qCAAOoG,KAAP;EAAOA,IAAAA,KAAP;EAAA;;EAAA,SACbA,KAAK,CAAClD,IAAN,CAAW,UAAAgD,IAAI;EAAA,WAAIQ,MAAM,CAACR,IAAD,EAAOlG,CAAP,CAAN,IAAmB4D,UAAU,CAAC5D,CAAD,EAAIkG,IAAJ,CAAjC;EAAA,GAAf,CADa;EAAA,CA5UjB;EAAA,IAsVAwC,aAtVA,GAsVgB,SAAhBA,aAAgB,CAAC1I,CAAD;EAAA,qCAAOoG,KAAP;EAAOA,IAAAA,KAAP;EAAA;;EAAA,SAAiBA,KAAK,CAAClD,IAAN,CAAWU,UAAU,CAAC5D,CAAD,CAArB,CAAjB;EAAA,CAtVhB;EAAA,IA8VA2I,SA9VA,GA8VY,SAAZA,SAAY,CAAA3I,CAAC;EAAA,SAAIA,CAAC,IAAIA,CAAC,CAAC8C,GAAP,IAAcc,UAAU,CAAC1C,QAAD,EAAWlB,CAAC,CAAC8C,GAAb,CAA5B;EAAA,CA9Vb;;EC9BJ;;;AAIA,EAGA;;;;;;;;;AAQA,MAAa8F,MAAM,GAAGxH,KAAK,CAAC,UAAC+C,GAAD,EAAMO,GAAN;EAAA,SAAcsD,KAAK,CAACtD,GAAD,CAAL,GAAaA,GAAG,CAACP,GAAD,CAAhB,GAAwBgB,SAAtC;EAAA,CAAD,CAApB;;ECZP;;;;;;;;;;;;;;;AAcA,MAAa0D,EAAE,GAAG,SAALA,EAAK,CAAC7I,CAAD,EAAgB;EAC9B,MAAI,CAACgI,KAAK,CAAChI,CAAD,CAAV,EAAe;EAAE,WAAOmF,SAAP;EAAmB;;EACpC,MAAME,WAAW,GAAGrF,CAAC,CAACqF,WAAtB;;EAF8B,oCAAT3E,IAAS;EAATA,IAAAA,IAAS;EAAA;;EAG9B,MAAI2E,WAAW,CAACtB,cAAZ,CAA2B,IAA3B,CAAJ,EAAsC;EAClC,WAAOV,KAAK,CAACgC,WAAW,CAACwD,EAAb,EAAiBnI,IAAjB,CAAZ;EACH,GAFD,MAGK,IAAIoH,0BAA0B,CAAC9H,CAAD,CAA9B,EAAmC;EACpC,WAAOqD,KAAK,CAACgC,WAAD,EAAc3E,IAAd,CAAZ;EACH,GAFI,MAGA,IAAI+F,UAAU,CAACpB,WAAD,CAAd,EAA6B;EAC9B,sBAAWA,WAAX,EAA0B3E,IAA1B;EACH;;EACD,SAAOyE,SAAP;EACH,CAbM;;;ECZH;;;;;;;;;EASA2D,IAAI,GAAG,SAAPA,IAAO,CAAC9I,CAAD,EAAI+I,GAAJ,EAAY;EACf;EACA,MAAI,CAAC/I,CAAL,EAAQ;EAAE,WAAOA,CAAP;EAAW;;EACrB,UAAQgF,MAAM,CAAChF,CAAD,CAAd;EACI,SAAKE,KAAK,CAACwB,IAAX;EACI,aAAO,CAACqH,GAAD,GAAO/I,CAAC,CAACgJ,KAAF,CAAQ,CAAR,CAAP,GAAoB/E,MAAM,CAACK,MAAP,CAAcyE,GAAd,EAAmB/I,CAAnB,CAA3B;EAEJ;;EACA,SAAKiJ,MAAM,CAACvH,IAAZ;EACA,SAAKiE,OAAO,CAACjE,IAAb;EACA,SAAK8D,MAAM,CAAC9D,IAAZ;EACA,SAAKkD,MAAM,CAAClD,IAAZ;EACA,SAAKwH,OAAO,CAACxH,IAAb;EACA,SAAKR,QAAQ,CAACQ,IAAd;EACA,SAAK,KAAL;EACA,SAAK,MAAL;EACA,SAAK,WAAL;EACI,aAAO1B,CAAP;;EAEJ,SAAK,KAAL;EACA,SAAK,KAAL;EACA,SAAK,SAAL;EACA,SAAK,SAAL;EACI,aAAO,IAAIA,CAAC,CAACqF,WAAN,CAAkBnF,KAAK,CAACC,IAAN,CAAWH,CAAX,CAAlB,CAAP;EAEJ;;EACA;EACI,aAAOiE,MAAM,CAACK,MAAP,CAAc,CAACyE,GAAD,GAAOF,EAAE,CAAC7I,CAAD,CAAT,GAAe+I,GAA7B,EAAkC/I,CAAlC,CAAP;EAxBR;EA0BH,CAxCE;;;ECEH;;;;;;;;;;;;;;;;;;;;;EAqBAmJ,SAAS,GAAG/H,KAAK,CAAC,UAACgI,QAAD,EAAW1E,GAAX,EAAmB;EACjC,MAAI,CAACA,GAAL,EAAU;EAAE,WAAOA,GAAP;EAAa;;EACzB,MAAI0E,QAAQ,CAACC,OAAT,CAAiB,GAAjB,MAA0B,CAAC,CAA/B,EAAkC;EAC9B,WAAO3E,GAAG,CAAC0E,QAAD,CAAV;EACH;;EACD,MAAME,KAAK,GAAGF,QAAQ,CAACG,KAAT,CAAe,GAAf,CAAd;EAAA,MACIC,KAAK,GAAGF,KAAK,CAACvI,MADlB;EAEA,MAAI0I,GAAG,GAAG,CAAV;EAAA,MACIC,MAAM,GAAGhF,GADb;;EAEA,SAAO+E,GAAG,GAAGD,KAAb,EAAoBC,GAAG,IAAI,CAA3B,EAA8B;EAC1B,QAAME,IAAI,GAAGD,MAAM,CAACJ,KAAK,CAACG,GAAD,CAAN,CAAnB;;EACA,QAAI,CAACzB,KAAK,CAAC2B,IAAD,CAAV,EAAkB;EACd,aAAOA,IAAP;EACH;;EACDD,IAAAA,MAAM,GAAGC,IAAT;EACH;;EACD,SAAOD,MAAP;EACH,CAjBgB,CAvBd;;ECHP;;;;AAIA;EAMI;;;;;;;;EAQAE,uBAAuB,GAAG,SAA1BA,uBAA0B,CAAAxD,KAAK;EAAA,SAAIA,KAAK,CAACrF,MAAN,GAC/BqF,KAAK,CAACtD,GAAN,CAAU,UAAAoD,IAAI;EAAA,sBAASG,aAAa,CAACH,IAAD,CAAtB;EAAA,GAAd,EAAgD9C,IAAhD,CAAqD,IAArD,CAD+B,GAC8B,EADlC;EAAA,CAV5B;;EAaH;;;;;;;;EAQAyG,uBAAuB,GAAG,SAA1BA,uBAA0B,CAAAC,WAAW,EAAI;EAAA,MAE7BC,WAF6B,GAI7BD,WAJ6B,CAE7BC,WAF6B;EAAA,MAEhBC,SAFgB,GAI7BF,WAJ6B,CAEhBE,SAFgB;EAAA,MAEL/E,KAFK,GAI7B6E,WAJ6B,CAEL7E,KAFK;EAAA,MAEEgF,gBAFF,GAI7BH,WAJ6B,CAEEG,gBAFF;EAAA,MAG7BC,aAH6B,GAI7BJ,WAJ6B,CAG7BI,aAH6B;EAAA,MAGdC,aAHc,GAI7BL,WAJ6B,CAGdK,aAHc;EAAA,MAKjCC,gBALiC,GAKdlD,OAAO,CAAC+C,gBAAD,CALO;EAAA,MAMjCI,SANiC,GAMrBD,gBAAgB,GAAG,SAAH,GAAe,qBANV;EAAA,MAOjCE,gBAPiC,GAOdF,gBAAgB,GAAGR,uBAAuB,CAACK,gBAAD,CAA1B,GAA+CA,gBAPjD;EAQrC,SAAO,CAACF,WAAW,cAAQA,WAAR,SAAyB,GAArC,cACAC,SADA,sBACsBK,SADtB,eACoCC,gBADpC,oCAEeJ,aAFf,uBAEyCjF,KAFzC,mBAGAkF,aAAa,GAAI,OAAOA,aAAP,GAAuB,GAA3B,GAAiC,EAH9C,CAAP;EAIH,CAjCE;;EAmCH;;;;;;;;EAQAI,yBAAyB,GAAG,SAA5BA,yBAA4B,CAACC,gBAAD;EAAA,MAAmBC,WAAnB,uEAAiC7D,QAAjC;EAAA,SACxB,UAAC8D,SAAD,EAAYX,WAAZ,EAAyBC,SAAzB,EAAoC/E,KAApC,EAAoE;EAAA,QAAzBkF,aAAyB,uEAAT,IAAS;EAChE,QAAMF,gBAAgB,GAAGhE,SAAS,CAACyE,SAAD,CAAlC;EAAA,QACIR,aAAa,GAAGlF,MAAM,CAACC,KAAD,CAD1B;;EAEA,QAAIwF,WAAW,CAACC,SAAD,EAAYzF,KAAZ,CAAf,EAAmC;EAAE,aAAOA,KAAP;EAAe,KAHY;;;EAIhE,UAAM,IAAI9D,KAAJ,CAAUqJ,gBAAgB,CAC5B;EAACT,MAAAA,WAAW,EAAXA,WAAD;EAAcC,MAAAA,SAAS,EAATA,SAAd;EAAyB/E,MAAAA,KAAK,EAALA,KAAzB;EAAgCgF,MAAAA,gBAAgB,EAAhBA,gBAAhC;EAAkDC,MAAAA,aAAa,EAAbA,aAAlD;EAAiEC,MAAAA,aAAa,EAAbA;EAAjE,KAD4B,CAA1B,CAAN;EAGH,GARuB;EAAA,CA3CzB;;EAqDH;;;;;;;;EAQAQ,0BAA0B,GAAG,SAA7BA,0BAA6B,CAACH,gBAAD;EAAA,MAAmBC,WAAnB,uEAAiC7D,QAAjC;EAAA,SACzB,UAACgE,UAAD,EAAab,WAAb,EAA0BC,SAA1B,EAAqC/E,KAArC,EAAqE;EAAA,QAAzBkF,aAAyB,uEAAT,IAAS;EACjE,QAAMU,iBAAiB,GAAGD,UAAU,CAAC9H,GAAX,CAAemD,SAAf,CAA1B;EAAA,QACI6E,UAAU,GAAGF,UAAU,CAAC1H,IAAX,CAAgB,UAAAwH,SAAS;EAAA,aAAID,WAAW,CAACC,SAAD,EAAYzF,KAAZ,CAAf;EAAA,KAAzB,CADjB;EAAA,QAEIiF,aAAa,GAAGlF,MAAM,CAACC,KAAD,CAF1B;;EAGA,QAAI6F,UAAJ,EAAgB;EAAE,aAAO7F,KAAP;EAAe;;EACjC,UAAM,IAAI9D,KAAJ,CACFqJ,gBAAgB,CAAC;EACbT,MAAAA,WAAW,EAAXA,WADa;EACAC,MAAAA,SAAS,EAATA,SADA;EACW/E,MAAAA,KAAK,EAALA,KADX;EAEbgF,MAAAA,gBAAgB,EAAEY,iBAFL;EAEwBX,MAAAA,aAAa,EAAbA,aAFxB;EAGbC,MAAAA,aAAa,EAAbA;EAHa,KAAD,CADd,CAAN;EAOH,GAbwB;EAAA,CA7D1B;;EA4EH;;;;;;;;;;;;;EAaAY,eAAe,GAAGR,yBAAyB,CAACV,uBAAD,CAzFxC;;EA2FH;;;;;;;;;;;;;EAaAmB,gBAAgB,GAAGL,0BAA0B,CAACd,uBAAD,CAxG1C;;EA0GH;;;;;;;;EAQAoB,wBAAwB,GAAG,SAA3BA,wBAA2B,CAAAT,gBAAgB;EAAA,SAAIpJ,KAAK,CAACmJ,yBAAyB,CAACC,gBAAD,CAA1B,CAAT;EAAA,CAlHxC;;EAoHH;;;;;;;;EAQAU,yBAAyB,GAAG,SAA5BA,yBAA4B,CAAAV,gBAAgB;EAAA,SAAIpJ,KAAK,CAACuJ,0BAA0B,CAACH,gBAAD,CAA3B,CAAT;EAAA,CA5HzC;;EA8HH;;;;;;;;;;;;EAYAW,cAAc,GAAG/J,KAAK,CAAC2J,eAAD,CA1InB;;EA4IH;;;;;;;;;;;EAWAK,eAAe,GAAGhK,KAAK,CAAC4J,gBAAD,CAvJpB;EA0JP;;;;EAIA;;;;;EAKA;;;;;;;;;;;EAWA;;;;EAIA;;;;;;;;EAQA;;;;;;;EAOA;;;;;;;;;;;EAWA;;;;;;;;;;;EC3MA;;;;;;;EAMA,SAASK,uBAAT,OAAgD;EAAA,MAAbC,UAAa,QAAbA,UAAa;EAC5C,MAAMlH,SAAS,GAAGkH,UAAU,GAAGC,cAAH,GAAoBC,UAAhD;EACA,SAAO,UAACC,SAAD,EAAYC,MAAZ,EAAuB;EAC1BD,IAAAA,SAAS,CAACxI,OAAV,CAAkB,UAAA0I,QAAQ,EAAI;EAAA,qCACgBA,QADhB;EAAA,UACnBC,OADmB;EAAA,UACVC,QADU;EAAA,UACAC,YADA;;EAE1BzI,MAAAA,KAAK,CAACe,SAAD,EAAY,CAACwH,OAAD,EAAUF,MAAV,EAAkBG,QAAlB,EAA4BC,YAA5B,CAAZ,CAAL;EACH,KAHD;EAIA,WAAOJ,MAAP;EACH,GAND;EAOH;;AAED;EAEI;;;;;;;;;EASAK,qBAAqB,GAAG,SAAxBA,qBAAwB,CAACzF,IAAD,EAAOoF,MAAP,EAAeG,QAAf,EAA4B;EAChD,MAAIG,MAAJ;;EACA,SAAO;EACHC,IAAAA,GAAG,EAAE,eAAY;EACb,aAAOD,MAAP;EACH,KAHE;EAIHE,IAAAA,GAAG,EAAE,aAAUjH,KAAV,EAAiB;EAClB+G,MAAAA,MAAM,GAAGb,cAAc,CAAC7E,IAAD,EAAOuF,QAAP,EAAiBH,MAAjB,EAAyBzG,KAAzB,CAAvB;EACH;EANE,GAAP;EAQH,CArBE;;EAuBH;;;;;;;EAOAkH,sBAAsB,GAAG,SAAzBA,sBAAyB,QAA0B;EAAA;EAAA,MAAxBT,MAAwB;EAAA,MAAhBU,UAAgB;;EAC/CA,EAAAA,UAAU,CAACd,UAAX,GAAwB,IAAxB;EACA,SAAO,CAACI,MAAD,EAASU,UAAT,CAAP;EACH,CAjCE;;EAmCH;;;;;;EAMAC,uBAAuB,GAAG,SAA1BA,uBAA0B,CAAAC,6BAA6B;EAAA,SACnD5F,MAAM,CAAC,OAAD,EAAU4F,6BAAV,CAAN;EACIA,EAAAA,6BADJ,GACoC,CAACA,6BAAD,CAFe;EAAA,CAzCpD;;EA6CH;;;;;;;;;EASAd,UAAU,GAAG,SAAbA,UAAa,CAAClF,IAAD,EAAOoF,MAAP,EAAeG,QAAf,EAAsD;EAAA,MAA7BC,YAA6B,uEAAd3G,SAAc;;EAAA,8BAChCkH,uBAAuB,CAACX,MAAD,CADS;EAAA;EAAA,MACxDa,OADwD;EAAA,MAC/CC,WAD+C;EAAA,MAE3DJ,UAF2D,GAE9CI,WAAW,IAAIT,qBAAqB,CAACzF,IAAD,EAAOiG,OAAP,EAAgBV,QAAhB,CAFU;;EAG/D5H,EAAAA,MAAM,CAACwI,cAAP,CAAsBF,OAAtB,EAA+BV,QAA/B,EAAyCO,UAAzC;;EACA,MAAI,CAACzE,WAAW,CAACmE,YAAD,CAAhB,EAAgC;EAC5BS,IAAAA,OAAO,CAACV,QAAD,CAAP,GAAoBC,YAApB;EACH;;EACD,SAAO,CAACS,OAAD,EAAUH,UAAV,CAAP;EACH,CA9DE;;EAgEH;;;;;;;;;EASAb,cAAc,GAAG,SAAjBA,cAAiB,CAACjF,IAAD,EAAOoF,MAAP,EAAeG,QAAf,EAAsD;EAAA,MAA7BC,YAA6B,uEAAd3G,SAAc;;EAAA,+BACpCkH,uBAAuB,CAACX,MAAD,CADa;EAAA;EAAA,MAC5Da,OAD4D;EAAA,MACnDC,WADmD;EAAA,MAE/DJ,UAF+D,GAElDI,WAAW,IAAIT,qBAAqB,CAACzF,IAAD,EAAOiG,OAAP,EAAgBV,QAAhB,CAFc;;EAGnE,SAAOL,UAAU,CACblF,IADa,EAEb6F,sBAAsB,CAAC,CAACI,OAAD,EAAUH,UAAV,CAAD,CAFT,EAGbP,QAHa,EAIbC,YAJa,CAAjB;EAMH,CAlFE;;EAoFH;;;;;;;EAOAY,eAAe,GAAGtL,KAAK,CAACiK,uBAAuB,CAAC;EAACC,EAAAA,UAAU,EAAE;EAAb,CAAD,CAAxB,CA3FpB;;EA6FH;;;;;;;;EAQAqB,WAAW,GAAGvL,KAAK,CAACiK,uBAAuB,CAAC;EAACC,EAAAA,UAAU,EAAE;EAAb,CAAD,CAAxB,CArGhB;EAyGP;;EACA;;EACA;;EAEA;;;;EAIA;;;;EAIA;;;;EAIA;;;;;;;;;EASA;;;;;;;;;ECtJI;;;;;;;EAOAsB,UAAU,GAAGvL,MAAM,CAAC,UAACkD,IAAD;EAAA,oCAAUC,IAAV;EAAUA,IAAAA,IAAV;EAAA;;EAAA,SAChB,CAACD,IAAD,GAAQA,IAAR,GAAeC,IAAI,CAACxB,MAAL,CAAY,UAACyB,MAAD,EAASC,GAAT;EAAA,WACvB,CAACA,GAAD,GAAOD,MAAP,GAAgBJ,IAAI,CAACK,GAAD,CAAJ,CAAU1B,MAAV,CAAiB,UAACL,GAAD,EAAMwB,GAAN,EAAc;EAC3C,UAAI0I,eAAe,GAAG5I,MAAM,CAAC6I,wBAAP,CAAgCnK,GAAhC,EAAqCwB,GAArC,CAAtB,CAD2C;;EAG3C,UAAIxB,GAAG,CAACoB,cAAJ,CAAmBI,GAAnB,KAA2B0I,eAA3B,IACA,EAAEA,eAAe,CAACZ,GAAhB,IAAuBY,eAAe,CAACX,GAAzC,CADA,IAEA,CAACW,eAAe,CAACE,QAFrB,EAE+B;EAC3B,eAAOpK,GAAP;EACH;;EACD,UAAIwE,QAAQ,CAACxE,GAAG,CAACwB,GAAD,CAAJ,CAAR,IAAsBgD,QAAQ,CAACzC,GAAG,CAACP,GAAD,CAAJ,CAAlC,EAA8C;EAC1CyI,QAAAA,UAAU,CAACjK,GAAG,CAACwB,GAAD,CAAJ,EAAWO,GAAG,CAACP,GAAD,CAAd,CAAV;EACH,OAFD,MAGK;EAAExB,QAAAA,GAAG,CAACwB,GAAD,CAAH,GAAWO,GAAG,CAACP,GAAD,CAAd;EAAsB;;EAC7B,aAAOxB,GAAP;EACH,KAbe,EAab8B,MAba,CADO;EAAA,GAAZ,EAebF,IAfa,CADC;EAAA,CAAD,CARhB;;ECLP;;;;AAKA;EAII;;;;;;;;;EASA1D,MAAM,GAAGyB,mBAAmB,CAAC,QAAD,CAXzB;;EAaH;;;;;;;EAOA0G,KAAK,GAAGnH,WAAW,CAAC,OAAD,CApBhB;;EAsBH;;;;;;;EAOAmL,QAAQ,GAAI;EAAA,SAAM,cAAc9M,KAAK,CAACsC,SAApB,GACVf,aAAa,CAAC,UAAD,CADH,GAEV,UAACwD,KAAD,EAAQgI,EAAR;EAAA,WAAeA,EAAE,CAAC5D,OAAH,CAAWpE,KAAX,IAAoB,CAAC,CAApC;EAAA,GAFI;EAAA,CAAD,EA7BR;;EAiCH;;;;;;;EAOAoE,OAAO,GAAG5H,aAAa,CAAC,SAAD,CAxCpB;;EA0CH;;;;;;;EAOAyL,WAAW,GAAGzL,aAAa,CAAC,aAAD,CAjDxB;;ECPP;;;;AAIA;EAII;;;;;;EAMA0L,QAAQ,GAAG,SAAXA,QAAW,CAAAlI,KAAK;EAAA,SAAI,CAAC,CAACA,KAAN;EAAA,CARb;;EAUH;;;;;;EAMAmI,OAAO,GAAG,SAAVA,OAAU,CAAAnI,KAAK;EAAA,SAAI,CAACA,KAAL;EAAA,CAhBZ;;EAkBH;;;;;EAKAoI,UAAU,GAAG,SAAbA,UAAa;EAAA,SAAM,IAAN;EAAA,CAvBV;;EAyBH;;;;;EAKAC,WAAW,GAAG,SAAdA,WAAc;EAAA,SAAM,KAAN;EAAA,CA9BX;;EAgCH;;;;;;;EAOAC,KAAK,GAAGnM,KAAK,CAAC,UAACf,CAAD,EAAIC,CAAJ;EAAA,SAAUD,CAAC,KAAKC,CAAhB;EAAA,CAAD,CAvCV;;EAyCH;;;;;;;EAOAkN,QAAQ,GAAGnM,MAAM,CAAC,UAAChB,CAAD;EAAA,oCAAOK,IAAP;EAAOA,IAAAA,IAAP;EAAA;;EAAA,SAAgBA,IAAI,CAACyC,KAAL,CAAW,UAAA7C,CAAC;EAAA,WAAIiN,KAAK,CAAClN,CAAD,EAAIC,CAAJ,CAAT;EAAA,GAAZ,CAAhB;EAAA,CAAD,CAhDd;;ECAP;;;;;;;;EAOA,IAAMwC,KAAG,GAAG1B,KAAK,CAAC,UAACvB,EAAD,EAAKoN,EAAL,EAAa;EAC3B,MAAI,CAACjF,KAAK,CAACiF,EAAD,CAAV,EAAgB;EAAE,WAAOA,EAAP;EAAY;;EAC9B,MAAIlE,GAAG,GAAGF,EAAE,CAACoE,EAAD,CAAZ;EAAA,MACIzD,KADJ;EAAA,MAEIiE,CAAC,GAAG,CAFR;;EAGA,UAAQzI,MAAM,CAACiI,EAAD,CAAd;EACI,SAAK,OAAL;EACIzD,MAAAA,KAAK,GAAGzI,MAAM,CAACkM,EAAD,CAAd;;EACA,UAAI,CAACzD,KAAL,EAAY;EAAE,eAAOT,GAAP;EAAa;;EAC3B,aAAO0E,CAAC,GAAGjE,KAAX,EAAkBiE,CAAC,IAAI,CAAvB,EAA0B;EACtB1E,QAAAA,GAAG,CAAClG,IAAJ,CAAShD,EAAE,CAACoN,EAAE,CAACQ,CAAD,CAAH,EAAQA,CAAR,EAAWR,EAAX,CAAX;EACH;;EACD,aAAOlE,GAAP;;EACJ,SAAK,QAAL;EACIS,MAAAA,KAAK,GAAGzI,MAAM,CAACkM,EAAD,CAAd;;EACA,UAAI,CAACA,EAAL,EAAS;EAAE,eAAOlE,GAAP;EAAa;;EACxB,aAAO0E,CAAC,GAAGjE,KAAX,EAAkBiE,CAAC,IAAI,CAAvB,EAA0B;EACtB1E,QAAAA,GAAG,IAAIlJ,EAAE,CAACoN,EAAE,CAACQ,CAAD,CAAH,EAAQA,CAAR,EAAWR,EAAX,CAAT;EACH;;EACD,aAAOlE,GAAP;;EACJ;EACI,UAAIJ,SAAS,CAACsE,EAAD,CAAb,EAAmB;EAAE,eAAOA,EAAE,CAACnK,GAAH,CAAOjD,EAAP,CAAP;EAAoB,OAD7C;;;EAII,aAAOoE,MAAM,CAACI,IAAP,CAAY4I,EAAZ,EAAgBjK,MAAhB,CAAuB,UAACL,GAAD,EAAMwB,GAAN,EAAc;EACxC4E,QAAAA,GAAG,CAAC5E,GAAD,CAAH,GAAWtE,EAAE,CAACoN,EAAE,CAAC9I,GAAD,CAAH,EAAUA,GAAV,EAAe8I,EAAf,CAAb;EACA,eAAOlE,GAAP;EACH,OAHM,EAGJA,GAHI,CAAP;EAnBR;EAwBH,CA7BgB,CAAjB;;;ECVI;;;;;;;EAOA2E,cAAc,GAAG,SAAjBA,cAAiB,CAAC/K,GAAD,EAAMC,IAAN,EAAe;EAC5BD,EAAAA,GAAG,CAACE,IAAJ,CAASD,IAAT;EACA,SAAOD,GAAP;EACH,CAZE;;ECDP;;;;AAIA;EAWI;;;;;;;EAOAgL,SAAS,GAAGvM,KAAK,CAAC,UAACwM,QAAD,EAAWX,EAAX;EAAA,SAAkBjE,KAAK,CAAC4E,QAAD,EAAWzI,SAAX,EAAsB8H,EAAtB,CAAvB;EAAA,CAAD,CATd;;EAWH;;;;;;;EAOAY,OAAO,GAAGzM,KAAK,CAAC,UAAC0M,KAAD,EAAQb,EAAR;EAAA,SAAejE,KAAK,CAAC,CAAD,EAAI8E,KAAJ,EAAWb,EAAX,CAApB;EAAA,CAAD,CAlBZ;;EAoBH;;;;;;EAMAc,SAAS,GAAGJ,SAAS,CAAC,CAAD,CA1BlB;;EA4BH;;;;;;;EAOAK,kBAAkB,GAAG5M,KAAK,CAAC,UAACf,CAAD,EAAIC,CAAJ,EAAU;EACjC,MAAID,CAAC,GAAGC,CAAR,EAAW;EAAE,WAAO,CAAP;EAAW,GAAxB,MACK,IAAID,CAAC,GAAGC,CAAR,EAAW;EAAE,WAAO,CAAC,CAAR;EAAY;;EAC9B,SAAO,CAAP;EACH,CAJyB,CAnCvB;;EAyCH;;;;;;EAMA2N,OAAO,GAAG5M,MAAM,CAAC;EAAA,oCAAI6M,KAAJ;EAAIA,IAAAA,KAAJ;EAAA;;EAAA,SAAcpL,KAAG,CAAC/B,MAAD,EAASmN,KAAT,CAAjB;EAAA,CAAD,CA/Cb;;EAiDH;;;;;;;EAOAC,UAAU,GAAG9M,MAAM,CAAC,YAAc;EAAA,qCAAV6M,KAAU;EAAVA,IAAAA,KAAU;EAAA;;EAC9B,MAAME,WAAW,GAAG/K,KAAK,CAAC4K,OAAD,EAAUC,KAAV,CAAzB;EAAA,MACIG,QAAQ,GAAGC,IAAI,CAACC,GAAL,CAASlL,KAAT,CAAeiL,IAAf,EAAqBF,WAArB,CADf;EAEA,SAAOtL,KAAG,CAAC,UAAC0L,IAAD,EAAO/E,GAAP;EAAA,WAAe2E,WAAW,CAAC3E,GAAD,CAAX,GAAmB4E,QAAnB,GACtBR,OAAO,CAACQ,QAAD,EAAWG,IAAX,CADe,GACIT,SAAS,CAACS,IAAD,CAD5B;EAAA,GAAD,EACqCN,KADrC,CAAV;EAEH,CALkB,CAxDhB;;EA+DH;;;;;;;;;EASAO,WAAW,GAAGrN,KAAK,CAAC,UAACsN,IAAD,EAAOC,EAAP,EAAWhM,GAAX,EAAgBsK,EAAhB,EAAuB;EACvC,MAAMzD,KAAK,GAAGzI,MAAM,CAACkM,EAAD,CAApB;;EACA,MAAI,CAACzD,KAAL,EAAY;EAAE,WAAO7G,GAAP;EAAa;;EAC3B,MAAI8G,GAAG,GAAG,CAAV;EAAA,MACImF,MAAM,GAAGjM,GADb;;EAEA,SAAO8G,GAAG,GAAGD,KAAb,EAAoBC,GAAG,EAAvB,EAA2B;EACvB,QAAIiF,IAAI,CAACzB,EAAE,CAACxD,GAAD,CAAH,EAAUA,GAAV,EAAewD,EAAf,CAAR,EAA4B;EAAE;EAAQ;;EACtC2B,IAAAA,MAAM,GAAGD,EAAE,CAACC,MAAD,EAAS3B,EAAE,CAACxD,GAAD,CAAX,EAAkBA,GAAlB,EAAuBwD,EAAvB,CAAX;EACH;;EACD,SAAO2B,MAAP;EACH,CAVkB,CAxEhB;;EAoFH;;;;;;;;;EASAC,gBAAgB,GAAGzN,KAAK,CAAC,UAACsN,IAAD,EAAOC,EAAP,EAAWhM,GAAX,EAAgBmM,GAAhB,EAAwB;EAC7C,MAAMtF,KAAK,GAAGzI,MAAM,CAAC+N,GAAD,CAApB;;EACA,MAAI,CAACtF,KAAL,EAAY;EAAE,WAAO7G,GAAP;EAAa;;EAC3B,MAAI8G,GAAG,GAAGD,KAAK,GAAG,CAAlB;EAAA,MACIoF,MAAM,GAAGjM,GADb;;EAEA,SAAO8G,GAAG,IAAI,CAAd,EAAiBA,GAAG,EAApB,EAAwB;EACpB,QAAIiF,IAAI,CAACI,GAAG,CAACrF,GAAD,CAAJ,EAAWA,GAAX,EAAgBqF,GAAhB,CAAR,EAA8B;EAAE;EAAQ;;EACxCF,IAAAA,MAAM,GAAGD,EAAE,CAACC,MAAD,EAASE,GAAG,CAACrF,GAAD,CAAZ,EAAmBA,GAAnB,EAAwBqF,GAAxB,CAAX;EACH;;EACD,SAAOF,MAAP;EACH,CAVuB,CA7FrB;;EAyGH;;;;;;;;AAQA5L,UAAM,GAAGyL,WAAW,CAACnB,WAAD,CAjHjB;;EAmHH;;;;;;;;AAQA5K,eAAW,GAAGmM,gBAAgB,CAACvB,WAAD,CA3H3B;;EA6HH;;;;;;EAMAyB,SAAS,GAAG,SAAZA,SAAY,CAAA/O,CAAC,EAAI;EAAE,MAAMgP,GAAG,GAAGjO,MAAM,CAACf,CAAD,CAAlB;EAAuB,SAAOgP,GAAG,GAAGA,GAAG,GAAG,CAAT,GAAa,CAAvB;EAA2B,CAnIlE;;EAqIH;;;;;;;EAOAC,cAAc,GAAG7N,KAAK,CAAC,UAACsN,IAAD,EAAOI,GAAP,EAAe;EAClC,MAAIrF,GAAG,GAAG,CAAV;EACA,MAAMD,KAAK,GAAGzI,MAAM,CAAC+N,GAAD,CAApB;;EACA,SAAOrF,GAAG,GAAGD,KAAb,EAAoBC,GAAG,IAAI,CAA3B,EAA8B;EAC1B,QAAMyF,kBAAkB,GAAG,CAAC,CAACR,IAAI,CAACI,GAAG,CAACrF,GAAD,CAAJ,EAAWA,GAAX,EAAgBqF,GAAhB,CAAjC;;EACA,QAAII,kBAAJ,EAAwB;EACpB,aAAOzF,GAAP;EACH;EACJ;;EACD,SAAO,CAAC,CAAR;EACH,CAVqB,CA5InB;;EAwJH;;;;;;;EAOA0F,mBAAmB,GAAG/N,KAAK,CAAC,UAACsN,IAAD,EAAOI,GAAP,EAAe;EACvC,MAAIrF,GAAG,GAAG1I,MAAM,CAAC+N,GAAD,CAAN,GAAc,CAAxB;;EACA,SAAOrF,GAAG,IAAI,CAAd,EAAiBA,GAAG,IAAI,CAAxB,EAA2B;EACvB,QAAMyF,kBAAkB,GAAG,CAAC,CAACR,IAAI,CAACI,GAAG,CAACrF,GAAD,CAAJ,EAAWA,GAAX,EAAgBqF,GAAhB,CAAjC;;EACA,QAAII,kBAAJ,EAAwB;EACpB,aAAOzF,GAAP;EACH;EACJ;;EACD,SAAO,CAAC,CAAR;EACH,CAT0B,CA/JxB;;EA0KH;;;;;;EAMA2F,gBAAgB,GAAGhO,KAAK,CAAC,UAACsN,IAAD,EAAOzB,EAAP,EAAc;EACnC,MAAMzD,KAAK,GAAGzI,MAAM,CAACkM,EAAD,CAApB;EACA,MAAIxD,GAAG,GAAG,CAAV;EAAA,MACIV,GAAG,GAAG,EADV;;EAEA,SAAOU,GAAG,GAAGD,KAAb,EAAoBC,GAAG,EAAvB,EAA2B;EACvB,QAAIiF,IAAI,CAACzB,EAAE,CAACxD,GAAD,CAAH,EAAUA,GAAV,EAAewD,EAAf,CAAR,EAA4B;EAAElE,MAAAA,GAAG,CAAClG,IAAJ,CAAS4G,GAAT;EAAgB;EACjD;;EACD,SAAOV,GAAG,CAAChI,MAAJ,GAAagI,GAAb,GAAmB5D,SAA1B;EACH,CARuB,CAhLrB;;EA0LH;;;;;;EAMAkK,SAAS,GAAGjO,KAAK,CAAC,UAACsN,IAAD,EAAOzB,EAAP,EAAc;EAC5B,MAAIxD,GAAG,GAAG,CAAV;EAAA,MACID,KAAK,GAAGzI,MAAM,CAACkM,EAAD,CADlB;;EAEA,MAAI,CAACzD,KAAL,EAAY;EAAE;EAAS;;EACvB,SAAOC,GAAG,GAAGD,KAAb,EAAoBC,GAAG,EAAvB,EAA2B;EACvB,QAAI6F,GAAG,GAAGrC,EAAE,CAACxD,GAAD,CAAZ;;EACA,QAAIiF,IAAI,CAACY,GAAD,EAAM7F,GAAN,EAAWwD,EAAX,CAAR,EAAwB;EAAE,aAAOqC,GAAP;EAAa;EAC1C;;EACD,SAAOnK,SAAP;EACH,CATgB,CAhMd;;MCNHoK,QAAQ,GAAGnO,KAAK,CAAC,UAACoO,IAAD,EAAOC,IAAP;EAAA,SAAgB7C,UAAU,CAAC4C,IAAD,EAAOC,IAAP,CAA1B;EAAA,CAAD,CAFb;EAAA,IAIHC,YAAY,GAAGtO,KAAK,CAAC,UAACoO,IAAD,EAAOC,IAAP;EAAA,SAAgBzM,QAAM,CAAC,UAACL,GAAD,EAAMwB,GAAN,EAAc;EACtD,QAAIsL,IAAI,CAAC1L,cAAL,CAAoBI,GAApB,CAAJ,EAA8B;EAC1BxB,MAAAA,GAAG,CAACwB,GAAD,CAAH,GAAWsL,IAAI,CAACtL,GAAD,CAAf;EACH;;EACD,WAAOxB,GAAP;EACH,GAL0C,EAKxC,EALwC,EAKpC0B,IAAI,CAACmL,IAAD,CALgC,CAAtB;EAAA,CAAD,CAJjB;EAAA,IAWHG,aAAa,GAAGvO,KAAK,CAAC,UAACoO,IAAD,EAAOC,IAAP;EAAA,SAAgBzM,QAAM,CAAC,UAACL,GAAD,EAAMwB,GAAN,EAAc;EACvD,QAAI,CAACsL,IAAI,CAAC1L,cAAL,CAAoBI,GAApB,CAAL,EAA+B;EAC3BxB,MAAAA,GAAG,CAACwB,GAAD,CAAH,GAAWqL,IAAI,CAACrL,GAAD,CAAf;EACH;;EACD,WAAOxB,GAAP;EACH,GAL2C,EAKzC,EALyC,EAKrC0B,IAAI,CAACmL,IAAD,CALiC,CAAtB;EAAA,CAAD,CAXlB;EAAA,IAkBHI,aAAa,GAAGvO,MAAM,CAAC,UAACkD,IAAD;EAAA,oCAAUC,IAAV;EAAUA,IAAAA,IAAV;EAAA;;EAAA,SAAmBxB,QAAM,CAAC,UAACL,GAAD,EAAM+B,GAAN;EAAA,WAC7CkI,UAAU,CAACjK,GAAD,EAAMgN,aAAa,CAACjL,GAAD,EAAMH,IAAN,CAAnB,CADmC;EAAA,GAAD,EACD,EADC,EACGC,IADH,CAAzB;EAAA,CAAD,CAlBnB;;ECLP;;;;AAIA;EAEI;;;;;;EAMAqL,GAAG,GAAGC,OAAO,CAACD,GAAR,CAAYE,IAAZ,CAAiBD,OAAjB,CARH;;EAUH;;;;;;EAMAE,KAAK,GAAGF,OAAO,CAACE,KAAR,CAAcD,IAAd,CAAmBD,OAAnB,CAhBL;;EAkBH;;;;;;EAMAG,IAAI,GAAG,SAAPA,IAAO;EAAA,oCAAIvP,IAAJ;EAAIA,IAAAA,IAAJ;EAAA;;EAAA,SAAcmP,GAAG,MAAH,SAAOnP,IAAP,GAAcA,IAAI,CAACwP,GAAL,EAA5B;EAAA,CAxBJ;;EA0BH;;;;;;EAMAC,IAAI,GAAGL,OAAO,CAACK,IAAR,CAAaJ,IAAb,CAAkBD,OAAlB,CAhCJ;;;ECFH;;;;;;EAMAM,SAAS,GAAG,SAAZA,SAAY,CAAApQ,CAAC;EAAA,SAAIqQ,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAevQ,CAAf,CAAX,CAAJ;EAAA,CARV;;;ECKH;;;;;;;EAOAwQ,WAAW,GAAG,SAAdA,WAAc,CAAA9L,GAAG;EAAA,SAAIL,IAAI,CAACK,GAAD,CAAJ,CAAU5B,GAAV,CAAc,UAAAqB,GAAG;EAAA,WAAI,CAACA,GAAD,EAAMO,GAAG,CAACP,GAAD,CAAT,CAAJ;EAAA,GAAjB,CAAJ;EAAA,CATd;;EAWH;;;;;;;;EAQAsM,eAAe,GAAG,SAAlBA,eAAkB,CAAC/L,GAAD;EAAA,MAAMgM,cAAN,uEAAuBzM,MAAvB;EAAA,SAAkCI,IAAI,CAACK,GAAD,CAAJ,CAAU5B,GAAV,CAAc,UAAAqB,GAAG;EAAA,WACjEuM,cAAc,IAAIhK,MAAM,CAACgK,cAAD,EAAiBhM,GAAG,CAACP,GAAD,CAApB,CAAxB,GACI,CAACA,GAAD,EAAMsM,eAAe,CAAC/L,GAAG,CAACP,GAAD,CAAJ,EAAWuM,cAAX,CAArB,CADJ,GAEI,CAACvM,GAAD,EAAMO,GAAG,CAACP,GAAD,CAAT,CAH6D;EAAA,GAAjB,CAAlC;EAAA,CAnBf;;EAyBH;;;;;;;EAOAwM,aAAa,GAAG,SAAhBA,aAAgB,CAAC1D,EAAD;EAAA,MAAK2D,OAAL,uEAAe3M,MAAf;EAAA,SAA0BgJ,EAAE,CAACjK,MAAH,CAAU,UAACL,GAAD,QAAuB;EAAA;EAAA,QAAhBwB,GAAgB;EAAA,QAAXc,KAAW;;EACvEtC,IAAAA,GAAG,CAACwB,GAAD,CAAH,GAAWc,KAAX;EACA,WAAOtC,GAAP;EACH,GAHyC,EAGvC,IAAIiO,OAAJ,EAHuC,CAA1B;EAAA,CAhCb;;EAqCH;;;;;;;;EAQAC,iBAAiB,GAAG,SAApBA,iBAAoB,CAAC5D,EAAD;EAAA,MAAK2D,OAAL,uEAAe3M,MAAf;EAAA,SAA0BgJ,EAAE,CAACjK,MAAH,CAAU,UAACL,GAAD,SAAuB;EAAA;EAAA,QAAhBwB,GAAgB;EAAA,QAAXc,KAAW;;EAC3E,QAAIiC,OAAO,CAACjC,KAAD,CAAP,IAAkBiC,OAAO,CAACjC,KAAK,CAAC,CAAD,CAAN,CAAzB,IAAuCA,KAAK,CAAC,CAAD,CAAL,CAASlE,MAAT,KAAoB,CAA/D,EAAkE;EAC9D4B,MAAAA,GAAG,CAACwB,GAAD,CAAH,GAAW0M,iBAAiB,CAAC5L,KAAD,EAAQ2L,OAAR,CAA5B;EACA,aAAOjO,GAAP;EACH;;EACDA,IAAAA,GAAG,CAACwB,GAAD,CAAH,GAAWc,KAAX;EACA,WAAOtC,GAAP;EACH,GAP6C,EAO3C,IAAIiO,OAAJ,EAP2C,CAA1B;EAAA,CA7CjB;;;ECEH;;;;;;;;;EASAE,OAAO,GAAG,SAAVA,OAAU,CAAA9Q,CAAC,EAAI;EACX,UAAQgF,MAAM,CAAChF,CAAD,CAAd;EACI,SAAK,MAAL;EACA,SAAK,WAAL;EACI,aAAO,EAAP;;EACJ,SAAKwF,MAAM,CAAC9D,IAAZ;EACA,SAAKxB,KAAK,CAACwB,IAAX;EACA,SAAK,SAAL;EACA,SAAK,SAAL;EACA,SAAK,KAAL;EACA,SAAK,KAAL;EACI,aAAOxB,KAAK,CAACC,IAAN,CAAWH,CAAX,CAAP;;EACJ,SAAKiE,MAAM,CAACvC,IAAZ;EACA;EACI,aAAO8O,WAAW,CAACxQ,CAAD,CAAlB;EAbR;EAeH,CA3BE;;ECDP;;;;;;;;;AAQA,MAAa+Q,OAAO,GAAG,SAAVA,OAAU;EAAA,oCAAIrQ,IAAJ;EAAIA,IAAAA,IAAJ;EAAA;;EAAA,SACf,UAAAsQ,IAAI;EAAA,WAAItO,WAAW,CAAC,UAACuC,KAAD,EAAQpF,EAAR;EAAA,aAAeA,EAAE,CAACoF,KAAD,CAAjB;EAAA,KAAD,EAA2B+L,IAA3B,EAAiCtQ,IAAjC,CAAf;EAAA,GADW;EAAA,CAAhB;;ECVP;;;;EAIA;;;;;;;AAOA,MAAauQ,EAAE,GAAG,SAALA,EAAK,CAAAjR,CAAC;EAAA,SAAIA,CAAJ;EAAA,CAAZ;;ECXP;;;AAIA;EAKI;;;;;;EAMAkR,OAAO,GAAG,SAAVA,OAAU,CAAArR,EAAE;EAAA,SAAI,UAAAG,CAAC;EAAA,WAAI,CAACH,EAAE,CAACG,CAAD,CAAP;EAAA,GAAL;EAAA,CART;;EAUH;;;;;;;EAOAmR,QAAQ,GAAG,SAAXA,QAAW,CAAAtR,EAAE;EAAA,SAAIuB,KAAK,CAAC,UAACf,CAAD,EAAIC,CAAJ;EAAA,WAAU,CAACT,EAAE,CAACQ,CAAD,EAAIC,CAAJ,CAAb;EAAA,GAAD,CAAT;EAAA,CAjBV;;EAmBH;;;;;;;EAOA8Q,QAAQ,GAAG,SAAXA,QAAW,CAAAvR,EAAE;EAAA,SAAIuB,KAAK,CAAC,UAACf,CAAD,EAAIC,CAAJ,EAAOC,CAAP;EAAA,WAAa,CAACV,EAAE,CAACQ,CAAD,EAAIC,CAAJ,EAAOC,CAAP,CAAhB;EAAA,GAAD,CAAT;EAAA,CA1BV;;EA4BH;;;;;;;;;EASA8Q,QAAQ,GAAG,SAAXA,QAAW,CAAAxR,EAAE;EAAA,SAAIwB,MAAM,CAAC;EAAA,sCAAIX,IAAJ;EAAIA,MAAAA,IAAJ;EAAA;;EAAA,WAAa,CAAC2C,KAAK,CAACxD,EAAD,EAAKa,IAAL,CAAnB;EAAA,GAAD,CAAV;EAAA,CArCV;;;ECHH;;;;;;;;;EASA4Q,KAAK,GAAGlQ,KAAK,CAAC,UAACmQ,SAAD,EAAYnN,SAAZ,EAAuBoN,YAAvB,EAAwC;EAClD,MAAI5C,MAAM,GAAG4C,YAAb;;EACA,SAAO,CAACD,SAAS,CAAC3C,MAAD,CAAjB,EAA2B;EACvBA,IAAAA,MAAM,GAAGxK,SAAS,CAACwK,MAAD,CAAlB;EACH;;EACD,SAAOA,MAAP;EACH,CANY,CAXV;;;ECEH;;;;;;;;EAQA6C,SAAS,GAAG,SAAZA,SAAY,CAACC,UAAD,EAAa9P,CAAb,EAAmB;EAC3B,MAAI,CAACA,CAAD,IAAM,EAAEA,CAAC,YAAYV,QAAf,CAAV,EAAoC;EAChC,UAAM,IAAIC,KAAJ,CAAU,UAAGuQ,UAAH,wDACM1M,MAAM,CAACpD,CAAD,CADZ,gCACqCA,CADrC,MAAV,CAAN;EAEH;;EACD,SAAOA,CAAP;EACH,CAhBE;;ECFP;;;;;;AAMA,MAAa+P,IAAI,GAAG,SAAPA,IAAO;EAAA,SAAMxM,SAAN;EAAA,CAAb;;ECNP;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,MAAayM,UAAU,GAAG,SAAbA,UAAa,CAAC/R,EAAD,EAAKgS,MAAL,EAAgB;EACtC,SAAO,YAAa;EAAA,sCAATnR,IAAS;EAATA,MAAAA,IAAS;EAAA;;EAChB,QAAIkO,MAAM,GAAG/O,EAAE,CAACwD,KAAH,CAAS,IAAT,EAAe3C,IAAf,CAAb;;EACA,WAAO,OAAOkO,MAAP,KAAkB,UAAlB,KACF,CAACiD,MAAD,IAAYjD,MAAM,CAAClN,IAAP,KAAgBmQ,MAD1B,CAAP,EAC2C;EACvCjD,MAAAA,MAAM,GAAGA,MAAM,EAAf;EACH;;EACD,WAAOA,MAAP;EACH,GAPD;EAQH,CATM;;;ECxBH;;;;;;;EAOAkD,UAAU,GAAG,SAAbA,UAAa,CAAA9R,CAAC;EAAA,SAAIyG,UAAU,CAACzG,CAAD,CAAV,GAAgBA,CAAhB,GAAoB;EAAA,WAAMA,CAAN;EAAA,GAAxB;EAAA,CATX;;ECFP;;;AAGA,EAEA;;;;;;;;;;EASA,IAAM+R,aAAa,GAAG,SAAhBA,aAAgB,CAAC5R,IAAD,EAAO6R,EAAP,EAAWC,IAAX,EAAoB;EACtC,MAAI9R,IAAI,GAAG6R,EAAX,EAAe;EACX,WAAOC,IAAI,GAAG,CAAP,GAAW,CAACA,IAAZ,GAAmBA,IAA1B,CADW;EAEd;;EACD,SAAOA,IAAI,GAAG,CAAP,GAAW,CAAC,CAAD,GAAKA,IAAhB,GAAuBA,IAA9B,CAJsC;EAKzC,CALD;;AAOA;EAEI;;;;;;;;;;;EAWAC,KAAK,GAAG9Q,KAAK,CAAC,UAACjB,IAAD,EAAO6R,EAAP,EAAwB;EAAA,MAAbC,IAAa,uEAAN,CAAM;EAClC,MAAIxE,CAAC,GAAGtN,IAAR;EACA,MAAM4I,GAAG,GAAG,EAAZ;EACAkJ,EAAAA,IAAI,GAAGF,aAAa,CAAC5R,IAAD,EAAO6R,EAAP,EAAWC,IAAX,CAApB;;EACA,MAAIA,IAAI,KAAK,CAAT,IAAc9R,IAAI,KAAK6R,EAA3B,EAA+B;EAAE,WAAO,CAAC7R,IAAD,CAAP;EAAgB;;EACjD,SAAO,CAAC6R,EAAE,GAAGvE,CAAN,IAAWwE,IAAX,IAAmB,CAA1B,EAA6BxE,CAAC,IAAIwE,IAAlC,EAAwC;EAAElJ,IAAAA,GAAG,CAAClG,IAAJ,CAAS4K,CAAT;EAAc;;EACxD,SAAO1E,GAAP;EACH,CAPY,CAbV;;ECrBP;;;AAIA,EAEA;;;;;;;;AAOA,MAAaQ,KAAK,GAAG9H,aAAa,CAAC,OAAD,CAA3B;;ECbP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECmCI;;;;;;;;;;;;;;;;;;;EAmBA0Q,MAAM,GAAG9Q,MAAM,CAAC;EAAA,oCAAIX,IAAJ;EAAIA,IAAAA,IAAJ;EAAA;;EAAA,SAAa2C,KAAK,CAAC+O,MAAD,EAAa1R,IAAb,CAAlB;EAAA,CAAD,CArBZ;;EAuBH;;;;;;;EAOA2R,IAAI,GAAG,SAAPA,IAAO,CAAArS,CAAC;EAAA,SAAIA,CAAC,CAAC,CAAD,CAAL;EAAA,CA9BL;;EAgCH;;;;;;;EAOAsS,IAAI,GAAG,SAAPA,IAAO,CAAArF,EAAE;EAAA,SAAIA,EAAE,CAAC8B,SAAS,CAAC9B,EAAD,CAAV,CAAN;EAAA,CAvCN;;EAyCH;;;;;;;EAOAsF,IAAI,GAAG,SAAPA,IAAO,CAAAtF,EAAE;EAAA,SAAIU,SAAS,CAAC,CAAD,EAAIV,EAAJ,CAAb;EAAA,CAhDN;;EAkDH;;;;;;;EAOAuF,IAAI,GAAG,SAAPA,IAAO,CAAAvF,EAAE;EAAA,SAAIY,OAAO,CAACkB,SAAS,CAAC9B,EAAD,CAAV,EAAgBA,EAAhB,CAAX;EAAA,CAzDN;;EA2DH;;;;;;;EAOAwF,MAAM,GAAG,SAATA,MAAS,CAAAxF,EAAE;EAAA,SAAI,CAACA,EAAD,IAAOlM,MAAM,CAACkM,EAAD,CAAN,KAAe,CAAtB,GAA0B9H,SAA1B,GAAsC,CAACkN,IAAI,CAACpF,EAAD,CAAL,EAAWsF,IAAI,CAACtF,EAAD,CAAf,CAA1C;EAAA,CAlER;;EAoEH;;;;;;;EAOAyF,OAAO,GAAG,SAAVA,OAAU,CAAAzF,EAAE;EAAA,SAAI,CAACA,EAAD,IAAOlM,MAAM,CAACkM,EAAD,CAAN,KAAe,CAAtB,GAA0B9H,SAA1B,GAAsC,CAACqN,IAAI,CAACvF,EAAD,CAAL,EAAWqF,IAAI,CAACrF,EAAD,CAAf,CAA1C;EAAA,CA3ET;;EA6EH;;;;;;;AAOApM,UAAM,GAAG,SAATA,MAAS,CAAAoM,EAAE,EAAI;EACX,UAAQlM,MAAM,CAACkM,EAAD,CAAd;EACI,SAAK9H,SAAL;EACA,SAAK,CAAL;EACI,aAAO,EAAP;;EACJ,SAAK,CAAL;EACI,UAAMwN,KAAK,GAAG1F,EAAE,CAAC,CAAD,CAAhB;EACA,aAAO0F,KAAK,IAAIA,KAAK,CAAC3J,KAAf,GAAuB+E,SAAS,CAAC4E,KAAD,CAAhC,GAA0CA,KAAjD;;EACJ,SAAK,CAAL;EACA;EACI,aAAOtP,KAAK,CAAC8O,MAAD,EAASlF,EAAT,CAAZ;EATR;EAWH,CAhGE;;EAkGH;;;;;;;;EAQA2F,SAAS,GAAGxR,KAAK,CAAC,UAACvB,EAAD,EAAKgT,WAAL;EAAA,SAAqBhS,QAAM,CAACiC,KAAG,CAACjD,EAAD,EAAKgT,WAAL,CAAJ,CAA3B;EAAA,CAAD,CA1Gd;;EA4GH;;;;;;;AAOApQ,WAAO,GAAG,SAAVA,OAAU,CAAAwK,EAAE,EAAI;EACZ,MAAI,CAACjF,KAAK,CAACiF,EAAD,CAAN,IAAc,CAACA,EAAE,CAAClM,MAAtB,EAA8B;EAC1B,WAAOkM,EAAP;EACH;;EACD,MAAIlE,GAAG,GAAGF,EAAE,CAACoE,EAAD,CAAZ;EAAA,MACIQ,CAAC,GAAGR,EAAE,CAAClM,MAAH,GAAY,CADpB;;EAEA,UAAQiE,MAAM,CAACiI,EAAD,CAAd;EACI,SAAK,QAAL;EACI,aAAOQ,CAAC,IAAI,CAAZ,EAAeA,CAAC,IAAI,CAApB,EAAuB;EACnB1E,QAAAA,GAAG,IAAIkE,EAAE,CAACQ,CAAD,CAAT;EACH;;EACD,aAAO1E,GAAP;;EACJ;EACI,aAAO0E,CAAC,IAAI,CAAZ,EAAeA,CAAC,IAAI,CAApB,EAAuB;EACnB1E,QAAAA,GAAG,CAAClG,IAAJ,CAASoK,EAAE,CAACQ,CAAD,CAAX;EACH;;EACD,aAAO1E,GAAP;EAVR;EAYH,CArIE;;EAuIH;;;;;;;;;;EAUA+J,WAAW,GAAG1R,KAAK,CAAC,UAAC2R,OAAD,EAAU9F,EAAV,EAAiB;EACjC,MAAI,CAACA,EAAD,IAAO,CAACA,EAAE,CAAClM,MAAf,EAAuB;EACnB,WAAOkM,EAAP;EACH;;EACD,MAAMzD,KAAK,GAAGyD,EAAE,CAAClM,MAAjB;EAAA,MACIiS,OAAO,GAAGxJ,KAAK,GAAG,CADtB;EAEA,MAAIT,GAAG,GAAGF,EAAE,CAACoE,EAAD,CAAZ;EAAA,MACIQ,CAAC,GAAG,CADR;;EAEA,MAAInG,QAAQ,CAAC2F,EAAD,CAAZ,EAAkB;EACd,WAAOQ,CAAC,GAAGjE,KAAX,EAAkBiE,CAAC,IAAI,CAAvB,EAA0B;EACtB1E,MAAAA,GAAG,IAAI0E,CAAC,KAAKuF,OAAN,GACH/F,EAAE,CAACQ,CAAD,CADC,GACKR,EAAE,CAACQ,CAAD,CAAF,GAAQsF,OADpB;EAEH;;EACD,WAAOhK,GAAP;EACH;;EACD,SAAO0E,CAAC,GAAGjE,KAAX,EAAkBiE,CAAC,IAAI,CAAvB,EAA0B;EACtB,QAAIA,CAAC,KAAKuF,OAAV,EAAmB;EACfjK,MAAAA,GAAG,CAAClG,IAAJ,CAASoK,EAAE,CAACQ,CAAD,CAAX;EACH,KAFD,MAEO;EACH1E,MAAAA,GAAG,CAAClG,IAAJ,CAASoK,EAAE,CAACQ,CAAD,CAAX,EAAgBsF,OAAhB;EACH;EACJ;;EACD,SAAOhK,GAAP;EACH,CAvBkB,CAjJhB;;EA0KH;;;;;;;;EAQAkK,WAAW,GAAG7R,KAAK,CAAC,UAAC6L,EAAD,EAAKiG,GAAL,EAAa;EAC7B,MAAI5L,QAAQ,CAAC4L,GAAD,CAAZ,EAAmB;EACf,WAAOJ,WAAW,CAAC7F,EAAD,EAAKiG,GAAL,CAAlB;EACH;;EACD,SAAOrS,QAAM,CAACiS,WAAW,CAAC7F,EAAD,EAAKiG,GAAL,CAAZ,CAAb;EACH,CALkB,CAlLhB;;EAyLH;;;;;;;;;;;;;;;;EAgBAC,SAAS,GAAG,SAAZA,SAAY,CAAAD,GAAG,EAAI;EACf,MAAIE,QAAQ,GAAGrS,MAAM,CAACmS,GAAD,CAArB;EAAA,MACIzJ,GAAG,GAAG,CADV;EAAA,MACa4J,IADb;;EAEA,MAAI,CAACD,QAAL,EAAe;EACX,WAAO,EAAP;EACH;;EACD,MAAMhF,WAAW,GAAG/K,KAAK,CAAC4K,OAAD,EAAUiF,GAAV,CAAzB;EAAA,MACII,cAAc,GAAGC,OAAO,CAACnF,WAAD,CAD5B;EAAA,MAEIoF,QAAQ,GAAG,EAFf;;EAGA,SAAO/J,GAAG,GAAG6J,cAAb,EAA6B7J,GAAG,IAAI,CAApC,EAAuC;EACnC,QAAMgK,OAAO,GAAG,EAAhB;;EACA,SAAKJ,IAAI,GAAG,CAAZ,EAAeA,IAAI,GAAGD,QAAtB,EAAgCC,IAAI,IAAI,CAAxC,EAA2C;EACvC,UAAIjF,WAAW,CAACiF,IAAD,CAAX,GAAoB5J,GAAG,GAAG,CAA9B,EAAiC;EAC7B;EACH;;EACDgK,MAAAA,OAAO,CAAC5Q,IAAR,CAAaqQ,GAAG,CAACG,IAAD,CAAH,CAAU5J,GAAV,CAAb;EACH;;EACD+J,IAAAA,QAAQ,CAAC3Q,IAAT,CAAc4Q,OAAd;EACH;;EACD,SAAO1Q,QAAM,CAAC,UAAA/C,CAAC;EAAA,WAAIe,MAAM,CAACf,CAAD,CAAN,GAAY,CAAhB;EAAA,GAAF,EAAqBwT,QAArB,CAAb;EACH,CA7NE;;EA+NH;;;;;;;;;;;;EAYAE,YAAY,GAAG,SAAfA,YAAe,CAAAzG,EAAE,EAAI;EACjB,MAAM0G,OAAO,GAAG5S,MAAM,CAACkM,EAAD,CAAtB;EAAA,MACI+B,GAAG,GAAGV,IAAI,CAACsF,GAAL,CAAS,CAAT,EAAYD,OAAZ,CADV;EAAA,MAEI5K,GAAG,GAAG,EAFV;;EAGA,OAAK,IAAI0E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuB,GAApB,EAAyBvB,CAAC,IAAI,CAA9B,EAAiC;EAC7B,QAAIoG,KAAK,GAAG,EAAZ;;EACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,OAApB,EAA6BG,CAAC,IAAI,CAAlC,EAAqC;EACjC,UAAIrG,CAAC,GAAI,KAAKqG,CAAd,EAAkB;EACdD,QAAAA,KAAK,CAAChR,IAAN,CAAWoK,EAAE,CAAC6G,CAAD,CAAb;EACH;EACJ;;EACD/K,IAAAA,GAAG,CAAClG,IAAJ,CAASgR,KAAT;EACH;;EACD,SAAO9K,GAAP;EACH,CAzPE;;EA2PH;;;;;;;;EAQAgL,OAAO,GAAG3S,KAAK,CAAC,UAAC4S,IAAD,EAAOX,IAAP,EAAa7E,IAAb,EAAsB;EAClC,MAAMzF,GAAG,GAAGgF,SAAS,CAACS,IAAD,CAArB;EAAA,MACIyF,GAAG,GAAGlL,GAAG,CAACiL,IAAD,CADb;EAEAjL,EAAAA,GAAG,CAACiL,IAAD,CAAH,GAAYjL,GAAG,CAACsK,IAAD,CAAf;EACAtK,EAAAA,GAAG,CAACsK,IAAD,CAAH,GAAYY,GAAZ;EACA,SAAOlL,GAAP;EACH,CANc,CAnQZ;;EA2QH;;;;;;;;EAQAmL,YAAY,GAAG,SAAfA,YAAe,CAAAjH,EAAE,EAAI;EACjB,MAAMzD,KAAK,GAAGzI,MAAM,CAACkM,EAAD,CAApB;;EAEA,MAAI,CAACzD,KAAD,IAAUA,KAAK,KAAK,CAAxB,EAA2B;EACvB,WAAO,CAACyD,EAAD,CAAP;EACH;;EAED,MAAIuB,IAAI,GAAGT,SAAS,CAACd,EAAD,CAApB;EAAA,MACI1M,CAAC,GAAG4T,MAAM,CAAC3K,KAAD,EAAQ,CAAR,CADd;EAAA,MAEIiE,CAAC,GAAG,CAFR;EAIA,MAAM1E,GAAG,GAAG,CAACyF,IAAD,CAAZ;;EAEA,SAAOf,CAAC,GAAGjE,KAAX,EAAkBiE,CAAC,EAAnB,EAAuB;EACnB,QAAIlN,CAAC,CAACkN,CAAD,CAAD,GAAOA,CAAX,EAAc;EACVe,MAAAA,IAAI,GAAGuF,OAAO,CAACtG,CAAC,GAAG,CAAJ,KAAU,CAAV,GAAc,CAAd,GAAkBlN,CAAC,CAACkN,CAAD,CAApB,EAAyBA,CAAzB,EAA4Be,IAA5B,CAAd;EACAzF,MAAAA,GAAG,CAAClG,IAAJ,CAAS2L,IAAT;EACAjO,MAAAA,CAAC,CAACkN,CAAD,CAAD,IAAQ,CAAR;EACAA,MAAAA,CAAC,GAAG,CAAJ;EACA;EACH;;EACDlN,IAAAA,CAAC,CAACkN,CAAD,CAAD,GAAO,CAAP;EACH;;EAED,SAAO1E,GAAP;EACH,CA5SE;;EA8SH;;;;;;;;EAQAqL,KAAK,GAAGpR,QAtTL;;EAwTH;;;;;;;;EAQAqR,KAAK,GAAG3R,aAhUL;;EAkUH;;;;;;;;EAQA4R,MAAM,GAAGlT,KAAK,CAAC,UAACuN,EAAD,EAAK1B,EAAL,EAAY;EACvB,MAAM3D,KAAK,GAAGmJ,MAAM,CAACxF,EAAD,CAApB;EACA,SAAO,CAAC3D,KAAD,GAAS,EAAT,GAActG,QAAM,CAAC2L,EAAD,EAAKrF,KAAK,CAAC,CAAD,CAAV,EAAeA,KAAK,CAAC,CAAD,CAApB,CAA3B;EACH,CAHa,CA1UX;;EA+UH;;;;;;;;EAQAiL,MAAM,GAAGnT,KAAK,CAAC,UAACuN,EAAD,EAAK1B,EAAL,EAAY;EACvB,MAAM3D,KAAK,GAAGoJ,OAAO,CAACzF,EAAD,CAArB;EACA,SAAO,CAAC3D,KAAD,GAAS,EAAT,GAAc5G,aAAW,CAACiM,EAAD,EAAKrF,KAAK,CAAC,CAAD,CAAV,EAAeA,KAAK,CAAC,CAAD,CAApB,CAAhC;EACH,CAHa,CAvVX;;EA4VH;;;;;;;;;EASAkL,SAAS,GAAGpT,KAAK,CAAC,UAACuN,EAAD,EAAK8F,IAAL,EAAWxH,EAAX,EAAkB;EAChC,MAAMuB,IAAI,GAAGT,SAAS,CAACd,EAAD,CAAtB;EAAA,MACIzD,KAAK,GAAGzI,MAAM,CAACkM,EAAD,CADlB;;EAEA,MAAI,CAACzD,KAAL,EAAY;EACR,WAAO,CAACiL,IAAD,EAAOjG,IAAP,CAAP;EACH;;EACD,MAAI/E,GAAG,GAAG,CAAV;EAAA,MACI9G,GAAG,GAAG8R,IADV;EAAA,MAEIC,MAAM,GAAG,EAFb;EAAA,MAGIC,KAHJ;;EAIA,SAAOlL,GAAG,GAAGD,KAAb,EAAoBC,GAAG,EAAvB,EAA2B;EACvBkL,IAAAA,KAAK,GAAGhG,EAAE,CAAChM,GAAD,EAAM6L,IAAI,CAAC/E,GAAD,CAAV,EAAiBA,GAAjB,CAAV;EACA9G,IAAAA,GAAG,GAAGgS,KAAK,CAAC,CAAD,CAAX;EACAD,IAAAA,MAAM,GAAGC,KAAK,CAAC,CAAD,CAAd;EACH;;EACD,SAAO,CAAChS,GAAD,EAAM+R,MAAN,CAAP;EACH,CAhBgB,CArWd;;EAuXH;;;;;;;;;EASAE,SAAS,GAAGxT,KAAK,CAAC,UAACuN,EAAD,EAAK8F,IAAL,EAAWxH,EAAX,EAAkB;EAChC,MAAMuB,IAAI,GAAGT,SAAS,CAACd,EAAD,CAAtB;EAAA,MACIzD,KAAK,GAAGzI,MAAM,CAACkM,EAAD,CADlB;;EAEA,MAAI,CAACzD,KAAL,EAAY;EACR,WAAO,CAACiL,IAAD,EAAOjG,IAAP,CAAP;EACH;;EACD,MAAI/E,GAAG,GAAGD,KAAK,GAAG,CAAlB;EAAA,MACI7G,GAAG,GAAG8R,IADV;EAAA,MAEIC,MAAM,GAAG,EAFb;EAAA,MAGIC,KAHJ;;EAIA,SAAOlL,GAAG,IAAI,CAAd,EAAiBA,GAAG,EAApB,EAAwB;EACpBkL,IAAAA,KAAK,GAAGhG,EAAE,CAAChM,GAAD,EAAM6L,IAAI,CAAC/E,GAAD,CAAV,EAAiBA,GAAjB,CAAV;EACA9G,IAAAA,GAAG,GAAGgS,KAAK,CAAC,CAAD,CAAX;EACAD,IAAAA,MAAM,GAAGC,KAAK,CAAC,CAAD,CAAd;EACH;;EACD,SAAO,CAAChS,GAAD,EAAM+R,MAAN,CAAP;EACH,CAhBgB,CAhYd;;EAkZH;;;;;;;;;EASAG,OAAO,GAAGzT,KAAK,CAAC,UAACoI,KAAD,EAAQmF,EAAR,EAAY3O,CAAZ,EAAkB;EAC9B,MAAIyJ,GAAG,GAAG,CAAV;EAAA,MACIV,GAAG,GAAG,EADV;EAAA,MAEI+L,KAAK,GAAG9U,CAFZ;;EAGA,SAAOyJ,GAAG,GAAGD,KAAb,EAAoBC,GAAG,IAAI,CAA3B,EAA8B;EAC1BV,IAAAA,GAAG,CAAClG,IAAJ,CAASiS,KAAT;EACAA,IAAAA,KAAK,GAAGnG,EAAE,CAACmG,KAAD,EAAQrL,GAAR,CAAV;EACH;;EACD,SAAOV,GAAP;EACH,CATc,CA3ZZ;;EAsaH;;;;;;;EAOAoL,MAAM,GAAG/S,KAAK,CAAC,UAACoI,KAAD,EAAQxJ,CAAR;EAAA,SAAc6U,OAAO,CAACrL,KAAD,EAAQ,UAAAnJ,CAAC;EAAA,WAAIA,CAAJ;EAAA,GAAT,EAAgBL,CAAhB,CAArB;EAAA,CAAD,CA7aX;;EA+aH;;;;;;;EAOA+U,SAAS,GAAGZ,MAtbT;;EAwbH;;;;;;;EAOAa,KAAK,GAAG5T,KAAK,CAAC,UAACoI,KAAD,EAAQyD,EAAR;EAAA,SAAepM,QAAM,CAACkU,SAAS,CAACvL,KAAD,EAAQyD,EAAR,CAAV,CAArB;EAAA,CAAD,CA/bV;;EAicH;;;;;;;;EAQAgI,OAAO,GAAG7T,KAAK,CAAC,UAACuN,EAAD,EAAK3O,CAAL,EAAW;EACvB,MAAIyJ,GAAG,GAAG,CAAV;EAAA,MACIV,GAAG,GAAG,EADV;EAAA,MAEImM,WAAW,GAAGvG,EAAE,CAAC3O,CAAD,EAAIyJ,GAAJ,EAASV,GAAT,CAFpB;;EAGA,SAAOmM,WAAP,EAAoB;EAChBnM,IAAAA,GAAG,CAAClG,IAAJ,CAASqS,WAAW,CAAC,CAAD,CAApB;EACAA,IAAAA,WAAW,GAAGvG,EAAE,CAACuG,WAAW,CAAC,CAAD,CAAZ,EAAiB,EAAEzL,GAAnB,EAAwBV,GAAxB,CAAhB;EACH;;EACD,SAAOA,GAAP;EACH,CATc,CAzcZ;;EAodH;;;;;;;EAOAoM,SAAS,GAAGlG,cA3dT;;EA6dH;;;;;;EAMAmG,WAAW,GAAGhG,gBAneX;;EAqeH;;;;;;EAMAiG,SAAS,GAAGjU,KAAK,CAAC,UAACpB,CAAD,EAAIiN,EAAJ,EAAW;EACzB,MAAMqI,QAAQ,GAAGjM,OAAO,CAACrJ,CAAD,EAAIiN,EAAJ,CAAxB;EACA,SAAOqI,QAAQ,KAAK,CAAC,CAAd,GAAkBA,QAAlB,GAA6BnQ,SAApC;EACH,CAHgB,CA3ed;;EAgfH;;;;;;EAMAoQ,WAAW,GAAGnU,KAAK,CAAC,UAAC6D,KAAD,EAAQgI,EAAR;EAAA,SAAemI,WAAW,CAAC,UAAApV,CAAC;EAAA,WAAIA,CAAC,KAAKiF,KAAV;EAAA,GAAF,EAAmBgI,EAAnB,CAA1B;EAAA,CAAD,CAtfhB;;EAwfH;;;;;;;EAOAuI,IAAI,GAAG3H,OA/fJ;;EAigBH;;;;;;;EAOA4H,IAAI,GAAG9H,SAxgBJ;;EA0gBH;;;;;;;;EAQA+H,OAAO,GAAG,SAAVA,OAAU,CAACjM,GAAD,EAAM+E,IAAN;EAAA,SAAe,CAACX,OAAO,CAACpE,GAAD,EAAM+E,IAAN,CAAR,EAAqBb,SAAS,CAAClE,GAAD,EAAM+E,IAAN,CAA9B,CAAf;EAAA,CAlhBP;;EAohBH;;;;;;;EAOAmH,SAAS,GAAGvU,KAAK,CAAC,UAACsN,IAAD,EAAOF,IAAP;EAAA,SACdC,WAAW,CACP2C,QAAQ,CAAC1C,IAAD,CADD;EAEPpH,EAAAA,QAAQ,CAACkH,IAAD,CAAR,GACI,UAAC7L,GAAD,EAAM3C,CAAN;EAAA,WAAY2C,GAAG,GAAG3C,CAAlB;EAAA,GADJ,GAEI0N,cAJG;EAKP7E,EAAAA,EAAE,CAAC2F,IAAD,CALK;EAMPA,EAAAA,IANO,CADG;EAAA,CAAD,CA3hBd;;EAqiBH;;;;;;;;EAQAoH,SAAS,GAAGxU,KAAK,CAAC,UAACsN,IAAD,EAAOF,IAAP,EAAgB;EAC9B,MAAMhF,KAAK,GAAGzI,MAAM,CAACyN,IAAD,CAApB;EAAA,MACIqH,UAAU,GACN5G,cAAc,CACV,UAACjP,CAAD,EAAIyN,CAAJ,EAAOR,EAAP;EAAA,WAAc,CAACyB,IAAI,CAAC1O,CAAD,EAAIyN,CAAJ,EAAOR,EAAP,CAAnB;EAAA,GADU,EAEVuB,IAFU,CAFtB;EAOA,SAAOqH,UAAU,KAAK,CAAC,CAAhB,GACHlI,SAAS,CAACnE,KAAD,EAAQgF,IAAR,CADN,GAEHxF,KAAK,CAAC6M,UAAD,EAAarM,KAAb,EAAoBgF,IAApB,CAFT;EAGH,CAXgB,CA7iBd;;EA0jBH;;;;;;;EAOAsH,YAAY,GAAG1U,KAAK,CAAC,UAACsN,IAAD,EAAOF,IAAP,EAAgB;EACjC,MAAMqH,UAAU,GACZ1G,mBAAmB,CACf,UAACnP,CAAD,EAAIyN,CAAJ,EAAOR,EAAP;EAAA,WAAc,CAACyB,IAAI,CAAC1O,CAAD,EAAIyN,CAAJ,EAAOR,EAAP,CAAnB;EAAA,GADe,EAEfuB,IAFe,CADvB;;EAKA,MAAIqH,UAAU,KAAK,CAAC,CAApB,EAAuB;EACnB,WAAOhN,EAAE,CAAC2F,IAAD,CAAT;EACH;;EACD,SAAOX,OAAO,CAACgI,UAAU,GAAG,CAAd,EAAiBrH,IAAjB,CAAd;EACH,CAVmB,CAjkBjB;;EA6kBH;;;;;;;;;;EAUAuH,IAAI,GAAG3U,KAAK,CAAC,UAACsN,IAAD,EAAOF,IAAP,EAAgB;EACzB,MAAMqH,UAAU,GAAG5G,cAAc,CAACmC,QAAQ,CAAC1C,IAAD,CAAT,EAAiBF,IAAjB,CAAjC;EACA,SAAOqH,UAAU,KAAK,CAAC,CAAhB,GACH,CAAClI,SAAS,CAAC,CAAD,EAAIa,IAAJ,CAAV,EAAqB3F,EAAE,CAAC2F,IAAD,CAAvB,CADG,GAEHkH,OAAO,CAACG,UAAD,EAAarH,IAAb,CAFX;EAGH,CALW,CAvlBT;;EA8lBH;;;;;;;;;;;;;;;;EAgBAwH,WAAW,GAAG5U,KAAK,CAAC,UAACsN,IAAD,EAAOF,IAAP,EAAgB;EAChC,MAAMqH,UAAU,GAAG5G,cAAc,CAACmC,QAAQ,CAAC1C,IAAD,CAAT,EAAiBF,IAAjB,CAAjC;EACA,SAAOqH,UAAU,KAAK,CAAC,CAAhB,GACH,CAAChN,EAAE,CAAC2F,IAAD,CAAH,EAAWb,SAAS,CAAC,CAAD,EAAIa,IAAJ,CAApB,CADG,GAC8B/L,SAAO,CAACiT,OAAO,CAACG,UAAD,EAAarH,IAAb,CAAR,CAD5C;EAEH,CAJkB,CA9mBhB;;EAonBH;;;;;;;EAOAyH,EAAE,GAAGrN,MA3nBF;;EA6nBH;;;;;;;EAOAsN,IAAI,GAAG7G,SApoBJ;;EAsoBH;;;;;;;AAOApM,WAAO,GAAG7B,KAAK,CAAC,UAACvB,EAAD,EAAK2O,IAAL,EAAc;EAC1B,MAAMhF,KAAK,GAAGzI,MAAM,CAACyN,IAAD,CAApB;;EACA,MAAI,CAAChF,KAAL,EAAY;EACR;EACH;;EACD,MAAIC,GAAG,GAAG,CAAV;;EACA,SAAOA,GAAG,GAAGD,KAAb,EAAoBC,GAAG,IAAI,CAA3B,EAA8B;EAC1B5J,IAAAA,EAAE,CAAC2O,IAAI,CAAC/E,GAAD,CAAL,EAAYA,GAAZ,EAAiB+E,IAAjB,CAAF;EACH;EACJ,CATc,CA7oBZ;;EAwpBH;;;;;;;AAOAzL,UAAM,GAAG3B,KAAK,CAAC,UAACsN,IAAD,EAAOzB,EAAP,EAAc;EACzB,MAAIxD,GAAG,GAAG,CAAV;EAAA,MACID,KAAK,GAAGzI,MAAM,CAACkM,EAAD,CADlB;EAAA,MAEIlE,GAAG,GAAG,EAFV;;EAGA,MAAI,CAACS,KAAL,EAAY;EACR,WAAOT,GAAP;EACH;;EACD,SAAOU,GAAG,GAAGD,KAAb,EAAoBC,GAAG,EAAvB,EAA2B;EACvB,QAAIiF,IAAI,CAACzB,EAAE,CAACxD,GAAD,CAAH,EAAUA,GAAV,EAAewD,EAAf,CAAR,EAA4B;EACxBlE,MAAAA,GAAG,CAAClG,IAAJ,CAASoK,EAAE,CAACxD,GAAD,CAAX;EACH;EACJ;;EACD,SAAOV,GAAP;EACH,CAba,CA/pBX;;EA8qBH;;;;;;;;;EASAoN,SAAS,GAAG/U,KAAK,CAAC,UAACsN,IAAD,EAAOF,IAAP;EAAA,SACd,CAACzN,MAAM,CAACyN,IAAD,CAAP,GACI,CAAC,EAAD,EAAK,EAAL,CADJ,GAEI,CAACzL,QAAM,CAAC2L,IAAD,EAAOF,IAAP,CAAP,EAAqBzL,QAAM,CAACqO,QAAQ,CAAC1C,IAAD,CAAT,EAAiBF,IAAjB,CAA3B,CAHU;EAAA,CAAD,CAvrBd;;EA4rBH;;;;;;;EAOA4H,IAAI,GAAGpJ,QAnsBJ;;EAqsBH;;;;;;;EAOAqJ,OAAO,GAAGlF,QAAQ,CAACnE,QAAD,CA5sBf;;EA8sBH;;;;;;;EAOAsJ,UAAU,GAAGlV,KAAK,CAAC,UAACmV,GAAD,EAAMC,GAAN,EAAc;EAC7B,MAAMC,MAAM,GAAG1V,MAAM,CAACwV,GAAD,CAArB;EAAA,MACIG,MAAM,GAAG3V,MAAM,CAACyV,GAAD,CADnB;;EAEA,MAAIE,MAAM,GAAGD,MAAT,IAAmB,CAACA,MAApB,IAA8B,CAACC,MAA/B,IAAyCrN,OAAO,CAACkN,GAAG,CAAC,CAAD,CAAJ,EAASC,GAAT,CAAP,KAAyB,CAAC,CAAvE,EAA0E;EACtE,WAAO,KAAP;EACH;;EACD,MAAI/M,GAAG,GAAG,CAAV;;EACA,SAAOA,GAAG,GAAGgN,MAAb,EAAqBhN,GAAG,EAAxB,EAA4B;EACxB,QAAI8M,GAAG,CAAC9M,GAAD,CAAH,KAAa+M,GAAG,CAAC/M,GAAD,CAApB,EAA2B;EACvB,aAAO,KAAP;EACH;EACJ;;EACD,SAAO,IAAP;EACH,CAbiB,CArtBf;;EAouBH;;;;;;;EAOAkN,UAAU,GAAGvV,KAAK,CAAC,UAACmV,GAAD,EAAMC,GAAN,EAAc;EAC7B,MAAMC,MAAM,GAAG1V,MAAM,CAACwV,GAAD,CAArB;EAAA,MACIG,MAAM,GAAG3V,MAAM,CAACyV,GAAD,CADnB;;EAEA,MAAIE,MAAM,GAAGD,MAAT,IAAmB,CAACA,MAApB,IAA8B,CAACC,MAA/B,IAAyCrN,OAAO,CAACkN,GAAG,CAAC,CAAD,CAAJ,EAASC,GAAT,CAAP,KAAyB,CAAC,CAAvE,EAA0E;EACtE,WAAO,KAAP;EACH;;EACD,MAAIxC,IAAI,GAAGyC,MAAM,GAAG,CAApB;EAAA,MACIpD,IAAI,GAAGqD,MAAM,GAAG,CADpB;;EAEA,SAAO1C,IAAI,IAAI,CAAf,EAAkBA,IAAI,EAAtB,EAA0B;EACtB,QAAIuC,GAAG,CAACvC,IAAD,CAAH,KAAcwC,GAAG,CAACnD,IAAD,CAArB,EAA6B;EACzB,aAAO,KAAP;EACH;;EACDA,IAAAA,IAAI,IAAI,CAAR;EACH;;EACD,SAAO,IAAP;EACH,CAfiB,CA3uBf;;EA4vBH;;;;;;;EAOAuD,SAAS,GAAGxV,KAAK,CAAC,UAACmV,GAAD,EAAMC,GAAN,EAAc;EAC5B,MAAMC,MAAM,GAAG1V,MAAM,CAACwV,GAAD,CAArB;EAAA,MACIG,MAAM,GAAG3V,MAAM,CAACyV,GAAD,CADnB;;EAEA,MAAIE,MAAM,GAAGD,MAAT,IAAmB,CAACA,MAApB,IAA8B,CAACC,MAAnC,EAA2C;EACvC,WAAO,KAAP;EACH;;EACD,MAAI1C,IAAJ;EAAA,MACI6C,QADJ;EAAA,MAEIpN,GAAG,GAAG,CAFV;;EAGA,SAAOA,GAAG,GAAGiN,MAAb,EAAqBjN,GAAG,IAAI,CAA5B,EAA+B;EAC3BoN,IAAAA,QAAQ,GAAG,CAAX;;EACA,SAAK7C,IAAI,GAAG,CAAZ,EAAeA,IAAI,GAAGyC,MAAtB,EAA8BzC,IAAI,IAAI,CAAtC,EAAyC;EACrC,UAAIwC,GAAG,CAACxC,IAAI,GAAGvK,GAAR,CAAH,KAAoB8M,GAAG,CAACvC,IAAD,CAA3B,EAAmC;EAC/B6C,QAAAA,QAAQ,IAAI,CAAZ;EACH;;EACD,UAAIA,QAAQ,KAAKJ,MAAjB,EAAyB;EACrB,eAAO,IAAP;EACH;EACJ;EACJ;;EACD,SAAO,KAAP;EACH,CArBgB,CAnwBd;;EA0xBH;;;;;;;EAOAK,eAAe,GAAG1V,KAAK,CAAC,UAACmV,GAAD,EAAMC,GAAN,EAAc;EAClC,MAAMxH,GAAG,GAAGV,IAAI,CAACsF,GAAL,CAAS,CAAT,EAAY7S,MAAM,CAACyV,GAAD,CAAlB,CAAZ;EAAA,MACIO,MAAM,GAAGhW,MAAM,CAACwV,GAAD,CADnB;EAEA,MAAIM,QAAJ,EACIpJ,CADJ;;EAEA,OAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGuB,GAAhB,EAAqBvB,CAAC,IAAI,CAA1B,EAA6B;EACzBoJ,IAAAA,QAAQ,GAAG,CAAX;;EACA,SAAK,IAAI/C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG9E,GAApB,EAAyB8E,CAAC,IAAI,CAA9B,EAAiC;EAC7B,UAAIrG,CAAC,GAAI,KAAKqG,CAAV,IAAgBzK,OAAO,CAACmN,GAAG,CAAC1C,CAAD,CAAJ,EAASyC,GAAT,CAAP,GAAuB,CAAC,CAA5C,EAA+C;EAC3CM,QAAAA,QAAQ,IAAI,CAAZ;EACH;;EACD,UAAIA,QAAQ,KAAKE,MAAjB,EAAyB;EACrB,eAAO,IAAP;EACH;EACJ;EACJ;;EACD,SAAO,KAAP;EACH,CAjBsB,CAjyBpB;;EAozBH;;;;;;;;;;;;EAYAC,KAAK,GAAG,SAARA,KAAQ,CAAA/J,EAAE;EAAA,SAAIgK,OAAO,CAAC,UAAC5W,CAAD,EAAIC,CAAJ;EAAA,WAAUD,CAAC,KAAKC,CAAhB;EAAA,GAAD,EAAoB2M,EAApB,CAAX;EAAA,CAh0BP;;EAk0BH;;;;;;;;;EASAgK,OAAO,GAAG7V,KAAK,CAAC,UAAC8V,UAAD,EAAajK,EAAb,EAAoB;EAChC,MAAMzD,KAAK,GAAGzI,MAAM,CAACkM,EAAD,CAApB;;EACA,MAAI,CAACzD,KAAL,EAAY;EACR,WAAOuE,SAAS,CAACd,EAAD,CAAhB;EACH;;EACD,MAAIxD,GAAG,GAAG,CAAV;EAAA,MACI0N,QADJ;EAAA,MAEIvU,IAFJ;EAAA,MAGIwU,MAAM,GAAG,SAATA,MAAS,CAAApX,CAAC,EAAI;EACV,QAAIkX,UAAU,CAAClX,CAAD,EAAImX,QAAJ,CAAd,EAA6B;EACzB1N,MAAAA,GAAG;EACN;;EACD,QAAIyN,UAAU,CAAClX,CAAD,EAAI4C,IAAJ,CAAd,EAAyB;EACrBuU,MAAAA,QAAQ,GAAGnX,CAAX;EACA,aAAO,IAAP;EACH;;EACD,WAAO,KAAP;EACH,GAZL;EAAA,MAaI2C,GAAG,GAAG,EAbV;;EAcA,SAAO8G,GAAG,GAAGD,KAAb,EAAoBC,GAAG,IAAI,CAA3B,EAA8B;EAC1B7G,IAAAA,IAAI,GAAGqK,EAAE,CAACxD,GAAD,CAAT;EACA9G,IAAAA,GAAG,CAACE,IAAJ,CAAS8S,SAAS,CAACyB,MAAD,EAASpO,KAAK,CAACS,GAAD,EAAMD,KAAN,EAAayD,EAAb,CAAd,CAAlB;EACH;;EACD,SAAOtK,GAAP;EACH,CAxBc,CA30BZ;;EAq2BH;;;;;;;;;;EAUA0U,KAAK,GAAG,SAARA,KAAQ,CAAApK,EAAE,EAAI;EACV,MAAIzD,KAAK,GAAGzI,MAAM,CAACkM,EAAD,CAAlB;EAAA,MACIxD,GAAG,GAAG,CADV;EAAA,MAEI9G,GAAG,GAAG,EAFV;;EAGA,MAAI,CAAC6G,KAAL,EAAY;EACR,WAAO,EAAP;EACH;;EACD,SAAOC,GAAG,IAAID,KAAd,EAAqBC,GAAG,IAAI,CAA5B,EAA+B;EAC3B9G,IAAAA,GAAG,CAACE,IAAJ,CAASgL,OAAO,CAACpE,GAAD,EAAMwD,EAAN,CAAhB;EACH;;EACD,SAAOtK,GAAP;EACH,CA13BE;EAAA,IA03BA;;EAEH;;;;;;;;;;EAUA2U,KAAK,GAAG,SAARA,KAAQ,CAAArK,EAAE,EAAI;EACV,MAAIzD,KAAK,GAAGzI,MAAM,CAACkM,EAAD,CAAlB;EAAA,MACIxD,GAAG,GAAG,CADV;EAAA,MAEI9G,GAAG,GAAG,EAFV;;EAGA,MAAI,CAAC6G,KAAL,EAAY;EACR,WAAO,EAAP;EACH;;EACD,SAAOC,GAAG,IAAID,KAAd,EAAqBC,GAAG,IAAI,CAA5B,EAA+B;EAC3B9G,IAAAA,GAAG,CAACE,IAAJ,CAASmG,KAAK,CAACS,GAAD,EAAMD,KAAN,EAAayD,EAAb,CAAd;EACH;;EACD,SAAOtK,GAAP;EACH,CAj5BE;EAAA,IAi5BA;;EAEH;;;;;;;EAOA4U,WAAW,GAAGnW,KAAK,CAAC,UAACoW,MAAD,EAAShJ,IAAT;EAAA,SAChB8H,UAAU,CAACkB,MAAD,EAAShJ,IAAT,CAAV,GACIkH,OAAO,CAAC3U,MAAM,CAACyW,MAAD,CAAP,EAAiBhJ,IAAjB,CAAP,CAA8B,CAA9B,CADJ,GAEIT,SAAS,CAACS,IAAD,CAHG;EAAA,CAAD,CA15BhB;;EA+5BH;;;;;;;;;EASAiJ,GAAG,GAAGrW,KAAK,CAAC,UAACsW,IAAD,EAAOC,IAAP,EAAgB;EACxB,MAAI,CAAC5W,MAAM,CAAC2W,IAAD,CAAP,IAAiB,CAAC3W,MAAM,CAAC4W,IAAD,CAA5B,EAAoC;EAChC,WAAO,EAAP;EACH;;EAHuB,oBAIPxJ,UAAU,CAACuJ,IAAD,EAAOC,IAAP,CAJH;EAAA;EAAA,MAIjBC,EAJiB;EAAA,MAIbC,EAJa;;EAKxB,SAAO7U,QAAM,CAAC,UAACL,GAAD,EAAMC,IAAN,EAAY6G,GAAZ;EAAA,WACNiE,cAAc,CAAC/K,GAAD,EAAM,CAACC,IAAD,EAAOiV,EAAE,CAACpO,GAAD,CAAT,CAAN,CADR;EAAA,GAAD,EAET,EAFS,EAELmO,EAFK,CAAb;EAGH,CARU,CAx6BR;;EAk7BH;;;;;;;;EAQAE,IAAI,GAAGzW,MAAM,CAAC,YAAc;EAAA,qCAAV6M,KAAU;EAAVA,IAAAA,KAAU;EAAA;;EACxB,MAAM6J,YAAY,GAAG1U,KAAK,CAAC8K,UAAD,EAAaD,KAAb,CAA1B;EACA,SAAOlL,QAAM,CAAC,UAACL,GAAD,EAAMC,IAAN,EAAY6G,GAAZ;EAAA,WACNiE,cAAc,CAAC/K,GAAD,EAAMG,KAAG,CAAC,UAAAmK,EAAE;EAAA,aAAIA,EAAE,CAACxD,GAAD,CAAN;EAAA,KAAH,EAAgBsO,YAAhB,CAAT,CADR;EAAA,GAAD,EAET,EAFS,EAELA,YAAY,CAAC,CAAD,CAFP,CAAb;EAGH,CALY,CA17BV;;EAi8BH;;;;;;;;EAQAC,IAAI,GAAG5W,KAAK,CAAC,UAACsW,IAAD,EAAOC,IAAP,EAAaM,IAAb;EAAA,SAAsBH,IAAI,CAACJ,IAAD,EAAOC,IAAP,EAAaM,IAAb,CAA1B;EAAA,CAAD,CAz8BT;;EA28BH;;;;;;;;;EASAC,IAAI,GAAG9W,KAAK,CAAC,UAACsW,IAAD,EAAOC,IAAP,EAAaM,IAAb,EAAmBE,IAAnB;EAAA,SAA4BL,IAAI,CAACJ,IAAD,EAAOC,IAAP,EAAaM,IAAb,EAAmBE,IAAnB,CAAhC;EAAA,CAAD,CAp9BT;;EAs9BH;;;;;;;;;;EAUAC,IAAI,GAAGhX,KAAK,CAAC,UAACsW,IAAD,EAAOC,IAAP,EAAaM,IAAb,EAAmBE,IAAnB,EAAyBE,IAAzB;EAAA,SAAkCP,IAAI,CAACJ,IAAD,EAAOC,IAAP,EAAaM,IAAb,EAAmBE,IAAnB,EAAyBE,IAAzB,CAAtC;EAAA,CAAD,CAh+BT;;EAk+BH;;;;;;;;;;;;;;;;;;;;;EAqBAC,OAAO,GAAGlX,KAAK,CAAC,UAACuN,EAAD,EAAK4H,GAAL,EAAUC,GAAV,EAAkB;EAC9B,MAAI,CAACzV,MAAM,CAACwV,GAAD,CAAP,IAAgB,CAACxV,MAAM,CAACyV,GAAD,CAA3B,EAAkC;EAC9B,WAAO,EAAP;EACH;;EAH6B,qBAIbrI,UAAU,CAACoI,GAAD,EAAMC,GAAN,CAJG;EAAA;EAAA,MAIvBoB,EAJuB;EAAA,MAInBC,EAJmB;;EAK9B,SAAO7U,QAAM,CAAC,UAACL,GAAD,EAAMC,IAAN,EAAY6G,GAAZ;EAAA,WACNiE,cAAc,CAAC/K,GAAD,EAAMgM,EAAE,CAAC/L,IAAD,EAAOiV,EAAE,CAACpO,GAAD,CAAT,CAAR,CADR;EAAA,GAAD,EAET,EAFS,EAELmO,EAFK,CAAb;EAGH,CARc,CAv/BZ;;EAigCH;;;;;;;;;;;;;EAaAW,QAAQ,GAAGjX,MAAM,CAAC,UAACqN,EAAD,EAAkB;EAAA,qCAAVT,KAAU;EAAVA,IAAAA,KAAU;EAAA;;EAChC,MAAM6J,YAAY,GAAG1U,KAAK,CAAC8K,UAAD,EAAaD,KAAb,CAA1B;EAAA,MACIsK,YAAY,GAAGzX,MAAM,CAACgX,YAAD,CADzB;;EAEA,MAAI,CAACS,YAAL,EAAmB;EACf,WAAO,EAAP;EACH,GAFD,MAGK,IAAIA,YAAY,KAAK,CAArB,EAAwB;EACzB,WAAO3K,OAAO,CAAC9M,MAAM,CAACgX,YAAY,CAAC,CAAD,CAAb,CAAP,EAA0BA,YAAY,CAAC,CAAD,CAAtC,CAAd;EACH;;EACD,SAAO/U,QAAM,CAAC,UAACL,GAAD,EAAMC,IAAN,EAAY6G,GAAZ;EAAA,WACNiE,cAAc,CAAC/K,GAAD,EAAMU,KAAK,CAACsL,EAAD,EAAK7L,KAAG,CAAC,UAAAmK,EAAE;EAAA,aAAIA,EAAE,CAACxD,GAAD,CAAN;EAAA,KAAH,EAAgBsO,YAAhB,CAAR,CAAX,CADR;EAAA,GAAD,EAET,EAFS,EAELA,YAAY,CAAC,CAAD,CAFP,CAAb;EAGH,CAZgB,CA9gCd;;EA4hCH;;;;;;;;;;;;EAYAU,QAAQ,GAAGrX,KAAK,CAAC,UAACuN,EAAD,EAAK4H,GAAL,EAAUC,GAAV,EAAekC,GAAf;EAAA,SAAuBH,QAAQ,CAAC5J,EAAD,EAAK4H,GAAL,EAAUC,GAAV,EAAekC,GAAf,CAA/B;EAAA,CAAD,CAxiCb;;EA0iCH;;;;;;;;;;;;;EAaAC,QAAQ,GAAGvX,KAAK,CAAC,UAACuN,EAAD,EAAK4H,GAAL,EAAUC,GAAV,EAAekC,GAAf,EAAoBE,GAApB;EAAA,SAA4BL,QAAQ,CAAC5J,EAAD,EAAK4H,GAAL,EAAUC,GAAV,EAAekC,GAAf,EAAoBE,GAApB,CAApC;EAAA,CAAD,CAvjCb;;EAyjCH;;;;;;;;;;;;;;EAcAC,QAAQ,GAAGzX,KAAK,CAAC,UAACuN,EAAD,EAAK4H,GAAL,EAAUC,GAAV,EAAekC,GAAf,EAAoBE,GAApB,EAAyBE,GAAzB;EAAA,SAAiCP,QAAQ,CAAC5J,EAAD,EAAK4H,GAAL,EAAUC,GAAV,EAAekC,GAAf,EAAoBE,GAApB,EAAyBE,GAAzB,CAAzC;EAAA,CAAD,CAvkCb;;EAykCH;;;;;;;EAOAC,KAAK,GAAG3E,KAAK,CAAC,UAACzR,GAAD,EAAMC,IAAN,EAAe;EACzBD,EAAAA,GAAG,CAAC,CAAD,CAAH,CAAOE,IAAP,CAAYD,IAAI,CAAC,CAAD,CAAhB;EACAD,EAAAA,GAAG,CAAC,CAAD,CAAH,CAAOE,IAAP,CAAYD,IAAI,CAAC,CAAD,CAAhB;EACA,SAAOD,GAAP;EACH,CAJY,EAIV,CAAC,EAAD,EAAK,EAAL,CAJU,CAhlCV;;EAslCH;;;;;;;EAOAqW,MAAM,GAAG,SAATA,MAAS,CAAAxK,IAAI,EAAI;EACb,MAAI,CAACzN,MAAM,CAACyN,IAAD,CAAX,EAAmB;EACf,WAAO,EAAP;EACH;;EACD,MAAMyK,QAAQ,GAAGlY,MAAM,CAACyN,IAAI,CAAC,CAAD,CAAL,CAAvB;EACA,MAAIiG,IAAI,GAAGwE,QAAQ,GACfhE,OAAO,CAAC,UAAA7B,QAAQ;EAAA,WAAIA,QAAQ,KAAK,CAAC,EAAD,EAAKA,QAAL,CAAL,GAAsBjO,SAAlC;EAAA,GAAT,EAAsD8T,QAAtD,CADQ,GAEf,EAFJ;EAGA,SAAO7E,KAAK,CAAC,UAACzR,GAAD,EAAMC,IAAN,EAAe;EACxBD,IAAAA,GAAG,CAACM,OAAJ,CAAY,UAACwQ,OAAD,EAAUhK,GAAV;EAAA,aAAkBgK,OAAO,CAAC5Q,IAAR,CAAaD,IAAI,CAAC6G,GAAD,CAAjB,CAAlB;EAAA,KAAZ;EACA,WAAO9G,GAAP;EACH,GAHW,EAGT8R,IAHS,EAGHjG,IAHG,CAAZ;EAIH,CAzmCE;;EA2mCH;;;;;;;EAOA0K,GAAG,GAAG9X,KAAK,CAAC,UAAC+X,CAAD,EAAIlM,EAAJ,EAAW;EACnB,MAAIxD,GAAG,GAAG,CAAV;EAAA,MACID,KAAK,GAAGzI,MAAM,CAACkM,EAAD,CADlB;;EAEA,MAAI,CAACzD,KAAL,EAAY;EACR,WAAO,KAAP;EACH;;EACD,SAAOC,GAAG,GAAGD,KAAb,EAAoBC,GAAG,IAAI,CAA3B,EAA8B;EAC1B,QAAI0P,CAAC,CAAClM,EAAE,CAACxD,GAAD,CAAH,CAAL,EAAgB;EACZ,aAAO,IAAP;EACH;EACJ;;EACD,SAAO,KAAP;EACH,CAZU,CAlnCR;;EAgoCH;;;;;;;EAOA2P,GAAG,GAAGhY,KAAK,CAAC,UAAC+X,CAAD,EAAIlM,EAAJ,EAAW;EACnB,MAAMzD,KAAK,GAAGzI,MAAM,CAACkM,EAAD,CAApB;EACA,MAAIxD,GAAG,GAAG,CAAV;;EACA,MAAI,CAACD,KAAL,EAAY;EACR,WAAO,KAAP;EACH;;EACD,SAAOC,GAAG,GAAGD,KAAb,EAAoBC,GAAG,EAAvB,EAA2B;EACvB,QAAI,CAAC0P,CAAC,CAAClM,EAAE,CAACxD,GAAD,CAAH,EAAUA,GAAV,EAAewD,EAAf,CAAN,EAA0B;EACtB,aAAO,KAAP;EACH;EACJ;;EACD,SAAO,IAAP;EACH,CAZU,CAvoCR;;EAqpCH;;;;;;;EAOAoM,GAAG,GAAG,SAANA,GAAM,CAAApM,EAAE;EAAA,SAAImM,GAAG,CAACjM,QAAD,EAAWF,EAAX,CAAP;EAAA,CA5pCL;;EA8pCH;;;;;;;;;EASAqM,EAAE,GAAG,SAALA,EAAK,CAAArM,EAAE;EAAA,SAAIiM,GAAG,CAAC/L,QAAD,EAAWF,EAAX,CAAP;EAAA,CAvqCJ;;EAyqCH;;;;;;;;;EASAsM,GAAG,GAAG,SAANA,GAAM,CAAAtM,EAAE;EAAA,SAAImM,GAAG,CAAChM,OAAD,EAAUH,EAAV,CAAP;EAAA,CAlrCL;;EAorCH;;;;;;;EAOAuM,GAAG,GAAG,SAANA,GAAM,CAAAhL,IAAI;EAAA,SAAI4F,KAAK,CAAC,UAACzR,GAAD,EAAM3C,CAAN;EAAA,WAAY2C,GAAG,GAAG3C,CAAlB;EAAA,GAAD,EAAsB,CAAtB,EAAyBwO,IAAzB,CAAT;EAAA,CA3rCP;;EA6rCH;;;;;;;EAOAiL,OAAO,GAAG,SAAVA,OAAU,CAAAjL,IAAI;EAAA,SAAI4F,KAAK,CAAC,UAACzR,GAAD,EAAM3C,CAAN;EAAA,WAAY2C,GAAG,GAAG3C,CAAlB;EAAA,GAAD,EAAsB,CAAtB,EAAyBwO,IAAzB,CAAT;EAAA,CApsCX;;EAssCH;;;;;;;EAOA+E,OAAO,GAAG,SAAVA,OAAU,CAAA/E,IAAI;EAAA,SAAI8D,IAAI,CAACoH,MAAM,CAAC1L,kBAAD,EAAqBQ,IAArB,CAAP,CAAR;EAAA,CA7sCX;;EA+sCH;;;;;;;EAOAmL,OAAO,GAAG,SAAVA,OAAU,CAAAnL,IAAI;EAAA,SAAI6D,IAAI,CAACqH,MAAM,CAAC1L,kBAAD,EAAqBQ,IAArB,CAAP,CAAR;EAAA,CAttCX;;EAwtCH;;;;;;;;;;;;;;;EAeAoL,KAAK,GAAGxY,KAAK,CAAC,UAACvB,EAAD,EAAK4U,IAAL,EAAWxH,EAAX,EAAkB;EAC5B,MAAI,CAACA,EAAD,IAAO,CAAClM,MAAM,CAACkM,EAAD,CAAlB,EAAwB;EACpB,WAAO,EAAP;EACH;;EACD,MAAMzD,KAAK,GAAGzI,MAAM,CAACkM,EAAD,CAApB;EACA,MAAIxD,GAAG,GAAG,CAAV;EAAA,MACImF,MAAM,GAAG6F,IADb;EAAA,MAEI1L,GAAG,GAAG,EAFV;;EAGA,SAAOU,GAAG,GAAGD,KAAb,EAAoB;EAChBoF,IAAAA,MAAM,GAAG/O,EAAE,CAAC+O,MAAD,EAAS3B,EAAE,CAACxD,GAAD,CAAX,EAAkBA,GAAlB,EAAuBwD,EAAvB,CAAX;EACAlE,IAAAA,GAAG,CAAClG,IAAJ,CAAS+L,MAAT;EACAnF,IAAAA,GAAG;EACN;;EACD,SAAOV,GAAP;EACH,CAdY,CAvuCV;;EAuvCH;;;;;;;;EAQA8Q,MAAM,GAAGzY,KAAK,CAAC,UAACvB,EAAD,EAAKoN,EAAL,EAAY;EACvB,MAAI,CAACA,EAAD,IAAO,CAACA,EAAE,CAAClM,MAAf,EAAuB;EACnB,WAAO,EAAP;EACH;;EACD,SAAO6Y,KAAK,CAAC/Z,EAAD,EAAKwS,IAAI,CAACpF,EAAD,CAAT,EAAesF,IAAI,CAACtF,EAAD,CAAnB,CAAZ;EACH,CALa,CA/vCX;;EAswCH;;;;;;;;;;EAUA6M,KAAK,GAAG1Y,KAAK,CAAC,UAACvB,EAAD,EAAK4U,IAAL,EAAWxH,EAAX,EAAkB;EAC5B,MAAI,CAACA,EAAD,IAAO,CAAClM,MAAM,CAACkM,EAAD,CAAlB,EAAwB;EACpB,WAAO,EAAP;EACH;;EACD,MAAMzD,KAAK,GAAGzI,MAAM,CAACkM,EAAD,CAApB;EACA,MAAIxD,GAAG,GAAGD,KAAK,GAAG,CAAlB;EAAA,MACIoF,MAAM,GAAG3B,EAAE,CAAC,CAAD,CADf;EAAA,MAEIlE,GAAG,GAAG,EAFV;;EAGA,SAAOU,GAAG,GAAG,CAAC,CAAd,EAAiB;EACbmF,IAAAA,MAAM,GAAG/O,EAAE,CAAC+O,MAAD,EAAS3B,EAAE,CAACxD,GAAD,CAAX,EAAkBA,GAAlB,EAAuBwD,EAAvB,CAAX;EACAlE,IAAAA,GAAG,CAAClG,IAAJ,CAAS+L,MAAT;EACAnF,IAAAA,GAAG;EACN;;EACD,SAAOV,GAAP;EACH,CAdY,CAhxCV;;EAgyCH;;;;;;;EAOAgR,MAAM,GAAG3Y,KAAK,CAAC,UAACvB,EAAD,EAAKoN,EAAL,EAAY;EACvB,MAAI,CAACA,EAAD,IAAO,CAACA,EAAE,CAAClM,MAAf,EAAuB;EACnB,WAAO,EAAP;EACH;;EACD,SAAO+Y,KAAK,CAACja,EAAD,EAAKyS,IAAI,CAACrF,EAAD,CAAT,EAAeuF,IAAI,CAACvF,EAAD,CAAnB,CAAZ;EACH,CALa,CAvyCX;;EA8yCH;;;;;;;;;;EAUA+M,GAAG,GAAG,SAANA,GAAM,CAAAxL,IAAI;EAAA,SAAIyL,KAAK,CAAC,UAAC5Z,CAAD,EAAIC,CAAJ;EAAA,WAAUD,CAAC,KAAKC,CAAhB;EAAA,GAAD,EAAoBkO,IAApB,CAAT;EAAA,CAxzCP;;EA0zCH;;;;;;;;EAQA0L,MAAM,GAAG9Y,KAAK,CAAC,UAACpB,CAAD,EAAIwO,IAAJ;EAAA,SAAa2L,QAAQ,CAAC,UAAC9Z,CAAD,EAAIC,CAAJ;EAAA,WAAUD,CAAC,KAAKC,CAAhB;EAAA,GAAD,EAAoBN,CAApB,EAAuBwO,IAAvB,CAArB;EAAA,CAAD,CAl0CX;;EAo0CH;;;;;;;;;EASA4L,IAAI,GAAG,SAAPA,IAAO,CAAAnN,EAAE;EAAA,SAAIyM,MAAM,CAAC1L,kBAAD,EAAqBf,EAArB,CAAV;EAAA,CA70CN;;EA+0CH;;;;;;;;;;;;;;;;;;;;;;EAsBAoN,MAAM,GAAGjZ,KAAK,CAAC,UAACkZ,OAAD,EAAUrN,EAAV;EAAA;EAGXnK,IAAAA,KAAG,CAAC,UAAAyX,SAAS;EAAA,aAAIA,SAAS,CAAC,CAAD,CAAb;EAAA,KAAV;EAGCb,IAAAA,MAAM;EAEF;EAAA;EAAA,UAAEc,EAAF;;EAAA;EAAA,UAAQC,EAAR;;EAAA,aAAgBzM,kBAAkB,CAACwM,EAAD,EAAKC,EAAL,CAAlC;EAAA,KAFE;EAKF3X,IAAAA,KAAG,CAAC,UAAAF,IAAI;EAAA,aAAI,CAAC0X,OAAO,CAAC1X,IAAD,CAAR,EAAgBA,IAAhB,CAAJ;EAAA,KAAL,EAAgCqK,EAAhC,CALD,CAHP;EAHQ;EAAA,CAAD,CAr2CX;;EAq3CH;;;;;;;;;;;EAWAyM,MAAM,GAAGtY,KAAK,CAAC,UAACsZ,UAAD,EAAazN,EAAb;EAAA,SAAoBc,SAAS,CAACd,EAAD,CAAT,CAAcmN,IAAd,CAAmBM,UAAU,IAAI1M,kBAAjC,CAApB;EAAA,CAAD,CAh4CX;;EAk4CH;;;;;;;;;;;EAWA2M,MAAM,GAAGvZ,KAAK,CAAC,UAACpB,CAAD,EAAIiN,EAAJ,EAAW;EACtB,MAAI,CAACA,EAAE,CAAClM,MAAR,EAAgB;EACZ,WAAO8H,EAAE,CAACoE,EAAD,EAAKjN,CAAL,CAAT;EACH;;EACD,MAAM4a,UAAU,GAAGzF,SAAS,CAAC,UAAAvS,IAAI;EAAA,WAAI5C,CAAC,IAAI4C,IAAT;EAAA,GAAL,EAAoBqK,EAApB,CAA5B;EACA,SAAO2N,UAAU,KAAK,CAAC,CAAhB,GAAoB/Z,QAAM,CAAC,CAACoM,EAAD,EAAKpE,EAAE,CAACoE,EAAD,EAAKjN,CAAL,CAAP,CAAD,CAA1B,GACHa,QAAM,CAACiS,WAAW,CAACjK,EAAE,CAACoE,EAAD,EAAKjN,CAAL,CAAH,EAAY0V,OAAO,CAACkF,UAAD,EAAa3N,EAAb,CAAnB,CAAZ,CADV;EAEH,CAPa,CA74CX;;EAs5CH;;;;;;;;;;;;EAYA4N,QAAQ,GAAGzZ,KAAK,CAAC,UAACsZ,UAAD,EAAa1a,CAAb,EAAgBiN,EAAhB,EAAuB;EACpC,MAAMzD,KAAK,GAAGzI,MAAM,CAACkM,EAAD,CAApB;;EACA,MAAI,CAACzD,KAAL,EAAY;EACR,WAAO,CAACxJ,CAAD,CAAP;EACH;;EACD,MAAIyJ,GAAG,GAAG,CAAV;;EACA,SAAOA,GAAG,GAAGD,KAAb,EAAoBC,GAAG,IAAI,CAA3B,EAA8B;EAC1B,QAAIiR,UAAU,CAAC1a,CAAD,EAAIiN,EAAE,CAACxD,GAAD,CAAN,CAAV,IAA0B,CAA9B,EAAiC;EAC7B,UAAMH,KAAK,GAAGoM,OAAO,CAACjM,GAAD,EAAMwD,EAAN,CAArB;EACA,aAAOpM,QAAM,CAAC,CAACyI,KAAK,CAAC,CAAD,CAAN,EAAW,CAACtJ,CAAD,CAAX,EAAgBsJ,KAAK,CAAC,CAAD,CAArB,CAAD,CAAb;EACH;EACJ;;EACD,SAAOoE,cAAc,CAACK,SAAS,CAACd,EAAD,CAAV,EAAgBjN,CAAhB,CAArB;EACH,CAbe,CAl6Cb;;EAi7CH;;;;;;;EAOAia,KAAK,GAAG7Y,KAAK,CAAC,UAACsN,IAAD,EAAOF,IAAP,EAAgB;EAC1B,MAAI,CAACzN,MAAM,CAACyN,IAAD,CAAX,EAAmB;EACf,WAAO,EAAP;EACH;;EACD,MAAMhF,KAAK,GAAGzI,MAAM,CAACyN,IAAD,CAApB;;EACA,MAAI/E,GAAG,GAAG,CAAV;EAAA,MACIqR,QADJ;EAAA,MAEI/R,GAAG,GAAG,EAFV;EAAA,MAGIgS,KAAK,GAAG,SAARA,KAAQ,CAAAC,UAAU;EAAA,WAAItM,IAAI,CAACoM,QAAD,EAAWE,UAAX,CAAR;EAAA,GAHtB;;EAIA,SAAOvR,GAAG,GAAGD,KAAb,EAAoBC,GAAG,IAAI,CAA3B,EAA8B;EAC1BqR,IAAAA,QAAQ,GAAGtM,IAAI,CAAC/E,GAAD,CAAf;;EACA,QAAIyP,GAAG,CAAC6B,KAAD,EAAQhS,GAAR,CAAP,EAAqB;EACjB;EACH;;EACDA,IAAAA,GAAG,CAAClG,IAAJ,CAASiY,QAAT;EACH;;EACD,SAAO/R,GAAP;EACH,CAjBY,CAx7CV;;EA28CH;;;;;;;;EAQAoR,QAAQ,GAAG/Y,KAAK,CAAC,UAACsN,IAAD,EAAO1O,CAAP,EAAUwO,IAAV,EAAmB;EAChC,MAAMoM,UAAU,GAAGzF,SAAS,CAAC,UAAAvS,IAAI;EAAA,WAAI8L,IAAI,CAAC1O,CAAD,EAAI4C,IAAJ,CAAR;EAAA,GAAL,EAAwB4L,IAAxB,CAA5B;;EACA,MAAIoM,UAAU,GAAG,CAAC,CAAlB,EAAqB;EACjB,QAAMtR,KAAK,GAAGoM,OAAO,CAACkF,UAAD,EAAapM,IAAb,CAArB;EACA,WAAO2D,MAAM,CAAC7I,KAAK,CAAC,CAAD,CAAN,EAAWiJ,IAAI,CAACjJ,KAAK,CAAC,CAAD,CAAN,CAAf,CAAb;EACH;;EACD,SAAOyE,SAAS,CAACS,IAAD,CAAhB;EACH,CAPe,CAn9Cb;;EA49CH;;;;;;;;;EASAyM,cAAc,GAAG7Z,KAAK,CAAC,UAACsN,IAAD,EAAO6H,GAAP,EAAYC,GAAZ;EAAA,SACnBpC,KAAK,CAAC,UAACzR,GAAD,EAAM3C,CAAN;EAAA,WAAYma,QAAQ,CAACzL,IAAD,EAAO1O,CAAP,EAAU2C,GAAV,CAApB;EAAA,GAAD,EAAqC4T,GAArC,EAA0CC,GAA1C,CADc;EAAA,CAAD,CAr+CnB;;EAw+CH;;;;;;;;EAQA0E,OAAO,GAAG9Z,KAAK,CAAC,UAACsN,IAAD,EAAOgJ,IAAP,EAAaC,IAAb;EAAA,SACZvD,KAAK,CAAC,UAACzR,GAAD,EAAMrC,CAAN,EAAY;EACV,QAAM6a,YAAY,GAAGjC,GAAG,CAAC,UAAA7Y,CAAC;EAAA,aAAIqO,IAAI,CAACrO,CAAD,EAAIC,CAAJ,CAAR;EAAA,KAAF,EAAkBqC,GAAlB,CAAxB;EACA,WAAO,CAACwY,YAAD,IAAiBxY,GAAG,CAACE,IAAJ,CAASvC,CAAT,GAAaqC,GAA9B,IAAqCA,GAA5C;EACH,GAHA,EAGEoL,SAAS,CAAC2J,IAAD,CAHX,EAGmBC,IAHnB,CADO;EAAA,CAAD,CAh/CZ;;EAu/CH;;;;;;;EAOAyD,KAAK,GAAGha,KAAK,CAAC,UAACsW,IAAD,EAAOC,IAAP;EAAA,SACVxF,MAAM,CAACuF,IAAD,EACF3U,QAAM,CAAC,UAAAuM,GAAG;EAAA,WAAI,CAACtC,QAAQ,CAACsC,GAAD,EAAMoI,IAAN,CAAb;EAAA,GAAJ,EAA8BC,IAA9B,CADJ,CADI;EAAA,CAAD,CA9/CV;;EAkgDH;;;;;;;EAOA0D,SAAS,GAAGja,KAAK,CAAC,UAACsW,IAAD,EAAOC,IAAP;EAAA,SACd,CAACD,IAAD,IAAS,CAACC,IAAV,IAAmB,CAACD,IAAD,IAAS,CAACC,IAA7B,GAAqC,EAArC,GACI5U,QAAM,CAAC,UAAAuM,GAAG;EAAA,WAAItC,QAAQ,CAACsC,GAAD,EAAMqI,IAAN,CAAZ;EAAA,GAAJ,EAA6BD,IAA7B,CAFI;EAAA,CAAD,CAzgDd;;EA6gDH;;;;;;;;EAQA4D,WAAW,GAAGla,KAAK,CAAC,UAACsN,IAAD,EAAO6M,KAAP,EAAcC,KAAd;EAAA,SAChBpH,KAAK,CAAC,UAACzR,GAAD,EAAMtC,CAAN;EAAA,WACE6Y,GAAG,CAAC,UAAA5Y,CAAC;EAAA,aAAIoO,IAAI,CAACrO,CAAD,EAAIC,CAAJ,CAAR;EAAA,KAAF,EAAkBkb,KAAlB,CAAH,IAA+B7Y,GAAG,CAACE,IAAJ,CAASxC,CAAT,GAAasC,GAA5C,IAAmDA,GADrD;EAAA,GAAD,EAEC,EAFD,EAEK4Y,KAFL,CADW;EAAA,CAAD,CArhDhB;;EA0hDH;;;;;;;;EAQAE,UAAU,GAAGra,KAAK,CAAC,UAACsa,MAAD,EAASC,MAAT,EAAoB;EAAE;EACrC,MAAID,MAAM,IAAI,CAACC,MAAf,EAAuB;EACnB,WAAO5N,SAAS,CAAC2N,MAAD,CAAhB;EACH,GAFD,MAGK,IAAI,CAACA,MAAD,IAAWC,MAAX,IAAsB,CAACD,MAAD,IAAW,CAACC,MAAtC,EAA+C;EAChD,WAAO,EAAP;EACH;;EACD,SAAO3Y,QAAM,CAAC,UAACL,GAAD,EAAM2M,GAAN;EAAA,WACN,CAACtC,QAAQ,CAACsC,GAAD,EAAMqM,MAAN,CAAT,IAA0BhZ,GAAG,CAACE,IAAJ,CAASyM,GAAT,GAAe3M,GAAzC,IAAgDA,GAD1C;EAAA,GAAD,EAEP,EAFO,EAEH+Y,MAFG,CAAb;EAGH,CAViB,CAliDf;;EA8iDH;;;;;;;EAOAE,UAAU,GAAGva,MAAM,CAAC,UAACwa,IAAD;EAAA,qCAAUC,MAAV;EAAUA,IAAAA,MAAV;EAAA;;EAAA,SAChB9Y,QAAM,CAAC,UAACL,GAAD,EAAMmM,GAAN;EAAA,WAAcqD,MAAM,CAACxP,GAAD,EAAM8Y,UAAU,CAAC3M,GAAD,EAAM+M,IAAN,CAAhB,CAApB;EAAA,GAAD,EAAmD,EAAnD,EAAuDC,MAAvD,CADU;EAAA,CAAD,CArjDhB;;ECjCP;;;;AAIA;EAUI;;;;;;EAMAC,KAAK,GAAGxS,KAAK,CAAC,UAAD,CARV;;EAUH;;;;;;EAMAyS,KAAK,GAAGzS,KAAK,CAAC,UAAD,CAhBV;;EAkBH;;;;;;EAMA0S,OAAO,GAAGhJ,WAAW,CAAC,GAAD,CAxBlB;;EA0BH;;;;;;EAMAiJ,OAAO,GAAGjJ,WAAW,CAAC,IAAD,CAhClB;;EAkCH;;;;;;;EAOAkJ,UAAU,GAAG,SAAbA,UAAa,CAAAlP,EAAE,EAAI;EACflC,EAAAA,eAAe,CAACvF,MAAD,EAAS,YAAT,EAAuB,IAAvB,EAA6ByH,EAA7B,CAAf;;EACA,SAAOA,EAAE,CAAC,CAAD,CAAF,CAAMmP,WAAN,KAAsBnP,EAAE,CAACoP,SAAH,CAAa,CAAb,CAA7B;EACH,CA5CE;;EA8CH;;;;;;;EAOAC,UAAU,GAAG,SAAbA,UAAa,CAAArP,EAAE,EAAI;EACflC,EAAAA,eAAe,CAACvF,MAAD,EAAS,YAAT,EAAuB,IAAvB,EAA6ByH,EAA7B,CAAf;;EACA,SAAOA,EAAE,CAAC,CAAD,CAAF,CAAMsP,WAAN,KAAsBtP,EAAE,CAACoP,SAAH,CAAa,CAAb,CAA7B;EACH,CAxDE;;EA0DH;;;;;;;;;EASAG,SAAS,GAAG,SAAZA,SAAY,CAACvP,EAAD;EAAA,MAAKwP,OAAL,uEAAe,WAAf;EAAA,SAA+B1L,OAAO,CAC1C3N,IAAI,CAAC,EAAD,CADsC,EAE1CN,KAAG,CAAC,UAAA4Z,GAAG;EAAA,WAAIJ,UAAU,CAACI,GAAG,CAACN,WAAJ,EAAD,CAAd;EAAA,GAAJ,CAFuC,EAG1CrZ,QAAM,CAAC,UAAA/C,CAAC;EAAA,WAAI,CAAC,CAACA,CAAN;EAAA,GAAF,CAHoC,EAI1CuJ,KAAK,CAACkT,OAAD,CAJqC,CAAP,CAKrC1R,eAAe,CAACvF,MAAD,EAAS,WAAT,EAAsB,IAAtB,EAA4ByH,EAA5B,CALsB,CAA/B;EAAA,CAnET;;EA0EH;;;;;;;;;EASA0P,SAAS,GAAG5L,OAAO,CAACuL,UAAD,EAAaE,SAAb,CAnFhB;EAuFP;;;;;;;;ECnGA;;;;;;;;;;AAUA,MAUaI,UAAU,GAAGC,WAAnB;EAEP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}