{"version":3,"file":"fjl.js","sources":["../../src/functionOps/curry.js","../../src/utils/utils.js","../../src/uncurried/jsPlatform/objectUncurried.js","../../src/uncurried/objectOps/typeOf.js","../../src/uncurried/objectOps/is.js","../../src/uncurried/objectOps/assignDeep.js","../../src/uncurried/jsPlatform/functionUncurried.js","../../src/uncurried/functionOps/apply.js","../../src/uncurried/objectOps/of.js","../../src/uncurried/jsPlatform/listUncurried.js","../../src/uncurried/jsPlatform/arrayUncurried.js","../../src/uncurried/functionOps/negate.js","../../src/uncurried/functionOps/call.js","../../src/uncurried/functionOps/compose.js","../../src/uncurried/functionOps/curry.js","../../src/uncurried/functionOps/curry_.js","../../src/uncurried/functionOps/id.js","../../src/uncurried/functionOps/functionOpsUncurried.js","../../src/booleanOps/is.js","../../src/booleanOps/booleanOps.js","../../src/uncurried/objectOps/prop.js","../../src/objectOps/typeOf.js","../../src/uncurried/objectOps/instanceOf.js","../../src/objectOps/instanceOf.js","../../src/objectOps/is.js","../../src/functionOps/apply.js","../../src/objectOps/of.js","../../src/uncurried/listOps/listOpsUncurriedAggregation.js","../../src/uncurried/listOps/map.js","../../src/uncurried/listOps/listOpsUncurriedUtils.js","../../src/uncurried/listOps/listOpsUncurried.js","../../src/uncurried/objectOps/setTheoryOps.js","../../src/objectOps/objectOps.js","../../src/functionOps/call.js","../../src/listOps/listOps.js","../../src/functionOps/compose.js","../../src/functionOps/negateP.js","../../src/functionOps/id.js","../../src/functionOps/flip.js","../../src/functionOps/until.js","../../src/functionOps/functionOps.js","../../src/numberOps/numberOps.js","../../src/uncurried/jsPlatform/stringUnCurried.js","../../src/jsPlatform/string.js","../../src/stringOps/stringOps.js","../../generated-for-src/version.js","../../src/fjl.js"],"sourcesContent":["/**\n * @author elydelacruz\n * @created 12/6/2016.\n * @memberOf functionOps\n * @description Different curry implementations for modern javascript currying.\n * @todo Make code here more minimal (reuse small parts here).\n * @todo separate curry_ (and it's variants) into a separate file/module.\n */\n\n/**\n * PlaceHolder (__) constructor.\n * @constructor PlaceHolder\n * @private\n */\nconst PlaceHolder = function PlaceHolder() {},\n\n    /**\n     * Placeholder instance.\n     * @type {PlaceHolder}\n     * @private\n     */\n    placeHolderInstance = new PlaceHolder();\n\n/**\n * Curries a function based on it's defined arity (argument's arrayOps expected length).\n * @function module:functionOps.curry\n * @param fn {Function}\n * @param argsToCurry {...*}\n * @returns {Function}\n */\nexport function curry (fn, ...argsToCurry) {\n    return (...args) => {\n        const concatedArgs = argsToCurry.concat(args);\n        return concatedArgs.length < fn.length ?\n            curry.apply(null, [fn].concat(concatedArgs)) :\n            fn.apply(null, concatedArgs);\n    };\n}\n\n/**\n * Checks to see if value is a `PlaceHolder`.\n * @function isPlaceHolder\n * @param instance {*}\n * @returns {boolean}\n * @private\n */\nfunction isPlaceHolder (instance) {\n    return instance instanceof PlaceHolder;\n}\n\n/**\n * Replaces `placeholder` values in `listOps`.\n * @function replacePlaceHolder\n * @param array {Array} - Array to replace placeholders in.\n * @param args {Array} - Args from to choose from to replace placeholders.\n * @returns {Array|*} - Returns passed in `listOps` with placeholders replaced by values in `args`.\n * @private\n */\nfunction replacePlaceHolders (array, args) {\n    let out = array.map(element => {\n        if (!isPlaceHolder(element)) {\n            return element;\n        }\n        else if (args.length > 0) {\n            return args.shift();\n        }\n        return element;\n    });\n    return args.length > 0 ? out.concat(args) : out;\n}\n\n/**\n * Curries passed in functionOps up to given arguments length (can enforce arity via placeholder values (`__`)).\n * @function module:functionOps.curry_\n * @param fn {Function}\n * @param argsToCurry {...*}\n * @returns {Function}\n */\nexport function curry_ (fn, ...argsToCurry) {\n    return (...args) => {\n        let concatedArgs = replacePlaceHolders(argsToCurry, args),\n            placeHolders = concatedArgs.filter(isPlaceHolder),\n            canBeCalled = placeHolders.length === 0 &&\n                concatedArgs.length >= fn.length;\n        return canBeCalled ? fn.apply(null, concatedArgs) :\n            curry_.apply(null, [fn].concat(concatedArgs));\n    };\n}\n\n/**\n * Curries a functionOps up to given arity also enforces arity via placeholder values (`__`).\n * @function module:functionOps.curryN_\n * @param executeArity {Number}\n * @param fn {Function}\n * @param curriedArgs {...*} - Allows `Placeholder` (`__`) values.\n * @returns {Function} - Passed in functionOps wrapped in a functionOps for currying.\n */\nexport function curryN_ (executeArity, fn, ...curriedArgs) {\n    return (...args) => {\n        let concatedArgs = replacePlaceHolders(curriedArgs, args),\n            placeHolders = concatedArgs.filter(isPlaceHolder),\n            canBeCalled = (concatedArgs.length - placeHolders.length >= executeArity) || !executeArity;\n        return !canBeCalled ? curryN_.apply(null, [executeArity, fn].concat(concatedArgs)) :\n            fn.apply(null, concatedArgs);\n    };\n}\n\n/**\n * Curries a functionOps up to a given arity.\n * @function module:functionOps.curryN\n * @param executeArity {Number}\n * @param fn {Function}\n * @param curriedArgs {...*}\n * @returns {Function}\n */\nexport function curryN (executeArity, fn, ...curriedArgs) {\n    return (...args) => {\n        let concatedArgs = curriedArgs.concat(args),\n            canBeCalled = (concatedArgs.length >= executeArity) || !executeArity;\n        return !canBeCalled ? curryN.apply(null, [executeArity, fn].concat(concatedArgs)) :\n            fn.apply(null, concatedArgs);\n    };\n}\n\nexport let\n\n    /**\n     * Place holder object (frozen) used by curry.\n     * @memberOf functionOps\n     * @type {PlaceHolder}\n     */\n    __ = Object.freeze ? Object.freeze(placeHolderInstance) : placeHolderInstance,\n\n    /**\n     * Curries a functionOps up to an arity of 2 (takes into account placeholders `__` (arity enforcers)) (won't call functionOps until 2 or more args).\n     * @function module:functionOps.curry2_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry2_ = fn => curryN_(2, fn),\n\n    /**\n     * Curries a functionOps up to an arity of 3 (takes into account placeholders `__` (arity enforcers)) (won't call functionOps until 3 or more args).\n     * @function module:functionOps.curry3_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry3_ = fn => curryN_(3, fn),\n\n    /**\n     * Curries a functionOps up to an arity of 4 (takes into account placeholders `__` (arity enforcers))  (won't call functionOps until 4 or more args).\n     * @function module:functionOps.curry4_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry4_ = fn => curryN_(4, fn),\n\n    /**\n     * Curries a functionOps up to an arity of 5  (takes into account placeholders `__` (arity enforcers))  (won't call functionOps until 5 or more args).\n     * @function module:functionOps.curry5_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry5_ = fn => curryN_(5, fn),\n\n    /**\n     * Curries a functionOps up to an arity of 2 (won't call functionOps until 2 or more args).\n     * @function module:functionOps.curry2\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry2 = fn => curryN(2, fn),\n\n    /**\n     * Curries a functionOps up to an arity of 3 (won't call functionOps until 3 or more args).\n     * @function module:functionOps.curry3\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry3 = fn => curryN(3, fn),\n\n    /**\n     * Curries a functionOps up to an arity of 4 (won't call functionOps until 4 or more args).\n     * @function module:functionOps.curry4\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry4 = fn => curryN(4, fn),\n\n    /**\n     * Curries a functionOps up to an arity of 5 (won't call functionOps until 5 or more args).\n     * @function module:functionOps.curry5\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry5 = fn => curryN(5, fn);\n","/**\n * Created by elydelacruz on 7/22/2017.\n */\n\nimport {curry, curry2} from   '../functionOps/curry';\n\nexport const\n\n    fPureTakesOne = name => (arg, f) => f[name](arg),\n\n    fPureTakes2 = name => (arg1, arg2, f) => f[name](arg1, arg2),\n\n    fPureTakesOneOrMore = name => (f, ...args) => f[name](...args),\n\n    fPureTakesOne_ = name => curry((arg, f) => f[name](arg)),\n\n    fPureTakes2_ = name => curry((arg1, arg2, f) => f[name](arg1, arg2)),\n\n    fPureTakesOneOrMore_ = name => curry2((f, ...args) => f[name](...args))\n;\n","/**\n * Created by elydelacruz on 9/6/2017.\n * Defines some of the platform methods for objects (the ones used within `fjl`) uncurried for use\n * throughout the library.  @note Doesn't include all methods for objects just the ones used in\n *  the library.\n * @todo change all files named '*UnCurried' to '*Uncurried'.\n */\n\nimport {fPureTakesOne} from   '../../utils/utils';\n\nexport const\n\n    /**\n     * Returns whether constructor has derived objectOps.\n     * @function module:jsPlatform.objectOpsUncurried.instanceOf\n     * @param instanceConstructor {Function} - Constructor.\n     * @param instance {*}\n     * @instance {*}\n     * @returns {Boolean}\n     */\n    instanceOf = (instanceConstructor, instance) =>\n        instance instanceof instanceConstructor,\n\n    /**\n     * @function module:jsPlatform.objectOpsUncurried.hasOwnProperty\n     * @param propName {*}\n     * @param typeInstance {*}\n     * @returns {Boolean}\n     */\n    hasOwnProperty = fPureTakesOne('hasOwnProperty'),\n\n    /**\n     * @function module:jsPlatform.objectOpsUncurried.length\n     * @param x {*}\n     * @returns {Number}\n     * @throws {Error} - Throws an error if value doesn't have a `length` property (\n     *  `null`, `undefined`, {Boolean}, Symbol, et. al.).\n     */\n    length = x => x.length,\n\n    /**\n     * @function module:jsPlatform.objectOpsUncurried.hasOwnProperty\n     * @param x {*}\n     * @returns {Number}\n     * @throws {Error} - Throws an error if value doesn't have a `toString`.\n     */\n    toString = x => x.toString(),\n\n    /**\n     * Gets own enumerable keys of passed in object (`Object.keys`).\n     * @function module:jsPlatform.objectOpsUncurried.keys\n     * @param obj {*}\n     * @returns {Array<String>}\n     */\n    keys = obj => Object.keys(obj),\n\n    /**\n     * Defined as `Object.assign` else is the same thing but shimmed.\n     * @function module:jsPlatform.objectOpsUncurried.assign\n     * @param obj0 {Object}\n     * @param objs {...{Object}}\n     * @returns {Object}\n     */\n    assign = (() =>\n        Object.assign ?\n            (obj0, ...objs) => Object.assign(obj0, ...objs) :\n            (obj0, ...objs) => objs.reduce((topAgg, obj) => {\n                return keys(obj).reduce((agg, key) => {\n                    agg[key] = obj[key];\n                    return agg;\n                }, topAgg);\n            }, obj0))();\n","/**\n * Created by elyde on 12/18/2016.\n */\nconst _Number = Number.name,\n    _NaN = 'NaN',\n    _Null = 'Null',\n    _Undefined = 'Undefined',\n    _undefined = 'undefined';\n\n/**\n * Returns the class name of an object from it's class stringOps.\n * @note Returns 'NaN' if value `isNaN` and value type is 'Number'.\n * @function module:fjl.typeOf\n * @param value {*}\n * @returns {string} - Constructor's name property if not null or undefined (in which case a\n *  name representing those types is returned ('Null' and or 'Undefined' (es6 compliant))).\n */\nexport function typeOf (value) {\n    let retVal;\n    if (typeof value === _undefined) {\n        retVal = _Undefined;\n    }\n    else if (value === null) {\n        retVal = _Null;\n    }\n    else {\n        let constructorName = (value).constructor.name;\n        retVal = constructorName === _Number && isNaN(value) ?\n            _NaN : constructorName;\n    }\n    return retVal;\n}\n","/**\n * Created by elyde on 12/18/2016.\n * @module is\n * @todo remove `isset`, `isEmpty` and `notEmptyAndOfType`\n */\n\nimport {typeOf} from './typeOf';\n\nimport {instanceOf, length, keys, hasOwnProperty} from '../jsPlatform/objectUncurried';\n\nlet _String = String.name,\n    _Number = Number.name,\n    _Object = Object.name,\n    _Boolean = Boolean.name,\n    _Function = Function.name,\n    _Array = Array.name,\n    _Symbol = 'Symbol',\n    _Map = 'Map',\n    _Set = 'Set',\n    _WeakMap = 'WeakMap',\n    _WeakSet = 'WeakSet',\n    _Null = 'Null',\n    _Undefined = 'Undefined';\n\nexport const\n\n    /**\n     * Returns whether a value is a functionOps or not.\n     * @function module:is.isFunction\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isFunction = value => instanceOf(Function, value),\n\n    /**\n     * Type checker.  Note** The `Type` passed in, if a constructor, should\n     * be a named constructor/functionOps-instance;  E.g.,\n     * ```\n     *  functionOps SomeName () {} // or\n     *  var SomeName = functionOps SomeName () {} // or\n     *  class SomeName {}\n     * ```\n     * @function module:fjl.isType\n     * @param type {Function|String} - Constructor or constructor name\n     * @param obj {*}\n     * @return {Boolean}\n     */\n    isType = (type, obj) => typeOf(obj) === (isFunction(type) ? type.name : type),\n\n    /**\n     * Checks if `value` is an es2015 `class`.\n     * @function module:is.isClass\n     * @param x {*}\n     * @returns {boolean}\n     */\n    isClass = x => x && /^\\s{0,3}class\\s{1,3}/.test(x.toString().substr(0, 10)),\n\n    /**\n     * Returns a booleanOps depicting whether a value is callable or not.\n     * @function module:is.isCallable\n     * @tentative\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isCallable = x => isFunction(x) && !isClass(x),\n\n    /**\n     * Checks if value is an arrayOps.\n     * @function module:is.isArray\n     * @param value {*}\n     * @returns {boolean}\n     */\n    isArray = value => isType(Array, value),\n\n    /**\n     * Checks whether value is an objectOps or not.\n     * @function module:is.isObject\n     * @param value\n     * @returns {Boolean}\n     */\n    isObject = value => isType(_Object, value),\n\n    /**\n     * Checks if value is a booleanOps.\n     * @function module:is.isBoolean\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isBoolean = value => isType(_Boolean, value),\n\n    /**\n     * Checks if value is a valid numberOps (also checks if isNaN so that you don't have to).\n     * @function module:is.isNumber\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isNumber = value => isType(_Number, value),\n\n    /**\n     * Checks whether value is a stringOps or not.\n     * @function module:is.isString\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isString = value => isType(_String, value),\n\n    /**\n     * Checks whether value is of `Map` or not.\n     * @function module:is.isMap\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isMap = value => isType(_Map, value),\n\n    /**\n     * Checks whether value is of `Set` or not.\n     * @function module:is.isSet\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isSet = value => isType(_Set, value),\n\n    /**\n     * Checks whether value is of `WeakMap` or not.\n     * @function module:is.isWeakMap\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isWeakMap = value => isType(_WeakMap, value),\n\n    /**\n     * Checks whether value is of `WeakSet` or not.\n     * @function module:is.isWeakSet\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isWeakSet = value => isType(_WeakSet, value),\n\n    /**\n     * Checks if value is undefined.\n     * @function module:is.isUndefined\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isUndefined = value => isType(_Undefined, value),\n\n    /**\n     * Checks if value is null.\n     * @function module:is.isNull\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isNull = value => isType(_Null, value),\n\n    /**\n     * Checks if value is a `Symbol`.\n     * @function module:is.isSymbol\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isSymbol = value => isType(_Symbol, value),\n\n    /**\n     * @tentative\n     */\n    isPromise = value => isType('Promise', value),\n\n    /**\n     * Checks if given `x` is one of the four\n     * \"usable\" immutable JS primitives; I.e.,\n     *  One of [String, Boolean, Number, Symbol]\n     * @function module:is.isUsableImmutablePrimitive\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isUsableImmutablePrimitive = x => {\n        const typeOfX = typeOf(x);\n        return [_String, _Number, _Boolean, _Symbol]\n            .some(Type => Type === typeOfX);\n    },\n\n    /**\n     * Checks if !length.\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isEmptyList = x => length(x) === 0,\n\n    /**\n     * Checks if objectOps has own properties/enumerable-props or not.\n     * @param obj {*}\n     * @returns {Boolean}\n     */\n    isEmptyObject = obj => isEmptyList(keys(obj)),\n\n    /**\n     * Checks if collection is empty or not (Map, WeakMap, WeakSet, Set etc.).\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isEmptyCollection = x => x.size === 0,\n\n    /**\n     * Checks to see if passed in argument is empty.\n     * @function module:is.empty\n     * @param value {*} - Value to check.\n     * @returns {Boolean}\n     */\n    isEmpty = value => {\n        let typeOfValue = typeOf(value),\n            retVal;\n\n        if (!value) { // '', 0, `null`, `undefined` or `false` then is empty\n            retVal = true;\n        }\n        else if (typeOfValue === _Array || typeOfValue === _Function) {\n            retVal = isEmptyList(value);\n        }\n        else if (typeOfValue === _Number && value !== 0) {\n            retVal = false;\n        }\n        else if (typeOfValue === _Object) {\n            retVal = isEmptyObject(value);\n        }\n        else if (hasOwnProperty('size', value)) {\n            retVal = isEmptyCollection(value);\n        }\n        else {\n            retVal = !value;\n        }\n        return retVal;\n    },\n\n    /**\n     * Returns true if an element is not empty and is of type.\n     * @function module:is.notEmptyAndOfType\n     * @param type {String|Function} - Type to check against (stringOps name or actual constructor).\n     * @param value {*} - Value to check.\n     * @returns {Boolean}\n     */\n    notEmptyAndOfType = (type, value) => !isEmpty(value) && isType(type, value),\n\n    /**\n     * Returns whether passed in values is defined and not null.\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isset = x => !isNull(x) && !isUndefined(x);\n","\nimport {isObject} from './is';\n\nimport {keys, hasOwnProperty} from '../jsPlatform/objectUncurried';\n\nexport const\n    /**\n     * Merges all objects down into one.\n     * @function module:jsPlatform.objectOpsUncurried.assignDeep\n     * @param obj0 {Object}\n     * @param objs {...{Object}}\n     * @returns {Object}\n     */\n    assignDeep = (obj0, ...objs) =>\n        objs.reduce((topAgg, obj) =>\n                keys(obj).reduce((agg, key) => {\n                    let propDescription = Object.getOwnPropertyDescriptor(agg, key);\n                    // If property is not writable move to next item in collection\n                    if (hasOwnProperty(key, agg) && propDescription &&\n                        !(propDescription.get && propDescription.set) &&\n                        !propDescription.writable) {\n                        return agg;\n                    }\n                    if (isObject(agg[key]) && isObject(obj[key])) {\n                        assignDeep(agg[key], obj[key]);\n                    }\n                    else { agg[key] = obj[key]; }\n                    return agg;\n                }, topAgg)\n            , obj0);\n","/**\n * Created by elydelacruz on 9/7/2017.\n */\nexport const\n\n    /**\n     * Functional `apply` functionOps (takes no context).\n     * @function module:jsPlatform.functionOps.apply\n     * @param fn {Function}\n     * @param args {Array|*}\n     * @returns {*}\n     */\n    apply = (fn, args) => fn.apply(null, args),\n\n    /**\n     * Functional `call` functionOps (takes no context).\n     * @function module:fnOperators.call\n     * @param fn {Function}\n     * @param args ...{*}\n     * @returns {*}\n     */\n    call = (fn, ...args) => apply(fn, args);\n","/**\n * Created by elydelacruz on 7/22/2017.\n */\n\n/**\n * Functional `apply` functionOps (takes no context).\n * @function module:functionOps.apply\n * @param fn {Function}\n * @param args {*}\n * @returns {*}\n */\nexport {apply} from '../jsPlatform/functionUncurried';\n","import {isFunction, isUsableImmutablePrimitive, isset} from './is';\nimport {hasOwnProperty} from '../jsPlatform/objectUncurried';\nimport {apply} from   '../functionOps/apply';\n\nexport const of = (x, ...args) => {\n    if (!isset(x)) { return undefined; }\n    const constructor = x.constructor;\n    if (hasOwnProperty('of', constructor)) {\n        return apply(constructor.of, args);\n    }\n    else if (isUsableImmutablePrimitive(x)) {\n        return apply(constructor, args);\n    }\n    else if (isFunction(constructor)) {\n        return new constructor(...args);\n    }\n    return undefined;\n};\n","/**\n *  List operations that overlap (apart from globally overlapping props and functions like `length` and `toString`)\n *      on both strings and arrays.\n */\n\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from   '../../utils/utils';\n\n// export {length, toString} from './objectOpsUnCurried';\n\nexport const\n\n    /**\n     * @function module:jsPlatform.listOpsUncurried.concat\n     */\n    concat = fPureTakesOneOrMore('concat'),\n\n    /**\n     * @function module:jsPlatform.listOpsUncurried.slice\n     */\n    slice = fPureTakes2('slice'),\n\n    /**\n     * `Array.prototype.includes` or shim.\n     * @function module:jsPlatform.listOpsUncurried.includes\n     * @param value {*}\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    includes = (() => 'includes' in Array.prototype ?\n            fPureTakesOne('includes') :\n            (value, xs) => xs.indexOf(value) > -1)(),\n\n    /**\n     * Searches list/list-like for given element `x`.\n     * @function module:jsPlatform.listOpsUncurried.indexOf\n     * @param x {*} - Element to search for.\n     * @param xs {Array|String|*} - list or list like to look in.\n     * @returns {Number} - `-1` if element not found else index at which it is found.\n     */\n    indexOf = fPureTakesOne('indexOf'),\n\n    /**\n     * Last index of (`Array.prototype.lastIndexOf`).\n     * @function module:jsPlatform.listOpsUncurried.lastIndexOf\n     * @param x {*} - Element to search for.\n     * @param xs {Array|String|*} - list or list like to look in.\n     * @returns {Number} - `-1` if element not found else index at which it is found.\n     */\n    lastIndexOf = fPureTakesOne('lastIndexOf')\n\n;\n","/**\n * Created by elyde on 7/20/2017.\n * Functional versions of common array methods (`map`, `filter`, etc.) (un-curried);\n * @module jsPlatform:arrayOpsUncurried\n * @todo updated doc blocks to list correct/updated module name.\n */\n\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from   '../../utils/utils';\n\nexport const\n\n    /**\n     * Array.prototype.reverse generator (generates a functionOps that calls the prototype version or a\n     * shimmed version if it doesn't exist).\n     * @returns {Function}\n     */\n    defineReverse = () =>\n        Array.prototype.reverse ? x => x.reverse() :\n            x => x.reduceRight((agg, item) => {\n                agg.push(item);\n                return agg;\n            }, []),\n\n    /**\n     * Maps a functionOps to functor (listOps etc.).\n     * @function module:arrayOpsUncurried.map\n     * @param fn {Function}\n     * @param functor {Array|{map: {Function}}}\n     * @returns {Array|{map: {Function}}}\n     */\n    map = fPureTakesOne('map'),\n\n    /**\n     * Filters a functor (listOps etc.) with passed in functionOps.\n     * @function module:arrayOpsUncurried.filter\n     * @param fn {Function}\n     * @param functor {Array|{filter: {Function}}}\n     * @returns {Array|{filter: {Function}}}\n     */\n    filter = fPureTakesOne('filter'),\n\n    /**\n     * Reduces a foldable (listOps etc.) with passed in functionOps.\n     * @function module:arrayOpsUncurried.reduce\n     * @param fn {Function}\n     * @param functor {Array|{reduce: {Function}}}\n     * @returns {Array|{reduce: {Function}}}\n     */\n    reduce = fPureTakes2('reduce'),\n\n    /**\n     * Reduces a foldable (listOps etc.) from the right with passed in functionOps.\n     * @function module:arrayOpsUncurried.reduceRight\n     * @param fn {Function}\n     * @param functor {Array|{reduceRight: {Function}}}\n     * @returns {Array|{reduceRight: {Function}}}\n     */\n    reduceRight = fPureTakes2('reduceRight'),\n\n    /**\n     * For each on functor (Array|Object|etc.).\n     * @param fn {Function}\n     * @param functor {Array|Object|*}\n     * @return {*|Array|Object} - The type of objectOps you pass in unless it doesn't have a `forEach` method.\n     * @throws {Error} - When passed in functor doesn't have a `forEach` method.\n     */\n    forEach = fPureTakesOne('forEach'),\n\n    /**\n     * Returns `true` if `fn` (predicate) returns true for at least one item\n     * in functor else returns `false`.\n     * @param fn {Function} - Predicate.\n     * @param functor {Array|Object|*}\n     * @return {*|Array|Object} - The type passed.\n     * @throws {Error} - When passed in objectOps doesn't have a `some` method.\n     */\n    some = fPureTakesOne('some'),\n\n    /**\n     * Returns `true` if `fn` (predicate) returns true for all items in functor else returns `false`.\n     * @param fn {Function} - Predicate.\n     * @param functor {Array|Object|*}\n     * @return {*|Array|Object} - The type passed.\n     * @throws {Error} - When passed in objectOps doesn't have an `every` method.\n     */\n    every = fPureTakesOne('every'),\n\n    /**\n     * Concats/appends all functors onto the end of first functor.\n     * Note:  functors passed in after the first one must be of the same type.\n     * @param functor {Array|Object|*}\n     * @param ...functor {Array|Object|*}\n     * @return {*|Array|Object} - The type passed.\n     * @throws {Error} - When passed in objectOps doesn't have an `every` method.\n     */\n    concat = fPureTakesOneOrMore('concat'),\n\n    /**\n     * Array.prototype.join\n     * @function module:listPrelude.join\n     * @param separator {String|RegExp}\n     * @param arr {Array}\n     * @returns {String}\n     */\n    join = fPureTakesOne('join'),\n\n    /**\n     * Same as Array.prototype.slice\n     * @param separator {String|RegExp}\n     * @param arr{Array}\n     * @returns {Array}\n     */\n    slice = fPureTakes2('slice'),\n\n    /**\n     * Same as Array.prototype.push\n     * @param item {*}\n     * @param arr {Array}\n     * @returns {Number}\n     */\n    push = fPureTakesOneOrMore('push'),\n\n    /**\n     * Reverses an listOps (shimmed if not exists).\n     * @function module:listPrelude.reverse\n     * @return {Array}\n     */\n    reverse = defineReverse();\n","/**\n * @module negate\n */\n\nimport {apply} from './apply';\n\nimport {reverse} from '../jsPlatform/arrayUncurried';\n\nexport const\n\n    negateF = fn => (a, b) => !fn(a, b),\n\n    negateF3 = fn => (a, b, c) => !fn(a, b, c),\n\n    negateF4 = fn => (a, b, c, d) => !fn(a, b, c, d),\n\n    negateF5 = fn => (a, b, c, d, e) => !fn(a, b, c, d, e),\n\n    /**\n     * Negates a javascript-'generic' predicate; `Function<element, index, list>`.\n     * @function module:functionOps.negateP\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    negateP = negateF3,\n\n    /**\n     * Returns a new function which is the dual of `fn` (or the negated version of `fn`).\n     * @function module:functionOps.negateFMany\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    negateFMany = fn => (...args) => !apply(fn, reverse(args));\n","/**\n * Created by elydelacruz on 7/22/2017.\n */\n\n/**\n * Functional `call` functionOps (takes no context).\n * @function module:functionOps.call\n * @param fn {Function}\n * @param args {*}\n * @returns {*}\n */\nexport {call} from '../jsPlatform/functionUncurried';\n","import {reduceRight} from '../jsPlatform/arrayUncurried';\n\n/**\n * Composes all functions passed in from right to left passing each functions return value to\n * the functionOps on the left of itself.\n * @function module:fjl.compose\n * @type {Function}\n * @param args {...Function}\n * @returns {Function}\n */\nexport const compose = (...args) => arg0 => reduceRight((value, fn) => fn(value), arg0, args);\n","/**\n * @author elydelacruz\n * @created 12/6/2016.\n * @module curry\n * @description Curry strict and curry arbitrarily functions `curry` and `curryN`.\n */\n\nimport {apply} from './apply';\n\nimport {append, length} from   '../listOps/listOpsUncurried';\n\nexport const\n\n    /**\n     * Curries a functionOps based on it's defined arity (argument's arrayOps expected length).\n     * @function curry\n     * @param fn {Function}\n     * @param argsToCurry {...*}\n     * @returns {Function}\n     */\n    curry = (fn, ...argsToCurry) => {\n        return (...args) => {\n            const concatedArgs = append(argsToCurry, args);\n            return length(concatedArgs) < length(fn) ?\n                apply(curry, append([fn], concatedArgs)) :\n                apply(fn, concatedArgs);\n        };\n    },\n\n    /**\n     * Curries a functionOps up to a given arity.\n     * @function curryN\n     * @param executeArity {Number}\n     * @param fn {Function}\n     * @param curriedArgs {...*}\n     * @returns {Function}\n     */\n    curryN = (executeArity, fn, ...curriedArgs) => {\n        return (...args) => {\n            let concatedArgs = append(curriedArgs, args),\n                canBeCalled = (length(concatedArgs) >= executeArity) || !executeArity;\n            return !canBeCalled ? apply(curryN, append([executeArity, fn], concatedArgs)) :\n                apply(fn, concatedArgs);\n        };\n    },\n\n    /**\n     * Curries a functionOps up to an arity of 2 (won't call functionOps until 2 or more args).\n     * @function curry2\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry2 = fn => curryN(2, fn),\n\n    /**\n     * Curries a functionOps up to an arity of 3 (won't call functionOps until 3 or more args).\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry3 = fn => curryN(3, fn),\n\n    /**\n     * Curries a functionOps up to an arity of 4 (won't call functionOps until 4 or more args).\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry4 = fn => curryN(4, fn),\n\n    /**\n     * Curries a functionOps up to an arity of 5 (won't call functionOps until 5 or more args).\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry5 = fn => curryN(5, fn);\n","/**\n * @author elydelacruz\n * @created 12/6/2016.\n * @file fjl-curry/src/curry.js\n * @module curry {{curry: Function, curryN: Function, curry2: Function, curry3: Function, curry4: Function, curry5: Function, curry_: Function, curryN_: Function, curry2_: Function, curry3_: Function, curry4_: Function, curry5_: Function}}\n * @description Different curry implementations for modern javascript currying.\n * @todo Make code here more minimal (reuse small parts here).\n */\n\nimport {apply} from './apply';\n\nimport {append, map, filter, length} from   '../listOps/listOpsUncurried';\n\n/**\n * PlaceHolder (__) constructor.\n * @constructor PlaceHolder\n * @private\n */\nconst PlaceHolder = function PlaceHolder() {},\n\n    /**\n     * Placeholder instance.\n     * @type {PlaceHolder}\n     */\n    placeHolderInstance = new PlaceHolder();\n\n/**\n * Checks to see if value is a `PlaceHolder`.\n * @function isPlaceHolder\n * @param instance {*}\n * @returns {boolean}\n */\nfunction isPlaceHolder (instance) {\n    return instance instanceof PlaceHolder;\n}\n\n/**\n * Replaces `placeholder` values in `listOps`.\n * @function replacePlaceHolder\n * @param array {Array} - Array to replace placeholders in.\n * @param args {Array} - Args from to choose from to replace placeholders.\n * @returns {Array|*} - Returns passed in `listOps` with placeholders replaced by values in `args`.\n */\nfunction replacePlaceHolders (array, args) {\n    let out = map(element => {\n            if (!isPlaceHolder(element)) { return element; }\n            else if (length(args)) { return args.shift(); }\n            return element;\n        }, array);\n    return length(args) ? append(out, args) : out;\n}\n\n/**\n * Curries passed in functionOps up to given arguments length (can enforce arity via placeholder values (`__`)).\n * @function curry_\n * @param fn {Function}\n * @param argsToCurry {...*}\n * @returns {Function}\n */\nexport function curry_ (fn, ...argsToCurry) {\n    return (...args) => {\n        let concatedArgs = replacePlaceHolders(argsToCurry, args),\n            placeHolders = filter(isPlaceHolder, concatedArgs),\n            canBeCalled = length(placeHolders) === 0 &&\n                length(concatedArgs) >= length(fn);\n        return canBeCalled ? apply(fn, concatedArgs) :\n            apply(curry_, append([fn], concatedArgs));\n    };\n}\n\n/**\n * Curries a functionOps up to given arity also enforces arity via placeholder values (`__`).\n * @function curryN_\n * @param executeArity {Number}\n * @param fn {Function}\n * @param curriedArgs {...*} - Allows `Placeholder` (`__`) values.\n * @returns {Function} - Passed in functionOps wrapped in a functionOps for currying.\n */\nexport function curryN_ (executeArity, fn, ...curriedArgs) {\n    return (...args) => {\n        let concatedArgs = replacePlaceHolders(curriedArgs, args),\n            placeHolders = filter(isPlaceHolder, concatedArgs),\n            canBeCalled = (length(concatedArgs) - length(placeHolders) >= executeArity) || !executeArity;\n        return !canBeCalled ?\n            apply(curryN_, append([executeArity, fn], concatedArgs)) :\n            apply(fn, concatedArgs);\n    };\n}\n\n/**\n * Place holder object (frozen) used by curry.\n * @type {PlaceHolder}\n */\nexport let __ = Object.freeze ? Object.freeze(placeHolderInstance) : placeHolderInstance,\n\n    /**\n     * Curries a functionOps up to an arity of 2 (takes into account placeholders `__` (arity enforcers)) (won't call functionOps until 2 or more args).\n     * @function curry2_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry2_ = fn => curryN_(2, fn),\n\n    /**\n     * Curries a functionOps up to an arity of 3 (takes into account placeholders `__` (arity enforcers)) (won't call functionOps until 3 or more args).\n     * @function curry3_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry3_ = fn => curryN_(3, fn),\n\n    /**\n     * Curries a functionOps up to an arity of 4 (takes into account placeholders `__` (arity enforcers))  (won't call functionOps until 4 or more args).\n     * @function curry4_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry4_ = fn => curryN_(4, fn),\n\n    /**\n     * Curries a functionOps up to an arity of 5  (takes into account placeholders `__` (arity enforcers))  (won't call functionOps until 5 or more args).\n     * @function curry5_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry5_ = fn => curryN_(5, fn)\n\n;\n","/**\n * @module id\n */\n\n/**\n * Returns passed in parameter.\n * @param x {*}\n * @returns {*}\n */\nexport const id = x => x;\n","/**\n * @module functionOpsUncurried\n */\nexport * from './apply';\nexport * from './call';\nexport * from './compose';\nexport * from './curry';\nexport * from './curry_';\nexport * from './flip';\nexport * from './id';\nexport * from './negate';\nexport * from './until';\n","export const\n\n    /**\n     * Returns whether `value` is 'truthy' or not\n     * @function module:booleanOps.isTruthy\n     * @param value\n     * @returns {Boolean}\n     */\n    isTruthy = value => !!value,\n\n    /**\n     * Returns whether `value` is 'falsy' or not\n     * @function module:booleanOps.isFalsy\n     * @param value\n     * @returns {Boolean}\n     */\n    isFalsy = value => !value;\n","/**\n * Created by elyde on 7/15/2017.\n * @module booleanOps\n */\n\nimport {curry2} from  '../functionOps/curry';\n\nexport {isTruthy, isFalsy} from './is';\n\nexport const\n\n    /**\n     * Returns `true`.\n     * @function module:booleanOps.alwaysTrue\n     * @returns {Boolean}\n     */\n    alwaysTrue = () => true,\n\n    /**\n     * Returns `false`.\n     * @function module:booleanOps.alwaysFalse\n     * @returns {Boolean}\n     */\n    alwaysFalse = () => false,\n\n    /**\n     * Returns whether both values are truthy or not.\n     * @function module:booleanOps.bAnd\n     * @param a {*}\n     * @param b {*}\n     * @returns {Boolean}\n     */\n    bAnd = curry2((a, b) => a && b),\n\n    /**\n     * Returns whether one of the two passed in values\n     *  are truthy or not.\n     * @function module:booleanOps.bOr\n     * @param a {*}\n     * @param b {*}\n     * @returns {Boolean}\n     */\n    bOr = curry2((a, b) => a || b),\n\n    /**\n     * Returns whether passed in value is truthy or not.\n     * @function module:booleanOps.bNot\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    bNot = x => !x,\n\n    /**\n     * Returns `true` - Makes code more readable in places.\n     * @tentative\n     * @function module:booleanOps.otherwise\n     * @returns {Boolean} - Always true\n     */\n    bOtherwise = alwaysTrue,\n\n    /**\n     * Returns whether both values passed in are equal or not.\n     * @function module:booleanOps.bEqual\n     * @param a {*}\n     * @param b {*}\n     * @returns {Boolean}\n     */\n    bEqual = curry2((a, b) => a === b);\n","/**\n *\n */\n\nexport const prop = (name, obj) => obj[name];\n","/**\n * Created by elyde on 12/18/2016.\n */\nconst _Number = Number.name,\n    _NaN = 'NaN',\n    _Null = 'Null',\n    _Undefined = 'Undefined',\n    _undefined = 'undefined';\n\n/**\n * Returns the class name of an object from it's class stringOps.\n * @note Returns 'NaN' if value `isNaN` and value type is 'Number'.\n * @function module:fjl.typeOf\n * @param value {*}\n * @returns {string} - Constructor's name property if not null or undefined (in which case a\n *  name representing those types is returned ('Null' and or 'Undefined' (es6 compliant))).\n */\nexport function typeOf (value) {\n    let retVal;\n    if (typeof value === _undefined) {\n        retVal = _Undefined;\n    }\n    else if (value === null) {\n        retVal = _Null;\n    }\n    else {\n        let constructorName = (value).constructor.name;\n        retVal = constructorName === _Number && isNaN(value) ?\n            _NaN : constructorName;\n    }\n    return retVal;\n}\n","/**\n * Created by elydelacruz on 7/22/2017.\n */\n\n/**\n * Functional, uncurried 'instanceof'.\n * @returns {Boolean}\n */\nexport {instanceOf} from '../jsPlatform/objectUncurried';\n","/**\n * Created by elydelacruz on 7/22/2017.\n */\n\nimport {curry} from   '../functionOps/curry';\n\nimport {instanceOf as pureInstanceOf} from '../uncurried/objectOps/instanceOf';\n\nexport const\n\n    /**\n     * Returns whether constructor has derived objectOps.\n     * @instanceConstructor {Function|Class}\n     * @instance {*}\n     * @returns {Boolean}\n     */\n    instanceOf = curry(pureInstanceOf);\n","/**\n * Created by elyde on 12/18/2016.\n * @module is\n * @todo remove `isset`, `isEmpty` and `notEmptyAndOfType`\n */\nimport {curry} from   '../functionOps/curry';\nimport {typeOf} from './typeOf';\nimport {instanceOf} from './instanceOf';\nimport {length, keys, hasOwnProperty} from '../uncurried/jsPlatform/objectUncurried';\n\nlet _String = String.name,\n    _Number = Number.name,\n    _Object = Object.name,\n    _Boolean = Boolean.name,\n    _Function = Function.name,\n    _Array = Array.name,\n    _Symbol = 'Symbol',\n    _Map = 'Map',\n    _Set = 'Set',\n    _WeakMap = 'WeakMap',\n    _WeakSet = 'WeakSet',\n    _Null = 'Null',\n    _Undefined = 'Undefined';\n\nexport const\n\n    /**\n     * Returns whether a value is a functionOps or not.\n     * @function module:is.isFunction\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isFunction = instanceOf(Function),\n\n    /**\n     * Type checker.  Note** The `Type` passed in, if a constructor, should\n     * be a named constructor/functionOps-instance;  E.g.,\n     * ```\n     *  functionOps SomeName () {} // or\n     *  var SomeName = functionOps SomeName () {} // or\n     *  class SomeName {}\n     * ```\n     * @function module:fjl.isType\n     * @param Type {Function|String} - Constructor or constructor name\n     * @param value {*}\n     * @return {Boolean}\n     */\n    isType = curry((type, obj) => typeOf(obj) === (isFunction(type) ? type.name : type)),\n\n    /**\n     * Checks if `value` is an es2015 `class`.\n     * @function module:is.isClass\n     * @param x {*}\n     * @returns {boolean}\n     */\n    isClass = x => x && /^\\s{0,3}class\\s{1,3}/.test(x.toString().substr(0, 10)),\n\n    /**\n     * Returns a booleanOps depicting whether a value is callable or not.\n     * @function module:is.isCallable\n     * @tentative\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isCallable = x => isFunction(x) && !isClass(x),\n\n    /**\n     * Checks if value is an arrayOps.\n     * @function module:is.isArray\n     * @param value {*}\n     * @returns {boolean}\n     */\n    isArray = isType(Array),\n\n    /**\n     * Checks whether value is an objectOps or not.\n     * @function module:is.isObject\n     * @param value\n     * @returns {Boolean}\n     */\n    isObject = isType(_Object),\n\n    /**\n     * Checks if value is a booleanOps.\n     * @function module:is.isBoolean\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isBoolean = isType(_Boolean),\n\n    /**\n     * Checks if value is a valid numberOps (also checks if isNaN so that you don't have to).\n     * @function module:is.isNumber\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isNumber = isType(_Number),\n\n    /**\n     * Checks whether value is a stringOps or not.\n     * @function module:is.isString\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isString = isType(_String),\n\n    /**\n     * Checks whether value is of `Map` or not.\n     * @function module:is.isMap\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isMap = isType(_Map),\n\n    /**\n     * Checks whether value is of `Set` or not.\n     * @function module:is.isSet\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isSet = isType(_Set),\n\n    /**\n     * Checks whether value is of `WeakMap` or not.\n     * @function module:is.isWeakMap\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isWeakMap = isType(_WeakMap),\n\n    /**\n     * Checks whether value is of `WeakSet` or not.\n     * @function module:is.isWeakSet\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isWeakSet = isType(_WeakSet),\n\n    /**\n     * Checks if value is undefined.\n     * @function module:is.isUndefined\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isUndefined = isType(_Undefined),\n\n    /**\n     * Checks if value is null.\n     * @function module:is.isNull\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isNull = isType(_Null),\n\n    /**\n     * Checks if value is a `Symbol`.\n     * @function module:is.isSymbol\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isSymbol = isType(_Symbol),\n\n    /**\n     * @tentative\n     */\n    isPromise = isType('Promise'),\n\n    /**\n     * Checks if given `x` is one of the four\n     * \"usable\" immutable JS primitives; I.e.,\n     *  One of [String, Boolean, Number, Symbol]\n     * @function module:is.isUsableImmutablePrimitive\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isUsableImmutablePrimitive = x => {\n        const typeOfX = typeOf(x);\n        return [_String, _Number, _Boolean, _Symbol]\n            .some(Type => Type === typeOfX);\n    },\n\n    /**\n     * Checks if !length.\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isEmptyList = x => length(x) === 0,\n\n    /**\n     * Checks if objectOps has own properties/enumerable-props or not.\n     * @param obj {*}\n     * @returns {Boolean}\n     */\n    isEmptyObject = obj => isEmptyList(keys(obj)),\n\n    /**\n     * Checks if collection is empty or not (Map, WeakMap, WeakSet, Set etc.).\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isEmptyCollection = x => x.size === 0,\n\n    /**\n     * Checks to see if passed in argument is empty.\n     * @function module:is.empty\n     * @param value {*} - Value to check.\n     * @returns {Boolean}\n     */\n    isEmpty = value => {\n        let typeOfValue = typeOf(value),\n            retVal;\n\n        if (!value) { // '', 0, `null`, `undefined` or `false` then is empty\n            retVal = true;\n        }\n        else if (typeOfValue === _Array || typeOfValue === _Function) {\n            retVal = isEmptyList(value);\n        }\n        else if (typeOfValue === _Number && value !== 0) {\n            retVal = false;\n        }\n        else if (typeOfValue === _Object) {\n            retVal = isEmptyObject(value);\n        }\n        else if (hasOwnProperty('size', value)) {\n            retVal = isEmptyCollection(value);\n        }\n        else {\n            retVal = !value;\n        }\n        return retVal;\n    },\n\n    /**\n     * Returns true if an element is not empty and is of type.\n     * @function module:is.notEmptyAndOfType\n     * @param type {String|Function} - Type to check against (stringOps name or actual constructor).\n     * @param value {*} - Value to check.\n     * @returns {Boolean}\n     */\n    notEmptyAndOfType = curry((type, value) => !isEmpty(value) && isType(type, value)),\n\n    /**\n     * Returns whether passed in values is defined and not null.\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isset = x => !isNull(x) && !isUndefined(x);\n","/**\n * Created by elydelacruz on 7/22/2017.\n * @memberOf functionOps\n */\nimport {curry} from './curry';\n\nimport {apply as pureApply} from '../uncurried/jsPlatform/functionUncurried';\n\nexport const\n\n    /**\n     * Functional `apply` functionOps (takes no context).\n     * @function module:functionOps.apply\n     * @param fn {Function}\n     * @param args {*}\n     * @returns {*}\n     */\n    apply = curry(pureApply);\n","import {isFunction, isUsableImmutablePrimitive, isset} from './is';\nimport {hasOwnProperty} from '../uncurried/jsPlatform/objectUncurried';\nimport {apply} from   '../functionOps/apply';\n\nexport const of = (x, ...args) => {\n    if (!isset(x)) { return undefined; }\n    const constructor = x.constructor;\n    if (hasOwnProperty('of', constructor)) {\n        return apply(constructor.of, args);\n    }\n    else if (isUsableImmutablePrimitive(x)) {\n        return apply(constructor, args);\n    }\n    else if (isFunction(constructor)) {\n        return new constructor(...args);\n    }\n    return undefined;\n};\n","import {typeOf} from  '../objectOps/objectOpsUncurried';\n\nexport const\n\n    aggregateStr = (agg, item) => agg + item,\n\n    aggregateArr = (agg, item) => {\n        agg.push(item);\n        return agg;\n    },\n\n    aggregateObj = (agg, item, ind) => {\n        agg[ind] = item;\n        return agg;\n    },\n\n    aggregatorByType = x => {\n        switch (typeOf(x)) {\n            case 'String': return aggregateStr;\n            case 'Array': return aggregateArr;\n            case 'Object':\n            default: return aggregateObj;\n        }\n    };\n","import {of} from   '../../objectOps/of';\n\nimport {aggregatorByType}   from './listOpsUncurriedAggregation';\n\nimport {length}              from '../jsPlatform/objectUncurried';\n\n/**\n * @function module:listOps.map\n * @param fn {Function} - Function to map on functor item(s).\n * @param xs {Array|String|*} - Functor.\n * @returns {Array|String|*} - Functor type that is passed in.\n */\nexport const map = (fn, xs) => {\n    let ind = 0,\n        limit = length(xs),\n        out = of(xs),\n        aggregate = aggregatorByType(xs);\n    if (!limit) { return out; }\n    for (; ind < limit; ind += 1) {\n        out = aggregate(out, fn(xs[ind], ind, xs), ind, xs);\n    }\n    return out;\n};\n","/**\n * Array operators module.\n * @module listOpsUtils\n */\nimport {apply}              from '../jsPlatform/functionUncurried';  // un-curried version\nimport {slice}              from '../jsPlatform/listUncurried';      // un-curried version good for both strings and arrays\nimport {length}             from '../jsPlatform/objectUncurried';\nimport {alwaysFalse}        from   '../../booleanOps/booleanOps';\nimport {map}                from './map';\n\nexport * from './listOpsUncurriedAggregation';\n\nexport const\n\n    /**\n     * Returns a slice of the given list from `startInd` to the end of the list.\n     * @param startInd {Number}\n     * @param arr {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    sliceFrom = (startInd, arr) => slice(startInd, length(arr), arr),\n\n    /**\n     * Slices from index `0` to given index.\n     * @module module:listOpsUncurried.sliceTo\n     * @param toInd {Number}\n     * @param xs {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    sliceTo = (toInd, xs) => slice(0, toInd, xs),\n\n    /**\n     * Slices a copy of list.\n     * @param xs {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    copy = xs => sliceFrom(0, xs),\n\n    genericAscOrdering = (a, b) => {\n        if (a > b) { return 1; }\n        else if (a < b) { return -1; }\n        return 0;\n    },\n\n    /**\n     * Returns length of all passed lists in list.\n     * @param lists ...{Array|String|*}\n     * @returns {Array|String|*}\n     */\n    lengths = (...lists) => length(lists) ? map(length, lists) : [],\n\n    lengthsToSmallest = (...lists) => {\n        const listLengths = apply(lengths, lists),\n            smallLen = Math.min.apply(Math, listLengths);\n        return map((list, ind) => listLengths[ind] > smallLen ?\n            sliceTo(smallLen, list) : copy(list), lists);\n    },\n\n    reduceUntil = (pred, op, agg, arr) => {\n        const limit = length(arr);\n        if (!limit) { return agg; }\n        let ind = 0,\n            result = agg;\n        for (; ind < limit; ind++) {\n            if (pred(arr[ind], ind, arr)) { break; }\n            result = op(result, arr[ind], ind, arr);\n        }\n        return result;\n    },\n\n    reduceRightUntil = (pred, op, agg, arr) => {\n        const limit = length(arr);\n        if (!limit) { return agg; }\n        let ind = limit - 1,\n            result = agg;\n        for (; ind >= 0; ind--) {\n            if (pred(arr[ind], ind, arr)) { break; }\n            result = op(result, arr[ind], ind, arr);\n        }\n        return result;\n    },\n\n    reduce = (operation, agg, arr) =>\n        reduceUntil(\n            alwaysFalse,            // predicate\n            operation,              // operation\n            agg,                    // aggregator\n            arr),                   // list\n\n    reduceRight = (operation, agg, arr) =>\n        reduceRightUntil(\n            alwaysFalse,            // predicate\n            operation,              // operation\n            agg,                    // aggregator\n            arr),                   // list\n\n    /**\n     * Gets last index of a list/list-like (Array|String|Function etc.).\n     * @function module:listOps.lastIndex\n     * @param x {Array|String|*} - list like or list.\n     * @returns {Number} - `-1` if no element found.\n     */\n    lastIndex = x => { const len = length(x); return len ? len - 1 : 0; },\n\n    /**\n     * Finds index in string or list.\n     * @function module:listOps.findIndexWhere\n     * @param pred {Function} - Predicate<element, index, arr>.\n     * @param arr {Array|String}\n     * @returns {Number} - `-1` if predicate not matched else `index` found\n     */\n    findIndexWhere = (pred, arr) => {\n        let ind = -1,\n            predicateFulfilled = false;\n        const limit = length(arr);\n        while (ind < limit && !predicateFulfilled) {\n            predicateFulfilled = pred(arr[++ind], ind, arr);\n        }\n        return ind;\n    },\n\n    /**\n     * Finds index in list from right to left.\n     * @function module:listOps.findIndexWhereRight\n     * @param pred {Function} - Predicate<element, index, arr>.\n     * @param arr {Array|String}\n     * @returns {Number} - `-1` if predicate not matched else `index` found\n     */\n    findIndexWhereRight = (pred, arr) => {\n        const limit = length(arr);\n        let ind = limit,\n            predicateFulfilled = false;\n        for (; ind >= 0 && !predicateFulfilled; --ind) {\n            predicateFulfilled = pred(arr[ind], ind, arr);\n        }\n        return ind;\n    },\n\n    /**\n     * @param pred {Function}\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {Array|undefined}\n     */\n    findIndicesWhere = (pred, xs) => {\n        const limit = length(xs);\n        if (!limit) { return undefined; }\n        let ind = 0,\n            out = [];\n        for (; ind < limit; ind++) {\n            if (pred(xs[ind], ind, xs)) { out.push(ind); }\n        }\n        return out;\n    },\n\n    /**\n     * @function module:listOps.find\n     * @param pred {Function}\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {*}\n     */\n    findWhere = (pred, xs) => {\n        let ind = 0,\n            limit = length(xs);\n        if (!limit) { return; }\n        for (; ind < limit; ind++) {\n            let elm = xs[ind];\n            if (pred(elm, ind, xs)) { return elm; }\n        }\n    }\n;\n","/**\n * 'Uncurried' list operators.\n * @module listOpsUncurried\n * @todo decide whether to throw errors where functions cannot function without a specific type or to return undefined (and also determine which cases are ok for just returning undefined).\n * @todo code unperformant shorthand in `listOps`\n * @todo rename monoid functions to normal functions since we are not really defining methods for monoids here.\n */\nimport {\n    concat as listAppend,\n    indexOf, slice, includes\n} from '../jsPlatform/listUncurried';\nimport {apply} from '../jsPlatform/functionUncurried';\nimport {negateF} from '../functionOps/negate';\nimport {negateP} from '../functionOps/functionOpsUncurried';\nimport {isTruthy, isFalsy} from '../../booleanOps/booleanOps';\nimport {isString, prop, of, length} from '../objectOps/objectOpsUncurried';\nimport {map} from './map';\n\nimport {\n    sliceFrom, sliceTo, lengths,\n    lengthsToSmallest, aggregateArr, aggregatorByType,\n    reduceUntil, reduce, reduceRight, lastIndex,\n    findIndexWhere, findIndexWhereRight, findIndicesWhere,\n    findWhere, copy, genericAscOrdering\n} from './listOpsUncurriedUtils';\n\n// Exported imports\nexport {length, map};\n\n// Exported internals\nexport const\n\n    /**\n     * Append two lists, i.e.,\n     * ```\n     * append([x1, ..., xm], [y1, ..., yn]) // outputs: [x1, ..., xm, y1, ..., yn]\n     * append([x1, ..., xm], [y1, ...]) // outputs: [x1, ..., xm, y1, ...]\n     * ```\n     * If the first list is not finite, the result is the first list.\n     * @haskellType `append :: List a => a -> a -> a`\n     * @function module:listOpsUncurried.append\n     * @param xs1 {Array|String|*} - list or list like.\n     * @param xs2 {Array|String|*} - list or list like.\n     * @returns {Array|String|*} - Same type as list like passed in.\n     */\n    append = listAppend,\n\n    /**\n     * Append two or more lists, i.e., same as `append` but for two ore more lists.\n     * @haskellType `appendMany :: List a => a -> [a] -> a\n     * @note In `@haskellType` we wrote `[a]` only to keep the haskell type valid though note in javascript\n     *  this is actually different since the function converts the zero ore more parameters into an array containing such for us.\n     * @function module:listOpsUncurried.appendMany\n     * @param args ...{Array|String|*} - Lists or lists likes.\n     * @returns {Array|String|*} - Same type as first list or list like passed in.\n     */\n    appendMany = (...args) => {\n        if (length(args)) { return apply(listAppend, args); }\n        throw new Error('`appendMany` requires at least one arg.');\n    },\n\n    /**\n     * Returns head of list (first item of list).\n     * @haskellType `head :: [a] -> a`\n     * @function module:listOpsUncurried.head\n     * @param x {Array|String}\n     * @returns {*} - First item from list\n     */\n    head = x => x[0],\n\n    /**\n     * Returns last item of list.\n     * @haskellType `last :: [a] -> a`\n     * @function module:listOpsUncurried.last\n     * @param xs {Array|String}\n     * @returns {*}\n     */\n    last = xs => xs[lastIndex(xs)],\n\n    /**\n     * Returns tail part of list (everything after the first item as new list).\n     * @haskelType `tail :: [a] -> [a]`\n     * @function module:listOpsUncurried.tail\n     * @param xs {Array}\n     * @returns {Array}\n     */\n    tail = xs => sliceFrom(1, xs),\n\n    /**\n     * Returns everything except last item of list as new list.\n     * @haskellType `init :: [a] -> [a]`\n     * @function module:listOpsUncurried.init\n     * @param xs {Array|String}\n     * @returns {Array|String}\n     */\n    init = xs => sliceTo(lastIndex(xs), xs),\n\n    /**\n     * Returns `head` and `tail` of passed in list/string in a tuple.\n     * @haskellType `uncons :: [a] -> Maybe (a, [a])`\n     * @function module:listOpsUncurried.uncons\n     * @param xs {Array|String}\n     * @returns {Array|String|*|undefined}\n     */\n    uncons = xs => {\n        if (!xs) {\n            return;\n        }\n        if (length(xs) === 0) {\n            return undefined;\n        }\n        return [head(xs), tail(xs)];\n    },\n\n    /**\n     * Returns `tail` and `head` of passed in list/string in a tuple.\n     * @haskellType `unconsr :: [a] -> Maybe ([a], a)`\n     * @function module:listOpsUncurried.unconsr\n     * @param xs {Array|String}\n     * @returns {Array|String|*|undefined}\n     */\n    unconsr = xs => {\n        if (!xs) {\n            return;\n        }\n        if (length(xs) === 0) {\n            return undefined;\n        }\n        return [init(xs), last(xs)];\n    },\n\n    /**\n     * Returns whether a list is empty or not.\n     * @note not to be mistaken with module:objectOps.isEmpty;\n     *  `objectOps.isEmpty` Checks any passed in type for empty;\n     *  `listOps.isEmpty` only checks if length on passed in\n     *  value is not truthy.\n     *  In typed languages this would be all we\n     *  need do due to assuming that only lists make it into our\n     *  function but in javascript this is loose and in order\n     *  to the function to perform well under load and\n     *  for it to follow the specification we are not allowed\n     *  to type check in it.\n     * @note Will keep it like this for now.\n     * @function module:listOpsUncurried.isEmpty\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isEmpty = x => !length(x),\n\n    /**\n     * Concatenates all the elements of a container of lists.\n     * @haskellType `concat :: Foldable t => t [a] -> [a]`\n     * @function module:listOpsUncurried.concat\n     * @param xs {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    concat = xs => {\n        if (!length(xs)) { return copy(xs); }\n        return isString(xs) ? xs : apply(appendMany, xs);\n    },\n\n    /**\n     * Map a function over all the elements of a container and concatenate the resulting lists.\n     * @haskellType `concatMap :: Foldable t => (a -> [b]) -> t a -> [b]`\n     * @function module:listOpsUncurried.concatMap\n     * @param fn {Function}\n     * @param foldableOfA {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    concatMap = (fn, foldableOfA) => concat(map(fn, foldableOfA)),\n\n    /**\n     * Returns a copy of the passed in list reverses.\n     * @haskellType `reverse :: [a] -> [a]`\n     * @function module:listOpsUncurried.reverse\n     * @param x {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    reverse = x => {\n        const aggregator = aggregatorByType(x);\n        return reduceRight(\n            (agg, item, ind) => aggregator(agg, item, ind),\n            of(x), x\n        );\n    },\n\n    /**\n     * Takes an element and a list and `intersperses' that element between the elements of the list. For example\n     * @function module:listOpsUncurried.intersperse\n     * @note In our version of the function javascript is loosely typed so, so is our function (to much overhead to make\n     *  it typed) so `between` can be any value.\n     * @param between {*} - Should be of the same type of elements contained in list.\n     * @param arr {Array|String|*} - List.\n     * @returns {Array|String|*}\n     */\n    intersperse = (between, arr) => {\n        const limit = length(arr),\n            lastInd = limit - 1,\n            aggregator = of(arr),\n            aggregatorOp = aggregatorByType(arr);\n        if (!limit) {\n            return aggregator;\n        }\n        return foldl((agg, item, ind) => {\n            return ind === lastInd ?\n                aggregatorOp(agg, item) :\n                aggregatorOp(\n                    aggregatorOp(agg, item),\n                    between\n                );\n        }, aggregator, arr);\n    },\n\n    /**\n     * `intercalate xs xss` is equivalent to (concat (intersperse xs xss)). It inserts the list xs in between the lists in xss and concatenates the result.\n     * @haskellType `intercalate :: [a] -> [[a]] -> [a]`\n     * @function module:listOpsUncurried.intercalate\n     * @param xs {Array|String|*}\n     * @param xss {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    intercalate = (xs, xss) => concat(intersperse(xs, xss)),\n\n    /**\n     * Transposes rows and columns into lists by index;  E.g.,\n     * Haskell example:\n     * ```\n     *  transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]\n     *\n     *  -- Notice the shorter arrays are ignored after their last index is copied over:\n     *  transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]\n     * ```\n     * @note from columns to rows.\n     * @note Empty lists are ignored.\n     * @todo upgrade this function to support lists of strings.\n     * @haskellType `transpose :: [[a]] -> [[a]]`\n     * @function module:listOpsUncurried.transpose\n     * @param xss {Array}\n     * @returns {Array}\n     */\n    transpose = xss => {\n        let numLists = length(xss),\n            ind = 0, ind2;\n        if (!numLists) {\n            return of(xss);\n        }\n        const listLengths = apply(lengths, xss),\n            longestListLen = maximum(listLengths),\n            outLists = [];\n        for (; ind < longestListLen; ind += 1) {\n            const outList = [];\n            for (ind2 = 0; ind2 < numLists; ind2 += 1) {\n                if (listLengths[ind2] < ind + 1) {\n                    continue;\n                }\n                outList.push(xss[ind2][ind]);\n            }\n            outLists.push(outList);\n        }\n        return filter(x => length(x), outLists);\n    },\n\n    /**\n     * Generates 2^n sub-sequences for passed in sequence (string/list) (`n` is\n     * the length of the passed in sequence so: 2^length(xs)).\n     * Note: The return value doubles per index/character passed in so use with caution!\n     *  Also note that for 2^16 (or for a sequence of 16 characters) this algorithm\n     *  will generate 65536 sub-sequences!  So caution should be taken to not\n     *  use this with sequences above a certain length on certain platform (the browser thread in specific).\n     * @function module:listOpsUncurried.subsequences\n     * @param xs {Array|String}\n     * @returns {Array}\n     */\n    subsequences = xs => {\n        const len = Math.pow(2, length(xs)),\n            out = [];\n        for (let i = 0; i < len; i += 1) {\n            const entry = [];\n            for (let j = 0; j < len; j += 1) {\n                if (i & (1 << j)) {\n                    entry.push(xs[j]);\n                }\n            }\n            out.push(entry);\n        }\n        return out;\n    },\n\n    permutations = xs => [xs],\n\n    foldl = reduce,\n\n    foldr = reduceRight,\n\n    foldl1 = (op, xs) => {\n        const parts = uncons(xs);\n        if (!parts) {\n            return of(xs);\n        }\n        return reduce(op, parts[0], parts[1]);\n    },\n\n    foldr1 = (op, xs) => {\n        const parts = unconsr(xs);\n        if (!parts) {\n            return of(xs);\n        }\n        return reduceRight(op, parts[1], parts[0]);\n    },\n\n    /**\n     * Performs a map then a reduce all in one (from left-to-right). Returns a tuple\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\n     * @function module:listOpsUncurried.mapAccumL\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\n     * @param xs {Array|String|*} - list type.\n     * @return {Array} - [aggregated, list]\n     */\n    mapAccumL = (op, zero, xs) => {\n        const list = sliceFrom(0, xs),\n            limit = length(xs);\n        if (!limit) {\n            return [zero, list];\n        }\n        let ind = 0,\n            agg = zero,\n            mapped = of(xs),\n            tuple;\n        for (; ind < limit; ind++) {\n            tuple = op(agg, list[ind], ind);\n            agg = tuple[0];\n            mapped = tuple[1];\n        }\n        return [agg, mapped];\n    },\n\n    /**\n     * Performs a map and a reduce all in one (from right-to-left). Returns a tuple\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\n     * @function module:listOpsUncurried.mapAccumR\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\n     * @param xs {Array|String|*} - list type.\n     * @return {Array} - [aggregated, list]\n     */\n    mapAccumR = (op, zero, xs) => {\n        const list = sliceFrom(0, xs),\n            limit = length(xs);\n        if (!limit) {\n            return [zero, list];\n        }\n        let ind = limit - 1,\n            agg = zero,\n            mapped = of(xs),\n            tuple;\n        for (; ind >= 0; ind--) {\n            tuple = op(agg, list[ind], ind);\n            agg = tuple[0];\n            mapped = tuple[1];\n        }\n        return [agg, mapped];\n    },\n\n    /**\n     * Iterate on value (`x`) with `op` up to `limit`.\n     * @function module:listOpsUncurried.iterate\n     * @param limit {Number}\n     * @param op {Function} - Operation\n     * @param x {*} - Starting point.\n     * @returns {*}\n     */\n    iterate = (limit, op, x) => {\n        let ind = 0,\n            out = x;\n        for (; ind < limit; ind += 1) {\n            out = op(out, ind);\n        }\n        return out;\n    },\n\n    /**\n     * Repeats `x` `limit` number of times\n     * @function module:listOpsUncurried.repeat\n     * @param limit {Number}\n     * @param x {*}\n     * @return {Array}\n     */\n    repeat = (limit, x) =>\n        iterate(limit, agg => {\n            agg.push(x);\n            return agg;\n        }, []),\n\n    /**\n     * Same as `repeat` due to the nature of javascript (see haskell version for usage).\n     * @function module:listOpsUncurried.replicate\n     * @param limit {Number}\n     * @param x {*}\n     * @return {Array}\n     */\n    replicate = repeat,\n\n    /**\n     * Replicates a list `limit` number of times and appends the results (concat)\n     * @function module:listOpsUncurried.cycle\n     * @param limit {Number}\n     * @param xs {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    cycle = (limit, xs) => concat(replicate(limit, xs)),\n\n    /**\n     * Unfolds a value into a list of somethings.\n     * @haskellType `unfoldr :: (b -> Maybe (a, b)) -> b -> [a]`\n     * @function module:listOpsUncurried.unfoldr\n     * @param op {Function} - Operation to perform (should return a two component tuple (item to aggregate and item to unfold in next iteration).\n     * @param x {*} - Starting parameter to unfold from.\n     * @returns {Array} - An array of whatever you return from `op` yielded.\n     */\n    unfoldr = (op, x) => {\n        let ind = 0,\n            out = [],\n            resultTuple = op(x, ind, out);\n        while (resultTuple) {\n            out.push(resultTuple[0]);\n            resultTuple = op(resultTuple[1], ++ind, out);\n        }\n        return out;\n    },\n\n    /**\n     * Finds index in string or list (alias for `findIndex`).\n     * @function module:listOpsUncurried.findIndex\n     * @param pred {Function} - Predicate<element, index, arr>.\n     * @param arr {Array|String}\n     * @returns {Number} - `-1` if predicate not matched else `index` found\n     */\n    findIndex = findIndexWhere,\n\n    /**\n     * @function module:listOpsUncurried.findIndices\n     * @param pred {Function}\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {Array|undefined}\n     */\n    findIndices = findIndicesWhere,\n\n    /**\n     * @function module:listOpsUncurried.elemIndex\n     * @param x {*} - Element to search for.\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {*}\n     */\n    elemIndex = (x, xs) => {\n        const foundInd = indexOf(x, xs);\n        return foundInd !== -1 ? foundInd : undefined;\n    },\n\n    /**\n     * @function module:listOpsUncurried.elemIndices\n     * @param value {*} - Element to search for.\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {*}\n     */\n    elemIndices = (value, xs) => findIndices(x => x === value, xs),\n\n    /**\n     * Takes `n` items from start of list to `limit` (exclusive).\n     * @function module:listOpsUncurried.take\n     * @param list {Array|String}\n     * @param limit {Number}\n     * @returns {String|Array} - Passed in type's type\n     */\n    take = (limit, list) => sliceTo(limit, list),\n\n    /**\n     * Drops `n` items from start of list to `count` (exclusive).\n     * @function module:listOpsUncurried.take\n     * @param list {Array|String}\n     * @param count {Number}\n     * @returns {String|Array} - Passed in type's type\n     */\n    drop = (count, list) => sliceFrom(count, list),\n\n    /**\n     * Splits `x` in two at given `index` (exclusive (includes element/character at\n     * given index in second part of returned list)).\n     * @function module:listOpsUncurried.splitAt\n     * @param ind {Number} - Index to split at.\n     * @param list {Array|String|*} - functor (list or string) to split.\n     * @returns {Array} - Array of whatever type `x` was when passed in\n     */\n    splitAt = (ind, list) => [\n        sliceTo(ind, list),\n        sliceFrom(ind, list)\n    ],\n\n    /**\n     * Gives an list with passed elements while predicate was true.\n     * @function module:listOpsUncurried.takeWhile\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @returns {Array}\n     */\n    takeWhile = (pred, list) => {\n        let zero = of(list);\n        const operation = aggregatorByType(list);\n        return reduceUntil(\n            negateP(pred),  // predicate\n            operation,      // operation\n            zero,           // aggregator\n            list\n        );\n    },\n\n    /**\n     * Returns an list without elements that match predicate.\n     * @function module:listOpsUncurried.dropWhile\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @refactor\n     * @returns {Array|String}\n     */\n    dropWhile = (pred, list) => {\n        const limit = length(list),\n            splitPoint =\n                findIndexWhere((item, ind, list2) =>\n                    !pred(list[ind], ind, list2), list);\n\n        return splitPoint === -1 ?\n            sliceTo(limit, list) :\n            slice(splitPoint, limit, list);\n    },\n\n    /**\n     * @function module:listOpsUncurried.dropWhile\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @refactor\n     * @returns {Array|String}\n     */\n    dropWhileEnd = (pred, list) => {\n        const limit = length(list),\n            splitPoint =\n                findIndexWhereRight((item, ind, list2) =>\n                    !pred(list[ind], ind, list2), list);\n\n        return splitPoint === -1 ?\n            sliceTo(limit, list) :\n            sliceTo(splitPoint + 1, list);\n    },\n\n    /**\n     * Gives a span such that the first list (in returned tuple) is the span of items matching upto `not predicate` and\n     * the second list in the tuple is a list of the remaining elements in the given list.\n     * **@Note: Not the same as `partition`.  Read descriptions closely!!!\n     * @function module:listOpsUncurried.partition\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\n     * @param list {Array|String|*} - Predicate<item, index, originalArrayOrString>\n     * @returns {Array|String|*} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\n     */\n    span = (pred, list) => {\n        const splitPoint = findIndexWhere(negateP(pred), list);\n        return splitPoint === -1 ?\n            splitAt(0, list) : splitAt(splitPoint, list);\n    },\n\n    breakOnList = (pred, list) => {\n        const splitPoint = findIndexWhere(pred, list);\n        return splitPoint === -1 ?\n            splitAt(0, list) : splitAt(splitPoint, list);\n    },\n\n    /**\n     * @function module:listOpsUncurried.at\n     * @param ind {Number} - Index.\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {*}\n     */\n    at = prop,\n\n    /**\n     * @function module:listOpsUncurried.find\n     * @param pred {Function}\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {*}\n     */\n    find = findWhere,\n\n    filter = (pred, xs) => {\n        let ind = 0,\n            limit = length(xs),\n            aggregator = aggregatorByType(xs),\n            out = of(xs);\n        if (!limit) {\n            return out;\n        }\n        for (; ind < limit; ind++) {\n            if (pred(xs[ind], ind, xs)) {\n                out = aggregator(out, xs[ind]);\n            }\n        }\n        return out;\n    },\n\n    /**\n     * Partitions a list on a predicate;  Items that match predicate are in first list in tuple;  Items that\n     * do not match the tuple are in second list in the returned tuple.\n     *  Essentially `[filter(p, xs), filter(negateP(p), xs)]`.\n     * @function module:listOpsUncurried.partition\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\n     * @param list {Array|String|*}\n     * @returns {Array|String} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\n     */\n    partition = (pred, list) => {\n        if (!length(list)) {\n            return [of(list), of(list)];\n        }\n        return [filter(pred, list), filter(negateP(pred), list)];\n    },\n\n    elem = includes,\n\n    notElem = negateF(includes),\n\n    lookup = at,\n\n    isPrefixOf = (xs1, xs2) => {\n        const limit1 = length(xs1),\n            limit2 = length(xs2);\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\n            return false;\n        }\n        let ind = 0;\n        for (; ind < limit1; ind++) {\n            if (xs1[ind] !== xs2[ind]) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    isSuffixOf = (xs1, xs2) => {\n        const limit1 = length(xs1),\n            limit2 = length(xs2);\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\n            return false;\n        }\n        let ind1 = limit1 - 1,\n            ind2 = limit2 - 1;\n        for (; ind1 >= 0; ind1--) {\n            if (xs1[ind1] !== xs2[ind2]) {\n                return false;\n            }\n            ind2 -= 1;\n        }\n        return true;\n    },\n\n    isInfixOf = (xs1, xs2) => {\n        const limit1 = length(xs1),\n            limit2 = length(xs2);\n        if (limit2 < limit1 || !limit1 || !limit2) {\n            return false;\n        }\n        let ind1,\n            foundLen,\n            ind = 0;\n        for (; ind < limit2; ind += 1) {\n            foundLen = 0;\n            for (ind1 = 0; ind1 < limit1; ind1 += 1) {\n                if (xs2[ind1 + ind] === xs1[ind1]) {\n                    foundLen += 1;\n                }\n                if (foundLen === limit1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    },\n\n    isSubsequenceOf = (xs1, xs2) => {\n        const len = Math.pow(2, length(xs2)),\n            lenXs1 = length(xs1);\n        let foundLen,\n            i;\n        for (i = 0; i < len; i += 1) {\n            foundLen = 0;\n            for (let j = 0; j < len; j += 1) {\n                if (i & (1 << j) && indexOf(xs2[j], xs1) > -1) {\n                    foundLen += 1;\n                }\n                if (foundLen === lenXs1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    },\n\n    /**\n     * The group function takes a list and returns a list of lists such that\n     *  the concatenation of the result is equal to the argument. Moreover, each\n     *  sublist in the result contains only equal elements. For example,\n     * `group \"Mississippi\" = [\"M\",\"i\",\"ss\",\"i\",\"ss\",\"i\",\"pp\",\"i\"]`\n     * It is a special case of groupBy, which allows the programmer to supply\n     *  their own equality test.\n     * @haskellType `group :: Eq a => [a] -> [[a]]`\n     * @function module:listOpsUncurried.group\n     * @param xs {Array|String|*}\n     * @returns {Array<Array|String|*>|*}\n     */\n    group = xs => groupBy((a, b) => a === b, xs),\n\n    /**\n     * Allows you to group items in a list based on your supplied equality check.\n     * @note Sames `group` but allows you to specify equality operation.\n     * @haskellType `groupBy :: (a -> a -> Bool) -> [a] -> [[a]]`\n     * @function module:listOpsUncurried.groupBy\n     * @param equalityOp {Function}\n     * @param xs {Array|String|*}\n     * @returns {*}\n     */\n    groupBy = (equalityOp, xs) => {\n        const limit = length(xs);\n        if (!limit) {\n            return sliceFrom(0, xs);\n        }\n        let ind = 0,\n            prevItem,\n            item,\n            predOp = x => {\n                if (equalityOp(x, prevItem)) {\n                    ind++;\n                }\n                if (equalityOp(x, item)) {\n                    prevItem = x;\n                    return true;\n                }\n                return false;\n            },\n            agg = [];\n        for (; ind < limit; ind += 1) {\n            item = xs[ind];\n            agg.push(takeWhile(predOp, slice(ind, limit, xs)));\n        }\n        return agg;\n    },\n\n    inits = xs => {\n        let limit = length(xs),\n            ind = 0,\n            agg = [];\n        if (!limit) {\n            return [];\n        }\n        for (; ind <= limit; ind += 1) {\n            agg = aggregateArr(agg, sliceTo(ind, xs));\n        }\n        return agg;\n    }, //map(list => init(list), xs),\n\n    tails = xs => {\n        let limit = length(xs),\n            ind = 0,\n            agg = [];\n        if (!limit) {\n            return [];\n        }\n        for (; ind <= limit; ind += 1) {\n            agg = aggregateArr(agg, slice(ind, limit, xs));\n        }\n        return agg;\n    }, //map(list => tail(list), xs),\n\n    stripPrefix = (prefix, list) =>\n        isPrefixOf(prefix, list) ?\n            splitAt(length(prefix), list)[1] :\n            sliceFrom(0, list),\n\n    /**\n     * zip takes two lists and returns a list of corresponding pairs.\n     * If one input list is short, excess elements of the longer list are discarded.\n     * @haskellType `zip :: [a] -> [b] -> [(a, b)]`\n     * @function module:listOpsUncurried.zip\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip = (arr1, arr2) => {\n        if (!length(arr1) || !length(arr2)) {\n            return of(arr1);\n        }\n        const [a1, a2] = lengthsToSmallest(arr1, arr2);\n        return reduce((agg, item, ind) =>\n                aggregateArr(agg, [item, a2[ind]]),\n            [], a1);\n    },\n\n    /**\n     * zipN takes one or more lists and returns a list containing lists of all indices\n     * at a given index, index by index.\n     * If one input list is short, excess elements of the longer list are discarded.\n     * @function module:listOpsUncurried.zipN\n     * @param lists {Array|String} - One ore more lists of the same type.\n     * @returns {Array}\n     */\n    zipN = (...lists) => {\n        const trimmedLists = apply(lengthsToSmallest, filter(length, lists)),\n            lenOfTrimmed = length(trimmedLists);\n        if (!lenOfTrimmed) {\n            return [];\n        }\n        else if (lenOfTrimmed === 1) {\n            return sliceTo(length(trimmedLists[0]), trimmedLists[0]);\n        }\n        return reduce((agg, item, ind) =>\n                aggregateArr(agg, map(xs => xs[ind], trimmedLists)),\n            [], trimmedLists[0]);\n    },\n\n    /**\n     * @haskellType `zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]`\n     * @function module:listOpsUncurried.zip3\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @param arr3 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip3 = zipN,\n\n    /**\n     * @haskellType `zip3 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]`\n     * @function module:listOpsUncurried.zip4\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @param arr3 {Array}\n     * @param arr4 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip4 = zipN,\n\n    /**\n     * @haskellType `zip3 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]`\n     * @function module:listOpsUncurried.zip5\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @param arr3 {Array}\n     * @param arr4 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip5 = zipN,\n\n    /**\n     * zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\n     * zipWith generalises zip by zipping with the function given as the\n     * first argument, instead of a function tupling function (function that returns a tuple). For example,\n     * zipWith (+) is applied to two lists to produce the list of corresponding sums.\n     * @note `_|_` means bottom or perpetual (@see\n     *  - https://wiki.haskell.org/Bottom\n     *  - https://stackoverflow.com/questions/19794681/what-does-this-syntax-mean-in-haskell-or\n     *  )\n     * @example\n     * ```\n     * zipWith f [] _|_ = []\n     * ```\n     * @haskellType `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`\n     * @function module:listOpsUncurried.zipWith\n     * @param op {Function} - Takes two parts of a tuple and returns a tuple.\n     *  E.g., ` op :: a -> b -> (a, b)`\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith = (op, xs1, xs2) => {\n        if (!length(xs1) || !length(xs2)) {\n            return of(xs1);\n        }\n        const [a1, a2] = lengthsToSmallest(xs1, xs2);\n        return reduce((agg, item, ind) =>\n                aggregateArr(agg, op(item, a2[ind])),\n            [], a1);\n    },\n\n    /**\n     * Zips all given lists with tupling function. Note: Haskell types do not have\n     *  a way (that I know of) to show one or more for params in a function so `@haskellType` below\n     *  is left there for general purpose not for exactness as is told by aforementioned.\n     * @haskellType `zipWithN :: (a -> b -> c) -> [a] -> [b] -> [c]` - Where `N` is the number\n     *  of lists to zip.\n     * @function module:listOpsUncurried.zipWithN\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\n     * @param lists ...{Array|String|*}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWithN = (op, ...lists) => {\n        const trimmedLists = apply(lengthsToSmallest, lists),\n            lenOfTrimmed = length(trimmedLists);\n        if (!lenOfTrimmed) {\n            return [];\n        }\n        else if (lenOfTrimmed === 1) {\n            return sliceTo(length(trimmedLists[0]), trimmedLists[0]);\n        }\n        return reduce((agg, item, ind) =>\n                aggregateArr(agg, apply(op, map(xs => xs[ind], trimmedLists))),\n            [], trimmedLists[0]);\n    },\n\n    /**\n     * Zips 3 lists with tupling function.\n     * @haskellType `zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]`\n     * @function module:listOpsUncurried.zipWith3\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @param xs3 {Array|String|*}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith3 = zipWithN,\n\n    /**\n     * Zips 4 lists with tupling function.\n     * @haskellType `zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c]  -> [d] -> [e]`\n     * @function module:listOpsUncurried.zipWith4\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> d -> (a, b, c, d)`\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @param xs3 {Array|String|*}\n     * @param xs4 {Array|String|*}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith4 = zipWithN,\n\n    /**\n     * Zips 5 lists.\n     * @haskellType `zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c]  -> [d] -> [e] -> [f]`\n     * @function module:listOpsUncurried.zipWith5\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> d -> e -> (a, b, c, d, e)`\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @param xs3 {Array|String|*}\n     * @param xs4 {Array|String|*}\n     * @param xs5 {Array|String|*}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith5 = zipWithN,\n\n    /**\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\n     * @haskellType `unzip :: [(a, b)] -> ([a], [b])`\n     * @todo Should support other list types (should not have `push` hard coded instead should use `mappend` (if available)).\n     * @function module:listOpsUncurried.unzip\n     * @param arr {Array|*}\n     * @returns {Array|*}\n     */\n    unzip = arr =>\n        foldl((agg, item) => {\n            agg[0].push(item[0]);\n            agg[1].push(item[1]);\n            return agg;\n        }, [[], []], arr),\n\n    /**\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\n     * @sudoHaskellType `unzipN :: [(a, b, ...x)] -> ([a], [b], ...[x])`\n     * @todo Should support other list types (should not have `push` hard coded instead should use `mappend` (if available)).\n     * @function module:listOpsUncurried.unzip\n     * @param list {Array|*} - List of tuples (lists).\n     * @returns {Array|*}\n     */\n    unzipN = list => {\n        if (!length(list)) {\n            return [];\n        }\n        const lenItem0 = length(list[0]);\n        let zero = lenItem0 ?\n            unfoldr(numLists => numLists-- ? [[], numLists] : undefined, lenItem0) :\n            [];\n        return foldl((agg, item) => {\n            agg.forEach((outList, ind) => outList.push(item[ind]));\n            return agg;\n        }, zero, list);\n    },\n\n    any = (p, xs) => {\n        let ind = 0,\n            limit = length(xs);\n        if (!limit) {\n            return false;\n        }\n        for (; ind < limit; ind += 1) {\n            if (p(xs[ind])) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    all = (p, xs) => {\n        const limit = length(xs);\n        let ind = 0;\n        if (limit === 0) {\n            return false;\n        }\n        for (; ind < limit; ind++) {\n            if (!p(xs[ind], ind, xs)) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    and = xs => all(isTruthy, xs),\n\n    or = xs => any(isTruthy, xs),\n\n    not = xs => all(isFalsy, xs),\n\n    sum = list => foldl((agg, x) => agg + x, 0, list),\n\n    product = arr => foldl((agg, x) => agg * x, 1, arr),\n\n    maximum = list => maximumBy(genericAscOrdering, list),\n\n    minimum = list => minimumBy(genericAscOrdering, list),\n\n    maximumBy = (ordering, xs) => last(sortBy(ordering, xs)),\n\n    minimumBy = (ordering, xs) => head(sortBy(ordering, xs)),\n\n    scanl = () => null,\n\n    scanl1 = () => null,\n\n    scanr = () => null,\n\n    scanr1 = () => null,\n\n    nub = list => nubBy((a, b) => a === b, list),\n\n    remove = (x, list) => removeBy((a, b) => a === b, x, list),\n\n    sort = xs => sortBy(genericAscOrdering, xs),\n\n    sortOn = (valueFn, xs) =>\n\n        // Un-decorate\n        map(decorated => decorated[1],\n\n            // Decorate and sort\n            sortBy(\n                // Ordering\n                (a1, b1) => {\n                    let a = a1[0],\n                        b = b1[0];\n                    if (a > b) {\n                        return 1;\n                    }\n                    else if (a < b) {\n                        return -1;\n                    }\n                    return 0;\n                },\n\n                // Decorate\n                map(item => [valueFn(item), item], xs)\n            )\n        ),\n\n    sortBy = (orderingFn, xs) => copy(xs).sort(orderingFn),\n\n    insert = (x, xs) => {\n        if (isEmpty(xs)) {\n            return aggregatorByType(xs)(copy(xs), x, 0);\n        }\n        let out = of(xs),\n            foundIndex = findIndex(item => x <= item, xs);\n        return foundIndex === -1 ? append(sliceFrom(0, out), x) :\n            concat(intersperse([x], splitAt(foundIndex, xs)));\n    },\n\n    /**\n     * A version of `insert` that allows you to specify the ordering of the inserted\n     * item;  Before/at, or after\n     * @function module:listOpsUncurried.insertBy\n     * @haskellType `insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]`\n     * @note `Ordering` === // something that is order-able\n     * @todo Optimize and work the logic of this function;  Think about the types that will be\n     *  operated on by this functions logic.\n     * @param orderingFn {Function} - A function that returns `-1`, `0`, or 1`.\n     * @param x {*} - Value to insert.\n     * @param xs {Array|String|*} - List to insert into (note new list is returned)\n     * @returns {Array|String|*} - New list.\n     */\n    insertBy = (orderingFn, x, xs) => {\n        const limit = length(xs),\n            aggregator = aggregatorByType(xs),\n            out = of(xs);\n        if (isEmpty(xs)) {\n            return aggregator(out, x, 0);\n        }\n        let ind = 0;\n        for (; ind < limit; ind += 1) {\n            if (orderingFn(x, xs[ind]) <= 0) {\n                const parts = splitAt(ind, xs);\n                // Fold parts[0], [x], parts[1] into `out` and `concat`\n                return concat(foldl(aggregator, out, [parts[0], [x], parts[1]]));\n            }\n        }\n        return aggregator(copy(xs), x);\n    },\n\n    nubBy = (pred, list) => {\n        if (isEmpty(list)) {\n            return of(list);\n        }\n        const limit = length(list);\n        let ind = 0,\n            currItem,\n            out = of(list),\n            anyOp = storedItem => pred(currItem, storedItem);\n        for (; ind < limit; ind += 1) {\n            currItem = list[ind];\n            if (any(anyOp, out)) {\n                continue;\n            }\n            out = append(out, currItem);\n        }\n        return out;\n    },\n\n    removeBy = (pred, x, list) => { // @todo optimize this implementation\n        const foundIndex = findIndex(item => pred(x, item), list),\n            parts = splitAt(foundIndex > -1 ? foundIndex : 0, list); // @todo correct this implementation\n        return append(parts[0], tail(parts[1]));\n    },\n\n    removeFirstsBy = (pred, xs1, xs2) =>\n        foldl((agg, item) => removeBy(pred, item, agg), xs1, xs2),\n\n    /**\n     * Returns the union on elements matching boolean check passed in.\n     * @function module:listOpsUncurried.unionBy\n     * @param pred {Function} - `pred :: a -> a -> Bool`\n     * @param arr1 {Array|String|*}\n     * @param arr2 {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    unionBy = (pred, arr1, arr2) => {\n        const aggregator = aggregatorByType(arr1);\n        return foldl((agg, b) => {\n            const alreadyAdded = any(a => pred(a, b), agg);\n            return !alreadyAdded ? aggregator(agg, b) : agg;\n        }, copy(arr1), arr2);\n    },\n\n    /**\n     * Creates a union on matching elements from array1.\n     * @function module:listOpsUncurried.union\n     * @param arr1 {Array|String|*}\n     * @param arr2 {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    union = (arr1, arr2) =>\n        append(arr1,\n            filter(elm => !includes(elm, arr1), arr2)),\n\n    /**\n     * Performs an intersection on list 1 with  elements from list 2.\n     * @function module:listOpsUncurried.intersect\n     * @param arr1 {Array|String|*}\n     * @param arr2 {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    intersect = (arr1, arr2) =>\n        !arr1 || !arr2 || (!arr1 && !arr2) ? [] :\n            filter(elm => includes(elm, arr2), arr1),\n\n    /**\n     * Returns an intersection by predicate.\n     * @function module:listOpsUncurried.intersectBy\n     * @param pred {Function} - `pred :: a -> b -> Bool`\n     * @param list1 {Array|String|*}\n     * @param list2 {Array|String|*}\n     * @return {Array|String|*}\n     */\n    intersectBy = (pred, list1, list2) => {\n        const aggregator = aggregatorByType(list1);\n        return foldl((agg, a) =>\n                any(b => pred(a, b), list2) ? aggregator(agg, a) : agg\n            , [], list1);\n    },\n\n    /**\n     * Returns the difference of list 1 from list 2.\n     * @note The `difference` operation here is non-associative;  E.g., `a - b` is not equal to `b - a`;\n     * @function module:listOpsUncurried.difference\n     * @param array1 {Array|String|*}\n     * @param array2 {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    difference = (array1, array2) => { // augment this with max length and min length ordering on op\n        if (array1 && !array2) {\n            return sliceFrom(0, array1);\n        }\n        else if (!array1 && array2 || (!array1 && !array2)) {\n            return [];\n        }\n        const aggregator = aggregatorByType(array1);\n        return reduce((agg, elm) =>\n                !includes(elm, array2) ? aggregator(agg, elm) : agg\n            , [], array1);\n    },\n\n    /**\n     * Returns the complement of list 0 and the reset of the passed in arrays.\n     * @function module:listOpsUncurried.complement\n     * @param arr0 {Array}\n     * @param arrays {...Array}\n     * @returns {Array}\n     */\n    complement = (arr0, ...arrays) =>\n        reduce((agg, arr) => append(agg, difference(arr, arr0)), [], arrays);\n","import {assignDeep} from './assignDeep';\nimport {hasOwnProperty, keys} from '../jsPlatform/objectUncurried';\nimport {foldl} from   '../listOps/listOpsUncurried';\n\nexport const\n\n    objUnion = (obj1, obj2) => assignDeep(obj1, obj2),\n\n    objIntersect = (obj1, obj2) => foldl((agg, key) => {\n        if (hasOwnProperty(key, obj2)) {\n            agg[key] = obj2[key];\n        }\n        return agg;\n    }, {}, keys(obj1)),\n\n    objDifference = (obj1, obj2) => foldl((agg, key) => {\n        if (!hasOwnProperty(key, obj2)) {\n            agg[key] = obj1[key];\n        }\n        return agg;\n    }, {}, keys(obj1)),\n\n    objComplement = (obj0, ...objs) => foldl((agg, obj) =>\n        assignDeep(agg, objDifference(obj, obj0)), {}, objs);\n","import {curry, curry2} from   '../functionOps/curry';\n\nimport {\n    instanceOf as pureInstanceOf,\n    hasOwnProperty as pureHasOwnProperty,\n    assign as pureAssign\n} from '../uncurried/jsPlatform/objectUncurried';\n\nimport {assignDeep as pureAssignDeep} from   '../uncurried/objectOps/assignDeep';\n\nexport {length, toString, keys} from '../uncurried/jsPlatform/objectUncurried';\n\nexport const\n\n    instanceOf = curry(pureInstanceOf),\n\n    hasOwnProperty = curry(pureHasOwnProperty),\n\n    assign = curry2(pureAssign),\n\n    assignDeep = curry2(pureAssignDeep);\n\nexport * from  '../uncurried/objectOps/typeOf';\n\nexport * from  '../uncurried/objectOps/is';\n\nexport * from  '../uncurried/objectOps/of';\n\nexport * from  '../uncurried/objectOps/setTheoryOps';\n","/**\n * Created by elydelacruz on 7/22/2017.\n * @memberOf functionOps\n */\nimport {curry2} from './curry';\n\nimport {call as pureCall} from '../uncurried/jsPlatform/functionUncurried';\n\nexport const\n\n    /**\n     * Functional `call` function (takes no context).\n     * @function module:functionOps.call\n     * @param fn {Function}\n     * @param args {*}\n     * @returns {*}\n     */\n    call = curry2(pureCall);\n","/**\n * List operators.\n * @module listOps\n * @todo decide whether to throw errors where functions cannot function without a specific type or to\n *  return undefined (and also determine which cases are ok for just returning undefined).\n * @todo code unperformant shorthand in `listOps`\n * @todo rename monoid functions to normal functions since we are not really defining methods for monoids here.\n */\nimport {curry, curry2} from   '../uncurried/functionOps/functionOpsUncurried';\n\n// Uncurried methods import\nimport {\n    append as _append, appendMany as _appendMany, all as _all, and as _and, or as _or, any as _any, find as _find,\n    findIndex as _findIndex, findIndices as _findIndices, zip as _zip, zipN as _zipN, zipWith as _zipWith,\n    unzip as _unzip, unzipN as _unzipN, map as _map, mapAccumL as _mapAccumL, mapAccumR as _mapAccumR, zipWithN as _zipWithN,\n    elem as _elem, notElem as _notElem, elemIndex as _elemIndex, elemIndices as _elemIndices, lookup as _lookup,\n    head as _head, last as _last, init as _init, tail as _tail, uncons as _uncons, length as _length,\n    reverse as _reverse, intersperse as _intersperse, intercalate as _intercalate, transpose as _transpose,\n    subsequences as _subsequences, permutations as _permutations, isEmpty as _isEmpty, iterate as _iterate,\n    repeat as _repeat, replicate as _replicate, cycle as _cycle, take as _take, drop as _drop, splitAt as _splitAt,\n    foldl as _foldl, foldl1 as _foldl1, foldr as _foldr, foldr1 as _foldr1, unfoldr as _unfoldr, concat as _concat,\n    concatMap as _concatMap, takeWhile as _takeWhile, dropWhile as _dropWhile, dropWhileEnd as _dropWhileEnd,\n    partition as _partition, at as _at, span as _span, breakOnList as _breakOnList, stripPrefix as _stripPrefix,\n    group as _group, inits as _inits, tails as _tails, isPrefixOf as _isPrefixOf, isSuffixOf as _isSuffixOf,\n    isInfixOf as _isInfixOf, isSubsequenceOf as _isSubsequenceOf, filter as _filter, sum as _sum, product as _product,\n    maximum as _maximum, maximumBy as _maximumBy, minimum as _minimum, minimumBy as _minimumBy, nub as _nub,\n    remove as _remove, insert as _insert, insertBy as _insertBy, nubBy as _nubBy, removeBy as _removeBy,\n    removeFirstsBy as _removeFirstsBy, unionBy as _unionBy, sort as _sort, sortOn as _sortOn, sortBy as _sortBy,\n    complement as _complement, difference as _difference, union as _union, intersect as _intersect,\n    intersectBy as _intersectBy, groupBy as _groupBy\n}\n    from   '../uncurried/listOps/listOpsUncurried';\n\n// Single arity methods (and single or more arg functions)\nexport {\n    and, or, zipN, unzip, unzipN, head, last, init, tail, uncons, isEmpty, concat, length, reverse, transpose, subsequences,\n    permutations, group, inits, tails, sum, product, maximum, minimum, sort, nub\n}\n    from   '../uncurried/listOps/listOpsUncurried';\n\n// Uncurried methods export\nexport {\n    _append, _appendMany, _all, _and, _or, _any, _find, _findIndex, _findIndices, _zip, _zipN, _zipWith,\n    _unzip, _unzipN, _map, _mapAccumL, _mapAccumR, _elem, _notElem, _elemIndex, _elemIndices, _lookup,\n    _head, _last, _init, _tail, _uncons, _length, _reverse, _intersperse, _intercalate, _transpose,\n    _subsequences, _permutations, _isEmpty, _iterate, _repeat, _replicate, _cycle, _take,\n    _drop, _splitAt, _foldl, _foldl1, _foldr, _foldr1, _unfoldr, _concat, _concatMap, _takeWhile, _dropWhile,\n    _dropWhileEnd, _partition, _at, _span, _breakOnList, _stripPrefix, _group, _inits, _tails, _isPrefixOf,\n    _isSuffixOf, _isInfixOf, _isSubsequenceOf, _filter, _sum, _product, _maximum, _maximumBy, _minimum, _minimumBy,\n    _nub, _remove, _insert, _insertBy, _nubBy, _removeBy, _removeFirstsBy, _unionBy, _sort, _sortOn, _sortBy,\n    _complement, _difference, _union, _intersect, _intersectBy, _groupBy\n};\n\n// Exported internals\nexport const\n\n    /**\n     * Append two lists, i.e.,\n     * ```\n     * append([x1, ..., xm], [y1, ..., yn]) // outputs: [x1, ..., xm, y1, ..., yn]\n     * append([x1, ..., xm], [y1, ...]) // outputs: [x1, ..., xm, y1, ...]\n     * ```\n     * If the first list is not finite, the result is the first list.\n     * @haskellType `append :: List a => a -> a -> a`\n     * @function module:listOps.append\n     * @param xs1 {Array|String|*} - list or list like.\n     * @param xs2 {Array|String|*} - list or list like.\n     * @returns {Array|String|*} - Same type as list like passed in.\n     */\n    append = curry(_append),\n\n    /**\n     * Append two or more lists, i.e., same as `append` but for two ore more lists.\n     * @haskellType `appendMany :: List a => a -> [a] -> a\n     * @note In `@haskellType` we wrote `[a]` only to keep the haskell type valid though note in javascript\n     *  this is actually different since the function converts the zero ore more parameters into an array containing such for us.\n     * @function module:listOps.appendMany\n     * @param x {Array|String|*}\n     * @param args ...{Array|String|*} - Lists or lists likes.\n     * @returns {Array|String|*} - Same type as first list or list like passed in.\n     */\n    appendMany = curry2(_appendMany),\n\n    /**\n     * Map a function over all the elements of a container and concatenate the resulting lists.\n     * @haskellType `concatMap :: Foldable t => (a -> [b]) -> t a -> [b]`\n     * @function module:listOps.concatMap\n     * @param fn {Function}\n     * @param foldableOfA {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    concatMap = curry2(_concatMap),\n\n    /**\n     * @function module:listOps.map\n     * @param fn {Function} - Function to map on functor item(s).\n     * @param xs {Array|String|*} - Functor.\n     * @returns {Array|String|*} - Functor type that is passed in.\n     */\n    map = curry(_map),\n\n    /**\n     * Takes an element and a list and `intersperses' that element between the elements of the list. For example\n     * @function module:listOps.intersperse\n     * @note In our version of the function javascript is loosely typed so, so is our function (to much overhead to make\n     *  it typed) so `between` can be any value.\n     * @param between {*} - Should be of the same type of elements contained in list.\n     * @param arr {Array|String|*} - List.\n     * @returns {Array|String|*}\n     */\n    intersperse = curry(_intersperse),\n\n    /**\n     * `intercalate xs xss` is equivalent to (concat (intersperse xs xss)). It inserts the list xs in between the lists in xss and concatenates the result.\n     * @haskellType `intercalate :: [a] -> [[a]] -> [a]`\n     * @function module:listOps.intercalate\n     * @param xs {Array|String|*}\n     * @param xss {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    intercalate = curry(_intercalate),\n\n    /**\n     * Reduces a foldable (list etc.) with passed in function.\n     * @function module:listOps.foldl\n     * @param fn {Function}\n     * @param zero {*} - Aggregator.\n     * @param functor {Array|String|*}\n     * @returns {*} - Usually same type as aggregate (`zero`) (depends on `fn`).\n     */\n    foldl = curry(_foldl),\n\n    /**\n     * Reduces a foldable (list etc.) from right to left with passed in function.\n     * @function module:listOps.foldr\n     * @param fn {Function}\n     * @param zero {*} - Aggregator.\n     * @param functor {Array|{reduce: {Function}}}\n     * @returns {*} - Usually same type as aggregate (`zero`) (depends on `fn`).\n     */\n    foldr = curry(_foldr),\n\n    /**\n     * Reduces a foldable (list etc.) with passed in function.\n     * @function module:listOps.foldl1\n     * @param fn {Function}\n     * @param functor {Array|{reduce: {Function}}}\n     * @returns {*}\n     */\n    foldl1 = curry(_foldl1),\n\n    /**\n     * Reduces a foldable (list etc.) from right to left with passed in function.\n     * @function module:listOps.foldr1\n     * @param fn {Function}\n     * @param functor {Array|{reduce: {Function}}}\n     * @returns {*}\n     */\n    foldr1 = curry(_foldr1),\n\n    /**\n     * Performs a map then a reduce all in one (from left-to-right). Returns a tuple\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\n     * @function module:listOps.mapAccumL\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\n     * @param xs {Array|String|*} - list type.\n     * @return {Array} - [aggregated, list]\n     */\n    mapAccumL = curry(_mapAccumL),\n\n    /**\n     * Performs a map and a reduce all in one (from right-to-left). Returns a tuple\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\n     * @function module:listOps.mapAccumR\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\n     * @param xs {Array|String|*} - list type.\n     * @return {Array} - [aggregated, list]\n     */\n    mapAccumR = curry(_mapAccumR),\n\n    /**\n     * Iterate on value (`x`) with `op` up to `limit`.\n     * @function module:listOps.iterate\n     * @param limit {Number}\n     * @param op {Function} - Operation\n     * @param x {*} - Starting point.\n     * @returns {*}\n     */\n    iterate = curry(_iterate),\n\n    repeat = curry(_repeat),\n\n    replicate = repeat,\n\n    cycle = curry(_cycle),\n\n    /**\n     * Unfolds a value into a list of somethings.\n     * @haskellType `unfoldr :: (b -> Maybe (a, b)) -> b -> [a]`\n     * @function module:listOps.unfoldr\n     * @param op {Function} - Operation to perform (should return a two component tuple (item to aggregate and item to unfold in next iteration).\n     * @param x {*} - Starting parameter to unfold from.\n     * @returns {Array} - An array of whatever you return from `op` yielded.\n     */\n    unfoldr = curry(_unfoldr),\n\n    /**\n     * Finds index in string or list (alias for `findIndex`).\n     * @function module:listOps.findIndex\n     * @param pred {Function} - Predicate<element, index, arr>.\n     * @param arr {Array|String}\n     * @returns {Number} - `-1` if predicate not matched else `index` found\n     */\n    findIndex = curry(_findIndex),\n\n    /**\n     * @function module:listOps.findIndices\n     * @param pred {Function}\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {Array|undefined}\n     */\n    findIndices = curry(_findIndices),\n\n    /**\n     * @function module:listOps.elemIndex\n     * @param x {*} - Element to search for.\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {*}\n     */\n    elemIndex = curry(_elemIndex),\n\n    /**\n     * @function module:listOps.elemIndices\n     * @param value {*} - Element to search for.\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {*}\n     */\n    elemIndices = curry(_elemIndices),\n\n    /**\n     * Takes `n` items from start of list to `limit` (exclusive).\n     * @function module:listOps.take\n     * @param list {Array|String}\n     * @param limit {Number}\n     * @returns {String|Array} - Passed in type's type\n     */\n    take = curry(_take),\n\n    /**\n     * Drops `n` items from start of list to `count` (exclusive).\n     * @function module:listOps.take\n     * @param list {Array|String}\n     * @param count {Number}\n     * @returns {String|Array} - Passed in type's type\n     */\n    drop = curry(_drop),\n\n    /**\n     * Splits `x` in two at given `index` (exclusive (includes element/character at\n     * given index in second part of returned list)).\n     * @function module:listOps.splitAt\n     * @param ind {Number} - Index to split at.\n     * @param list {Array|String|*} - functor (list or string) to split.\n     * @returns {Array} - Array of whatever type `x` was when passed in\n     */\n    splitAt = curry(_splitAt),\n\n    /**\n     * Gives an list with passed elements while predicate was true.\n     * @function module:listOps.takeWhile\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @returns {Array}\n     */\n    takeWhile = curry(_takeWhile),\n\n    /**\n     * Returns an list without elements that match predicate.\n     * @function module:listOps.dropWhile\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @refactor\n     * @returns {Array|String}\n     */\n    dropWhile = curry(_dropWhile),\n\n    /**\n     * @function module:listOps.dropWhile\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @refactor\n     * @returns {Array|String}\n     */\n    dropWhileEnd = curry(_dropWhileEnd),\n\n    /**\n     * Gives a span such that the first list (in returned tuple) is the span of items matching upto `not predicate` and\n     * the second list in the tuple is a list of the remaining elements in the given list.\n     * **@Note: Not the same as `partition`.  Read descriptions closely!!!\n     * @function module:listOps.partition\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\n     * @param list {Array|String|*} - Predicate<item, index, originalArrayOrString>\n     * @returns {Array|String|*} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\n     */\n    span = curry(_span),\n\n    breakOnList = curry(_breakOnList),\n\n    /**\n     * @function module:listOps.at\n     * @param ind {Number} - Index.\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {*}\n     */\n    at = curry(_at),\n\n    /**\n     * @function module:listOps.find\n     * @param pred {Function}\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {*}\n     */\n    find = curry(_find),\n\n    filter = curry(_filter),\n\n    /**\n     * Partitions a list on a predicate;  Items that match predicate are in first list in tuple;  Items that\n     * do not match the tuple are in second list in the returned tuple.\n     *  Essentially `[filter(p, xs), filter(negateP(p), xs)]`.\n     * @function module:listOps.partition\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\n     * @param list {Array|String|*}\n     * @returns {Array|String} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\n     */\n    partition = curry(_partition),\n\n    elem = curry(_elem),\n\n    notElem = curry2(_notElem),\n\n    lookup = at,\n\n    isPrefixOf = curry(_isPrefixOf),\n\n    isSuffixOf = curry(_isSuffixOf),\n\n    isInfixOf = curry(_isInfixOf),\n\n    isSubsequenceOf = curry(_isSubsequenceOf),\n\n    /**\n     * Allows you to group items in a list based on your supplied equality check.\n     * @note Sames `group` but allows you to specify equality operation.\n     * @haskellType `groupBy :: (a -> a -> Bool) -> [a] -> [[a]]`\n     * @function module:listOpsUncurried.groupBy\n     * @param equalityOp {Function}\n     * @param xs {Array|String|*}\n     * @returns {*}\n     */\n    groupBy = curry(_groupBy),\n\n    stripPrefix = curry(_stripPrefix),\n\n    /**\n     * zip takes two lists and returns a list of corresponding pairs.\n     * If one input list is short, excess elements of the longer list are discarded.\n     * @haskellType `zip :: [a] -> [b] -> [(a, b)]`\n     * @function module:listOps.zip\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip = curry(_zip),\n\n    /**\n     * zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\n     * zipWith generalises zip by zipping with the function given as the\n     * first argument, instead of a function tupling function (function that returns a tuple). For example,\n     * zipWith (+) is applied to two lists to produce the list of corresponding sums.\n     * @note `_|_` means bottom or perpetual (@see\n     *  - https://wiki.haskell.org/Bottom\n     *  - https://stackoverflow.com/questions/19794681/what-does-this-syntax-mean-in-haskell-or\n     *  )\n     * @example\n     * ```\n     * zipWith f [] _|_ = []\n     * ```\n     * @haskellType `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`\n     * @function module:listOps.zipWith\n     * @param op {Function} - Takes two parts of a tuple and returns a tuple.\n     *  E.g., ` op :: a -> b -> (a, b)`\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith = curry(_zipWith),\n\n    /**\n     * Zips all given lists with tupling function. Note: Haskell types do not have\n     *  a way (that I know of) to show one or more for params in a function so `@haskellType` below\n     *  is left there for general purpose not for exactness as is told by aforementioned.\n     * @haskellType `zipWithN :: (a -> b -> c) -> [a] -> [b] -> [c]` - Where `N` is the number\n     *  of lists to zip.\n     * @function module:listOps.zipWithN\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\n     * @param lists ...{Array|String|*}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWithN = curry2(_zipWithN),\n\n    /**\n     * Zips 3 lists with tupling function.\n     * @haskellType `zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]`\n     * @function module:listOps.zipWith3\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @param xs3 {Array|String|*}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith3 = zipWithN,\n\n    /**\n     * Zips 4 lists with tupling function.\n     * @haskellType `zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c]  -> [d] -> [e]`\n     * @function module:listOps.zipWith4\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> d -> (a, b, c, d)`\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @param xs3 {Array|String|*}\n     * @param xs4 {Array|String|*}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith4 = zipWithN,\n\n    /**\n     * Zips 5 lists.\n     * @haskellType `zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c]  -> [d] -> [e] -> [f]`\n     * @function module:listOps.zipWith5\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> d -> e -> (a, b, c, d, e)`\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @param xs3 {Array|String|*}\n     * @param xs4 {Array|String|*}\n     * @param xs5 {Array|String|*}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith5 = zipWithN,\n\n    any = curry(_any),\n\n    all = curry(_all),\n\n    maximumBy = curry(_maximumBy),\n\n    minimumBy = curry(_minimumBy),\n\n    scanl = () => null,\n\n    scanl1 = () => null,\n\n    scanr = () => null,\n\n    scanr1 = () => null,\n\n    remove = curry(_remove),\n\n    sortOn = curry(_sortOn),\n\n    sortBy = curry(_sortBy),\n\n    insert = curry(_insert),\n\n    /**\n     * A version of `insert` that allows you to specify the ordering of the inserted\n     * item;  Before/at, or after\n     * @function module:listOpsUncurried.insertBy\n     * @haskellType `insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]`\n     * @note `Ordering` === // something that is order-able\n     * @todo Optimize and work the logic of this function;  Think about the types that will be\n     *  operated on by this functions logic.\n     * @param orderingFn {Function} - A function that returns `-1`, `0`, or 1`.\n     * @param x {*} - Value to insert.\n     * @param xs {Array|String|*} - List to insert into (note new list is returned)\n     * @returns {Array|String|*} - New list.\n     */\n    insertBy = curry(_insertBy),\n\n    nubBy = curry(_nubBy),\n\n    removeBy = curry(_removeBy),\n\n    removeFirstsBy = curry(_removeFirstsBy),\n\n    /**\n     * Returns the union on elements matching boolean check passed in.\n     * @function module:listOps.unionBy\n     * @param pred {Function} - `pred :: a -> a -> Bool`\n     * @param arr1 {Array|String|*}\n     * @param arr2 {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    unionBy = curry(_unionBy),\n\n    /**\n     * Creates a union on matching elements from array1.\n     * @function module:listOps.union\n     * @param arr1 {Array|String|*}\n     * @param arr2 {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    union = curry(_union),\n\n    /**\n     * Performs an intersection on list 1 with  elements from list 2.\n     * @function module:listOps.intersect\n     * @param arr1 {Array|String|*}\n     * @param arr2 {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    intersect = curry(_intersect),\n\n    /**\n     * Returns an intersection by predicate.\n     * @function module:listOps.intersectBy\n     * @param pred {Function} - `pred :: a -> b -> Bool`\n     * @param list1 {Array|String|*}\n     * @param list2 {Array|String|*}\n     * @return {Array|String|*}\n     */\n    intersectBy = curry(_intersectBy),\n\n    /**\n     * Returns the difference of list 1 from list 2.\n     * @note The `difference` operation here is non-associative;  E.g., `a - b` is not equal to `b - a`;\n     * @function module:listOps.difference\n     * @param array1 {Array|String|*}\n     * @param array2 {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    difference = curry(_difference),\n\n    /**\n     * Returns the complement of list 0 and the reset of the passed in arrays.\n     * @function module:listOps.complement\n     * @param arr0 {Array}\n     * @param arrays {...Array}\n     * @returns {Array}\n     */\n    complement = curry2(_complement);\n","/**\n * @memberOf functionOps\n */\nimport {foldr} from   '../listOps/listOps';\n\n/**\n * Composes all functions passed in from right to left passing each functions return value to\n * the functionOps on the left of itself.\n * @function module:functionOps.compose\n * @type {Function}\n * @param args {...Function}\n * @returns {Function}\n */\nexport const compose = (...args) => arg0 => foldr((value, fn) => fn(value), arg0, args);\n","/**\n * @memberOf functionOps\n */\n\n/**\n * Negates a predicate function.\n * @function module:functionOps.negateP\n * @param fn {Function}\n * @returns {Function} - Negated predicate\n */\nexport const negateP = fn => (x, ind, xs) => !fn(x, ind, xs);\n","/**\n * @memberOf functionOps\n */\n\n/**\n * Returns passed in parameter.\n * @function module:functionOps.id\n * @param x {*}\n * @returns {*}\n */\nexport const id = x => x;\n","/**\n * @memberOf functionOps\n */\nimport {reverse} from   '../listOps/listOps';\nimport {curry, curry3} from './curry';\nimport {apply} from './apply';\nimport {call} from './call';\n\nexport const\n\n    /**\n     * Flips a functions arguments order and returns a new functionOps requiring such (arguments in reverse order).\n     * @function module:fnOperators.flipN\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    flipN = fn => curry3((...args) => apply(fn, reverse(args))),\n\n    /**\n     * Flips a functionOps's first and second arguments and and returns a new functionOps requiring said arguments in reverse.\n     * @function module:fnOperators.flip\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    flip = fn => curry((b, a) => call(fn, a, b));\n","/**\n * @memberOf functionOps\n */\nimport {curry} from './curry';\n\nexport const\n\n    /**\n     * Run `operation` until predicate returns `true`.\n     * @function module:functionOps.until\n     * @param predicate {Function} :: a -> Boolean\n     * @param operation {Function} :: a -> a\n     * @param typeInstance {*} :: * - A monoidal zero or some starting point.\n     * @returns {*} - What ever type `typeInstance` is\n     */\n    until = curry((predicate, operation, typeInstance) => {\n        let result = typeInstance;\n        while (!predicate(result)) {\n            result = operation(result);\n        }\n        return result;\n    });\n","/**\n * Function operations: `\n * @module functionOps\n */\nexport {call} from './call';\n\nexport {apply} from './apply';\n\nexport {compose} from './compose';\n\nexport {curry, curryN, curry2, curry3, curry4, curry5,\n    __, curry_, curryN_, curry2_, curry3_, curry4_, curry5_} from './curry';\n\nexport {negateP} from './negateP';\n\nexport {id} from './id';\n\nexport {flip, flipN} from './flip';\n\nexport {until} from './until';\n","export const negate = x => Math.abs(x) * -1;\n","/**\n * Created by elydelacruz on 9/6/2017.\n */\n\nimport {fPureTakesOne} from   '../../utils/utils';\n\n/**\n * Functional version of `String.prototype.split`.\n * @function module:stringOpsUnCurried.split\n * @param separator {String|RegExp}\n * @param str {String}\n * @returns {Array}\n */\nexport const split = fPureTakesOne('split');\n","/**\n * Created by elydelacruz on 9/6/2017.\n * @module jsPlatform_string\n */\n\nimport {curry} from   '../functionOps/curry';\n\nimport {split as pureSplit} from '../uncurried/jsPlatform/stringUnCurried';\n\n/**\n * Functional version of `String.prototype.split`.\n * @curried\n * @function module:jsPlatform_string.split\n * @param separator {String|RegExp}\n * @param str {String}\n * @returns {Array}\n */\nexport const split = curry(pureSplit);\n","/**\n * Contains functions for operating strings.\n * @author elyde\n * @created 7/9/2017.\n */\nimport {intercalate} from   '../listOps/listOps';\n\nimport {split} from '../jsPlatform/string';\n\nexport const\n\n    /**\n     * Splits a stringOps on all '\\n', '\\r', '\\n\\r', or '\\r\\n' characters.\n     * @function module:stringOps.lines\n     * @param str {String}\n     * @returns {Array}\n     */\n    lines = split(/[\\n\\r]/gm),\n\n    /**\n     * Splits a stringOps on all '\\s' and/or all '\\t' characters.\n     * @function module:stringOps.words\n     * @param str{String}\n     * @returns {Array}\n     */\n    words = split(/[\\s\\t]/gm),\n\n    /**\n     * Intersperse an array of strings with '\\s' and then concats them.\n     * @function module:stringOps.unwords\n     * @param arr {String}\n     * @returns {Array}\n     */\n    unwords = intercalate(' '),\n\n    /**\n     * Intersperses a '\\n' character into a list of strings and then concats it.\n     * @function module:stringOps.unlines\n     * @param list {Array|String|*}\n     * @returns {Array}\n     */\n    unlines = intercalate('\\n');\n","/**\n * Content generated by '{project-root}/node-scripts/VersionNumberReadStream.js'.\n * Generated Fri Sep 29 2017 23:09:14 GMT-0400 (EDT) \n */\n\nexport let version = '0.14.89';\n\nexport default version;\n\n","/**\n * Created by elyde on 12/6/2016.\n * @file fjl.js\n * @goal to include everything from haskell's Prelude where it makes sense in order to create\n *  a subset of functions which can make the javascript developer more efficient and make his/her\n *  code more concise (and functional).\n * @description Includes operations from haskell's Prelude.\n * @motivation preludejs, lodash/fp, RamdaJs, Haskell.\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-List.html\n * @todo any cross importing between packages should be done from the package object (package file: E.g., './src/functionOps/functionOps.js').\n * @todo decide how to include 'uncurried' members in the main export of the library.\n * @module fjl\n */\n\nexport * from './objectOps/objectOps';\nexport * from './booleanOps/booleanOps';\nexport * from './functionOps/functionOps';\nexport * from './listOps/listOps';\nexport * from './numberOps/numberOps';\nexport * from './stringOps/stringOps';\n\nexport {version} from   '../generated-for-src/version';\n"],"names":["PlaceHolder","placeHolderInstance","curry","fn","argsToCurry","args","concatedArgs","concat","length","apply","isPlaceHolder","instance","replacePlaceHolders","array","out","map","element","shift","curry_","placeHolders","filter","canBeCalled","curryN_","executeArity","curriedArgs","curryN","__","Object","freeze","curry2_","curry3_","curry4_","curry5_","curry2","curry3","curry4","curry5","fPureTakesOne","arg","f","name","fPureTakes2","arg1","arg2","fPureTakesOneOrMore","instanceOf","instanceConstructor","hasOwnProperty","x","toString","keys","obj","assign","obj0","objs","reduce","topAgg","agg","key","_Number","Number","_NaN","_Null","_Undefined","_undefined","typeOf","value","retVal","constructorName","constructor","isNaN","_String","String","_Object","_Boolean","Boolean","_Function","Function","_Array","Array","_Symbol","_Map","_Set","_WeakMap","_WeakSet","isFunction","isType","type","isClass","test","substr","isCallable","isArray","isObject","isBoolean","isNumber","isString","isMap","isSet","isWeakMap","isWeakSet","isUndefined","isNull","isSymbol","isPromise","isUsableImmutablePrimitive","typeOfX","some","Type","isEmptyList","isEmptyObject","isEmptyCollection","size","isEmpty","typeOfValue","notEmptyAndOfType","isset","assignDeep","propDescription","getOwnPropertyDescriptor","get","set","writable","call","of","undefined","slice","includes","prototype","xs","indexOf","lastIndexOf","reduceRight","forEach","every","join","push","negateF","a","b","negateF3","c","negateP","append","isTruthy","isFalsy","alwaysTrue","alwaysFalse","bAnd","bOr","bNot","bOtherwise","bEqual","prop","pureInstanceOf","pureApply","aggregateStr","item","aggregateArr","aggregateObj","ind","aggregatorByType","limit","aggregate","sliceFrom","startInd","arr","sliceTo","toInd","copy","genericAscOrdering","lengths","lists","lengthsToSmallest","listLengths","smallLen","Math","min","list","reduceUntil","pred","op","result","reduceRightUntil","operation","lastIndex","len","findIndexWhere","predicateFulfilled","findIndexWhereRight","findIndicesWhere","findWhere","elm","listAppend","appendMany","Error","head","last","tail","init","uncons","unconsr","concatMap","foldableOfA","reverse","aggregator","intersperse","between","lastInd","aggregatorOp","foldl","intercalate","xss","transpose","numLists","ind2","longestListLen","maximum","outLists","outList","subsequences","pow","i","entry","j","permutations","foldr","foldl1","parts","foldr1","mapAccumL","zero","mapped","tuple","mapAccumR","iterate","repeat","replicate","cycle","unfoldr","resultTuple","findIndex","findIndices","elemIndex","foundInd","elemIndices","take","drop","count","splitAt","takeWhile","dropWhile","splitPoint","list2","dropWhileEnd","span","breakOnList","at","find","partition","elem","notElem","lookup","isPrefixOf","xs1","xs2","limit1","limit2","isSuffixOf","ind1","isInfixOf","foundLen","isSubsequenceOf","lenXs1","group","groupBy","equalityOp","prevItem","predOp","inits","tails","stripPrefix","prefix","zip","arr1","arr2","a1","a2","zipN","trimmedLists","lenOfTrimmed","zipWith","zipWithN","unzip","unzipN","lenItem0","any","p","all","and","or","sum","product","maximumBy","minimum","minimumBy","ordering","sortBy","nub","nubBy","remove","removeBy","sort","sortOn","valueFn","decorated","b1","orderingFn","insert","foundIndex","insertBy","currItem","anyOp","storedItem","removeFirstsBy","unionBy","alreadyAdded","union","intersect","intersectBy","list1","difference","array1","array2","complement","arr0","arrays","objUnion","obj1","obj2","objIntersect","objDifference","objComplement","pureHasOwnProperty","pureAssign","pureAssignDeep","pureCall","_append","_appendMany","_concatMap","_map","_intersperse","_intercalate","_foldl","_foldr","_foldl1","_foldr1","_mapAccumL","_mapAccumR","_iterate","_repeat","_cycle","_unfoldr","_findIndex","_findIndices","_elemIndex","_elemIndices","_take","_drop","_splitAt","_takeWhile","_dropWhile","_dropWhileEnd","_span","_breakOnList","_at","_find","_filter","_partition","_elem","_notElem","_isPrefixOf","_isSuffixOf","_isInfixOf","_isSubsequenceOf","_groupBy","_stripPrefix","_zip","_zipWith","_zipWithN","zipWith3","zipWith4","zipWith5","_any","_all","_maximumBy","_minimumBy","scanl","scanl1","scanr","scanr1","_remove","_sortOn","_sortBy","_insert","_insertBy","_nubBy","_removeBy","_removeFirstsBy","_unionBy","_union","_intersect","_intersectBy","_difference","_complement","compose","arg0","id","flipN","flip","until","predicate","typeInstance","negate","abs","split","pureSplit","lines","words","unwords","unlines","version"],"mappings":"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"}