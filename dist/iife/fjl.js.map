{"version":3,"file":"fjl.js","sources":["../../src/uncurried/_utils.js","../../src/uncurried/_jsPlatform/_object.js","../../src/uncurried/_jsPlatform/_array.js","../../src/uncurried/_jsPlatform/_list.js","../../src/uncurried/_jsPlatform/_string.js","../../src/uncurried/_jsPlatform/_function.js","../../src/uncurried/_jsPlatform.js","../../src/uncurried/_functionOps/_curry.js","../../src/uncurried/_objectOps/_prop.js","../../src/uncurried/_objectOps/_typeOf.js","../../src/uncurried/_objectOps/_is.js","../../src/uncurried/_objectOps/_assignDeep.js","../../src/uncurried/_functionOps/_negate.js","../../src/booleanOps.js","../../src/uncurried/_objectOps/_of.js","../../src/uncurried/_objectOps.js","../../src/uncurried/_listOps/_aggregation.js","../../src/uncurried/_listOps/_map.js","../../src/uncurried/_listOps/_utils.js","../../src/uncurried/_listOps.js","../../src/uncurried/_objectOps/_setTheory.js","../../src/objectOps.js","../../src/uncurried/_functionOps/_until.js","../../src/uncurried/_functionOps/_flip.js","../../src/uncurried/_functionOps/__curry.js","../../src/uncurried/_functionOps/_id.js","../../src/uncurried/_functionOps/_compose.js","../../src/functionOps.js","../../src/uncurried/_functionOps.js","../../src/utils.js","../../src/jsPlatform/array.js","../../src/jsPlatform/list.js","../../src/jsPlatform/string.js","../../src/jsPlatform.js","../../src/listOps.js","../../src/stringOps.js","../../src/fjl.js"],"sourcesContent":["export const\r\n\r\n    fPureTakesOne = name => (arg, f) => f[name](arg),\r\n\r\n    fPureTakes2 = name => (arg1, arg2, f) => f[name](arg1, arg2),\r\n\r\n    fPureTakes3 = name => (arg1, arg2, arg3, f) => f[name](arg1, arg2, arg3),\r\n\r\n    fPureTakes4 = name => (arg1, arg2, arg3, arg4, f) => f[name](arg1, arg2, arg3, arg4),\r\n\r\n    fPureTakes5 = name => (arg1, arg2, arg3, arg4, arg5, f) => f[name](arg1, arg2, arg3, arg4, arg5),\r\n\r\n    fPureTakesOneOrMore = name => (f, ...args) => f[name](...args);\r\n","/**\r\n * Created by elydelacruz on 9/6/2017.\r\n * Defines some of the platform methods for objects (the ones used within `fjl`) uncurried for use\r\n * throughout the library.  @note Doesn't include all methods for objects just the ones used in\r\n *  the library.\r\n * @todo change all files named '*UnCurried' to '*_'.\r\n */\r\n\r\nimport {fPureTakesOne} from '../_utils';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns whether constructor has derived _objectOps.\r\n     * @function module:_jsPlatform_objectOps.instanceOf\r\n     * @param instanceConstructor {Function} - Constructor.\r\n     * @param instance {*}\r\n     * @instance {*}\r\n     * @returns {Boolean}\r\n     */\r\n    instanceOf = (instanceConstructor, instance) =>\r\n        instance instanceof instanceConstructor,\r\n\r\n    /**\r\n     * @function module:_jsPlatform_objectOps.hasOwnProperty\r\n     * @param propName {*}\r\n     * @param typeInstance {*}\r\n     * @returns {Boolean}\r\n     */\r\n    hasOwnProperty = fPureTakesOne('hasOwnProperty'),\r\n\r\n    /**\r\n     * @function module:_jsPlatform_objectOps.length\r\n     * @param x {*}\r\n     * @returns {Number}\r\n     * @throws {Error} - Throws an error if value doesn't have a `length` property (\r\n     *  `null`, `undefined`, {Boolean}, Symbol, et. al.).\r\n     */\r\n    length = x => x.length,\r\n\r\n    /**\r\n     * Gets own enumerable keys of passed in object (`Object.keys`).\r\n     * @function module:_jsPlatform_objectOps.keys\r\n     * @param obj {*}\r\n     * @returns {Array<String>}\r\n     */\r\n    keys = obj => Object.keys(obj),\r\n\r\n    /**\r\n     * Defined as `Object.assign` else is the same thing but shimmed.\r\n     * @function module:_jsPlatform_objectOps.assign\r\n     * @param obj0 {Object}\r\n     * @param objs {...{Object}}\r\n     * @returns {Object}\r\n     */\r\n    assign = (() => Object.assign ?\r\n            (obj0, ...objs) => Object.assign(obj0, ...objs) :\r\n            (obj0, ...objs) => objs.reduce((topAgg, obj) => {\r\n                return keys(obj).reduce((agg, key) => {\r\n                    agg[key] = obj[key];\r\n                    return agg;\r\n                }, topAgg);\r\n            }, obj0)\r\n        )();\r\n","/**\r\n * Created by elyde on 7/20/2017.\r\n * Functional versions of common array methods (`map`, `filter`, etc.) (un-curried);\r\n * @module _jsPlatform_arrayOps\r\n * @private\r\n * @todo updated doc blocks to list correct/updated module name.\r\n */\r\n\r\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from '../_utils';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Array.prototype.reverse generator (generates a _functionOps that calls the prototype version or a\r\n     * shimmed version if it doesn't exist).\r\n     * @returns {Function}\r\n     */\r\n    defineReverse = () =>\r\n        Array.prototype.reverse ? x => x.reverse() :\r\n            x => x.reduceRight((agg, item) => {\r\n                agg.push(item);\r\n                return agg;\r\n            }, []),\r\n\r\n    /**\r\n     * Maps a _functionOps to functor (_listOps etc.).\r\n     * @function module:_jsPlatform_array.map\r\n     * @param fn {Function}\r\n     * @param functor {Array|{map: {Function}}}\r\n     * @returns {Array|{map: {Function}}}\r\n     */\r\n    map = fPureTakesOne('map'),\r\n\r\n    /**\r\n     * Filters a functor (_listOps etc.) with passed in _functionOps.\r\n     * @function module:_jsPlatform_array.filter\r\n     * @param fn {Function}\r\n     * @param functor {Array|{filter: {Function}}}\r\n     * @returns {Array|{filter: {Function}}}\r\n     */\r\n    filter = fPureTakesOne('filter'),\r\n\r\n    /**\r\n     * Reduces a foldable (_listOps etc.) with passed in _functionOps.\r\n     * @function module:_jsPlatform_array.reduce\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduce: {Function}}}\r\n     * @returns {Array|{reduce: {Function}}}\r\n     */\r\n    reduce = fPureTakes2('reduce'),\r\n\r\n    /**\r\n     * Reduces a foldable (_listOps etc.) from the right with passed in _functionOps.\r\n     * @function module:_jsPlatform_array.reduceRight\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduceRight: {Function}}}\r\n     * @returns {Array|{reduceRight: {Function}}}\r\n     */\r\n    reduceRight = fPureTakes2('reduceRight'),\r\n\r\n    /**\r\n     * For each on functor (Array|Object|etc.).\r\n     * @param fn {Function}\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type of object you pass in unless it doesn't have a `forEach` method.\r\n     * @throws {Error} - When passed in functor doesn't have a `forEach` method.\r\n     */\r\n    forEach = fPureTakesOne('forEach'),\r\n\r\n    /**\r\n     * Returns `true` if `fn` (predicate) returns true for at least one item\r\n     * in functor else returns `false`.\r\n     * @param fn {Function} - Predicate.\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have a `some` method.\r\n     */\r\n    some = fPureTakesOne('some'),\r\n\r\n    /**\r\n     * Returns `true` if `fn` (predicate) returns true for all items in functor else returns `false`.\r\n     * @param fn {Function} - Predicate.\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have an `every` method.\r\n     */\r\n    every = fPureTakesOne('every'),\r\n\r\n    /**\r\n     * Array.prototype.join\r\n     * @function module:listPrelude.join\r\n     * @param separator {String|RegExp}\r\n     * @param arr {Array}\r\n     * @returns {String}\r\n     */\r\n    join = fPureTakesOne('join'),\r\n\r\n    /**\r\n     * Same as Array.prototype.push\r\n     * @param item {*}\r\n     * @param arr {Array}\r\n     * @returns {Number}\r\n     */\r\n    push = fPureTakesOneOrMore('push'),\r\n\r\n    /**\r\n     * Reverses an _listOps (shimmed if not exists).\r\n     * @function module:listPrelude.reverse\r\n     * @return {Array}\r\n     */\r\n    reverse = defineReverse();\r\n","/**\r\n *  List operations that overlap (apart from globally overlapping props and functions like `length`)\r\n *      on both strings and arrays.\r\n */\r\n\r\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from '../_utils';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Concats/appends all functors onto the end of first functor.\r\n     * Note:  functors passed in after the first one must be of the same type.\r\n     * @function module:_jsPlatform_list.concat\r\n     * @param functor {Array|Object|*}\r\n     * @param ...functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have an `every` method.\r\n     */\r\n    concat = fPureTakesOneOrMore('concat'),\r\n\r\n    /**\r\n     * Same as Array.prototype.slice\r\n     * @function module:_jsPlatform_list.slice\r\n     * @param separator {String|RegExp}\r\n     * @param arr{Array}\r\n     * @returns {Array}\r\n     */\r\n    slice = fPureTakes2('slice'),\r\n\r\n    /**\r\n     * `Array.prototype.includes` or shim.\r\n     * @function module:_jsPlatform_list.includes\r\n     * @param value {*}\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    includes = (() => 'includes' in Array.prototype ?\r\n            fPureTakesOne('includes') :\r\n            (value, xs) => xs.indexOf(value) > -1)(),\r\n\r\n    /**\r\n     * Searches list/list-like for given element `x`.\r\n     * @function module:_jsPlatform_list.indexOf\r\n     * @param x {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like to look in.\r\n     * @returns {Number} - `-1` if element not found else index at which it is found.\r\n     */\r\n    indexOf = fPureTakesOne('indexOf'),\r\n\r\n    /**\r\n     * Last index of (`Array.prototype.lastIndexOf`).\r\n     * @function module:_jsPlatform_list.lastIndexOf\r\n     * @param x {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like to look in.\r\n     * @returns {Number} - `-1` if element not found else index at which it is found.\r\n     */\r\n    lastIndexOf = fPureTakesOne('lastIndexOf')\r\n\r\n;\r\n","/**\r\n * Created by elydelacruz on 9/6/2017.\r\n */\r\n\r\nimport {fPureTakesOne} from '../_utils';\r\n\r\n/**\r\n * Functional version of `String.prototype.split`.\r\n * @function module:_stringOps.split\r\n * @param separator {String|RegExp}\r\n * @param str {String}\r\n * @returns {Array}\r\n */\r\nexport const split = fPureTakesOne('split');\r\n","/**\r\n * Created by elydelacruz on 9/7/2017.\r\n * @module _jsPlatform_function\r\n * @private\r\n */\r\nexport const\r\n\r\n    /**\r\n     * Functional `apply` function (takes no context).\r\n     * @function module:_jsPlatform_function.apply\r\n     * @param fn {Function}\r\n     * @param args {Array|*}\r\n     * @returns {*}\r\n     */\r\n    apply = (fn, args) => fn.apply(null, args),\r\n\r\n    /**\r\n     * Functional `call` function (takes no context).\r\n     * @function module:_jsPlatform_function.call\r\n     * @param fn {Function}\r\n     * @param args {...*}\r\n     * @returns {*}\r\n     */\r\n    call = (fn, ...args) => apply(fn, args);\r\n","/**\r\n * @module jsPlatform_\r\n * @private\r\n */\r\nexport * from './_jsPlatform/_object';\r\nexport * from './_jsPlatform/_array';\r\nexport * from './_jsPlatform/_list';\r\nexport * from './_jsPlatform/_string';\r\nexport * from './_jsPlatform/_function';\r\n","/**\r\n * @author elydelacruz\r\n * @created 12/6/2016.\r\n * @memberOf _functionOps\r\n * @description \"Curry strict\" and \"curry arbitrarily\" functions (`curry`, `curryN`).\r\n */\r\nimport {apply, length, concat} from '../_jsPlatform';\r\nexport const\r\n\r\n    /**\r\n     * Curries a functionOps based on it's defined arity (argument's arrayOps expected length).\r\n     * @function module:_functionOps.curry\r\n     * @param fn {Function}\r\n     * @param argsToCurry {...*}\r\n     * @returns {Function}\r\n     */\r\n    curry = (fn, ...argsToCurry) => {\r\n        return (...args) => {\r\n            const concatedArgs = concat(argsToCurry, args);\r\n            return length(concatedArgs) < length(fn) ?\r\n                apply(curry, concat([fn], concatedArgs)) :\r\n                apply(fn, concatedArgs);\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Curries a functionOps up to a given arity.\r\n     * @function module:_functionOps.curryN\r\n     * @param executeArity {Number}\r\n     * @param fn {Function}\r\n     * @param curriedArgs {...*}\r\n     * @returns {Function}\r\n     */\r\n    curryN = (executeArity, fn, ...curriedArgs) => {\r\n        return (...args) => {\r\n            let concatedArgs = concat(curriedArgs, args),\r\n                canBeCalled = (length(concatedArgs) >= executeArity) || !executeArity;\r\n            return !canBeCalled ? apply(curryN, concat([executeArity, fn], concatedArgs)) :\r\n                apply(fn, concatedArgs);\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Curries a _functionOps up to an arity of 2 (won't call _functionOps until 2 or more args).\r\n     * @function module:_functionOps.curry2\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry2 = fn => curryN(2, fn),\r\n\r\n    /**\r\n     * Curries a _functionOps up to an arity of 3 (won't call _functionOps until 3 or more args).\r\n     * @function module:_functionOps.curry3\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry3 = fn => curryN(3, fn),\r\n\r\n    /**\r\n     * Curries a _functionOps up to an arity of 4 (won't call _functionOps until 4 or more args).\r\n     * @function module:_functionOps.curry4\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry4 = fn => curryN(4, fn),\r\n\r\n    /**\r\n     * Curries a _functionOps up to an arity of 5 (won't call _functionOps until 5 or more args).\r\n     * @function module:_functionOps.curry5\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry5 = fn => curryN(5, fn);\r\n","/**\r\n * @memberOf _objectOps\r\n */\r\n\r\n/**\r\n * Returns property value if found; Else `undefined`.\r\n * @function module:_objectOps.prop\r\n * @param name {String} - Key to search on `obj`\r\n * @param obj {Object} - Object to search `name` on.\r\n * @returns {*}\r\n */\r\nexport const prop = (name, obj) => obj[name];\r\n","/**\r\n * Created by elyde on 12/18/2016.\r\n * @memberOf _objectOps\r\n */\r\nconst _Number = Number.name,\r\n    _NaN = 'NaN',\r\n    _Null = 'Null',\r\n    _Undefined = 'Undefined';\r\n\r\n/**\r\n * Returns the constructor/class/type name of a value.\r\n * @note Returns 'NaN' if value is of type `Number` and value is `isNaN`.\r\n * @note Returns 'Undefined' if value is `undefined`\r\n * @note Returns 'Null' if value is `null`\r\n * For values that have no concrete constructors and/or casters\r\n * (null, NaN, and undefined) we returned normalized names for them ('Null', 'NaN', 'Number')\r\n * @function module:_objectOps.typeOf\r\n * @param value {*}\r\n * @returns {string} - Constructor's name or derived name (in the case of `null`, `undefined`, or `NaN` (whose\r\n *  normalized names are 'Null', 'Undefined', 'NaN' respectively).\r\n */\r\nexport function typeOf (value) {\r\n    let retVal;\r\n    if (value === undefined) {\r\n        retVal = _Undefined;\r\n    }\r\n    else if (value === null) {\r\n        retVal = _Null;\r\n    }\r\n    else {\r\n        let constructorName = (value).constructor.name;\r\n        retVal = constructorName === _Number && isNaN(value) ?\r\n            _NaN : constructorName;\r\n    }\r\n    return retVal;\r\n}\r\n","/**\r\n * Created by elyde on 12/18/2016.\r\n * @memberOf _objectOps\r\n */\r\n\r\nimport {typeOf} from './_typeOf';\r\nimport {instanceOf, length, keys, hasOwnProperty} from '../_jsPlatform/_object';\r\n\r\nlet _String = String.name,\r\n    _Number = Number.name,\r\n    _Object = Object.name,\r\n    _Boolean = Boolean.name,\r\n    _Function = Function.name,\r\n    _Array = Array.name,\r\n    _Symbol = 'Symbol',\r\n    _Map = 'Map',\r\n    _Set = 'Set',\r\n    _WeakMap = 'WeakMap',\r\n    _WeakSet = 'WeakSet',\r\n    _Null = 'Null',\r\n    _Undefined = 'Undefined';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns whether a value is a _functionOps or not.\r\n     * @function module:_objectOps._isFunction\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isFunction = value => instanceOf(Function, value),\r\n\r\n    /**\r\n     * Type checker.  Note** The `Type` passed in, if a constructor, should\r\n     * be a named constructor/_functionOps-instance;  E.g.,\r\n     * ```\r\n     *  _functionOps SomeName () {} // or\r\n     *  var SomeName = _functionOps SomeName () {} // or\r\n     *  class SomeName {}\r\n     * ```\r\n     * @function module:_objectOps._isType\r\n     * @param type {Function|String} - Constructor or constructor name\r\n     * @param obj {*}\r\n     * @return {Boolean}\r\n     */\r\n    isType = (type, obj) => typeOf(obj) === (isFunction(type) ? type.name : type),\r\n\r\n    /**\r\n     * Checks if `value` is an es2015 `class`.\r\n     * @function module:_objectOps._isClass\r\n     * @param x {*}\r\n     * @returns {boolean}\r\n     */\r\n    isClass = x => x && /^\\s{0,3}class\\s{1,3}/.test((x + '').substr(0, 10)),\r\n\r\n    /**\r\n     * Returns a boolean depicting whether a value is callable or not.\r\n     * @function module:_objectOps._isCallable\r\n     * @tentative\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isCallable = x => isFunction(x) && !isClass(x),\r\n\r\n    /**\r\n     * Checks if value is an array (same as `Array.isArray`).\r\n     * @function module:_objectOps._isArray\r\n     * @param value {*}\r\n     * @returns {boolean}\r\n     */\r\n    {isArray} = Array,\r\n\r\n    /**\r\n     * Checks whether value is an object or not.\r\n     * @function module:_objectOps._isObject\r\n     * @param value\r\n     * @returns {Boolean}\r\n     */\r\n    isObject = value => isType(_Object, value),\r\n\r\n    /**\r\n     * Checks if value is a boolean.\r\n     * @function module:_objectOps._isBoolean\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isBoolean = value => isType(_Boolean, value),\r\n\r\n    /**\r\n     * Checks if value is a valid number (also checks if isNaN so that you don't have to).\r\n     * @function module:_objectOps._isNumber\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isNumber = value => isType(_Number, value),\r\n\r\n    /**\r\n     * Checks whether value is a stringOps or not.\r\n     * @function module:_objectOps._isString\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isString = value => isType(_String, value),\r\n\r\n    /**\r\n     * Checks whether value is of `Map` or not.\r\n     * @function module:_objectOps._isMap\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isMap = value => isType(_Map, value),\r\n\r\n    /**\r\n     * Checks whether value is of `Set` or not.\r\n     * @function module:_objectOps._isSet\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isSet = value => isType(_Set, value),\r\n\r\n    /**\r\n     * Checks whether value is of `WeakMap` or not.\r\n     * @function module:_objectOps._isWeakMap\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isWeakMap = value => isType(_WeakMap, value),\r\n\r\n    /**\r\n     * Checks whether value is of `WeakSet` or not.\r\n     * @function module:_objectOps._isWeakSet\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isWeakSet = value => isType(_WeakSet, value),\r\n\r\n    /**\r\n     * Checks if value is undefined.\r\n     * @function module:_objectOps._isUndefined\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isUndefined = value => isType(_Undefined, value),\r\n\r\n    /**\r\n     * Checks if value is null.\r\n     * @function module:_objectOps._isNull\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isNull = value => isType(_Null, value),\r\n\r\n    /**\r\n     * Checks if value is a `Symbol`.\r\n     * @function module:_objectOps._isSymbol\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isSymbol = value => isType(_Symbol, value),\r\n\r\n    /**\r\n     * Checks if given `x` is set and of one of\r\n     *  [String, Boolean, Number, Symbol] (null and undefined are immutable\r\n     *  but are not \"usable\" (usually not what we want to operate on).\r\n     * @deprecated If needed copy&paste implementation to your project.\r\n     * @function module:_objectOps._isUsableImmutablePrimitive\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isUsableImmutablePrimitive = x => {\r\n        const typeOfX = typeOf(x);\r\n        return isset(x) &&\r\n            [_String, _Number, _Boolean, _Symbol]\r\n                .some(Type => Type === typeOfX);\r\n    },\r\n\r\n    /**\r\n     * Checks if !length.\r\n     * @function module:_objectOps._isEmptyList\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyList = x => !length(x),\r\n\r\n    /**\r\n     * Checks if object has own properties/enumerable-props or not.\r\n     * @function module:_objectOps._isEmptyObject\r\n     * @param obj {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyObject = obj => isEmptyList(keys(obj)),\r\n\r\n    /**\r\n     * Checks if collection is empty or not (Map, WeakMap, WeakSet, Set etc.).\r\n     * @function module:_objectOps._isEmptyCollection\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyCollection = x => x.size === 0,\r\n\r\n    /**\r\n     * Checks to see if passed in value is empty;  I.e.,\r\n     *  check for one of '', 0, `null`, `undefined`, `false`, empty array, empty object, empty function (zero arity),\r\n     *  or empty collection (es6 Map, Set, WeakMap, or WeakSet etc. (`!value.size`);\r\n     * @function module:_objectOps._isEmpty\r\n     * @param value {*} - Value to check.\r\n     * @returns {Boolean}\r\n     */\r\n    isEmpty = value => {\r\n        let typeOfValue = typeOf(value),\r\n            retVal;\r\n        if (!value) { // if '', 0, `null`, `undefined`, or `false` then is empty\r\n            retVal = true;\r\n        }\r\n        else if (typeOfValue === _Array || typeOfValue === _Function) {\r\n            retVal = isEmptyList(value);\r\n        }\r\n        else if (typeOfValue === _Number) {\r\n            retVal = false;\r\n        }\r\n        else if (typeOfValue === _Object) {\r\n            retVal = isEmptyObject(value);\r\n        }\r\n        else if (hasOwnProperty('size', value) && isNumber(value.size)) {\r\n            retVal = isEmptyCollection(value);\r\n        }\r\n        else {\r\n            retVal = !value;\r\n        }\r\n        return retVal;\r\n    },\r\n\r\n    /**\r\n     * Returns whether passed in values is defined and not null or not.\r\n     * @function module:_objectOps._isset\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isset = x => x !== null && x !== undefined;\r\n","\r\nimport {isObject} from './_is';\r\n\r\nimport {keys, hasOwnProperty} from '../_jsPlatform/_object';\r\n\r\nexport const\r\n    /**\r\n     * Merges all objects down into one.\r\n     * @function module:jsPlatform._objectOps.assignDeep\r\n     * @param obj0 {Object}\r\n     * @param objs {...{Object}}\r\n     * @returns {Object}\r\n     */\r\n    assignDeep = (obj0, ...objs) =>\r\n        objs.reduce((topAgg, obj) =>\r\n                keys(obj).reduce((agg, key) => {\r\n                    let propDescription = Object.getOwnPropertyDescriptor(agg, key);\r\n                    // If property is not writable move to next item in collection\r\n                    if (hasOwnProperty(key, agg) && propDescription &&\r\n                        !(propDescription.get && propDescription.set) &&\r\n                        !propDescription.writable) {\r\n                        return agg;\r\n                    }\r\n                    if (isObject(agg[key]) && isObject(obj[key])) {\r\n                        assignDeep(agg[key], obj[key]);\r\n                    }\r\n                    else { agg[key] = obj[key]; }\r\n                    return agg;\r\n                }, topAgg)\r\n            , obj0);\r\n","/**\r\n * @memberOf _functionOps\r\n */\r\n\r\nimport {apply} from '../_jsPlatform/_function';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Takes a function that takes two parameters and returns a negated version of given\r\n     * function.\r\n     * @function module:_negate.negateF\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateF = fn => (a, b) => !fn(a, b),\r\n\r\n    /**\r\n     * Takes a function that takes three parameters and returns a\r\n     * negated version of given function.\r\n     * @function module:_negate.negateF3\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateF3 = fn => (a, b, c) => !fn(a, b, c),\r\n\r\n    /**\r\n     * Takes a function that takes four parameters and returns a\r\n     * negated version of given function.\r\n     * @function module:_negate.negateF4\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateF4 = fn => (a, b, c, d) => !fn(a, b, c, d),\r\n\r\n    /**\r\n     * Takes a function that takes four parameters and returns a\r\n     * negated version of given function.\r\n     * @function module:_negate.negateF5\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateF5 = fn => (a, b, c, d, e) => !fn(a, b, c, d, e),\r\n\r\n    /**\r\n     * Negates a javascript-'generic' predicate; `Function<element, index, list>`.\r\n     * @function module:_functionOps.negateP\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateP = negateF3,\r\n\r\n    /**\r\n     * Returns a new function which is the dual of `fn` (or the negated version of `fn`).\r\n     * @function module:_functionOps.negateFMany\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateFMany = fn => (...args) => !apply(fn, args);\r\n","/**\r\n * Created by elyde on 7/15/2017.\r\n * @module booleanOps\r\n */\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns whether `value` is 'truthy' or not\r\n     * @function module:booleanOps.isTruthy\r\n     * @param value\r\n     * @returns {Boolean}\r\n     */\r\n    isTruthy = value => !!value,\r\n\r\n    /**\r\n     * Returns whether `value` is 'falsy' or not\r\n     * @function module:booleanOps.isFalsy\r\n     * @param value\r\n     * @returns {Boolean}\r\n     */\r\n    isFalsy = value => !value,\r\n\r\n    /**\r\n     * Returns `true`.\r\n     * @function module:booleanOps.alwaysTrue\r\n     * @returns {Boolean}\r\n     */\r\n    alwaysTrue = () => true,\r\n\r\n    /**\r\n     * Returns `false`.\r\n     * @function module:booleanOps.alwaysFalse\r\n     * @returns {Boolean}\r\n     */\r\n    alwaysFalse = () => false;\r\n","import {isFunction, isset} from './_is';\r\nimport {hasOwnProperty} from '../_jsPlatform/_object';\r\nimport {apply} from '../_jsPlatform/_function';\r\nimport {typeOf} from './_typeOf';\r\n\r\n/**\r\n * Checks if given `x` is set and of one of\r\n *  [String, Boolean, Number, or Symbol] (null and undefined are immutable\r\n *   but are not \"usable\" or 'not what we usually want to operate on'.\r\n * @private\r\n * @param x {*}\r\n * @returns {Boolean}\r\n */\r\nfunction isUsableImmutablePrimitive (x) {\r\n    const typeOfX = typeOf(x);\r\n    return isset(x) &&\r\n        [String.name, Number.name, Boolean.name, Symbol.name]\r\n            .some(Type => Type === typeOfX);\r\n}\r\n\r\n/**\r\n * Creates a value `of` given type;  Checks for one of the following construction strategies (in order listed):\r\n * ```\r\n * // - If exists `(value).constructor.of` uses this.\r\n * // - If value is of one String, Boolean, Symbol, or Number types calls it's\r\n * //      constructor as a function (in cast form;  E.g., `constructor(...args)` )\r\n * // - Else if constructor is a function, thus far, then calls constructor using\r\n * //      the `new` keyword (with any passed in args).\r\n * ```\r\n * @function module:_objectOps.of\r\n * @param x {*} - Value to derive returned value's type from.\r\n * @param [args] {...*} - Any args to pass in to matched construction strategy.\r\n * @returns {*|undefined} - New value of given value's type else `undefined`.\r\n */\r\nexport const of = (x, ...args) => {\r\n    if (!isset(x)) { return undefined; }\r\n    const constructor = x.constructor;\r\n    if (hasOwnProperty('of', constructor)) {\r\n        return apply(constructor.of, args);\r\n    }\r\n    else if (isUsableImmutablePrimitive(x)) {\r\n        return apply(constructor, args);\r\n    }\r\n    else if (isFunction(constructor)) {\r\n        return new constructor(...args);\r\n    }\r\n    return undefined;\r\n};\r\n","/**\r\n * @module _objectOps\r\n * @description Object operations (uncurried).\r\n * @private\r\n */\r\nexport * from './_jsPlatform/_object';\r\nexport * from './_objectOps/_prop';\r\nexport * from './_objectOps/_typeOf';\r\nexport * from './_objectOps/_is';\r\nexport * from './_objectOps/_of';\r\nexport * from './_objectOps/_assignDeep';\r\nexport * from './_objectOps/_setTheory';\r\n","import {typeOf} from '../_objectOps';\r\n\r\nexport const\r\n\r\n    aggregateStr = (agg, item) => agg + item,\r\n\r\n    aggregateArr = (agg, item) => {\r\n        agg.push(item);\r\n        return agg;\r\n    },\r\n\r\n    aggregateObj = (agg, item, ind) => {\r\n        agg[ind] = item;\r\n        return agg;\r\n    },\r\n\r\n    aggregatorByType = x => {\r\n        switch (typeOf(x)) {\r\n            case 'String': return aggregateStr;\r\n            case 'Array': return aggregateArr;\r\n            case 'Object':\r\n            default: return aggregateObj;\r\n        }\r\n    };\r\n","import {of} from '../_objectOps/_of';\r\n\r\nimport {aggregatorByType}   from './_aggregation';\r\n\r\nimport {length}              from '../_jsPlatform/_object';\r\n\r\n/**\r\n * @function module:_listOps.map\r\n * @param fn {Function} - Function to map on functor item(s).\r\n * @param xs {Array|String|*} - Functor.\r\n * @returns {Array|String|*} - Functor type that is passed in.\r\n */\r\nexport const map = (fn, xs) => {\r\n    let ind = 0,\r\n        limit = length(xs),\r\n        out = of(xs),\r\n        aggregate = aggregatorByType(xs);\r\n    if (!limit) { return out; }\r\n    for (; ind < limit; ind += 1) {\r\n        out = aggregate(out, fn(xs[ind], ind, xs), ind, xs);\r\n    }\r\n    return out;\r\n};\r\n","/**\r\n * List operator utils module.\r\n * @module _listOpUtils\r\n * @private\r\n */\r\nimport {apply}              from '../_jsPlatform/_function';  // un-curried version\r\nimport {slice}              from '../_jsPlatform/_list';      // un-curried version good for both strings and arrays\r\nimport {length}             from '../_jsPlatform/_object';\r\nimport {alwaysFalse}        from '../../booleanOps';\r\nimport {map}                from './_map';\r\n\r\nexport * from './_aggregation';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns a slice of the given list from `startInd` to the end of the list.\r\n     * @function module:_listOpsUtils.sliceFrom\r\n     * @param startInd {Number}\r\n     * @param arr {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    sliceFrom = (startInd, arr) => slice(startInd, undefined, arr),\r\n\r\n    /**\r\n     * Slices from index `0` to given index.\r\n     * @function module:_listOpsUtils.sliceTo\r\n     * @param toInd {Number}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    sliceTo = (toInd, xs) => slice(0, toInd, xs),\r\n\r\n    /**\r\n     * Slices a copy of list.\r\n     * @function _listOpUtils.sliceFrom\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    copy = xs => sliceFrom(0, xs),\r\n\r\n    /**\r\n     * Slices a copy of list.\r\n     * @function _listOpUtils.sliceCopy\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    sliceCopy = copy,\r\n\r\n    /**\r\n     * Generic 'ascending order' ordering function (use by the likes of `list.sort` etc.)\r\n     * @function module:_listOpsUtils.genericAscOrdering\r\n     * @param a {*}\r\n     * @param b {*}\r\n     * @returns {number}\r\n     */\r\n    genericAscOrdering = (a, b) => {\r\n        if (a > b) { return 1; }\r\n        else if (a < b) { return -1; }\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * Returns length of all passed lists in list.\r\n     * @function module:_listOpsUtils.lengths\r\n     * @param lists ...{Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    lengths = (...lists) => length(lists) ? map(length, lists) : [],\r\n\r\n    /**\r\n     * @function module:_listOpsUtils.lengthsToSmallest\r\n     * @param lists {...(Array|String|*)}\r\n     * @returns {Array|String|*}\r\n     */\r\n    lengthsToSmallest = (...lists) => {\r\n        const listLengths = apply(lengths, lists),\r\n            smallLen = Math.min.apply(Math, listLengths);\r\n        return map((list, ind) => listLengths[ind] > smallLen ?\r\n            sliceTo(smallLen, list) : copy(list), lists);\r\n    },\r\n\r\n    /**\r\n     * Reduces until predicate.\r\n     * @param pred\r\n     * @param op\r\n     * @param agg\r\n     * @param arr\r\n     * @returns {*}\r\n     */\r\n    reduceUntil = (pred, op, agg, arr) => {\r\n        const limit = length(arr);\r\n        if (!limit) { return agg; }\r\n        let ind = 0,\r\n            result = agg;\r\n        for (; ind < limit; ind++) {\r\n            if (pred(arr[ind], ind, arr)) { break; }\r\n            result = op(result, arr[ind], ind, arr);\r\n        }\r\n        return result;\r\n    },\r\n\r\n    /**\r\n     * Reduces until predicate (from the right).\r\n     * @param pred\r\n     * @param op\r\n     * @param agg\r\n     * @param arr\r\n     * @returns {*}\r\n     */\r\n    reduceRightUntil = (pred, op, agg, arr) => {\r\n        const limit = length(arr);\r\n        if (!limit) { return agg; }\r\n        let ind = limit - 1,\r\n            result = agg;\r\n        for (; ind >= 0; ind--) {\r\n            if (pred(arr[ind], ind, arr)) { break; }\r\n            result = op(result, arr[ind], ind, arr);\r\n        }\r\n        return result;\r\n    },\r\n\r\n    reduce = (operation, agg, arr) =>\r\n        reduceUntil(\r\n            alwaysFalse,            // until-predicate\r\n            operation,              // operation\r\n            agg,                    // aggregator\r\n            arr),                   // list\r\n\r\n    reduceRight = (operation, agg, arr) =>\r\n        reduceRightUntil(\r\n            alwaysFalse,            // until-predicate\r\n            operation,              // operation\r\n            agg,                    // aggregator\r\n            arr),                   // list\r\n\r\n    /**\r\n     * Gets last index of a list/list-like (Array|String|Function etc.).\r\n     * @function module:_listOpUtilslastIndex\r\n     * @param x {Array|String|*} - list like or list.\r\n     * @returns {Number} - `-1` if no element found.\r\n     */\r\n    lastIndex = x => { const len = length(x); return len ? len - 1 : 0; },\r\n\r\n    /**\r\n     * Finds index in string or list.\r\n     * @function module:_listOpUtilsfindIndexWhere\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    findIndexWhere = (pred, arr) => {\r\n        let ind = -1,\r\n            predicateFulfilled = false;\r\n        const limit = length(arr);\r\n        while (ind < limit && !predicateFulfilled) {\r\n            predicateFulfilled = pred(arr[++ind], ind, arr);\r\n        }\r\n        return ind;\r\n    },\r\n\r\n    /**\r\n     * Finds index in list from right to left.\r\n     * @function module:_listOpUtilsfindIndexWhereRight\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    findIndexWhereRight = (pred, arr) => {\r\n        const limit = length(arr);\r\n        let ind = limit,\r\n            predicateFulfilled = false;\r\n        for (; ind >= 0 && !predicateFulfilled; --ind) {\r\n            predicateFulfilled = pred(arr[ind], ind, arr);\r\n        }\r\n        return ind;\r\n    },\r\n\r\n    /**\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {Array|undefined}\r\n     */\r\n    findIndicesWhere = (pred, xs) => {\r\n        const limit = length(xs);\r\n        if (!limit) { return undefined; }\r\n        let ind = 0,\r\n            out = [];\r\n        for (; ind < limit; ind++) {\r\n            if (pred(xs[ind], ind, xs)) { out.push(ind); }\r\n        }\r\n        return out.length ? out : undefined;\r\n    },\r\n\r\n    /**\r\n     * @function module:_listOpUtilsfind\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    findWhere = (pred, xs) => {\r\n        let ind = 0,\r\n            limit = length(xs);\r\n        if (!limit) { return; }\r\n        for (; ind < limit; ind++) {\r\n            let elm = xs[ind];\r\n            if (pred(elm, ind, xs)) { return elm; }\r\n        }\r\n    }\r\n\r\n;\r\n","/**\r\n * List operations module.\r\n * @module _listOps\r\n * @todo decide whether to throw errors where functions cannot function without a specific type or to return undefined (and also determine which cases are ok for just returning undefined).\r\n * @private\r\n */\r\nimport {\r\n    concat as listAppend,\r\n    indexOf, slice, includes\r\n}\r\n    from './_jsPlatform/_list';\r\n\r\nimport {apply} from './_jsPlatform/_function';\r\nimport {negateP, negateF} from './_functionOps/_negate';\r\nimport {isTruthy, isFalsy} from '../booleanOps';\r\nimport {isString, isEmptyList, prop, of, length/*, isset*/} from './_objectOps';\r\nimport {map} from './_listOps/_map';\r\n\r\nimport {\r\n    sliceFrom, sliceTo, lengths,\r\n    lengthsToSmallest, aggregateArr, aggregatorByType,\r\n    reduceUntil, reduce, reduceRight, lastIndex,\r\n    findIndexWhere, findIndexWhereRight, findIndicesWhere,\r\n    findWhere, copy, genericAscOrdering\r\n}\r\n    from './_listOps/_utils';\r\n\r\n// Exported imports\r\nexport {map};\r\n\r\n// Exported internals\r\nexport const\r\n\r\n    /**\r\n     * Append two lists, i.e.,\r\n     * ```\r\n     * append([x1, ..., xm], [y1, ..., yn]) // outputs: [x1, ..., xm, y1, ..., yn]\r\n     * append([x1, ..., xm], [y1, ...]) // outputs: [x1, ..., xm, y1, ...]\r\n     * ```\r\n     * If the first list is not finite, the result is the first list.\r\n     * @haskellType `append :: List a => a -> a -> a`\r\n     * @function module:_listOps.append\r\n     * @param xs1 {Array|String|*} - list or list like.\r\n     * @param xs2 {Array|String|*} - list or list like.\r\n     * @returns {Array|String|*} - Same type as list like passed in.\r\n     */\r\n    append = listAppend,\r\n\r\n    /**\r\n     * Append two or more lists, i.e., same as `append` but for two ore more lists.\r\n     * @haskellType `appendMany :: List a => a -> [a] -> a\r\n     * @note In `@haskellType` we wrote `[a]` only to keep the haskell type valid though note in javascript\r\n     *  this is actually different since the function converts the zero ore more parameters into an array containing such for us.\r\n     * @function module:_listOps.appendMany\r\n     * @param args ...{Array|String|*} - Lists or lists likes.\r\n     * @returns {Array|String|*} - Same type as first list or list like passed in.\r\n     */\r\n    appendMany = (...args) => {\r\n        if (length(args)) { return apply(listAppend, args); }\r\n        throw new Error('`appendMany` requires at least one arg.');\r\n    },\r\n\r\n    /**\r\n     * Returns head of list (first item of list).\r\n     * @haskellType `head :: [a] -> a`\r\n     * @function module:_listOps.head\r\n     * @param x {Array|String}\r\n     * @returns {*} - First item from list\r\n     */\r\n    head = x => x[0],\r\n\r\n    /**\r\n     * Returns last item of list.\r\n     * @haskellType `last :: [a] -> a`\r\n     * @function module:_listOps.last\r\n     * @param xs {Array|String}\r\n     * @returns {*}\r\n     */\r\n    last = xs => xs[lastIndex(xs)],\r\n\r\n    /**\r\n     * Returns tail part of list (everything after the first item as new list).\r\n     * @haskelType `tail :: [a] -> [a]`\r\n     * @function module:_listOps.tail\r\n     * @param xs {Array}\r\n     * @returns {Array}\r\n     */\r\n    tail = xs => sliceFrom(1, xs),\r\n\r\n    /**\r\n     * Returns everything except last item of list as new list.\r\n     * @haskellType `init :: [a] -> [a]`\r\n     * @function module:_listOps.init\r\n     * @param xs {Array|String}\r\n     * @returns {Array|String}\r\n     */\r\n    init = xs => sliceTo(lastIndex(xs), xs),\r\n\r\n    /**\r\n     * Returns `head` and `tail` of passed in list/string in a tuple.\r\n     * @haskellType `uncons :: [a] -> Maybe (a, [a])`\r\n     * @function module:_listOps.uncons\r\n     * @param xs {Array|String}\r\n     * @returns {Array|String|*|undefined}\r\n     */\r\n    uncons = xs => {\r\n        if (!xs) {\r\n            return;\r\n        }\r\n        if (length(xs) === 0) {\r\n            return undefined;\r\n        }\r\n        return [head(xs), tail(xs)];\r\n    },\r\n\r\n    /**\r\n     * Returns `tail` and `head` of passed in list/string in a tuple.\r\n     * @haskellType `unconsr :: [a] -> Maybe ([a], a)`\r\n     * @function module:_listOps.unconsr\r\n     * @param xs {Array|String}\r\n     * @returns {Array|String|*|undefined}\r\n     */\r\n    unconsr = xs => {\r\n        if (!xs) {\r\n            return;\r\n        }\r\n        if (length(xs) === 0) {\r\n            return undefined;\r\n        }\r\n        return [init(xs), last(xs)];\r\n    },\r\n    \r\n    /**\r\n     * Concatenates all the elements of a container of lists.\r\n     * @haskellType `concat :: Foldable t => t [a] -> [a]`\r\n     * @function module:_listOps.concat\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    concat = xs => {\r\n        if (!length(xs)) { return copy(xs); }\r\n        return isString(xs) ? xs : apply(appendMany, xs);\r\n    },\r\n\r\n    /**\r\n     * Map a function over all the elements of a container and concatenate the resulting lists.\r\n     * @haskellType `concatMap :: Foldable t => (a -> [b]) -> t a -> [b]`\r\n     * @function module:_listOps.concatMap\r\n     * @param fn {Function}\r\n     * @param foldableOfA {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    concatMap = (fn, foldableOfA) => concat(map(fn, foldableOfA)),\r\n\r\n    /**\r\n     * Returns a copy of the passed in list reverses.\r\n     * @haskellType `reverse :: [a] -> [a]`\r\n     * @function module:_listOps.reverse\r\n     * @param x {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    reverse = x => {\r\n        const aggregator = aggregatorByType(x);\r\n        return foldr (\r\n            (agg, item, ind) => aggregator(agg, item, ind),\r\n            of(x), x\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Takes an element and a list and `intersperses' that element between the elements of the list. For example\r\n     * @function module:_listOps.intersperse\r\n     * @note In our version of the function javascript is loosely typed so, so is our function (to much overhead to make\r\n     *  it typed) so `between` can be any value.\r\n     * @param between {*} - Should be of the same type of elements contained in list.\r\n     * @param arr {Array|String|*} - List.\r\n     * @returns {Array|String|*}\r\n     */\r\n    intersperse = (between, arr) => {\r\n        const limit = length(arr),\r\n            lastInd = limit - 1,\r\n            aggregator = of(arr),\r\n            aggregatorOp = aggregatorByType(arr);\r\n        if (!limit) {\r\n            return aggregator;\r\n        }\r\n        return foldl((agg, item, ind) => {\r\n            return ind === lastInd ?\r\n                aggregatorOp(agg, item) :\r\n                aggregatorOp(\r\n                    aggregatorOp(agg, item),\r\n                    between\r\n                );\r\n        }, aggregator, arr);\r\n    },\r\n\r\n    /**\r\n     * `intercalate xs xss` is equivalent to (concat (intersperse xs xss)). It inserts the list xs in between the lists in xss and concatenates the result.\r\n     * @haskellType `intercalate :: [a] -> [[a]] -> [a]`\r\n     * @function module:_listOps.intercalate\r\n     * @param xs {Array|String|*}\r\n     * @param xss {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    intercalate = (xs, xss) => concat(intersperse(xs, xss)),\r\n\r\n    /**\r\n     * Transposes rows and columns into lists by index;  E.g.,\r\n     * Haskell example:\r\n     * ```\r\n     *  transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]\r\n     *\r\n     *  -- Notice the shorter arrays are ignored after their last index is copied over:\r\n     *  transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]\r\n     * ```\r\n     * @note from columns to rows.\r\n     * @note Empty lists are ignored.\r\n     * @todo upgrade this function to support lists of strings.\r\n     * @haskellType `transpose :: [[a]] -> [[a]]`\r\n     * @function module:_listOps.transpose\r\n     * @param xss {Array}\r\n     * @returns {Array}\r\n     */\r\n    transpose = xss => {\r\n        let numLists = length(xss),\r\n            ind = 0, ind2;\r\n        if (!numLists) {\r\n            return of(xss);\r\n        }\r\n        const listLengths = apply(lengths, xss),\r\n            longestListLen = maximum(listLengths),\r\n            outLists = [];\r\n        for (; ind < longestListLen; ind += 1) {\r\n            const outList = [];\r\n            for (ind2 = 0; ind2 < numLists; ind2 += 1) {\r\n                if (listLengths[ind2] < ind + 1) {\r\n                    continue;\r\n                }\r\n                outList.push(xss[ind2][ind]);\r\n            }\r\n            outLists.push(outList);\r\n        }\r\n        return filter(x => length(x), outLists);\r\n    },\r\n\r\n    /**\r\n     * Generates 2^n sub-sequences for passed in sequence (string/list) (`n` is\r\n     * the length of the passed in sequence so: 2^length(xs)).\r\n     * Note: The return value doubles per index/character passed in so use with caution!\r\n     *  Also note that for 2^16 (or for a sequence of 16 characters) this algorithm\r\n     *  will generate 65536 sub-sequences!  So caution should be taken to not\r\n     *  use this with sequences above a certain length on certain platform (the browser thread in specific).\r\n     * @function module:_listOps.subsequences\r\n     * @jsperftest https://jsperf.com/subsequences\r\n     * @param xs {Array|String}\r\n     * @returns {Array.<Array>}\r\n     */\r\n    subsequences = xs => {\r\n        const listLen = length(xs),\r\n            len = Math.pow(2, listLen),\r\n            out = [];\r\n        for (let i = 0; i < len; i += 1) {\r\n            let entry = [];\r\n            for (let j = 0; j < listLen; j += 1) {\r\n                if (i & (1 << j)) {\r\n                    entry.push(xs[j]);\r\n                }\r\n            }\r\n            out.push(entry);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Same as `subsequences` but returns an `Array.<Type>` instead\r\n     *  of an array of arrays.  **Note:** `Type` here means\r\n     *  a string, an instance of array, or some indexable-like type.\r\n     * @function module:_listOps.subsequences1\r\n     * @jsperftest https://jsperf.com/subsequences\r\n     * @param xs {Array|String}\r\n     * @returns {Array.<(Array|String|*)>}\r\n     */\r\n    subsequences1 = xs => {\r\n        const listLen = length(xs),\r\n            len = Math.pow(2, listLen),\r\n            aggregator = aggregatorByType(xs),\r\n            out = [];\r\n        for (let i = 0; i < len; i += 1) {\r\n            let entry = of(xs);\r\n            for (let j = 0; j < listLen; j += 1) {\r\n                if (i & (1 << j)) {\r\n                    entry = aggregator(entry, xs[j]);\r\n                }\r\n            }\r\n            out.push(entry);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    swapped = (ind1, ind2, list) => {\r\n        const out = sliceFrom(0, list),\r\n            tmp = out[ind1];\r\n        out[ind1] = out[ind2];\r\n        out[ind2] = tmp;\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Returns a list of permutations for passed in list.\r\n     *  Use caution with lists above a length of 15 (will take long due to nature of\r\n     *  algorithm).\r\n     * @function module:_listOps.permutations\r\n     * @param xs {Array|String|*} - List.\r\n     * @returns {Array<Array|String|*>} - Array of permutations.\r\n     */\r\n    permutations = xs => {\r\n        const limit = length(xs);\r\n\r\n        if (!limit || limit === 1) {\r\n            return [xs];\r\n        }\r\n\r\n        let list = sliceFrom(0, xs),\r\n            c = repeat(limit, 0),\r\n            i = 0;\r\n\r\n        const out = [list];\r\n\r\n        for (; i < limit; i++) {\r\n            if (c[i] < i) {\r\n                list = swapped(i % 2 === 0 ? 0 : c[i], i, list);\r\n                out.push(list);\r\n                c[i] += 1;\r\n                i = 0;\r\n                continue;\r\n            }\r\n            c[i] = 0;\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Left associative fold.  Reduces a container of elements down by the given operation (same as [].reduce).\r\n     * @function module:_listOps.foldl\r\n     * @param fn {Function}\r\n     * @param zero {*} - Aggregator.\r\n     * @param functor {Array|String|*}\r\n     * @returns {*} - Whatever type is lastly returned from `fn`.\r\n     */\r\n    foldl = reduce,\r\n\r\n    /**\r\n     * Right associative fold.  Reduces a container of elements down by the given operation (same as [].reduceRight).\r\n     * @function module:_listOps.foldr\r\n     * @param fn {Function}\r\n     * @param zero {*} - Aggregator.\r\n     * @param functor {Array|String|*}\r\n     * @returns {*} - Whatever type is lastly returned from `fn`.\r\n     */\r\n    foldr = reduceRight,\r\n\r\n    /**\r\n     * A variant of `foldl` except that this one doesn't require the starting point.  The starting point/value will be pulled\r\n     * out from a copy of the container.\r\n     * @function module:_listOps.foldl1\r\n     * @param op {Function}\r\n     * @param xs {Array|String|*}\r\n     * @returns {*} - Whatever type is lastly returned from `op`.\r\n     */\r\n    foldl1 = (op, xs) => {\r\n        const parts = uncons(xs);\r\n        if (!parts) {\r\n            return of(xs);\r\n        }\r\n        return reduce(op, parts[0], parts[1]);\r\n    },\r\n\r\n    /**\r\n     * A variant of `foldr` except that this one doesn't require the starting point/value.  The starting point/value will be pulled\r\n     * out from a copy of the container.\r\n     * @function module:_listOps.foldr1\r\n     * @param op {Function}\r\n     * @param xs {Array|String|*}\r\n     * @returns {*} - Whatever type is lastly returned from `op`.\r\n     */\r\n    foldr1 = (op, xs) => {\r\n        const parts = unconsr(xs);\r\n        if (!parts) {\r\n            return of(xs);\r\n        }\r\n        return reduceRight(op, parts[1], parts[0]);\r\n    },\r\n\r\n    /**\r\n     * Performs a map then a reduce all in one (from left-to-right). Returns a tuple\r\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\r\n     * @function module:_listOps.mapAccumL\r\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\r\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\r\n     * @param xs {Array|String|*} - list type.\r\n     * @return {Array} - [aggregated, list]\r\n     */\r\n    mapAccumL = (op, zero, xs) => {\r\n        const list = sliceFrom(0, xs),\r\n            limit = length(xs);\r\n        if (!limit) {\r\n            return [zero, list];\r\n        }\r\n        let ind = 0,\r\n            agg = zero,\r\n            mapped = of(xs),\r\n            tuple;\r\n        for (; ind < limit; ind++) {\r\n            tuple = op(agg, list[ind], ind);\r\n            agg = tuple[0];\r\n            mapped = tuple[1];\r\n        }\r\n        return [agg, mapped];\r\n    },\r\n\r\n    /**\r\n     * Performs a map and a reduce all in one (from right-to-left). Returns a tuple\r\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\r\n     * @function module:_listOps.mapAccumR\r\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\r\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\r\n     * @param xs {Array|String|*} - list type.\r\n     * @return {Array} - [aggregated, list]\r\n     */\r\n    mapAccumR = (op, zero, xs) => {\r\n        const list = sliceFrom(0, xs),\r\n            limit = length(xs);\r\n        if (!limit) {\r\n            return [zero, list];\r\n        }\r\n        let ind = limit - 1,\r\n            agg = zero,\r\n            mapped = of(xs),\r\n            tuple;\r\n        for (; ind >= 0; ind--) {\r\n            tuple = op(agg, list[ind], ind);\r\n            agg = tuple[0];\r\n            mapped = tuple[1];\r\n        }\r\n        return [agg, mapped];\r\n    },\r\n\r\n    /**\r\n     * Iterate on value (`x`) with `op` up to `limit`.\r\n     * @function module:_listOps.iterate\r\n     * @param limit {Number}\r\n     * @param op {Function} - Operation\r\n     * @param x {*} - Starting point.\r\n     * @returns {*}\r\n     */\r\n    iterate = (limit, op, x) => {\r\n        let ind = 0,\r\n            out = x;\r\n        for (; ind < limit; ind += 1) {\r\n            out = op(out, ind);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Repeats `x` `limit` number of times\r\n     * @function module:_listOps.repeat\r\n     * @param limit {Number}\r\n     * @param x {*}\r\n     * @return {Array}\r\n     */\r\n    repeat = (limit, x) =>\r\n        iterate(limit, agg => {\r\n            agg.push(x);\r\n            return agg;\r\n        }, []),\r\n\r\n    /**\r\n     * Same as `repeat` due to the nature of javascript (see haskell version for usage).\r\n     * @function module:_listOps.replicate\r\n     * @param limit {Number}\r\n     * @param x {*}\r\n     * @return {Array}\r\n     */\r\n    replicate = repeat,\r\n\r\n    /**\r\n     * Replicates a list `limit` number of times and appends the results (concat)\r\n     * @function module:_listOps.cycle\r\n     * @param limit {Number}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    cycle = (limit, xs) => concat(replicate(limit, xs)),\r\n\r\n    /**\r\n     * Unfolds a value into a list of somethings.\r\n     * @haskellType `unfoldr :: (b -> Maybe (a, b)) -> b -> [a]`\r\n     * @function module:_listOps.unfoldr\r\n     * @param op {Function} - Operation to perform (should return a two component tuple (item to aggregate and item to unfold in next iteration).\r\n     * @param x {*} - Starting parameter to unfold from.\r\n     * @returns {Array} - An array of whatever you return from `op` yielded.\r\n     */\r\n    unfoldr = (op, x) => {\r\n        let ind = 0,\r\n            out = [],\r\n            resultTuple = op(x, ind, out);\r\n        while (resultTuple) {\r\n            out.push(resultTuple[0]);\r\n            resultTuple = op(resultTuple[1], ++ind, out);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Finds index in string or list (alias for `findIndex`).\r\n     * @function module:_listOps.findIndex\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    findIndex = findIndexWhere,\r\n\r\n    /**\r\n     * @function module:_listOps.findIndices\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {Array|undefined}\r\n     */\r\n    findIndices = findIndicesWhere,\r\n\r\n    /**\r\n     * @function module:_listOps.elemIndex\r\n     * @param x {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    elemIndex = (x, xs) => {\r\n        const foundInd = indexOf(x, xs);\r\n        return foundInd !== -1 ? foundInd : undefined;\r\n    },\r\n\r\n    /**\r\n     * @function module:_listOps.elemIndices\r\n     * @param value {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    elemIndices = (value, xs) => findIndices(x => x === value, xs),\r\n\r\n    /**\r\n     * Takes `n` items from start of list to `limit` (exclusive).\r\n     * @function module:_listOps.take\r\n     * @param list {Array|String}\r\n     * @param limit {Number}\r\n     * @returns {String|Array} - Passed in type's type\r\n     */\r\n    take = (limit, list) => sliceTo(limit, list),\r\n\r\n    /**\r\n     * Drops `n` items from start of list to `count` (exclusive).\r\n     * @function module:_listOps.take\r\n     * @param list {Array|String}\r\n     * @param count {Number}\r\n     * @returns {String|Array} - Passed in type's type\r\n     */\r\n    drop = (count, list) => sliceFrom(count, list),\r\n\r\n    /**\r\n     * Splits `x` in two at given `index` (exclusive (includes element/character at\r\n     * given index in second part of returned list)).\r\n     * @function module:_listOps.splitAt\r\n     * @param ind {Number} - Index to split at.\r\n     * @param list {Array|String|*} - functor (list or string) to split.\r\n     * @returns {Array} - Array of whatever type `x` was when passed in\r\n     */\r\n    splitAt = (ind, list) => [\r\n        sliceTo(ind, list),\r\n        sliceFrom(ind, list)\r\n    ],\r\n\r\n    /**\r\n     * Gives an list with passed elements while predicate was true.\r\n     * @function module:_listOps.takeWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @returns {Array}\r\n     */\r\n    takeWhile = (pred, list) => {\r\n        let zero = of(list);\r\n        const operation = aggregatorByType(list);\r\n        return reduceUntil(\r\n            negateP(pred),  // predicate\r\n            operation,      // operation\r\n            zero,           // aggregator\r\n            list\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Returns an list without elements that match predicate.\r\n     * @function module:_listOps.dropWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @refactor\r\n     * @returns {Array|String}\r\n     */\r\n    dropWhile = (pred, list) => {\r\n        const limit = length(list),\r\n            splitPoint =\r\n                findIndexWhere((item, ind, list2) =>\r\n                    !pred(list[ind], ind, list2), list);\r\n\r\n        return splitPoint === -1 ?\r\n            sliceTo(limit, list) :\r\n            slice(splitPoint, limit, list);\r\n    },\r\n\r\n    /**\r\n     * @function module:_listOps.dropWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @refactor\r\n     * @returns {Array|String}\r\n     */\r\n    dropWhileEnd = (pred, list) => {\r\n        const limit = length(list),\r\n            splitPoint =\r\n                findIndexWhereRight((item, ind, list2) =>\r\n                    !pred(list[ind], ind, list2), list);\r\n\r\n        return splitPoint === -1 ?\r\n            sliceTo(limit, list) :\r\n            sliceTo(splitPoint + 1, list);\r\n    },\r\n\r\n    /**\r\n     * Gives a span such that the first list (in returned tuple) is the span of items matching upto `not predicate` and\r\n     * the second list in the tuple is a list of the remaining elements in the given list.\r\n     * **@Note: Not the same as `partition`.  Read descriptions closely!!!\r\n     * @function module:_listOps.partition\r\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\r\n     * @param list {Array|String|*} - Predicate<item, index, originalArrayOrString>\r\n     * @returns {Array|String|*} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\r\n     */\r\n    span = (pred, list) => {\r\n        const splitPoint = findIndexWhere(negateP(pred), list);\r\n        return splitPoint === -1 ?\r\n            splitAt(0, list) : splitAt(splitPoint, list);\r\n    },\r\n\r\n    breakOnList = (pred, list) => {\r\n        const splitPoint = findIndexWhere(pred, list);\r\n        return splitPoint === -1 ?\r\n            splitAt(0, list) : splitAt(splitPoint, list);\r\n    },\r\n\r\n    /**\r\n     * @function module:_listOps.at\r\n     * @param ind {Number} - Index.\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    at = prop,\r\n\r\n    /**\r\n     * Find an item in structure of elements based on given predicate (`pred`).\r\n     * @function module:_listOps.find\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*} - Found item.\r\n     */\r\n    find = findWhere,\r\n\r\n    /**\r\n     * Filters a structure of elements using given predicate (`pred`) (same as `[].filter`).\r\n     * @function module:_listOps.filter\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {Array|String|*} - Structure of filtered elements.\r\n     */\r\n    filter = (pred, xs) => {\r\n        let ind = 0,\r\n            limit = length(xs),\r\n            aggregator = aggregatorByType(xs),\r\n            out = of(xs);\r\n        if (!limit) {\r\n            return out;\r\n        }\r\n        for (; ind < limit; ind++) {\r\n            if (pred(xs[ind], ind, xs)) {\r\n                out = aggregator(out, xs[ind]);\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Partitions a list on a predicate;  Items that match predicate are in first list in tuple;  Items that\r\n     * do not match the tuple are in second list in the returned tuple.\r\n     *  Essentially `[filter(p, xs), filter(negateP(p), xs)]`.\r\n     * @function module:_listOps.partition\r\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\r\n     * @param list {Array|String|*}\r\n     * @returns {Array|String} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\r\n     */\r\n    partition = (pred, list) => {\r\n        if (!length(list)) {\r\n            return [of(list), of(list)];\r\n        }\r\n        return [filter(pred, list), filter(negateP(pred), list)];\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean indicating whether an element exists in given structure of elements.\r\n     * @function module:_listOps.elem\r\n     * @param element {*}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Boolean}\r\n     */\r\n    elem = includes,\r\n\r\n    /**\r\n     * The opposite of `elem` - Returns a boolean indicating whether an element exists in given list.\r\n     * @function module:_listOps.elem\r\n     * @param element {*}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Boolean}\r\n     */\r\n    notElem = negateF(includes),\r\n\r\n    lookup = at,\r\n\r\n    isPrefixOf = (xs1, xs2) => {\r\n        const limit1 = length(xs1),\r\n            limit2 = length(xs2);\r\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\r\n            return false;\r\n        }\r\n        let ind = 0;\r\n        for (; ind < limit1; ind++) {\r\n            if (xs1[ind] !== xs2[ind]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n\r\n    isSuffixOf = (xs1, xs2) => {\r\n        const limit1 = length(xs1),\r\n            limit2 = length(xs2);\r\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\r\n            return false;\r\n        }\r\n        let ind1 = limit1 - 1,\r\n            ind2 = limit2 - 1;\r\n        for (; ind1 >= 0; ind1--) {\r\n            if (xs1[ind1] !== xs2[ind2]) {\r\n                return false;\r\n            }\r\n            ind2 -= 1;\r\n        }\r\n        return true;\r\n    },\r\n\r\n    isInfixOf = (xs1, xs2) => {\r\n        const limit1 = length(xs1),\r\n            limit2 = length(xs2);\r\n        if (limit2 < limit1 || !limit1 || !limit2) {\r\n            return false;\r\n        }\r\n        let ind1,\r\n            foundLen,\r\n            ind = 0;\r\n        for (; ind < limit2; ind += 1) {\r\n            foundLen = 0;\r\n            for (ind1 = 0; ind1 < limit1; ind1 += 1) {\r\n                if (xs2[ind1 + ind] === xs1[ind1]) {\r\n                    foundLen += 1;\r\n                }\r\n                if (foundLen === limit1) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    isSubsequenceOf = (xs1, xs2) => {\r\n        const len = Math.pow(2, length(xs2)),\r\n            lenXs1 = length(xs1);\r\n        let foundLen,\r\n            i;\r\n        for (i = 0; i < len; i += 1) {\r\n            foundLen = 0;\r\n            for (let j = 0; j < len; j += 1) {\r\n                if (i & (1 << j) && indexOf(xs2[j], xs1) > -1) {\r\n                    foundLen += 1;\r\n                }\r\n                if (foundLen === lenXs1) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * The group function takes a list and returns a list of lists such that\r\n     *  the concatenation of the result is equal to the argument. Moreover, each\r\n     *  sublist in the result contains only equal elements. For example,\r\n     * `group \"Mississippi\" = [\"M\",\"i\",\"ss\",\"i\",\"ss\",\"i\",\"pp\",\"i\"]`\r\n     * It is a special case of groupBy, which allows the programmer to supply\r\n     *  their own equality test.\r\n     * @haskellType `group :: Eq a => [a] -> [[a]]`\r\n     * @function module:_listOps.group\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array<Array|String|*>|*}\r\n     */\r\n    group = xs => groupBy((a, b) => a === b, xs),\r\n\r\n    /**\r\n     * Allows you to group items in a list based on your supplied equality check.\r\n     * @note Sames `group` but allows you to specify equality operation.\r\n     * @haskellType `groupBy :: (a -> a -> Bool) -> [a] -> [[a]]`\r\n     * @function module:_listOps.groupBy\r\n     * @param equalityOp {Function}\r\n     * @param xs {Array|String|*}\r\n     * @returns {*}\r\n     */\r\n    groupBy = (equalityOp, xs) => {\r\n        const limit = length(xs);\r\n        if (!limit) {\r\n            return sliceFrom(0, xs);\r\n        }\r\n        let ind = 0,\r\n            prevItem,\r\n            item,\r\n            predOp = x => {\r\n                if (equalityOp(x, prevItem)) {\r\n                    ind++;\r\n                }\r\n                if (equalityOp(x, item)) {\r\n                    prevItem = x;\r\n                    return true;\r\n                }\r\n                return false;\r\n            },\r\n            agg = [];\r\n        for (; ind < limit; ind += 1) {\r\n            item = xs[ind];\r\n            agg.push(takeWhile(predOp, slice(ind, limit, xs)));\r\n        }\r\n        return agg;\r\n    },\r\n\r\n    /**\r\n     * The inits function returns all initial segments of the argument, shortest first. For example,\r\n     * ```\r\n     * shallowEquals(inits('abc'), ['','a','ab','abc'])\r\n     * ```\r\n     * @function module:_listOps.inits\r\n     * @haskellType `inits :: [a] -> [[a]]`\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    inits = xs => {\r\n        let limit = length(xs),\r\n            ind = 0,\r\n            agg = [];\r\n        if (!limit) {\r\n            return [];\r\n        }\r\n        for (; ind <= limit; ind += 1) {\r\n            agg = aggregateArr(agg, sliceTo(ind, xs));\r\n        }\r\n        return agg;\r\n    }, //map(list => init(list), xs),\r\n\r\n    /**\r\n     * The inits function returns all initial segments of the argument, shortest first. For example,\r\n     * ```\r\n     * shallowEquals(tails('abc'), ['abc', 'bc', 'c',''])\r\n     * ```\r\n     * @function module:_listOps.tails\r\n     * @haskellType `tails :: [a] -> [[a]]`\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    tails = xs => {\r\n        let limit = length(xs),\r\n            ind = 0,\r\n            agg = [];\r\n        if (!limit) {\r\n            return [];\r\n        }\r\n        for (; ind <= limit; ind += 1) {\r\n            agg = aggregateArr(agg, slice(ind, limit, xs));\r\n        }\r\n        return agg;\r\n    }, //map(list => tail(list), xs),\r\n\r\n    stripPrefix = (prefix, list) =>\r\n        isPrefixOf(prefix, list) ?\r\n            splitAt(length(prefix), list)[1] :\r\n            sliceFrom(0, list),\r\n\r\n    /**\r\n     * zip takes two lists and returns a list of corresponding pairs.\r\n     * If one input list is short, excess elements of the longer list are discarded.\r\n     * @haskellType `zip :: [a] -> [b] -> [(a, b)]`\r\n     * @function module:_listOps.zip\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip = (arr1, arr2) => {\r\n        if (!length(arr1) || !length(arr2)) {\r\n            return of(arr1);\r\n        }\r\n        const [a1, a2] = lengthsToSmallest(arr1, arr2);\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArr(agg, [item, a2[ind]]),\r\n            [], a1);\r\n    },\r\n\r\n    /**\r\n     * zipN takes one or more lists and returns a list containing lists of all indices\r\n     * at a given index, index by index.\r\n     * If one input list is short, excess elements of the longer list are discarded.\r\n     * @function module:_listOps.zipN\r\n     * @param lists {Array|String} - One ore more lists of the same type.\r\n     * @returns {Array}\r\n     */\r\n    zipN = (...lists) => {\r\n        const trimmedLists = apply(lengthsToSmallest, filter(length, lists)),\r\n            lenOfTrimmed = length(trimmedLists);\r\n        if (!lenOfTrimmed) {\r\n            return [];\r\n        }\r\n        else if (lenOfTrimmed === 1) {\r\n            return sliceTo(length(trimmedLists[0]), trimmedLists[0]);\r\n        }\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArr(agg, map(xs => xs[ind], trimmedLists)),\r\n            [], trimmedLists[0]);\r\n    },\r\n\r\n    /**\r\n     * @haskellType `zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]`\r\n     * @function module:_listOps.zip3\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip3 = (arr1, arr2, arr3) => zipN(arr1, arr2, arr3),\r\n\r\n    /**\r\n     * @haskellType `zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]`\r\n     * @function module:_listOps.zip4\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @param arr4 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip4 = (arr1, arr2, arr3, arr4) => zipN(arr1, arr2, arr3, arr4),\r\n\r\n    /**\r\n     * @haskellType `zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]`\r\n     * @function module:_listOps.zip5\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @param arr4 {Array}\r\n     * @param arr5 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip5 = (arr1, arr2, arr3, arr4, arr5) => zipN(arr1, arr2, arr3, arr4, arr5),\r\n\r\n    /**\r\n     * zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\r\n     * zipWith generalises zip by zipping with the function given as the\r\n     * first argument, instead of a function tupling function (function that returns a tuple). For example,\r\n     * zipWith (+) is applied to two lists to produce the list of corresponding sums.\r\n     * @note `_|_` means bottom or perpetual (@see\r\n     *  - https://wiki.haskell.org/Bottom\r\n     *  - https://stackoverflow.com/questions/19794681/what-does-this-syntax-mean-in-haskell-or\r\n     *  )\r\n     * @example\r\n     * ```\r\n     * zipWith f [] _|_ = []\r\n     * ```\r\n     * @haskellType `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`\r\n     * @function module:_listOps.zipWith\r\n     * @param op {Function} - Takes two parts of a tuple and returns a tuple.\r\n     *  E.g., ` op :: a -> b -> (a, b)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith = (op, xs1, xs2) => {\r\n        if (!length(xs1) || !length(xs2)) {\r\n            return of(xs1);\r\n        }\r\n        const [a1, a2] = lengthsToSmallest(xs1, xs2);\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArr(agg, op(item, a2[ind])),\r\n            [], a1);\r\n    },\r\n\r\n    /**\r\n     * Zips all given lists with tupling function. Note: Haskell types do not have\r\n     *  a way (that I know of) to show one or more for params in a function so `@haskellType` below\r\n     *  is left there for general purpose not for exactness as is told by aforementioned.\r\n     * @haskellType `zipWithN :: (a -> b -> c) -> [a] -> [b] -> [c]` - Where `N` is the number\r\n     *  of lists to zip.\r\n     * @function module:_listOps.zipWithN\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\r\n     * @param lists ...{Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWithN = (op, ...lists) => {\r\n        const trimmedLists = apply(lengthsToSmallest, lists),\r\n            lenOfTrimmed = length(trimmedLists);\r\n        if (!lenOfTrimmed) {\r\n            return [];\r\n        }\r\n        else if (lenOfTrimmed === 1) {\r\n            return sliceTo(length(trimmedLists[0]), trimmedLists[0]);\r\n        }\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArr(agg, apply(op, map(xs => xs[ind], trimmedLists))),\r\n            [], trimmedLists[0]);\r\n    },\r\n\r\n    /**\r\n     * Zips 3 lists with tupling function.\r\n     * @haskellType `zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]`\r\n     * @function module:_listOps.zipWith3\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @param xs3 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith3 = (op, xs1, xs2, xs3) => zipWithN(op, xs1, xs2, xs3),\r\n\r\n    /**\r\n     * Zips 4 lists with tupling function.\r\n     * @haskellType `zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c]  -> [d] -> [e]`\r\n     * @function module:_listOps.zipWith4\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> d -> (a, b, c, d)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @param xs3 {Array|String|*}\r\n     * @param xs4 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith4 = (op, xs1, xs2, xs3, xs4) => zipWithN(op, xs1, xs2, xs3, xs4),\r\n\r\n    /**\r\n     * Zips 5 lists.\r\n     * @haskellType `zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c]  -> [d] -> [e] -> [f]`\r\n     * @function module:_listOps.zipWith5\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> d -> e -> (a, b, c, d, e)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @param xs3 {Array|String|*}\r\n     * @param xs4 {Array|String|*}\r\n     * @param xs5 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith5 = (op, xs1, xs2, xs3, xs4, xs5) => zipWithN(op, xs1, xs2, xs3, xs4, xs5),\r\n\r\n    /**\r\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\r\n     * @haskellType `unzip :: [(a, b)] -> ([a], [b])`\r\n     * @todo Should support other list types (should not have `push` hard coded instead should use `mappend` (if available)).\r\n     * @function module:_listOps.unzip\r\n     * @param arr {Array|*}\r\n     * @returns {Array|*}\r\n     */\r\n    unzip = arr =>\r\n        foldl((agg, item) => {\r\n            agg[0].push(item[0]);\r\n            agg[1].push(item[1]);\r\n            return agg;\r\n        }, [[], []], arr),\r\n\r\n    /**\r\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\r\n     * @sudoHaskellType `unzipN :: [(a, b, ...x)] -> ([a], [b], ...[x])`\r\n     * @todo Should support other list types (should not have `push` hard coded instead should use `mappend` (if available)).\r\n     * @function module:_listOps.unzip\r\n     * @param list {Array|*} - List of tuples (lists).\r\n     * @returns {Array|*}\r\n     */\r\n    unzipN = list => {\r\n        if (!length(list)) {\r\n            return [];\r\n        }\r\n        const lenItem0 = length(list[0]);\r\n        let zero = lenItem0 ?\r\n            unfoldr(numLists => numLists-- ? [[], numLists] : undefined, lenItem0) :\r\n            [];\r\n        return foldl((agg, item) => {\r\n            agg.forEach((outList, ind) => outList.push(item[ind]));\r\n            return agg;\r\n        }, zero, list);\r\n    },\r\n\r\n    /**\r\n     * Returns true if any item in container passes predicate `p`.\r\n     * @function module:_listOps.any\r\n     * @param p {Function} - Predicate.\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    any = (p, xs) => {\r\n        let ind = 0,\r\n            limit = length(xs);\r\n        if (!limit) {\r\n            return false;\r\n        }\r\n        for (; ind < limit; ind += 1) {\r\n            if (p(xs[ind])) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Returns true if all items in container pass predicate `p`.\r\n     * @function module:_listOps.all\r\n     * @param p {Function} - Predicate.\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    all = (p, xs) => {\r\n        const limit = length(xs);\r\n        let ind = 0;\r\n        if (limit === 0) {\r\n            return false;\r\n        }\r\n        for (; ind < limit; ind++) {\r\n            if (!p(xs[ind], ind, xs)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Conjuction of container of bools (or truthy and/or falsy values);  Returns\r\n     * `true` if all in container are 'truthy' else returns `false`\r\n     * @function module:_listOps.and\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    and = xs => all(isTruthy, xs),\r\n\r\n    /**\r\n     * Returns a boolean indicating whether any item in container is 'truthy' or not.\r\n     * **Note** The haskell type for this function only takes two items, but here\r\n     * we allow the passing of more than one item (may change later to adhere to the haskell type).\r\n     * @function module:_listOps.or\r\n     * @haskellType `or :: Bool -> Bool -> Bool`\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    or = xs => any(isTruthy, xs),\r\n\r\n    /**\r\n     * Returns a boolean indicating whether all items in container are 'falsy' or not.\r\n     * **Note** The haskell type for this function only takes two items, but here\r\n     * we allow the passing of more than one item (may change later to adhere to the haskell type).\r\n     * @function module:_listOps.not\r\n     * @haskellType `not :: Bool -> Bool`\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    not = xs => all(isFalsy, xs),\r\n\r\n    /**\r\n     * Computes the sum of the numbers of a structure.\r\n     * @function module:_listOps.sum\r\n     * @haskellType `sum :: (List t, Num a) => t a -> a`\r\n     * @param list {Array|String}\r\n     * @returns {Number}\r\n     */\r\n    sum = list => foldl((agg, x) => agg + x, 0, list),\r\n\r\n    /**\r\n     * Computes the product of the numbers of a structure.\r\n     * @function module:_listOps.product\r\n     * @haskellType `product :: (List t, Num a) => t a -> a`\r\n     * @param list {Array|String}\r\n     * @returns {Number}\r\n     */\r\n    product = list => foldl((agg, x) => agg * x, 1, list),\r\n\r\n    /**\r\n     * Returns the largest element in a non-empty structure of elements.\r\n     * @function module:_listOps.maximum\r\n     * @haskellType `maximum :: forall a . Ord a => t a -> a`\r\n     * @param list {Array|String}\r\n     * @returns {*} - Whatever type the array is made of (if any).\r\n     */\r\n    maximum = list => last(sortBy(genericAscOrdering, list)),\r\n\r\n    /**\r\n     * Returns the smallest element in a non-empty structure of elements.\r\n     * @function module:_listOps.minimum\r\n     * @haskellType `minimum :: forall a . Ord a => t a -> a`\r\n     * @param list {Array|String}\r\n     * @returns {*} - Whatever type the array is made of (if any).\r\n     */\r\n    minimum = list => head(sortBy(genericAscOrdering, list)),\r\n\r\n    /**\r\n     * @function module:_listOps.scanl\r\n     * @param fn {Function}\r\n     * @param zero {*}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|*}\r\n     */\r\n    scanl = (fn, zero, xs) => {\r\n        if (!xs || !length(xs)) {\r\n            return [];\r\n        }\r\n        const limit = length(xs);\r\n        let ind = 0,\r\n            result = zero,\r\n            out = [];\r\n        while (ind < limit) {\r\n            result = fn(result, xs[ind], ind, xs);\r\n            out.push(result);\r\n            ind++;\r\n        }\r\n        return out;\r\n    },\r\n\r\n    scanl1 = (fn, xs) => {\r\n        if (!xs || !xs.length) { return []; }\r\n        return scanl(fn, head(xs), tail(xs));\r\n    },\r\n\r\n    scanr = (fn, zero, xs) => {\r\n        if (!xs || !length(xs)) {\r\n            return [];\r\n        }\r\n        const limit = length(xs);\r\n        let ind = limit - 1,\r\n            result = xs[0],\r\n            out = [];\r\n        while (ind > -1) {\r\n            result = fn(result, xs[ind], ind, xs);\r\n            out.push(result);\r\n            ind--;\r\n        }\r\n        return out;\r\n    },\r\n\r\n    scanr1 = (fn, xs) => {\r\n        if (!xs || !xs.length) { return []; }\r\n        return scanr(fn, last(xs), init(xs));\r\n    },\r\n\r\n    nub = list => nubBy((a, b) => a === b, list),\r\n\r\n    remove = (x, list) => removeBy((a, b) => a === b, x, list),\r\n\r\n    sort = xs => sortBy(genericAscOrdering, xs),\r\n\r\n    sortOn = (valueFn, xs) =>\r\n\r\n        // Un-decorate\r\n        map(decorated => decorated[1],\r\n\r\n            // Decorate and sort\r\n            sortBy(\r\n                // Ordering\r\n                ([a0], [b0]) => genericAscOrdering(a0, b0),\r\n\r\n                // Decorate\r\n                map(item => [valueFn(item), item], xs)\r\n            )\r\n        ),\r\n\r\n    sortBy = (orderingFn, xs) => copy(xs).sort(orderingFn || genericAscOrdering),\r\n\r\n    insert = (x, xs) => {\r\n        if (isEmptyList(xs)) {\r\n            return aggregatorByType(xs)(copy(xs), x, 0);\r\n        }\r\n        let out = of(xs),\r\n            foundIndex = findIndex(item => x <= item, xs);\r\n        return foundIndex === -1 ? append(sliceFrom(0, out), x) :\r\n            concat(intersperse([x], splitAt(foundIndex, xs)));\r\n    },\r\n\r\n    /**\r\n     * A version of `insert` that allows you to specify the ordering of the inserted\r\n     * item;  Before/at, or after\r\n     * @function module:_listOps.insertBy\r\n     * @haskellType `insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]`\r\n     * @note `Ordering` === // something that is order-able\r\n     * @todo Optimize and work the logic of this function;  Think about the types that will be\r\n     *  operated on by this functions logic.\r\n     * @param orderingFn {Function} - A function that returns `-1`, `0`, or 1`.\r\n     * @param x {*} - Value to insert.\r\n     * @param xs {Array|String|*} - List to insert into (note new list is returned)\r\n     * @returns {Array|String|*} - New list.\r\n     */\r\n    insertBy = (orderingFn, x, xs) => {\r\n        const limit = length(xs),\r\n            aggregator = aggregatorByType(xs),\r\n            out = of(xs);\r\n        if (isEmptyList(xs)) {\r\n            return aggregator(out, x, 0);\r\n        }\r\n        let ind = 0;\r\n        for (; ind < limit; ind += 1) {\r\n            if (orderingFn(x, xs[ind]) <= 0) {\r\n                const parts = splitAt(ind, xs);\r\n                // Fold parts[0], [x], parts[1] into `out` and `concat`\r\n                return concat(foldl(aggregator, out, [parts[0], [x], parts[1]]));\r\n            }\r\n        }\r\n        return aggregator(copy(xs), x);\r\n    },\r\n\r\n    nubBy = (pred, list) => {\r\n        if (isEmptyList(list)) {\r\n            return of(list);\r\n        }\r\n        const limit = length(list);\r\n        let ind = 0,\r\n            currItem,\r\n            out = of(list),\r\n            anyOp = storedItem => pred(currItem, storedItem);\r\n        for (; ind < limit; ind += 1) {\r\n            currItem = list[ind];\r\n            if (any(anyOp, out)) {\r\n                continue;\r\n            }\r\n            out = append(out, currItem);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    removeBy = (pred, x, list) => { // @todo optimize this implementation\r\n        const foundIndex = findIndex(item => pred(x, item), list),\r\n            parts = splitAt(foundIndex > -1 ? foundIndex : 0, list); // @todo correct this implementation\r\n        return append(parts[0], tail(parts[1]));\r\n    },\r\n\r\n    removeFirstsBy = (pred, xs1, xs2) =>\r\n        foldl((agg, item) => removeBy(pred, item, agg), xs1, xs2),\r\n\r\n    /**\r\n     * Returns the union on elements matching boolean check passed in.\r\n     * @function module:_listOps.unionBy\r\n     * @param pred {Function} - `pred :: a -> a -> Bool`\r\n     * @param arr1 {Array|String|*}\r\n     * @param arr2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    unionBy = (pred, arr1, arr2) => {\r\n        const aggregator = aggregatorByType(arr1);\r\n        return foldl((agg, b) => {\r\n            const alreadyAdded = any(a => pred(a, b), agg);\r\n            return !alreadyAdded ? aggregator(agg, b) : agg;\r\n        }, copy(arr1), arr2);\r\n    },\r\n\r\n    /**\r\n     * Creates a union on matching elements from array1.\r\n     * @function module:_listOps.union\r\n     * @param arr1 {Array|String|*}\r\n     * @param arr2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    union = (arr1, arr2) =>\r\n        append(arr1,\r\n            filter(elm => !includes(elm, arr1), arr2)),\r\n\r\n    /**\r\n     * Performs an intersection on list 1 with  elements from list 2.\r\n     * @function module:_listOps.intersect\r\n     * @param arr1 {Array|String|*}\r\n     * @param arr2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    intersect = (arr1, arr2) =>\r\n        !arr1 || !arr2 || (!arr1 && !arr2) ? [] :\r\n            filter(elm => includes(elm, arr2), arr1),\r\n\r\n    /**\r\n     * Returns an intersection by predicate.\r\n     * @function module:_listOps.intersectBy\r\n     * @param pred {Function} - `pred :: a -> b -> Bool`\r\n     * @param list1 {Array|String|*}\r\n     * @param list2 {Array|String|*}\r\n     * @return {Array|String|*}\r\n     */\r\n    intersectBy = (pred, list1, list2) => {\r\n        const aggregator = aggregatorByType(list1);\r\n        return foldl((agg, a) =>\r\n                any(b => pred(a, b), list2) ? aggregator(agg, a) : agg\r\n            , [], list1);\r\n    },\r\n\r\n    /**\r\n     * Returns the difference of list 1 from list 2.\r\n     * @note The `difference` operation here is non-associative;  E.g., `a - b` is not equal to `b - a`;\r\n     * @function module:_listOps.difference\r\n     * @param array1 {Array|String|*}\r\n     * @param array2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    difference = (array1, array2) => { // augment this with max length and min length ordering on op\r\n        if (array1 && !array2) {\r\n            return sliceFrom(0, array1);\r\n        }\r\n        else if (!array1 && array2 || (!array1 && !array2)) {\r\n            return [];\r\n        }\r\n        const aggregator = aggregatorByType(array1);\r\n        return reduce((agg, elm) =>\r\n                !includes(elm, array2) ? aggregator(agg, elm) : agg\r\n            , [], array1);\r\n    },\r\n\r\n    /**\r\n     * Returns the complement of list 0 and the reset of the passed in arrays.\r\n     * @function module:_listOps.complement\r\n     * @param arr0 {Array}\r\n     * @param arrays {...Array}\r\n     * @returns {Array}\r\n     */\r\n    complement = (arr0, ...arrays) =>\r\n        reduce((agg, arr) => append(agg, difference(arr, arr0)), [], arrays);\r\n","import {assignDeep} from './_assignDeep';\r\nimport {hasOwnProperty, keys} from '../_jsPlatform/_object';\r\nimport {foldl} from '../_listOps';\r\n\r\nexport const\r\n\r\n    objUnion = (obj1, obj2) => assignDeep(obj1, obj2),\r\n\r\n    objIntersect = (obj1, obj2) => foldl((agg, key) => {\r\n        if (hasOwnProperty(key, obj2)) {\r\n            agg[key] = obj2[key];\r\n        }\r\n        return agg;\r\n    }, {}, keys(obj1)),\r\n\r\n    objDifference = (obj1, obj2) => foldl((agg, key) => {\r\n        if (!hasOwnProperty(key, obj2)) {\r\n            agg[key] = obj1[key];\r\n        }\r\n        return agg;\r\n    }, {}, keys(obj1)),\r\n\r\n    objComplement = (obj0, ...objs) => foldl((agg, obj) =>\r\n        assignDeep(agg, objDifference(obj, obj0)), {}, objs);\r\n","/**\r\n * @module objectOps\r\n */\r\nimport {curry, curry2} from './uncurried/_functionOps/_curry';\r\nimport {\r\n    instanceOf as _instanceOf,\r\n    hasOwnProperty as _hasOwnProperty,\r\n    assign as _assign} from './uncurried/_jsPlatform/_object';\r\nimport {prop as _prop} from './uncurried/_objectOps/_prop';\r\nimport {assignDeep as _assignDeep}      from './uncurried/_objectOps/_assignDeep';\r\nimport {\r\n    objUnion as _objUnion,\r\n    objComplement as _objComplement,\r\n    objIntersect as _objIntersect,\r\n    objDifference as _objDifference}    from './uncurried/_objectOps/_setTheory';\r\nimport {isType as _isType}\r\n    from './uncurried/_objectOps/_is';\r\n\r\nexport {length, keys} from './uncurried/_jsPlatform/_object';\r\nexport * from './uncurried/_objectOps/_typeOf';\r\nexport * from './uncurried/_objectOps/_of';\r\nexport {\r\n    isFunction, isClass, isCallable, isArray, isObject, isBoolean,\r\n    isNumber, isString, isMap, isSet, isWeakMap, isWeakSet, isUndefined,\r\n    isNull, isSymbol, isUsableImmutablePrimitive,\r\n    isEmptyList, isEmptyObject, isEmptyCollection, isEmpty, isset\r\n} from './uncurried/_objectOps/_is';\r\n\r\nexport {_instanceOf, _isType, _hasOwnProperty, _assign, _prop, _assignDeep, _objUnion,\r\n_objComplement, _objIntersect, _objDifference};\r\n\r\nexport const\r\n\r\n    /**\r\n     * Gives `undefined` or prop value if it is available.\r\n     * @function module:objectOps.prop\r\n     * @param propName {String}\r\n     * @param obj {*} - Object to search.\r\n     * @returns {*|undefined}\r\n     * @curried\r\n     */\r\n    prop = curry(_prop),\r\n\r\n    /**\r\n     * `instanceof` in function form.\r\n     * @function module:objectOps.instanceOf\r\n     * @param instance {*}\r\n     * @param Type {Function}\r\n     * @returns {Boolean}\r\n     * @curried\r\n     */\r\n    instanceOf = curry(_instanceOf),\r\n\r\n    /**\r\n     * `hasOwnProperty` as a method (takes object last).\r\n     * @function module:objectOps.hasOwnProperty\r\n     * @param propName {String}\r\n     * @param obj {*} - Object to search.\r\n     * @returns {Boolean}\r\n     * @curried\r\n     */\r\n    hasOwnProperty = curry(_hasOwnProperty),\r\n\r\n    /**\r\n     * `Object.assign` if it is available else a shim.\r\n     * @function module:objectOps.assign\r\n     * @param [...obj]{Object} - One or more objects to merge onto first object.\r\n     * @returns {Object}\r\n     * @curried - Called after having two or more args\r\n     */\r\n    assign = curry2(_assign),\r\n\r\n    /**\r\n     * Same as `Object.assign` except does a deep merge.\r\n     * @function module:objectOps.assignDeep\r\n     * @param [...obj]{Object} - One or more objects to deep merge onto first object.\r\n     * @returns {Object}\r\n     * @curried - Called after having two or more args\r\n     */\r\n    assignDeep = curry2(_assignDeep),\r\n\r\n    /**\r\n     * Cartesian union for objects (operates on two objects).\r\n     * @function module:objectOps.objUnion\r\n     * @param obj1 {Object}\r\n     * @param obj2 {Object}\r\n     * @returns {Object} - Unified obj.\r\n     * @curried\r\n     */\r\n    objUnion = curry(_objUnion),\r\n\r\n    /**\r\n     * Returns the cartesian intersection of two objects.\r\n     * @function module:objectOps.objIntersect\r\n     * @param obj1 {Object}\r\n     * @param obj2 {Object}\r\n     * @returns {Object} - Intersection of given objects.\r\n     * @curried\r\n     */\r\n    objIntersect = curry(_objIntersect),\r\n\r\n    /**\r\n     * Returns the cartesian difference of two objects.\r\n     * @function module:objectOps.objDifference\r\n     * @param obj1 {Object}\r\n     * @param obj2 {Object}\r\n     * @returns {Object} - Difference of given objects.\r\n     * @curried\r\n     */\r\n    objDifference = curry(_objDifference),\r\n\r\n    /**\r\n     * Returns the cartesian complement of one or more objects on given object.\r\n     * @function module:objectOps.objDifference\r\n     * @param obj {Object}\r\n     * @param [...obj]{Object} - One or more objects to calculate complement from.\r\n     * @returns {Object} - Complement of given objects.\r\n     * @curried\r\n     */\r\n    objComplement = curry2(_objComplement),\r\n\r\n    /**\r\n     * Returns a boolean indicating whether a value is of given type or not.\r\n     * @function module:objectOps.isType\r\n     * @param Type {Function|String} - Constructor or constructor name\r\n     * @param value {*}\r\n     * @return {Boolean}\r\n     */\r\n    isType = curry(_isType);\r\n\r\n    /**\r\n     * Returns whether a value is a function or not.\r\n     * @function module:objectOps.isFunction\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Checks if `value` is an es2015 `class`.\r\n     * @function module:objectOps.isClass\r\n     * @param x {*}\r\n     * @returns {boolean}\r\n     */\r\n\r\n    /**\r\n     * Returns a boolean depicting whether a value is callable or not.\r\n     * @function module:objectOps.isCallable\r\n     * @tentative\r\n     * @private\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Checks if value is an array.\r\n     * @function module:objectOps.isArray\r\n     * @param value {*}\r\n     * @returns {boolean}\r\n     */\r\n\r\n    /**\r\n     * Checks whether value is an object or not.\r\n     * @function module:objectOps.isObject\r\n     * @param value\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Checks if value is a boolean.\r\n     * @function module:objectOps.isBoolean\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Checks if value is a valid number (also checks if isNaN so that you don't have to).\r\n     * @function module:objectOps.isNumber\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Checks whether value is a string or not.\r\n     * @function module:objectOps.isString\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Checks whether value is of `Map` or not.\r\n     * @function module:objectOps.isMap\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Checks whether value is of `Set` or not.\r\n     * @function module:objectOps.isSet\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Checks whether value is of `WeakMap` or not.\r\n     * @function module:objectOps.isWeakMap\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Checks whether value is of `WeakSet` or not.\r\n     * @function module:objectOps.isWeakSet\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Checks if value is undefined.\r\n     * @function module:objectOps.isUndefined\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Checks if value is null.\r\n     * @function module:objectOps.isNull\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Checks if value is a `Symbol`.\r\n     * @function module:objectOps.isSymbol\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * @tentative\r\n     * @private\r\n     */\r\n\r\n    /**\r\n     * Checks if given `x` is one of the four\r\n     * \"usable\" immutable JS primitives; I.e.,\r\n     *  One of [String, Boolean, Number, Symbol]\r\n     * @function module:objectOps.isUsableImmutablePrimitive\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Checks if !length.\r\n     * @function module:objectOps.isEmptyList\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Checks if object has own properties/enumerable-props or not.\r\n     * @function module:objectOps.isEmptyObject\r\n     * @param obj {*}\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Checks if collection is empty or not (Map, WeakMap, WeakSet, Set etc.).\r\n     * @function module:objectOps.isEmptyCollection\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Checks to see if passed in argument is empty.\r\n     * @function module:objectOps.isEmpty\r\n     * @param value {*} - Value to check.\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Returns whether passed in values is defined and not null.\r\n     * @function module:objectOps.isset\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n\r\n    /**\r\n     * Returns the constructor/class/type name of a value.\r\n     * @note Returns 'NaN' if value is of type `Number` and value is `isNaN`.\r\n     * @note Returns 'Undefined' if value is `undefined`\r\n     * @note Returns 'Null' if value is `null`\r\n     * For values that have no concrete constructors and/or casters\r\n     * (null, NaN, and undefined) we returned normalized names for them ('Null', 'NaN', 'Number')\r\n     * @function module:objectOps.typeOf\r\n     * @param value {*}\r\n     * @returns {string} - Constructor's name or derived name (in the case of `null`, `undefined`, or `NaN` (whose\r\n     *  normalized names are 'Null', 'Undefined', 'NaN' respectively).\r\n     */\r\n\r\n    /**\r\n     * Creates a value `of` given type;  Checks for one of the following construction strategies (in order listed):\r\n     * - If exists `(value).constructor.of` uses this.\r\n     * - If value is of one String, Boolean, Symbol, or Number types calls it's constructor as a function (in cast form;  E.g., `constructor(...args)` )\r\n     * - Else if constructor is a function, thus far, then calls constructor using the `new` keyword (with any passed in args).\r\n     * @function module:objectOps.of\r\n     * @param x {*} - Value to derive returned value's type from.\r\n     * @param [args] {...*} - Any args to pass in to matched construction strategy.\r\n     * @returns {*|undefined} - New value of given value's type else `undefined`.\r\n     */\r\n\r\n    /**\r\n     * @function module:objectOps.length\r\n     * @param x {*}\r\n     * @returns {Number}\r\n     * @throws {Error} - Throws an error if value doesn't have a `length` property (\r\n     *  `null`, `undefined`, {Boolean}, Symbol, et. al.).\r\n     */\r\n\r\n    /**\r\n     * Gets own enumerable keys of passed in object (same as `Object.keys`).\r\n     * @function module:objectOps.keys\r\n     * @param obj {*}\r\n     * @returns {Array<String>}\r\n     */\r\n","export const\r\n\r\n    /**\r\n     * Run `operation` until predicate returns `true`.\r\n     * @function module:_functionOps.until\r\n     * @param predicate {Function} :: a -> Boolean\r\n     * @param operation {Function} :: a -> a\r\n     * @param typeInstance {*} :: * - A monoidal zero or some starting point.\r\n     * @returns {*} - What ever type `typeInstance` is\r\n     */\r\n    until = (predicate, operation, typeInstance) => {\r\n        let result = typeInstance;\r\n        while (!predicate(result)) {\r\n            result = operation(result);\r\n        }\r\n        return result;\r\n    };\r\n","import {reverse} from '../_jsPlatform/_array';\r\nimport {apply, call} from '../_jsPlatform/_function';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Flips a functions arguments order and returns a new functionOps requiring such (arguments in reverse order).\r\n     * @function module:_functionOps.flipN\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    flipN = fn => (...args) => apply(fn, reverse(args)),\r\n\r\n    /**\r\n     * Returns a function that receives 3 args in reverse (3, 2, 1 etc.).\r\n     * @function module:_functionOps.flip3\r\n     * @param fn {Function} - Function<a, b, c>\r\n     * @returns {Function} - Function<c, b, a>\r\n     */\r\n    flip3 = fn => (a, b, c) => call(fn, c, b, a),\r\n\r\n    /**\r\n     * Returns a function that receives 4 args in reverse (4, 3, 2, 1 etc.).\r\n     * @function module:_functionOps.flip4\r\n     * @param fn {Function} - Function<a, b, c, d>\r\n     * @returns {Function} - Function<d, c, b, a>\r\n     */\r\n    flip4 = fn => (a, b, c, d) => call(fn, d, c, b, a),\r\n\r\n    /**\r\n     * Returns a function that receives 5 args in reverse (5, 4, 3, 2, 1 etc.).\r\n     * @function module:_functionOps.flip5\r\n     * @param fn {Function} - Function<a, b, c, d, e>\r\n     * @returns {Function} - Function<e, d, c, b, a>\r\n     */\r\n    flip5 = fn => (a, b, c, d, e) => call(fn, e, d, c, b, a),\r\n\r\n    /**\r\n     * Flips a _functionOps's first and second arguments and and returns a new _functionOps requiring said arguments in reverse.\r\n     * @function module:_functionOps.flip\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    flip = fn => (b, a) => call(fn, a, b);\r\n","/**\r\n * @memberOf _functionOps\r\n * @author elydelacruz\r\n * @created 12/6/2016.\r\n * @description Curry implementation with place holder concept (`__`).\r\n * @todo Make code here more minimal (reuse small parts here).\r\n */\r\n\r\nimport {apply, concat, map, filter, length} from '../_jsPlatform';\r\n\r\n/**\r\n * PlaceHolder (__) constructor.\r\n * @constructor PlaceHolder\r\n * @private\r\n */\r\nconst PlaceHolder = function PlaceHolder() {},\r\n\r\n    /**\r\n     * Placeholder instance.\r\n     * @type {PlaceHolder}\r\n     * @private\r\n     */\r\n    placeHolderInstance = new PlaceHolder();\r\n\r\n/**\r\n * Checks to see if value is a `PlaceHolder`.\r\n * @param instance {*}\r\n * @returns {boolean}\r\n * @private\r\n */\r\nfunction isPlaceHolder (instance) {\r\n    return instance instanceof PlaceHolder;\r\n}\r\n\r\n/**\r\n * Replaces `placeholder` values in `_listOps`.\r\n * @function replacePlaceHolder\r\n * @private\r\n * @param array {Array} - Array to replace placeholders in.\r\n * @param args {Array} - Args from to choose from to replace placeholders.\r\n * @returns {Array|*} - Returns passed in `_listOps` with placeholders replaced by values in `args`.\r\n */\r\nfunction replacePlaceHolders (array, args) {\r\n    let out = map(element => {\r\n            if (!isPlaceHolder(element)) { return element; }\r\n            else if (length(args)) { return args.shift(); }\r\n            return element;\r\n        }, array);\r\n    return length(args) ? concat(out, args) : out;\r\n}\r\n\r\n/**\r\n * Curries passed in functionOps up to given arguments length (can enforce arity via placeholder values (`__`)).\r\n * @function module:_functionOps.curry_\r\n * @param fn {Function}\r\n * @param argsToCurry {...*}\r\n * @returns {Function}\r\n */\r\nexport function curry_ (fn, ...argsToCurry) {\r\n    return (...args) => {\r\n        let concatedArgs = replacePlaceHolders(argsToCurry, args),\r\n            placeHolders = filter(isPlaceHolder, concatedArgs),\r\n            canBeCalled = length(placeHolders) === 0 &&\r\n                length(concatedArgs) >= length(fn);\r\n        return canBeCalled ? apply(fn, concatedArgs) :\r\n            apply(curry_, concat([fn], concatedArgs));\r\n    };\r\n}\r\n\r\n/**\r\n * Curries a _functionOps up to given arity also enforces arity via placeholder values (`__`).\r\n * @function module:_functionOps.curryN_\r\n * @param executeArity {Number}\r\n * @param fn {Function}\r\n * @param curriedArgs {...*} - Allows `Placeholder` (`__`) values.\r\n * @returns {Function} - Passed in _functionOps wrapped in a _functionOps for currying.\r\n */\r\nexport function curryN_ (executeArity, fn, ...curriedArgs) {\r\n    return (...args) => {\r\n        let concatedArgs = replacePlaceHolders(curriedArgs, args),\r\n            placeHolders = filter(isPlaceHolder, concatedArgs),\r\n            canBeCalled = (length(concatedArgs) - length(placeHolders) >= executeArity) || !executeArity;\r\n        return !canBeCalled ?\r\n            apply(curryN_, concat([executeArity, fn], concatedArgs)) :\r\n            apply(fn, concatedArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * Place holder object (frozen) used by curry.\r\n * @memberOf _functionOps\r\n * @type {PlaceHolder}\r\n */\r\nexport let __ = Object.freeze ? Object.freeze(placeHolderInstance) : placeHolderInstance,\r\n\r\n    /**\r\n     * Curries a _functionOps up to an arity of 2 (takes into account placeholders `__` (arity enforcers)) (won't call _functionOps until 2 or more args).\r\n     * @function module:_functionOps.curry2_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry2_ = fn => curryN_(2, fn),\r\n\r\n    /**\r\n     * Curries a _functionOps up to an arity of 3 (takes into account placeholders `__` (arity enforcers)) (won't call _functionOps until 3 or more args).\r\n     * @function module:_functionOps.curry3_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry3_ = fn => curryN_(3, fn),\r\n\r\n    /**\r\n     * Curries a _functionOps up to an arity of 4 (takes into account placeholders `__` (arity enforcers))  (won't call _functionOps until 4 or more args).\r\n     * @function module:_functionOps.curry4_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry4_ = fn => curryN_(4, fn),\r\n\r\n    /**\r\n     * Curries a _functionOps up to an arity of 5  (takes into account placeholders `__` (arity enforcers))  (won't call _functionOps until 5 or more args).\r\n     * @function module:_functionOps.curry5_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry5_ = fn => curryN_(5, fn)\r\n\r\n;\r\n","/**\r\n * @memberOf _functionOps\r\n */\r\n\r\n/**\r\n * Returns passed in parameter.\r\n * @haskellType `id :: a -> a`\r\n * @function module:_functionOps.id\r\n * @param x {*}\r\n * @returns {*}\r\n */\r\nexport const id = x => x;\r\n","import {reduceRight} from '../_jsPlatform/_array';\r\n\r\n/**\r\n * Composes all functions passed in from right to left passing each functions return value to\r\n * the functionOps on the left of itself.\r\n * @function module:_functionOps.compose\r\n * @type {Function}\r\n * @param args {...{Function}}\r\n * @returns {Function}\r\n */\r\nexport const compose = (...args) =>\r\n        arg0 => reduceRight((value, fn) => fn(value), arg0, args);\r\n","/**\r\n * Function operations: `\r\n * @module functionOps\r\n */\r\n\r\nimport {curry, curry2, curry3} from './uncurried/_functionOps/_curry';\r\n\r\nimport {\r\n    apply as _apply,\r\n    call as _call, reverse\r\n} from './uncurried/_jsPlatform';\r\n\r\nimport {\r\n    until as _until\r\n} from './uncurried/_functionOps/_until';\r\n\r\nimport {\r\n    flip as _flip,\r\n    flipN as _flipN,\r\n    flip3 as _flip3,\r\n    flip4 as _flip4,\r\n    flip5 as _flip5\r\n} from './uncurried/_functionOps/_flip';\r\n\r\nexport * from './uncurried/_functionOps/_curry';\r\nexport * from './uncurried/_functionOps/__curry';\r\nexport * from './uncurried/_functionOps/_negate';\r\nexport * from './uncurried/_functionOps/_id';\r\nexport * from './uncurried/_functionOps/_compose';\r\n\r\nexport {_apply, _call, _until, _flip, _flip3, _flip4, _flip5,  _flipN};\r\n\r\nexport const\r\n\r\n    /**\r\n     * Functional `apply` function (takes no context).\r\n     * @function module:functionOps.apply\r\n     * @param fn {Function}\r\n     * @param [args] {Array<*>}\r\n     * @returns {*}\r\n     * @curried - Triggered at 2 or more args.\r\n     */\r\n    apply = curry(_apply),\r\n\r\n    /**\r\n     * Functional `call` function (takes no context).\r\n     * @function module:functionOps.call\r\n     * @param fn {Function}\r\n     * @param [args] {...*}\r\n     * @returns {*}\r\n     * @curried\r\n     */\r\n    call = curry2(_call),\r\n\r\n    /**\r\n     * Run `operation` `until` predicate returns `true`.\r\n     * @function module:functionOps.until\r\n     * @param predicate {Function} :: a -> Boolean\r\n     * @param operation {Function} :: a -> a\r\n     * @param typeInstance {*} :: * - A monoidal zero or some starting point.\r\n     * @returns {*} - What ever type `typeInstance` is\r\n     * @curried\r\n     */\r\n    until = curry(_until),\r\n\r\n    /**\r\n     * Flips a functions arguments order and returns a new function requiring such (arguments in reverse order).\r\n     * @function module:fnOperators.flipN\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     * @curried - Triggered at 3 or more (args).\r\n     */\r\n    flipN = fn => curry3((...args) => apply(fn, reverse(args))),\r\n\r\n    /**\r\n     * Flips a function's first and second arguments and and returns a new function requiring said arguments in reverse.\r\n     * @function module:fnOperators.flip\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     * @curried\r\n     */\r\n    flip = fn => curry(_flip(fn)),\r\n\r\n    /**\r\n     * Returns a function that receives 3 args in reverse (3, 2, 1 etc.).\r\n     * @function module:functionOps.flip3\r\n     * @param fn {Function} - Function<a, b, c>\r\n     * @returns {Function} - Function<c, b, a>\r\n     * @curried\r\n     */\r\n    flip3 = fn => curry(_flip3(fn)),\r\n\r\n    /**\r\n     * Returns a function that receives 4 args in reverse (4, 3, 2, 1 etc.).\r\n     * @function module:functionOps.flip4\r\n     * @param fn {Function} - Function<a, b, c, d>\r\n     * @returns {Function} - Function<d, c, b, a>\r\n     * @curried\r\n     */\r\n    flip4 = fn => curry(_flip4(fn)),\r\n\r\n    /**\r\n     * Returns a function that receives 5 args in reverse (5, 4, 3, 2, 1 etc.).\r\n     * @function module:functionOps.flip5\r\n     * @param fn {Function} - Function<a, b, c, d, e>\r\n     * @returns {Function} - Function<e, d, c, b, a>\r\n     * @curried\r\n     */\r\n    flip5 = fn => curry(_flip5(fn));\r\n\r\n    /**\r\n     * Curries a function based on it's defined arity (argument's arrayOps expected length).\r\n     * @function module:functionOps.curry\r\n     * @param fn {Function}\r\n     * @param argsToCurry {...*}\r\n     * @returns {Function}\r\n     * @curried\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to a given arity.\r\n     * @function module:functionOps.curryN\r\n     * @param executeArity {Number}\r\n     * @param fn {Function}\r\n     * @param curriedArgs {...*}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to an arity of 2 (won't call function until 2 or more args).\r\n     * @function module:functionOps.curry2\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to an arity of 3 (won't call function until 3 or more args).\r\n     * @function module:functionOps.curry3\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to an arity of 4 (won't call function until 4 or more args).\r\n     * @function module:functionOps.curry4\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to an arity of 5 (won't call function until 5 or more args).\r\n     * @function module:functionOps.curry5\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries passed in function up to given arguments length (can enforce arity via placeholder values (`__`)).\r\n     * @function module:functionOps.curry_\r\n     * @param fn {Function}\r\n     * @param argsToCurry {...*}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to given arity also enforces arity via placeholder values (`__`).\r\n     * @function module:functionOps.curryN_\r\n     * @param executeArity {Number}\r\n     * @param fn {Function}\r\n     * @param curriedArgs {...*} - Allows `Placeholder` (`__`) values.\r\n     * @returns {Function} - Passed in function wrapped in a function for currying.\r\n     */\r\n\r\n    /**\r\n     * Place holder object (frozen) used by curry.\r\n     * @memberOf functionOps\r\n     * @type {PlaceHolder}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to an arity of 2 (takes into account placeholders `__` (arity enforcers))\r\n     * (won't call function until 2 or more args (not counting placeholder (`__`) value).\r\n     * @function module:functionOps.curry2_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to an arity of 3 (takes into account placeholders `__` (arity enforcers))\r\n     * (won't call function until 3 or more args (not counting placeholder (`__`) value).\r\n     * @function module:functionOps.curry3_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to an arity of 4 (takes into account placeholders `__` (arity enforcers))\r\n     * (won't call function until 4 or more args (not counting placeholder (`__`) value).\r\n     * @function module:functionOps.curry4_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to an arity of 5  (takes into account placeholders `__` (arity enforcers))\r\n     * (won't call function until 5 or more args (not counting placeholder (`__`) value).\r\n     * @function module:functionOps.curry5_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Takes a function that takes two parameters and returns a negated version of given\r\n     * function.\r\n     * @function module:functionOps.negateF\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Takes a function that takes three parameters and returns a\r\n     * negated version of given function.\r\n     * @function module:functionOps.negateF3\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Takes a function that takes four parameters and returns a\r\n     * negated version of given function.\r\n     * @function module:functionOps.negateF4\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Takes a function that takes four parameters and returns a\r\n     * negated version of given function.\r\n     * @function module:functionOps.negateF5\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Negates a javascript-'generic' predicate; `Function<element, index, list>`.\r\n     * @function module:functionOps.negateP\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Returns a new function which is the dual of `fn` (or the negated version of `fn`).\r\n     * @function module:functionOps.negateFMany\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Returns passed in parameter.\r\n     * @haskellType `id :: a -> a`\r\n     * @function module:functionOps.id\r\n     * @param x {*}\r\n     * @returns {*}\r\n     */\r\n\r\n    /**\r\n     * Composes all functions passed in from right to left passing each functions return value to\r\n     * the function on the left of itself.\r\n     * @function module:functionOps.compose\r\n     * @param args {...Function}\r\n     * @returns {Function}\r\n     */\r\n","/**\r\n * @module _functionOps\r\n * @private\r\n */\r\nexport {apply, call} from './_jsPlatform/_function';\r\nexport * from './_functionOps/_compose';\r\nexport * from './_functionOps/_curry';\r\nexport * from './_functionOps/__curry';\r\nexport * from './_functionOps/_flip';\r\nexport * from './_functionOps/_id';\r\nexport * from './_functionOps/_negate';\r\nexport * from './_functionOps/_until';\r\n","/**\r\n * Created by elydelacruz on 7/22/2017.\r\n * @module utils\r\n * @private\r\n */\r\n\r\nimport {curry, curry2} from './uncurried/_functionOps/_curry';\r\nexport * from './uncurried/_utils';\r\nexport const\r\n\r\n    fPureTakesOne_ = name => curry((arg, f) => f[name](arg)),\r\n\r\n    fPureTakes2_ = name => curry((arg1, arg2, f) => f[name](arg1, arg2)),\r\n\r\n    fPureTakesOneOrMore_ = name => curry2((f, ...args) => f[name](...args))\r\n;\r\n","/**\r\n * Created by elyde on 7/20/2017.\r\n * Curried functional versions of common array methods (`filter`, `map`, etc.).\r\n * @module jsPlatform_array\r\n * @private\r\n */\r\n\r\nimport {fPureTakesOne_, fPureTakes2_, fPureTakesOneOrMore_} from '../utils';\r\n\r\n/**\r\n * Reverses a list (shimmed if not exists).\r\n * @function module:jsPlatform_array.reverse\r\n * @return {Array}\r\n */\r\nexport {reverse} from '../uncurried/_jsPlatform/_array';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Maps a function to functor (lists etc.).\r\n     * @function module:jsPlatform_array.map\r\n     * @param fn {Function}\r\n     * @param functor {Array|{map: {Function}}}\r\n     * @returns {Array|{map: {Function}}}\r\n     */\r\n    map = fPureTakesOne_('map'),\r\n\r\n    /**\r\n     * Filters a functor (lists etc.) with passed in function.\r\n     * @function module:jsPlatform_array.filter\r\n     * @param fn {Function}\r\n     * @param functor {Array|{filter: {Function}}}\r\n     * @returns {Array|{filter: {Function}}}\r\n     */\r\n    filter = fPureTakesOne_('filter'),\r\n\r\n    /**\r\n     * Reduces a foldable (lists etc.) with passed in function.\r\n     * @function module:jsPlatform_array.reduce\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduce: {Function}}}\r\n     * @returns {Array|{reduce: {Function}}}\r\n     */\r\n    reduce = fPureTakes2_('reduce'),\r\n\r\n    /**\r\n     * Reduces a foldable (lists etc.) from the right with passed in function.\r\n     * @function module:jsPlatform_array.reduceRight\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduceRight: {Function}}}\r\n     * @returns {Array|{reduceRight: {Function}}}\r\n     */\r\n    reduceRight = fPureTakes2_('reduceRight'),\r\n\r\n    /**\r\n     * For each on functor (Array|Object|etc.).\r\n     * @function module:jsPlatform_array.forEach\r\n     * @param fn {Function}\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type of object you pass in unless it doesn't have a `forEach` method.\r\n     * @throws {Error} - When passed in functor doesn't have a `forEach` method.\r\n     */\r\n    forEach = fPureTakesOne_('forEach'),\r\n\r\n    /**\r\n     * Returns `true` if `fn` (predicate) returns true for at least one item\r\n     * in functor else returns `false`.\r\n     * @function module:jsPlatform_array.some\r\n     * @param fn {Function} - Predicate.\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have a `some` method.\r\n     */\r\n    some = fPureTakesOne_('some'),\r\n\r\n    /**\r\n     * Returns `true` if `fn` (predicate) returns true for all items in functor else returns `false`.\r\n     * @function module:jsPlatform_array.every\r\n     * @param fn {Function} - Predicate.\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have an `every` method.\r\n     */\r\n    every = fPureTakesOne_('every'),\r\n\r\n    /**\r\n     * Array.prototype.join\r\n     * @function module:jsPlatform_array.join\r\n     * @param separator {String|RegExp}\r\n     * @param arr {Array}\r\n     * @returns {String}\r\n     */\r\n    join = fPureTakesOne_('join'),\r\n\r\n    /**\r\n     * Same as Array.prototype.push\r\n     * @function module:jsPlatform_array.push\r\n     * @param item {*}\r\n     * @param arr {Array}\r\n     * @returns {Number}\r\n     */\r\n    push = fPureTakesOneOrMore_('push');\r\n","/**\r\n * List operations that overlap (apart from globally overlapping props and functions like `length`)\r\n * on both strings and arrays.\r\n * @module jsPlatform_list\r\n * @private\r\n */\r\n\r\nimport {curry} from '../uncurried/_functionOps/_curry';\r\n\r\nimport {\r\n    concat as concat_,\r\n    slice as slice_,\r\n    includes as includes_,\r\n    indexOf as indexOf_,\r\n    lastIndexOf as lastIndexOf_ } from '../uncurried/_jsPlatform/_list';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Concats/appends all functors onto the end of first functor.\r\n     * Note:  functors passed in after the first one must be of the same type.\r\n     * @function module:jsPlatform_array.concat\r\n     * @param functor {Array|Object|*}\r\n     * @param ...functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have an `every` method.\r\n     */\r\n    concat = curry(concat_),\r\n\r\n    /**\r\n     * Same as Array.prototype.slice\r\n     * @function module:jsPlatform_array.slice\r\n     * @param separator {String|RegExp}\r\n     * @param arr{Array}\r\n     * @returns {Array}\r\n     */\r\n    slice = curry(slice_),\r\n\r\n    includes = curry(includes_),\r\n\r\n    indexOf = curry(indexOf_),\r\n\r\n    lastIndexOf = curry(lastIndexOf_)\r\n\r\n;\r\n","/**\r\n * Created by elydelacruz on 9/6/2017.\r\n * @module jsPlatform_string\r\n * @private\r\n */\r\n\r\nimport {curry} from '../uncurried/_functionOps/_curry';\r\n\r\nimport {split as _split} from '../uncurried/_jsPlatform/_string';\r\n\r\n/**\r\n * Functional version of `String.prototype.split`.\r\n * @curried\r\n * @function module:jsPlatform_string.split\r\n * @param separator {String|RegExp}\r\n * @param str {String}\r\n * @returns {Array}\r\n */\r\nexport const split = curry(_split);\r\n","/**\n * @module jsPlatform\n * @private\n */\n\nexport * from './jsPlatform/array';\nexport * from './jsPlatform/list';\nexport * from './jsPlatform/string';\n","/**\r\n * List operators.\r\n * @module listOps\r\n * @todo decide whether to throw errors where functions cannot function without a specific type or to\r\n *  return undefined (and also determine which cases are ok for just returning undefined).\r\n * @todo code unperformant shorthand in `listOps`\r\n * @todo rename monoid functions to normal functions since we are not really defining methods for monoids here.\r\n */\r\nimport {curry, curry2, curry3, curry4, curry5, curryN} from './uncurried/_functionOps';\r\n\r\n// Uncurried methods import\r\nimport {\r\n    append as _append, appendMany as _appendMany, all as _all, any as _any, find as _find,\r\n    findIndex as _findIndex, findIndices as _findIndices, zip as _zip, zipN as _zipN, zipWith as _zipWith,\r\n    map as _map, mapAccumL as _mapAccumL, mapAccumR as _mapAccumR, zipWithN as _zipWithN,\r\n    elem as _elem, notElem as _notElem, elemIndex as _elemIndex, elemIndices as _elemIndices, lookup as _lookup,\r\n    intersperse as _intersperse, intercalate as _intercalate, iterate as _iterate,\r\n    repeat as _repeat, replicate as _replicate, cycle as _cycle, take as _take, drop as _drop, splitAt as _splitAt,\r\n    foldl as _foldl, foldl1 as _foldl1, foldr as _foldr, foldr1 as _foldr1, unfoldr as _unfoldr,\r\n    concatMap as _concatMap, takeWhile as _takeWhile, dropWhile as _dropWhile, dropWhileEnd as _dropWhileEnd,\r\n    partition as _partition, at as _at, span as _span, breakOnList as _breakOnList, stripPrefix as _stripPrefix,\r\n    isPrefixOf as _isPrefixOf, isSuffixOf as _isSuffixOf,\r\n    isInfixOf as _isInfixOf, isSubsequenceOf as _isSubsequenceOf, filter as _filter,\r\n    remove as _remove, insert as _insert, insertBy as _insertBy, nubBy as _nubBy, removeBy as _removeBy,\r\n    removeFirstsBy as _removeFirstsBy, unionBy as _unionBy, sortOn as _sortOn, sortBy as _sortBy,\r\n    complement as _complement, difference as _difference, union as _union, intersect as _intersect,\r\n    intersectBy as _intersectBy, groupBy as _groupBy,\r\n    scanl as _scanl, scanl1 as _scanl1, scanr as _scanr, scanr1 as _scanr1\r\n}\r\n    from './uncurried/_listOps';\r\n\r\nexport {slice, includes, indexOf, lastIndexOf, split, push} from './jsPlatform';\r\n\r\n// Single arity methods (and single or more arg functions)\r\nexport {\r\n    and, or, zipN, unzip, unzipN, head, last, init, tail, uncons, concat, reverse, transpose, subsequences,\r\n    permutations, group, inits, tails, sum, product, maximum, minimum, sort, nub\r\n}\r\n    from './uncurried/_listOps';\r\n\r\n// Uncurried methods export\r\nexport {\r\n    _append, _appendMany, _all, _any, _find, _findIndex, _findIndices, _zip, _zipN, _zipWith,\r\n    _map, _mapAccumL, _mapAccumR, _elem, _notElem, _elemIndex, _elemIndices, _lookup,\r\n    _intersperse, _intercalate, _iterate, _repeat, _replicate, _cycle, _take,\r\n    _drop, _splitAt, _foldl, _foldl1, _foldr, _foldr1, _unfoldr, _concatMap, _takeWhile, _dropWhile,\r\n    _dropWhileEnd, _partition, _at, _span, _breakOnList, _stripPrefix, _isPrefixOf,\r\n    _isSuffixOf, _isInfixOf, _isSubsequenceOf, _filter,\r\n    _remove, _insert, _insertBy, _nubBy, _removeBy, _removeFirstsBy, _unionBy, _sortOn, _sortBy,\r\n    _complement, _difference, _union, _intersect, _intersectBy, _groupBy\r\n};\r\n\r\n// Exported internals\r\nexport const\r\n\r\n    /**\r\n     * Append two lists, i.e.,\r\n     * ```\r\n     * append([x1, ..., xm], [y1, ..., yn]) // outputs: [x1, ..., xm, y1, ..., yn]\r\n     * append([x1, ..., xm], [y1, ...]) // outputs: [x1, ..., xm, y1, ...]\r\n     * ```\r\n     * If the first list is not finite, the result is the first list.\r\n     * @haskellType `append :: List a => a -> a -> a`\r\n     * @function module:listOps.append\r\n     * @param xs1 {Array|String|*} - list or list like.\r\n     * @param xs2 {Array|String|*} - list or list like.\r\n     * @returns {Array|String|*} - Same type as list like passed in.\r\n     */\r\n    append = curry(_append),\r\n\r\n    /**\r\n     * Append two or more lists, i.e., same as `append` but for two ore more lists.\r\n     * @haskellType `appendMany :: List a => a -> [a] -> a\r\n     * @note In `@haskellType` we wrote `[a]` only to keep the haskell type valid though note in javascript\r\n     *  this is actually different since the function converts the zero ore more parameters into an array containing such for us.\r\n     * @function module:listOps.appendMany\r\n     * @param x {Array|String|*}\r\n     * @param args ...{Array|String|*} - Lists or lists likes.\r\n     * @returns {Array|String|*} - Same type as first list or list like passed in.\r\n     */\r\n    appendMany = curry2(_appendMany),\r\n\r\n    /**\r\n     * Map a function over all the elements of a container and concatenate the resulting lists.\r\n     * @haskellType `concatMap :: Foldable t => (a -> [b]) -> t a -> [b]`\r\n     * @function module:listOps.concatMap\r\n     * @param fn {Function}\r\n     * @param foldableOfA {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    concatMap = curry2(_concatMap),\r\n\r\n    /**\r\n     * @function module:listOps.map\r\n     * @param fn {Function} - Function to map on functor item(s).\r\n     * @param xs {Array|String|*} - Functor.\r\n     * @returns {Array|String|*} - Functor type that is passed in.\r\n     */\r\n    map = curry(_map),\r\n\r\n    /**\r\n     * Takes an element and a list and `intersperses' that element between the elements of the list. For example\r\n     * @function module:listOps.intersperse\r\n     * @note In our version of the function javascript is loosely typed so, so is our function (to much overhead to make\r\n     *  it typed) so `between` can be any value.\r\n     * @param between {*} - Should be of the same type of elements contained in list.\r\n     * @param arr {Array|String|*} - List.\r\n     * @returns {Array|String|*}\r\n     */\r\n    intersperse = curry(_intersperse),\r\n\r\n    /**\r\n     * `intercalate xs xss` is equivalent to (concat (intersperse xs xss)). It inserts the list xs in between the lists in xss and concatenates the result.\r\n     * @haskellType `intercalate :: [a] -> [[a]] -> [a]`\r\n     * @function module:listOps.intercalate\r\n     * @param xs {Array|String|*}\r\n     * @param xss {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    intercalate = curry(_intercalate),\r\n\r\n    /**\r\n     * Reduces a foldable (list etc.) with passed in function.\r\n     * @function module:listOps.foldl\r\n     * @param fn {Function}\r\n     * @param zero {*} - Aggregator.\r\n     * @param functor {Array|String|*}\r\n     * @returns {*} - Usually same type as aggregate (`zero`) (depends on `fn`).\r\n     */\r\n    foldl = curry(_foldl),\r\n\r\n    /**\r\n     * Reduces a foldable (list etc.) from right to left with passed in function.\r\n     * @function module:listOps.foldr\r\n     * @param fn {Function}\r\n     * @param zero {*} - Aggregator.\r\n     * @param functor {Array|{reduce: {Function}}}\r\n     * @returns {*} - Usually same type as aggregate (`zero`) (depends on `fn`).\r\n     */\r\n    foldr = curry(_foldr),\r\n\r\n    /**\r\n     * Reduces a foldable (list etc.) with passed in function.\r\n     * @function module:listOps.foldl1\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduce: {Function}}}\r\n     * @returns {*}\r\n     */\r\n    foldl1 = curry(_foldl1),\r\n\r\n    /**\r\n     * Reduces a foldable (list etc.) from right to left with passed in function.\r\n     * @function module:listOps.foldr1\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduce: {Function}}}\r\n     * @returns {*}\r\n     */\r\n    foldr1 = curry(_foldr1),\r\n\r\n    /**\r\n     * Performs a map then a reduce all in one (from left-to-right). Returns a tuple\r\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\r\n     * @function module:listOps.mapAccumL\r\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\r\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\r\n     * @param xs {Array|String|*} - list type.\r\n     * @return {Array} - [aggregated, list]\r\n     */\r\n    mapAccumL = curry(_mapAccumL),\r\n\r\n    /**\r\n     * Performs a map and a reduce all in one (from right-to-left). Returns a tuple\r\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\r\n     * @function module:listOps.mapAccumR\r\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\r\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\r\n     * @param xs {Array|String|*} - list type.\r\n     * @return {Array} - [aggregated, list]\r\n     */\r\n    mapAccumR = curry(_mapAccumR),\r\n\r\n    /**\r\n     * Iterate on value (`x`) with `op` up to `limit`.\r\n     * @function module:listOps.iterate\r\n     * @param limit {Number}\r\n     * @param op {Function} - Operation\r\n     * @param x {*} - Starting point.\r\n     * @returns {*}\r\n     */\r\n    iterate = curry(_iterate),\r\n\r\n    repeat = curry(_repeat),\r\n\r\n    replicate = repeat,\r\n\r\n    cycle = curry(_cycle),\r\n\r\n    /**\r\n     * Unfolds a value into a list of somethings.\r\n     * @haskellType `unfoldr :: (b -> Maybe (a, b)) -> b -> [a]`\r\n     * @function module:listOps.unfoldr\r\n     * @param op {Function} - Operation to perform (should return a two component tuple (item to aggregate and item to unfold in next iteration).\r\n     * @param x {*} - Starting parameter to unfold from.\r\n     * @returns {Array} - An array of whatever you return from `op` yielded.\r\n     */\r\n    unfoldr = curry(_unfoldr),\r\n\r\n    /**\r\n     * Finds index in string or list (alias for `findIndex`).\r\n     * @function module:listOps.findIndex\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    findIndex = curry(_findIndex),\r\n\r\n    /**\r\n     * @function module:listOps.findIndices\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {Array|undefined}\r\n     */\r\n    findIndices = curry(_findIndices),\r\n\r\n    /**\r\n     * @function module:listOps.elemIndex\r\n     * @param x {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    elemIndex = curry(_elemIndex),\r\n\r\n    /**\r\n     * @function module:listOps.elemIndices\r\n     * @param value {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    elemIndices = curry(_elemIndices),\r\n\r\n    /**\r\n     * Takes `n` items from start of list to `limit` (exclusive).\r\n     * @function module:listOps.take\r\n     * @param list {Array|String}\r\n     * @param limit {Number}\r\n     * @returns {String|Array} - Passed in type's type\r\n     */\r\n    take = curry(_take),\r\n\r\n    /**\r\n     * Drops `n` items from start of list to `count` (exclusive).\r\n     * @function module:listOps.take\r\n     * @param list {Array|String}\r\n     * @param count {Number}\r\n     * @returns {String|Array} - Passed in type's type\r\n     */\r\n    drop = curry(_drop),\r\n\r\n    /**\r\n     * Splits `x` in two at given `index` (exclusive (includes element/character at\r\n     * given index in second part of returned list)).\r\n     * @function module:listOps.splitAt\r\n     * @param ind {Number} - Index to split at.\r\n     * @param list {Array|String|*} - functor (list or string) to split.\r\n     * @returns {Array} - Array of whatever type `x` was when passed in\r\n     */\r\n    splitAt = curry(_splitAt),\r\n\r\n    /**\r\n     * Gives an list with passed elements while predicate was true.\r\n     * @function module:listOps.takeWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @returns {Array}\r\n     */\r\n    takeWhile = curry(_takeWhile),\r\n\r\n    /**\r\n     * Returns an list without elements that match predicate.\r\n     * @function module:listOps.dropWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @refactor\r\n     * @returns {Array|String}\r\n     */\r\n    dropWhile = curry(_dropWhile),\r\n\r\n    /**\r\n     * @function module:listOps.dropWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @refactor\r\n     * @returns {Array|String}\r\n     */\r\n    dropWhileEnd = curry(_dropWhileEnd),\r\n\r\n    /**\r\n     * Gives a span such that the first list (in returned tuple) is the span of items matching upto `not predicate` and\r\n     * the second list in the tuple is a list of the remaining elements in the given list.\r\n     * **@Note: Not the same as `partition`.  Read descriptions closely!!!\r\n     * @function module:listOps.partition\r\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\r\n     * @param list {Array|String|*} - Predicate<item, index, originalArrayOrString>\r\n     * @returns {Array|String|*} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\r\n     */\r\n    span = curry(_span),\r\n\r\n    breakOnList = curry(_breakOnList),\r\n\r\n    /**\r\n     * @function module:listOps.at\r\n     * @param ind {Number} - Index.\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    at = curry(_at),\r\n\r\n    /**\r\n     * @function module:listOps.find\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    find = curry(_find),\r\n\r\n    filter = curry(_filter),\r\n\r\n    /**\r\n     * Partitions a list on a predicate;  Items that match predicate are in first list in tuple;  Items that\r\n     * do not match the tuple are in second list in the returned tuple.\r\n     *  Essentially `[filter(p, xs), filter(negateP(p), xs)]`.\r\n     * @function module:listOps.partition\r\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\r\n     * @param list {Array|String|*}\r\n     * @returns {Array|String} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\r\n     */\r\n    partition = curry(_partition),\r\n\r\n    elem = curry(_elem),\r\n\r\n    notElem = curry2(_notElem),\r\n\r\n    lookup = at,\r\n\r\n    isPrefixOf = curry(_isPrefixOf),\r\n\r\n    isSuffixOf = curry(_isSuffixOf),\r\n\r\n    isInfixOf = curry(_isInfixOf),\r\n\r\n    isSubsequenceOf = curry(_isSubsequenceOf),\r\n\r\n    /**\r\n     * Allows you to group items in a list based on your supplied equality check.\r\n     * @note Sames `group` but allows you to specify equality operation.\r\n     * @haskellType `groupBy :: (a -> a -> Bool) -> [a] -> [[a]]`\r\n     * @function module:listOps.groupBy\r\n     * @param equalityOp {Function}\r\n     * @param xs {Array|String|*}\r\n     * @returns {*}\r\n     */\r\n    groupBy = curry(_groupBy),\r\n\r\n    stripPrefix = curry(_stripPrefix),\r\n\r\n    /**\r\n     * zip takes two lists and returns a list of corresponding pairs.\r\n     * If one input list is short, excess elements of the longer list are discarded.\r\n     * @haskellType `zip :: [a] -> [b] -> [(a, b)]`\r\n     * @function module:listOps.zip\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip = curry(_zip),\r\n\r\n    /**\r\n     * zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\r\n     * zipWith generalises zip by zipping with the function given as the\r\n     * first argument, instead of a function tupling function (function that returns a tuple). For example,\r\n     * zipWith (+) is applied to two lists to produce the list of corresponding sums.\r\n     * @note `_|_` means bottom or perpetual (@see\r\n     *  - https://wiki.haskell.org/Bottom\r\n     *  - https://stackoverflow.com/questions/19794681/what-does-this-syntax-mean-in-haskell-or\r\n     *  )\r\n     * @example\r\n     * ```\r\n     * zipWith f [] _|_ = []\r\n     * ```\r\n     * @haskellType `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`\r\n     * @function module:listOps.zipWith\r\n     * @param op {Function} - Takes two parts of a tuple and returns a tuple.\r\n     *  E.g., ` op :: a -> b -> (a, b)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith = curry(_zipWith),\r\n\r\n    /**\r\n     * Zips all given lists with tupling function. Note: Haskell types do not have\r\n     *  a way (that I know of) to show one or more for params in a function so `@haskellType` below\r\n     *  is left there for general purpose not for exactness as is told by aforementioned.\r\n     * @haskellType `zipWithN :: (a -> b -> c) -> [a] -> [b] -> [c]` - Where `N` is the number\r\n     *  of lists to zip.\r\n     * @function module:listOps.zipWithN\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\r\n     * @param lists ...{Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWithN = curry3(_zipWithN),\r\n\r\n    /**\r\n     * Zips 3 lists with tupling function.\r\n     * @haskellType `zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]`\r\n     * @function module:listOps.zipWith3\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @param xs3 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith3 = curry4(zipWithN),\r\n\r\n    /**\r\n     * Zips 4 lists with tupling function.\r\n     * @haskellType `zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c]  -> [d] -> [e]`\r\n     * @function module:listOps.zipWith4\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> d -> (a, b, c, d)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @param xs3 {Array|String|*}\r\n     * @param xs4 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith4 = curry5(zipWithN),\r\n\r\n    /**\r\n     * Zips 5 lists.\r\n     * @haskellType `zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c]  -> [d] -> [e] -> [f]`\r\n     * @function module:listOps.zipWith5\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> d -> e -> (a, b, c, d, e)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @param xs3 {Array|String|*}\r\n     * @param xs4 {Array|String|*}\r\n     * @param xs5 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith5 = curryN(6, zipWithN),\r\n\r\n    any = curry(_any),\r\n\r\n    all = curry(_all),\r\n\r\n    scanl = curry(_scanl),\r\n\r\n    scanl1 = curry(_scanl1),\r\n\r\n    scanr = curry(_scanr),\r\n\r\n    scanr1 = curry(_scanr1),\r\n\r\n    remove = curry(_remove),\r\n\r\n    sortOn = curry(_sortOn),\r\n\r\n    sortBy = curry(_sortBy),\r\n\r\n    insert = curry(_insert),\r\n\r\n    /**\r\n     * A version of `insert` that allows you to specify the ordering of the inserted\r\n     * item;  Before/at, or after\r\n     * @function module:listOps.insertBy\r\n     * @haskellType `insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]`\r\n     * @note `Ordering` === // something that is order-able\r\n     * @todo Optimize and work the logic of this function;  Think about the types that will be\r\n     *  operated on by this functions logic.\r\n     * @param orderingFn {Function} - A function that returns `-1`, `0`, or 1`.\r\n     * @param x {*} - Value to insert.\r\n     * @param xs {Array|String|*} - List to insert into (note new list is returned)\r\n     * @returns {Array|String|*} - New list.\r\n     */\r\n    insertBy = curry(_insertBy),\r\n\r\n    nubBy = curry(_nubBy),\r\n\r\n    removeBy = curry(_removeBy),\r\n\r\n    removeFirstsBy = curry(_removeFirstsBy),\r\n\r\n    /**\r\n     * Returns the union on elements matching boolean check passed in.\r\n     * @function module:listOps.unionBy\r\n     * @param pred {Function} - `pred :: a -> a -> Bool`\r\n     * @param arr1 {Array|String|*}\r\n     * @param arr2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    unionBy = curry(_unionBy),\r\n\r\n    /**\r\n     * Creates a union on matching elements from array1.\r\n     * @function module:listOps.union\r\n     * @param arr1 {Array|String|*}\r\n     * @param arr2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    union = curry(_union),\r\n\r\n    /**\r\n     * Performs an intersection on list 1 with  elements from list 2.\r\n     * @function module:listOps.intersect\r\n     * @param arr1 {Array|String|*}\r\n     * @param arr2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    intersect = curry(_intersect),\r\n\r\n    /**\r\n     * Returns an intersection by predicate.\r\n     * @function module:listOps.intersectBy\r\n     * @param pred {Function} - `pred :: a -> b -> Bool`\r\n     * @param list1 {Array|String|*}\r\n     * @param list2 {Array|String|*}\r\n     * @return {Array|String|*}\r\n     */\r\n    intersectBy = curry(_intersectBy),\r\n\r\n    /**\r\n     * Returns the difference of list 1 from list 2.\r\n     * @note The `difference` operation here is non-associative;  E.g., `a - b` is not equal to `b - a`;\r\n     * @function module:listOps.difference\r\n     * @param array1 {Array|String|*}\r\n     * @param array2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    difference = curry(_difference),\r\n\r\n    /**\r\n     * Returns the complement of list 0 and the reset of the passed in arrays.\r\n     * @function module:listOps.complement\r\n     * @param arr0 {Array}\r\n     * @param arrays {...Array}\r\n     * @returns {Array}\r\n     */\r\n    complement = curry2(_complement);\r\n","/**\r\n * Contains functions for operating strings.\r\n * @author elyde\r\n * @created 7/9/2017.\r\n * @module stringOps\r\n */\r\nimport {intercalate} from './listOps';\r\n\r\nimport {split} from './jsPlatform/string';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Splits a string on all '\\n', '\\r', '\\n\\r', or '\\r\\n' characters.\r\n     * @function module:stringOps.lines\r\n     * @param str {String}\r\n     * @returns {Array}\r\n     */\r\n    lines = split(/[\\n\\r]/gm),\r\n\r\n    /**\r\n     * Splits a string on all '\\s' and/or all '\\t' characters.\r\n     * @function module:stringOps.words\r\n     * @param str{String}\r\n     * @returns {Array}\r\n     */\r\n    words = split(/[\\s\\t]/gm),\r\n\r\n    /**\r\n     * Intersperse an array of strings with '\\s' and then concats them.\r\n     * @function module:stringOps.unwords\r\n     * @param arr {String}\r\n     * @returns {Array}\r\n     */\r\n    unwords = intercalate(' '),\r\n\r\n    /**\r\n     * Intersperses a '\\n' character into a list of strings and then concats it.\r\n     * @function module:stringOps.unlines\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    unlines = intercalate('\\n');\r\n","/**\r\n * Created by elyde on 12/6/2016.\r\n * @file fjl.js\r\n * @goal to include everything from haskell's Prelude where it makes sense in order to create\r\n *  a subset of functions which can make the javascript developer more efficient and make his/her\r\n *  code more concise (and functional).\r\n * @description Includes operations from haskell's Prelude.\r\n * @motivation preludejs, lodash/fp, RamdaJs, Haskell.\r\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html\r\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-List.html\r\n * @module fjl\r\n */\r\nexport * from './objectOps';\r\nexport * from './booleanOps';\r\nexport * from './functionOps';\r\nexport * from './listOps';\r\nexport * from './stringOps';\r\nexport * from './utils';\r\nexport * from './uncurried/_listOps/_utils';\r\n"],"names":["fPureTakesOne","arg","f","name","fPureTakes2","arg1","arg2","fPureTakes3","arg3","fPureTakes4","arg4","fPureTakes5","arg5","fPureTakesOneOrMore","args","instanceOf","instanceConstructor","instance","hasOwnProperty","length","x","keys","Object","obj","assign","obj0","objs","reduce","topAgg","agg","key","defineReverse","Array","prototype","reverse","reduceRight","item","push","map","filter","forEach","some","every","join","concat","slice","includes","value","xs","indexOf","lastIndexOf","split","apply","fn","call","curry","argsToCurry","concatedArgs","curryN","executeArity","curriedArgs","canBeCalled","curry2","curry3","curry4","curry5","prop","_Number","Number","_NaN","_Null","_Undefined","typeOf","retVal","undefined","constructorName","constructor","isNaN","_String","String","_Object","_Boolean","Boolean","_Function","Function","_Array","_Symbol","_Map","_Set","_WeakMap","_WeakSet","isFunction","isType","type","isClass","test","substr","isCallable","isArray","isObject","isBoolean","isNumber","isString","isMap","isSet","isWeakMap","isWeakSet","isUndefined","isNull","isSymbol","isUsableImmutablePrimitive","typeOfX","isset","Type","isEmptyList","isEmptyObject","isEmptyCollection","size","isEmpty","typeOfValue","assignDeep","propDescription","getOwnPropertyDescriptor","get","set","writable","negateF","a","b","negateF3","c","negateF4","d","negateF5","e","negateP","negateFMany","isTruthy","isFalsy","alwaysTrue","alwaysFalse","Symbol","of","aggregateStr","aggregateArr","aggregateObj","ind","aggregatorByType","limit","out","aggregate","sliceFrom","startInd","arr","sliceTo","toInd","copy","sliceCopy","genericAscOrdering","lengths","lists","lengthsToSmallest","listLengths","smallLen","Math","min","list","reduceUntil","pred","op","result","reduceRightUntil","operation","lastIndex","len","findIndexWhere","predicateFulfilled","findIndexWhereRight","findIndicesWhere","findWhere","elm","append","listAppend","appendMany","Error","head","last","tail","init","uncons","unconsr","concatMap","foldableOfA","aggregator","foldr","intersperse","between","lastInd","aggregatorOp","foldl","intercalate","xss","transpose","numLists","ind2","longestListLen","maximum","outLists","outList","subsequences","listLen","pow","i","entry","j","swapped","ind1","tmp","permutations","repeat","foldl1","parts","foldr1","mapAccumL","zero","mapped","tuple","mapAccumR","iterate","replicate","cycle","unfoldr","resultTuple","findIndex","findIndices","elemIndex","foundInd","elemIndices","take","drop","count","splitAt","takeWhile","dropWhile","splitPoint","list2","dropWhileEnd","span","breakOnList","at","find","partition","elem","notElem","lookup","isPrefixOf","xs1","xs2","limit1","limit2","isSuffixOf","isInfixOf","foundLen","isSubsequenceOf","lenXs1","group","groupBy","equalityOp","prevItem","predOp","inits","tails","stripPrefix","prefix","zip","arr1","arr2","a1","a2","zipN","trimmedLists","lenOfTrimmed","zipWith","zipWithN","unzip","unzipN","lenItem0","any","p","all","and","or","sum","product","sortBy","minimum","scanl","scanl1","scanr","scanr1","nub","nubBy","remove","removeBy","sort","sortOn","valueFn","decorated","a0","b0","orderingFn","insert","foundIndex","insertBy","currItem","anyOp","storedItem","removeFirstsBy","unionBy","alreadyAdded","union","intersect","intersectBy","list1","difference","array1","array2","complement","arr0","arrays","objUnion","obj1","obj2","objIntersect","objDifference","objComplement","_prop","_instanceOf","_hasOwnProperty","_assign","_assignDeep","_objUnion","_objIntersect","_objDifference","_objComplement","_isType","until","predicate","typeInstance","flipN","flip3","flip4","flip5","flip","PlaceHolder","placeHolderInstance","isPlaceHolder","replacePlaceHolders","array","element","shift","curry_","placeHolders","curryN_","__","freeze","curry2_","curry3_","curry4_","curry5_","id","compose","arg0","_apply","_call","_until","_flip","_flip3","_flip4","_flip5","fPureTakesOne_","fPureTakes2_","fPureTakesOneOrMore_","concat_","slice_","includes_","indexOf_","lastIndexOf_","_split","_append","_appendMany","_concatMap","_map","_intersperse","_intercalate","_foldl","_foldr","_foldl1","_foldr1","_mapAccumL","_mapAccumR","_iterate","_repeat","_cycle","_unfoldr","_findIndex","_findIndices","_elemIndex","_elemIndices","_take","_drop","_splitAt","_takeWhile","_dropWhile","_dropWhileEnd","_span","_breakOnList","_at","_find","_filter","_partition","_elem","_notElem","_isPrefixOf","_isSuffixOf","_isInfixOf","_isSubsequenceOf","_groupBy","_stripPrefix","_zip","_zipWith","_zipWithN","zipWith3","zipWith4","zipWith5","_any","_all","_scanl","_scanl1","_scanr","_scanr1","_remove","_sortOn","_sortBy","_insert","_insertBy","_nubBy","_removeBy","_removeFirstsBy","_unionBy","_union","_intersect","_intersectBy","_difference","_complement","lines","words","unwords","unlines"],"mappings":"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"}