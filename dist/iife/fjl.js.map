{"version":3,"file":"fjl.js","sources":["../../src/object/typeOf.js","../../src/function/fnOrError.js","../../src/function/curry.js","../../src/utils.js","../../src/jsPlatform/object.js","../../src/object/is.js","../../src/object/lookup.js","../../src/jsPlatform/function.js","../../src/object/of.js","../../src/object/copy.js","../../src/object/searchObj.js","../../src/object/assignDeep.js","../../src/jsPlatform/list.js","../../src/function/negate.js","../../src/boolean.js","../../src/list/map.js","../../src/list/aggregation.js","../../src/list/utils.js","../../src/list/range.js","../../src/jsPlatform/array.js","../../src/jsPlatform/string.js","../../src/jsPlatform.js","../../src/list.js","../../src/object/setTheory.js","../../src/object/console.js","../../src/object/jsonClone.js","../../src/object/assocList.js","../../src/object/toArray.js","../../src/object.js","../../src/function/compose.js","../../src/function/flip.js","../../src/function/id.js","../../src/function/until.js","../../src/function.js","../../src/errorThrowing.js","../../src/string.js","../../src/fjl.js"],"sourcesContent":["/**\r\n * Created by elyde on 12/18/2016.\r\n * @memberOf object\r\n */\r\nconst _Number = Number.name,\r\n    _NaN = 'NaN',\r\n    _Null = 'Null',\r\n    _Undefined = 'Undefined';\r\n\r\n/**\r\n * Returns the constructor/class/type name of a value.\r\n * @note Returns 'NaN' if value is of type `Number` and value is `isNaN`.\r\n * @note Returns 'Undefined' if value is `undefined`\r\n * @note Returns 'Null' if value is `null`\r\n * For values that have no concrete constructors and/or casters\r\n * (null, NaN, and undefined) we returned normalized names for them ('Null', 'NaN', 'Number')\r\n * @function module:object.typeOf\r\n * @param value {*}\r\n * @returns {string} - Constructor's name or derived name (in the case of `null`, `undefined`, or `NaN` (whose\r\n *  normalized names are 'Null', 'Undefined', 'NaN' respectively).\r\n */\r\nexport function typeOf (value) {\r\n    let retVal;\r\n    if (value === undefined) {\r\n        retVal = _Undefined;\r\n    }\r\n    else if (value === null) {\r\n        retVal = _Null;\r\n    }\r\n    else {\r\n        let constructorName = (value).constructor.name;\r\n        retVal = constructorName === _Number && isNaN(value) ?\r\n            _NaN : constructorName;\r\n    }\r\n    return retVal;\r\n}\r\n","import {typeOf} from '../object/typeOf';\r\n\r\nconst\r\n\r\n    /**\r\n     * Returns a function or throws an error if given `f` is not a function.\r\n     * @function module:function.fnOrError\r\n     * @param symbolName {String} - Error message prefix.\r\n     * @param f {Function|*} - Expected function.\r\n     * @returns {Function}\r\n     * @throws {Error} - Error if `f` is not of `function`\r\n     */\r\n    fnOrError = (symbolName, f) => {\r\n        if (!f || !(f instanceof Function)) {\r\n            throw new Error(`${symbolName} should be a function. ` +\r\n                `Type received: ${typeOf(f)};  Value received: ${f}.`);\r\n        }\r\n        return f;\r\n    }\r\n\r\n;\r\n\r\nexport default fnOrError;\r\n","import fnOrError from './fnOrError';\r\n\r\n/**\r\n * @author elydelacruz\r\n * @created 12/6/2016.\r\n * @memberOf function\r\n * @description \"Curry strict\" and \"curry arbitrarily\" functions (`curry`, `curryN`).\r\n */\r\n\r\nexport const\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    curryNotFnErrPrefix = '`fn` in `curry(fn, ...args)`',\r\n\r\n    /**\r\n     * Curries a function up to a given arity.\r\n     * @function module:function.curryN\r\n     * @param executeArity {Number}\r\n     * @param fn {Function}\r\n     * @param curriedArgs {...*}\r\n     * @returns {Function}\r\n     */\r\n    curryN = (executeArity, fn, ...curriedArgs) => {\r\n        return (...args) => {\r\n            let concatedArgs = curriedArgs.concat(args),\r\n                canBeCalled = (concatedArgs.length >= executeArity) || !executeArity;\r\n            return !canBeCalled ? curryN.apply(null, [executeArity, fnOrError(curryNotFnErrPrefix, fn)].concat(concatedArgs)) :\r\n                fnOrError(curryNotFnErrPrefix, fn).apply(null, concatedArgs);\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Curries a function based on it's defined arity (argument's arrayOps expected length).\r\n     * @function module:function.curry\r\n     * @param fn {Function}\r\n     * @param argsToCurry {...*}\r\n     * @returns {Function}\r\n     */\r\n    curry = (fn, ...argsToCurry) => curryN(fnOrError(curryNotFnErrPrefix, fn).length, fn, ...argsToCurry),\r\n\r\n    /**\r\n     * Curries a function up to an arity of 2 (won't call function until 2 or more args).\r\n     * @function module:function.curry2\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry2 = fn => curryN(2, fn),\r\n\r\n    /**\r\n     * Curries a function up to an arity of 3 (won't call function until 3 or more args).\r\n     * @function module:function.curry3\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry3 = fn => curryN(3, fn),\r\n\r\n    /**\r\n     * Curries a function up to an arity of 4 (won't call function until 4 or more args).\r\n     * @function module:function.curry4\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry4 = fn => curryN(4, fn),\r\n\r\n    /**\r\n     * Curries a function up to an arity of 5 (won't call function until 5 or more args).\r\n     * @function module:function.curry5\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry5 = fn => curryN(5, fn);\r\n","/**\r\n * @module utils\r\n */\r\nimport {curry, curry2} from './function/curry';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns a function that takes an argument and an object on which to execute 'method name'\r\n     * with said parameters.\r\n     * @function module:utils.fPureTakesOne\r\n     * @param name {String}\r\n     * @returns {Function}\r\n     */\r\n    fPureTakesOne = name => curry((arg, f) => f[name](arg)),\r\n\r\n    /**\r\n     * Returns a function that takes 2 arguments and an object on which to execute 'method name'\r\n     * with said parameters.\r\n     * @function module:utils.fPureTakes2\r\n     * @param name {String}\r\n     * @returns {Function}\r\n     */\r\n    fPureTakes2 = name => curry((arg1, arg2, f) => f[name](arg1, arg2)),\r\n\r\n    /**\r\n     * Returns a function that takes 3 arguments and an object on which to execute 'method name'\r\n     * with said parameters.\r\n     * @function module:utils.fPureTakes3\r\n     * @param name {String}\r\n     * @returns {Function}\r\n     */\r\n    fPureTakes3 = name => curry((arg1, arg2, arg3, f) => f[name](arg1, arg2, arg3)),\r\n\r\n    /**\r\n     * Returns a function that takes 4 arguments and an object on which to execute 'method name'\r\n     * with said parameters.\r\n     * @function module:utils.fPureTakes4\r\n     * @param name {String}\r\n     * @returns {Function}\r\n     */\r\n    fPureTakes4 = name => curry((arg1, arg2, arg3, arg4, f) => f[name](arg1, arg2, arg3, arg4)),\r\n\r\n    /**\r\n     * Returns a function that takes 5 arguments and an object on which to execute 'method name'\r\n     * with said parameters.\r\n     * @function module:utils.fPureTakes5\r\n     * @param name {String}\r\n     * @returns {Function}\r\n     */\r\n    fPureTakes5 = name => curry((arg1, arg2, arg3, arg4, arg5, f) => f[name](arg1, arg2, arg3, arg4, arg5)),\r\n\r\n    /**\r\n     * Returns a function that takes an object and one or more arguments on which to execute 'method name'\r\n     * with said parameters.\r\n     * @function module:utils.fPureTakesOneOrMore\r\n     * @param name {String}\r\n     * @returns {Function}\r\n     */\r\n    fPureTakesOneOrMore = name => curry2((f, ...args) => f[name](...args))\r\n\r\n;\r\n","/**\r\n * @memberOf object\r\n * @description Defines some of the platform methods for objects (the ones used within `fjl`).\r\n */\r\n\r\nimport {fPureTakesOne} from '../utils';\r\nimport {curry} from '../function/curry';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns whether constructor has derived object.\r\n     * @function module:_jsPlatformobject.instanceOf\r\n     * @param instanceConstructor {Function} - Constructor.\r\n     * @param instance {*}\r\n     * @instance {*}\r\n     * @returns {Boolean}\r\n     */\r\n    instanceOf = curry((instanceConstructor, instance) =>\r\n        instance instanceof instanceConstructor),\r\n\r\n    /**\r\n     * @function module:_jsPlatformobject.hasOwnProperty\r\n     * @param propName {*}\r\n     * @param typeInstance {*}\r\n     * @returns {Boolean}\r\n     */\r\n    hasOwnProperty = fPureTakesOne('hasOwnProperty'),\r\n\r\n    /**\r\n     * @function module:_jsPlatformobject.length\r\n     * @param x {*}\r\n     * @returns {Number}\r\n     * @throws {Error} - Throws an error if value doesn't have a `length` property (\r\n     *  `null`, `undefined`, {Boolean}, Symbol, et. al.).\r\n     */\r\n    length = x => x.length,\r\n\r\n    /**\r\n     * Gets own enumerable keys of passed in object (`Object.keys`).\r\n     * @function module:_jsPlatformobject.keys\r\n     * @param obj {*}\r\n     * @returns {Array<String>}\r\n     */\r\n    {keys} = Object,\r\n\r\n    /**\r\n     * Defined as `Object.assign` else is the same thing but shimmed.\r\n     * @function module:_jsPlatformobject.assign\r\n     * @param obj0 {Object}\r\n     * @param objs {...{Object}}\r\n     * @returns {Object}\r\n     */\r\n    assign = (() => Object.assign ?\r\n            (obj0, ...objs) => Object.assign(obj0, ...objs) :\r\n            (obj0, ...objs) => objs.reduce((topAgg, obj) => {\r\n                return keys(obj).reduce((agg, key) => {\r\n                    agg[key] = obj[key];\r\n                    return agg;\r\n                }, topAgg);\r\n            }, obj0)\r\n        )();\r\n","/**\r\n * Created by elyde on 12/18/2016.\r\n * @memberOf object\r\n */\r\n\r\nimport {typeOf} from './typeOf';\r\nimport {instanceOf, length, keys, hasOwnProperty} from '../jsPlatform/object';\r\nimport {curry} from '../function/curry';\r\n\r\nlet _String = String.name,\r\n    _Number = Number.name,\r\n    _Object = Object.name,\r\n    _Boolean = Boolean.name,\r\n    _Function = Function.name,\r\n    _Array = Array.name,\r\n    _Symbol = 'Symbol',\r\n    _Map = 'Map',\r\n    _Set = 'Set',\r\n    _WeakMap = 'WeakMap',\r\n    _WeakSet = 'WeakSet',\r\n    _Null = 'Null',\r\n    _Undefined = 'Undefined';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Resolves/normalizes a type name from either a string or a constructor.\r\n     * @function module:object.toTypeRef\r\n     * @param type {Function|String} - String or function representing a type.\r\n     * @returns {String}\r\n     * @private\r\n     */\r\n    toTypeRef = type => {\r\n        if (!type) {\r\n            return typeOf(type);\r\n        }\r\n        else if (type.constructor === String || (type instanceof Function)) {\r\n            return type;\r\n        }\r\n        return typeOf(type);\r\n    },\r\n\r\n    toTypeRefName = Type => {\r\n        const ref = toTypeRef(Type);\r\n        return ref instanceof Function ? ref.name : ref;\r\n    },\r\n\r\n    /**\r\n     * Returns whether a value is a function or not.\r\n     * @function module:object.isFunction\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isFunction = instanceOf(Function),\r\n\r\n    /**\r\n     * Strict type checker.  Checks if given value is a direct instance of given type;  E.g.,\r\n     * @example\r\n     *   isType(String, 'abcdefg')  === true // true\r\n     *   isType(String.name, 'abcdefg') === true\r\n     *   isType(Number, NaN) === false\r\n     *   isType(Number, 99) === true\r\n     *   isType('Null', 99) === false // though, for `null` and `undefined` checks\r\n     *                                // @see `isset`, in this module, instead\r\n     *   isType('Undefined', undefined) === true // true\r\n     *\r\n     * @note Useful where absolute types, or some semblance thereof, are required.\r\n     * @function module:object.isType\r\n     * @param type {Function|ObjectConstructor|String} - Constructor or constructor name\r\n     * @param obj {*}\r\n     * @return {Boolean}\r\n     */\r\n    isType = curry((type, obj) => typeOf(obj) === toTypeRefName(type)),\r\n\r\n    /**\r\n     * Loose type checker;  E.g., If `type` is not a constructor, but a constructor name, does a type check on\r\n     * constructor names, else if first check fails and `type` is a constructor, performs an `instanceof` check\r\n     * on value with constructor.\r\n     * @note Use care when checking for `Array` and/or `Object` since the both are considered objects by `instanceof` checker.\r\n     * @note For `null` and `undefined` their class cased names can be used for type checks\r\n     * `isOfType('Null', null) === true (passes strict type check)` (or better yet `isset` can be used).\r\n     * @throwsafe - Doesn't throw on `null` or `undefined` `obj` values.\r\n     * @example\r\n     * isOfType(Number, 99) === true        // true  (passes strict type check (numbers are not instances of `Number`\r\n     *                                      //        constructor)\r\n     * isOfType('Number', 99) === true      // true  (passes strict type check)\r\n     * isOfType(Number, NaN) === true       // true. (passes instance of check)\r\n     *                                      //        If you want \"true\" strict type checking use `isType`\r\n     * isOfType(Object, []) === true        // true  (passes instance of check)\r\n     * isOfType(Array, []) === true         // true  (passes instance of check)\r\n     * isOfType(Object, {}) === true        // true  (passes instance of check)\r\n     * isOfType(Object.name, {}) === true   // true  (Passes strict type check)\r\n     * class Abc extends String {}\r\n     * isOfType(String, new Abc('abcd')) // true (passes instanceof check)\r\n     *\r\n     * @function module:is.isOfType\r\n     * @param type {Function|String} - Type reference (constructor or `constructor.name`).\r\n     * @param x {*} - Value to check.\r\n     * @returns {Boolean}\r\n     */\r\n    isOfType = curry((type, x) => isType(type, x) || instanceOf(type, x)),\r\n\r\n    /**\r\n     * Checks if `value` is an es2015 `class`.\r\n     * @function module:object.isClass\r\n     * @param x {*}\r\n     * @returns {boolean}\r\n     */\r\n    isClass = x => x && /^\\s{0,3}class\\s{1,3}/.test((x + '').substr(0, 10)),\r\n\r\n    /**\r\n     * Returns a boolean depicting whether a value is callable or not.\r\n     * @function module:object.isCallable\r\n     * @tentative\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isCallable = x => isFunction(x) && !isClass(x),\r\n\r\n    /**\r\n     * Checks if value is an array (same as `Array.isArray`).\r\n     * @function module:object.isArray\r\n     * @param value {*}\r\n     * @returns {boolean}\r\n     */\r\n    {isArray} = Array,\r\n\r\n    /**\r\n     * Checks whether value is an object or not.\r\n     * @function module:object.isObject\r\n     * @param value\r\n     * @returns {Boolean}\r\n     */\r\n    isObject = isType(_Object),\r\n\r\n    /**\r\n     * Checks if value is a boolean.\r\n     * @function module:object.isBoolean\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isBoolean = isType(_Boolean),\r\n\r\n    /**\r\n     * Checks if value is a valid number (also checks if isNaN so that you don't have to).\r\n     * @function module:object.isNumber\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isNumber = isType(_Number),\r\n\r\n    /**\r\n     * Checks whether value is a string or not.\r\n     * @function module:object.isString\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isString = isType(_String),\r\n\r\n    /**\r\n     * Checks whether value is of `Map` or not.\r\n     * @function module:object.isMap\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isMap = isType(_Map),\r\n\r\n    /**\r\n     * Checks whether value is of `Set` or not.\r\n     * @function module:object.isSet\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isSet = isType(_Set),\r\n\r\n    /**\r\n     * Checks whether value is of `WeakMap` or not.\r\n     * @function module:object.isWeakMap\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isWeakMap =isType(_WeakMap),\r\n\r\n    /**\r\n     * Checks whether value is of `WeakSet` or not.\r\n     * @function module:object.isWeakSet\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isWeakSet = isType(_WeakSet),\r\n\r\n    /**\r\n     * Checks if value is undefined.\r\n     * @function module:object.isUndefined\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isUndefined = isType(_Undefined),\r\n\r\n    /**\r\n     * Checks if value is null.\r\n     * @function module:object.isNull\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isNull = isType(_Null),\r\n\r\n    /**\r\n     * Checks if value is a `Symbol`.\r\n     * @function module:object.isSymbol\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isSymbol = isType(_Symbol),\r\n\r\n    /**\r\n     * Checks if given `x` is set and of one of\r\n     *  [String, Boolean, Number, Symbol] (null and undefined are immutable\r\n     *  but are not \"usable\" (usually not what we want to operate on).\r\n     * @function module:object.isUsableImmutablePrimitive\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isUsableImmutablePrimitive = x => {\r\n        const typeOfX = typeOf(x);\r\n        return isset(x) &&\r\n            [_String, _Number, _Boolean, _Symbol]\r\n                .some(Type => Type === typeOfX);\r\n    },\r\n\r\n    /**\r\n     * Checks if !length.\r\n     * @function module:object.isEmptyList\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyList = x => !length(x),\r\n\r\n    /**\r\n     * Checks if object has own properties/enumerable-props or not.\r\n     * @function module:object.isEmptyObject\r\n     * @param obj {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyObject = obj => isEmptyList(keys(obj)),\r\n\r\n    /**\r\n     * Checks if collection is empty or not (Map, WeakMap, WeakSet, Set etc.).\r\n     * @function module:object.isEmptyCollection\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyCollection = x => x.size === 0,\r\n\r\n    /**\r\n     * Checks to see if passed in value is empty;  I.e.,\r\n     *  check for one of '', 0, `null`, `undefined`, `false`, empty array, empty object, empty function (zero arity),\r\n     *  or empty collection (es6 Map, Set, WeakMap, or WeakSet etc. (`!value.size`);\r\n     * @function module:object.isEmpty\r\n     * @param value {*} - Value to check.\r\n     * @returns {Boolean}\r\n     */\r\n    isEmpty = value => {\r\n        let retVal;\r\n        if (!value) { // if '', 0, `null`, `undefined`, or `false` then is empty\r\n            retVal = true;\r\n        }\r\n        const typeOfValue = typeOf(value);\r\n        if (typeOfValue === _Array || typeOfValue === _Function) {\r\n            retVal = isEmptyList(value);\r\n        }\r\n        else if (typeOfValue === _Number) {\r\n            retVal = false;\r\n        }\r\n        else if (typeOfValue === _Object) {\r\n            retVal = isEmptyObject(value);\r\n        }\r\n        else if (hasOwnProperty('size', value) && isNumber(value.size)) {\r\n            retVal = isEmptyCollection(value);\r\n        }\r\n        else {\r\n            retVal = !value;\r\n        }\r\n        return retVal;\r\n    },\r\n\r\n    /**\r\n     * Returns whether passed in values is defined and not null or not.\r\n     * @function module:object.isset\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isset = x => x !== null && x !== undefined;\r\n","/**\r\n * @memberOf object\r\n */\r\n\r\nimport {isset} from './is';\r\nimport {curry} from '../function/curry';\r\n\r\n/**\r\n * Looks up property and returns it's value; Else `undefined`.\r\n * Method is null safe (will not throw on `null` or `undefined`).\r\n * @function module:object.lookup\r\n * @param key {String} - Key to search on `obj`\r\n * @param obj {Object} - Object to search `name` on.\r\n * @returns {*}\r\n */\r\nexport const lookup = curry((key, obj) => isset(obj) ? obj[key] : undefined);\r\n","import {curry} from '../function/curry';\r\n\r\n/**\r\n * Created by elydelacruz on 9/7/2017.\r\n * @module _jsPlatform_function\r\n * @private\r\n */\r\nexport const\r\n\r\n    /**\r\n     * Functional `apply` function (takes no context).\r\n     * @function module:_jsPlatform_function.apply\r\n     * @param fn {Function}\r\n     * @param args {Array|*}\r\n     * @returns {*}\r\n     */\r\n    apply = curry((fn, args) => fn.apply(null, args)),\r\n\r\n    /**\r\n     * Functional `call` function (takes no context).\r\n     * @function module:_jsPlatform_function.call\r\n     * @param fn {Function}\r\n     * @param args {...*}\r\n     * @returns {*}\r\n     */\r\n    call = (fn, ...args) => apply(fn, args);\r\n","import {isFunction, isset, isUsableImmutablePrimitive} from './is';\r\nimport {hasOwnProperty} from '../jsPlatform/object';\r\nimport {apply} from '../jsPlatform/function';\r\n\r\n/**\r\n * Creates a value `of` given type;  Checks for one of the following construction strategies (in order listed):\r\n * ```\r\n * // - If exists `(value).constructor.of` uses this.\r\n * // - If value is of one String, Boolean, Symbol, or Number types calls it's\r\n * //      constructor as a function (in cast form;  E.g., `constructor(...args)` )\r\n * // - Else if constructor is a function, thus far, then calls constructor using\r\n * //      the `new` keyword (with any passed in args).\r\n * ```\r\n * @function module:object.of\r\n * @param x {*} - Value to derive returned value's type from.\r\n * @param [args] {...*} - Any args to pass in to matched construction strategy.\r\n * @returns {*|undefined} - New value of given value's type else `undefined`.\r\n */\r\nexport const of = (x, ...args) => {\r\n    if (!isset(x)) { return undefined; }\r\n    const constructor = x.constructor;\r\n    if (hasOwnProperty('of', constructor)) {\r\n        return apply(constructor.of, args);\r\n    }\r\n    else if (isUsableImmutablePrimitive(x)) {\r\n        return apply(constructor, args);\r\n    }\r\n    else if (isFunction(constructor)) {\r\n        return new constructor(...args);\r\n    }\r\n    return undefined;\r\n};\r\n","import {typeOf} from './typeOf';\r\nimport {of} from './of';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Make a copy of a value or optionally copy incoming value onto an outgoing value (second parameter).\r\n     * @note If incoming thing is an immmutable primitive (string, number, symbol, null, undefined, boolean)\r\n     *  it is returned as is.\r\n     * @function module:object.copy\r\n     * @param x {*} - Thing to copy.\r\n     * @param [out = undefined] {*} - Optional value to copy on to.  Not required.\r\n     * @returns {*} - Copied thing or optionally outgoing value copied onto.\r\n     */\r\n    copy = (x, out) => {\r\n        // if `null`, `undefined`, `''`, `0`, `false` return\r\n        if (!x) { return x; }\r\n        switch (typeOf(x)) {\r\n            case Array.name:\r\n                return !out ? x.slice(0) : Object.assign(out, x);\r\n\r\n            // If immutable primitive, return it\r\n            case Symbol.name:\r\n            case Boolean.name:\r\n            case String.name:\r\n            case Number.name:\r\n            case Promise.name:\r\n            case Function.name:\r\n            case 'NaN':\r\n            case 'Null':\r\n            case 'Undefined':\r\n                return x;\r\n\r\n            case 'Map':\r\n            case 'Set':\r\n            case 'WeakMap':\r\n            case 'WeakSet':\r\n                return new x.constructor(Array.from(x));\r\n\r\n            // Else make copy\r\n            default:\r\n                return Object.assign(!out ? of(x) : out, x);\r\n        }\r\n    }\r\n;\r\n\r\nexport default copy;\r\n","import {isset} from './is';\r\nimport {curry} from '../function/curry';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Gives you value at key/namespace-key within `obj`;  E.g.,\r\n     * searchObj('all.your.base', {all: {your: {base: 99}}}) === 99 // `true`\r\n     * @note If key is unreachable (undefined) returns `undefined`.\r\n     *  Useful in cases where we do not want to check each key along the way before getting/checking value;  E.g.,\r\n     * @example\r\n     * ```\r\n     * if (obj && obj.all && obj.all.your && obj.all.your.base) {\r\n     *   // Thing we want to do\r\n     * }\r\n     *\r\n     * // So with our function becomes\r\n     * if (searchObj('all.your.base', obj)) {\r\n     *   // Thing we want to do\r\n     * }\r\n     * ```\r\n     * @function module:object.searchObj\r\n     * @param nsString {String}\r\n     * @param obj {*}\r\n     * @returns {*}\r\n     */\r\n    searchObj = curry((nsString, obj) => {\r\n        if (!obj) { return obj; }\r\n        if (nsString.indexOf('.') === -1) {\r\n            return obj[nsString];\r\n        }\r\n        const parts = nsString.split('.'),\r\n            limit = parts.length;\r\n        let ind = 0,\r\n            parent = obj;\r\n        for (; ind < limit; ind += 1) {\r\n            const node = parent[parts[ind]];\r\n            if (!isset(node)) {\r\n                return node;\r\n            }\r\n            parent = node;\r\n        }\r\n        return parent;\r\n    })\r\n;\r\n","\r\nimport {isObject} from './is';\r\nimport {keys, hasOwnProperty} from '../jsPlatform/object';\r\n\r\nexport const\r\n    /**\r\n     * Merges all objects down into one (takes two or more args).\r\n     * @function module:object.assignDeep\r\n     * @param obj0 {Object}\r\n     * @param [objs] {...{Object}} - One or more objects to merge onto `obj0`.\r\n     * @returns {Object}\r\n     */\r\n    assignDeep = (obj0, ...objs) =>\r\n        !obj0 ? obj0 : objs.reduce((topAgg, obj) =>\r\n            !obj ? topAgg : keys(obj).reduce((agg, key) => {\r\n                let propDescription = Object.getOwnPropertyDescriptor(agg, key);\r\n                // If property is not writable move to next item in collection\r\n                if (hasOwnProperty(key, agg) && propDescription &&\r\n                    !(propDescription.get && propDescription.set) &&\r\n                    !propDescription.writable) {\r\n                    return agg;\r\n                }\r\n                if (isObject(agg[key]) && isObject(obj[key])) {\r\n                    assignDeep(agg[key], obj[key]);\r\n                }\r\n                else { agg[key] = obj[key]; }\r\n                return agg;\r\n            }, topAgg)\r\n        , obj0);\r\n","/**\r\n *  List operations that overlap (apart from globally overlapping props and functions like `length`)\r\n *      on both strings and arrays.\r\n */\r\n\r\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from '../utils';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Concats/appends all functors onto the end of first functor.\r\n     * Note:  functors passed in after the first one must be of the same type.\r\n     * @function module:_jsPlatform_list.concat\r\n     * @param functor {Array|Object|*}\r\n     * @param ...functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have an `every` method.\r\n     */\r\n    concat = fPureTakesOneOrMore('concat'),\r\n\r\n    /**\r\n     * Same as Array.prototype.slice\r\n     * @function module:_jsPlatform_list.slice\r\n     * @param separator {String|RegExp}\r\n     * @param arr{Array}\r\n     * @returns {Array}\r\n     */\r\n    slice = fPureTakes2('slice'),\r\n\r\n    /**\r\n     * `Array.prototype.includes` or shim.\r\n     * @function module:_jsPlatform_list.includes\r\n     * @param value {*}\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    includes = (() => 'includes' in Array.prototype ?\r\n            fPureTakesOne('includes') :\r\n            (value, xs) => xs.indexOf(value) > -1)(),\r\n\r\n    /**\r\n     * Searches list/list-like for given element `x`.\r\n     * @function module:_jsPlatform_list.indexOf\r\n     * @param x {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like to look in.\r\n     * @returns {Number} - `-1` if element not found else index at which it is found.\r\n     */\r\n    indexOf = fPureTakesOne('indexOf'),\r\n\r\n    /**\r\n     * Last index of (`Array.prototype.lastIndexOf`).\r\n     * @function module:_jsPlatform_list.lastIndexOf\r\n     * @param x {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like to look in.\r\n     * @returns {Number} - `-1` if element not found else index at which it is found.\r\n     */\r\n    lastIndexOf = fPureTakesOne('lastIndexOf')\r\n\r\n;\r\n","/**\r\n * @memberOf function\r\n */\r\n\r\nimport {apply} from '../jsPlatform/function';\r\nimport {curry} from './curry';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Negates a function that takes one/no argument.\r\n     * @function module:function.negateF\r\n     * @param fn {Function}\r\n     * @returns {function(*=): boolean}\r\n     */\r\n    negateF = fn => x => !fn(x),\r\n\r\n    /**\r\n     * Takes a function that takes two parameters and returns a negated version of given\r\n     * function.\r\n     * @function module:_negate.negateF2\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateF2 = fn => curry((a, b) => !fn(a, b)),\r\n\r\n    /**\r\n     * Takes a function that takes three parameters and returns a\r\n     * negated version of given function.\r\n     * @function module:_negate.negateF3\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateF3 = fn => curry((a, b, c) => !fn(a, b, c)),\r\n\r\n    /**\r\n     * Returns a negated version of given function.\r\n     * Returned function is variadiac (takes one or more arguments).\r\n     * @note function returned is uncurried.\r\n     * @uncurried\r\n     * @function module:function.negateFN\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateFN = fn => (...args) => !apply(fn, args);\r\n","/**\r\n * @module boolean\r\n * @description Contains functional version of 'always-true', 'always-false', 'is-truthy', and 'is-falsy'.\r\n */\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns whether `value` is 'truthy' or not\r\n     * @function module:boolean.isTruthy\r\n     * @param value\r\n     * @returns {Boolean}\r\n     */\r\n    isTruthy = value => !!value,\r\n\r\n    /**\r\n     * Returns whether `value` is 'falsy' or not\r\n     * @function module:boolean.isFalsy\r\n     * @param value\r\n     * @returns {Boolean}\r\n     */\r\n    isFalsy = value => !value,\r\n\r\n    /**\r\n     * Returns `true`.\r\n     * @function module:boolean.alwaysTrue\r\n     * @returns {Boolean}\r\n     */\r\n    alwaysTrue = () => true,\r\n\r\n    /**\r\n     * Returns `false`.\r\n     * @function module:boolean.alwaysFalse\r\n     * @returns {Boolean}\r\n     */\r\n    alwaysFalse = () => false;\r\n","import {length} from '../jsPlatform/object';\r\nimport {curry} from '../function/curry';\r\n\r\n/**\r\n * @function module:list.map\r\n * @param fn {Function} - Function to map on array.\r\n * @param xs {Array}\r\n * @returns {Array}\r\n */\r\nconst map = curry((fn, xs) =>  {\r\n    let ind = 0,\r\n        limit = length(xs),\r\n        out = [];\r\n    if (!limit) { return out; }\r\n    while (ind < limit) {\r\n        out.push(fn(xs[ind], ind, xs));\r\n        ind += 1;\r\n    }\r\n    return out;\r\n});\r\n\r\nexport default map;\r\n","\r\nexport const\r\n\r\n    /**\r\n     * Pushes incoming `item` onto array (`agg`) and return array (`agg`).\r\n     * @private\r\n     * @param agg {Array}\r\n     * @param item {*}\r\n     * @returns {Array}\r\n     */\r\n    aggregateArr$ = (agg, item) => {\r\n        agg.push(item);\r\n        return agg;\r\n    }\r\n\r\n;\r\n","/**\r\n * List operator utils module.\r\n * @module _listOpUtils\r\n * @private\r\n */\r\nimport {apply}          from '../jsPlatform/function';  // un-curried version\r\nimport {slice}          from '../jsPlatform/list';      // un-curried version good for both strings and arrays\r\nimport {length}         from '../jsPlatform/object';\r\nimport {alwaysFalse}    from '../boolean';\r\nimport map              from './map';\r\nimport {curry}          from '../function/curry';\r\n\r\nexport * from './aggregation';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns a slice of the given list from `startInd` to the end of the list.\r\n     * @function module:listUtils.sliceFrom\r\n     * @param startInd {Number}\r\n     * @param arr {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    sliceFrom = curry((startInd, arr) => slice(startInd, undefined, arr)),\r\n\r\n    /**\r\n     * Slices from index `0` to given index.\r\n     * @function module:listUtils.sliceTo\r\n     * @param toInd {Number}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    sliceTo = curry((toInd, xs) => slice(0, toInd, xs)),\r\n\r\n    /**\r\n     * Slices a copy of list.\r\n     * @function _listOpUtils.sliceCopy\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    sliceCopy = sliceFrom(0),\r\n\r\n    /**\r\n     * Generic 'ascending order' ordering function (use by the likes of `list.sort` etc.)\r\n     * @function module:listUtils.genericAscOrdering\r\n     * @param a {*}\r\n     * @param b {*}\r\n     * @returns {number}\r\n     */\r\n    genericAscOrdering = curry((a, b) => {\r\n        if (a > b) { return 1; }\r\n        else if (a < b) { return -1; }\r\n        return 0;\r\n    }),\r\n\r\n    /**\r\n     * Returns length of all passed lists in list.\r\n     * @function module:listUtils.lengths\r\n     * @param lists ...{Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    lengths = (...lists) => length(lists) ? map(length, lists) : [],\r\n\r\n    /**\r\n     * @function module:listUtils.lengthsToSmallest\r\n     * @param lists {...(Array|String|*)}\r\n     * @returns {Array|String|*}\r\n     */\r\n    lengthsToSmallest = (...lists) => {\r\n        const listLengths = apply(lengths, lists),\r\n            smallLen = Math.min.apply(Math, listLengths);\r\n        return map((list, ind) => listLengths[ind] > smallLen ?\r\n            sliceTo(smallLen, list) : sliceCopy(list), lists);\r\n    },\r\n\r\n    /**\r\n     * Reduces until predicate.\r\n     * @param pred\r\n     * @param op\r\n     * @param agg\r\n     * @param arr\r\n     * @returns {*}\r\n     */\r\n    reduceUntil = curry((pred, op, agg, arr) => {\r\n        const limit = length(arr);\r\n        if (!limit) { return agg; }\r\n        let ind = 0,\r\n            result = agg;\r\n        for (; ind < limit; ind++) {\r\n            if (pred(arr[ind], ind, arr)) { break; }\r\n            result = op(result, arr[ind], ind, arr);\r\n        }\r\n        return result;\r\n    }),\r\n\r\n    /**\r\n     * Reduces until predicate (from the right).\r\n     * @param pred\r\n     * @param op\r\n     * @param agg\r\n     * @param arr\r\n     * @returns {*}\r\n     */\r\n    reduceRightUntil = curry((pred, op, agg, arr) => {\r\n        const limit = length(arr);\r\n        if (!limit) { return agg; }\r\n        let ind = limit - 1,\r\n            result = agg;\r\n        for (; ind >= 0; ind--) {\r\n            if (pred(arr[ind], ind, arr)) { break; }\r\n            result = op(result, arr[ind], ind, arr);\r\n        }\r\n        return result;\r\n    }),\r\n\r\n    reduce = reduceUntil(alwaysFalse),\r\n\r\n    reduceRight = reduceRightUntil(alwaysFalse),\r\n\r\n    /**\r\n     * Gets last index of a list/list-like (Array|String|Function etc.).\r\n     * @function module:listOpUtilslastIndex\r\n     * @param x {Array|String|*} - list like or list.\r\n     * @returns {Number} - `-1` if no element found.\r\n     */\r\n    lastIndex = x => { const len = length(x); return len ? len - 1 : 0; },\r\n\r\n    /**\r\n     * Finds index in string or list.\r\n     * @function module:listOpUtilsfindIndexWhere\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    findIndexWhere = curry((pred, arr) => {\r\n        let ind = -1,\r\n            predicateFulfilled = false;\r\n        const limit = length(arr);\r\n        while (ind < limit && !predicateFulfilled) {\r\n            predicateFulfilled = pred(arr[++ind], ind, arr);\r\n        }\r\n        return ind;\r\n    }),\r\n\r\n    /**\r\n     * Finds index in list from right to left.\r\n     * @function module:listOpUtilsfindIndexWhereRight\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    findIndexWhereRight = curry((pred, arr) => {\r\n        const limit = length(arr);\r\n        let ind = limit,\r\n            predicateFulfilled = false;\r\n        for (; ind >= 0 && !predicateFulfilled; --ind) {\r\n            predicateFulfilled = pred(arr[ind], ind, arr);\r\n        }\r\n        return ind;\r\n    }),\r\n\r\n    /**\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {Array|undefined}\r\n     */\r\n    findIndicesWhere = curry((pred, xs) => {\r\n        if (!xs || !xs.length) { return undefined; }\r\n        const limit = length(xs);\r\n        let ind = 0,\r\n            out = [];\r\n        for (; ind < limit; ind++) {\r\n            if (pred(xs[ind], ind, xs)) { out.push(ind); }\r\n        }\r\n        return out.length ? out : undefined;\r\n    }),\r\n\r\n    /**\r\n     * @function module:listOpUtilsfind\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    findWhere = curry((pred, xs) => {\r\n        let ind = 0,\r\n            limit = length(xs);\r\n        if (!limit) { return; }\r\n        for (; ind < limit; ind++) {\r\n            let elm = xs[ind];\r\n            if (pred(elm, ind, xs)) { return elm; }\r\n        }\r\n    })\r\n\r\n;\r\n","/**\r\n * @module object\r\n */\r\nimport {curry} from '../function/curry';\r\n\r\n/**\r\n * Normalizes step for `from` and `to` combination.\r\n * @function module:list.normalizeStep\r\n * @param from {Number}\r\n * @param to {Number}\r\n * @param [step = 1] {Number}\r\n * @returns {Number}\r\n * @private\r\n */\r\nconst normalizeStep = (from, to, step) => {\r\n    if (from > to) {\r\n        return step > 0 ? -step : step; // make step negative\r\n    }\r\n    return step < 0 ? -1 * step : step; // make step positive\r\n};\r\n\r\nexport const\r\n\r\n    /**\r\n     * @note normalizes `step` to be of valid\r\n     *  direction (negative if range required is in the negative direction\r\n     *  and positive otherwise).\r\n     * @function module:list.range\r\n     * @param from {Number}\r\n     * @param to {Number}\r\n     * @param [step = 1] {Number}\r\n     * @returns {Array.<Number>}\r\n     */\r\n    range = curry((from, to, step = 1) => {\r\n        let i = from;\r\n        const out = [];\r\n        step = normalizeStep(from, to, step);\r\n        if (step === 0 || from === to) { return [from]; }\r\n        for (; (to - i) * step >= 0; i += step) { out.push(i); }\r\n        return out;\r\n    })\r\n;\r\n","/**\r\n * Created by elyde on 7/20/2017.\r\n * Functional versions of common array methods (`map`, `filter`, etc.) (un-curried);\r\n * @module _jsPlatform_arrayOps\r\n * @private\r\n * @todo updated doc blocks to list correct/updated module name.\r\n */\r\n\r\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from '../utils';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Array.prototype.reverse generator (generates a function that calls the prototype version or a\r\n     * shimmed version if it doesn't exist).\r\n     * @returns {Function}\r\n     */\r\n    defineReverse = () =>\r\n        Array.prototype.reverse ? x => x.reverse() :\r\n            x => x.reduceRight((agg, item) => {\r\n                agg.push(item);\r\n                return agg;\r\n            }, []),\r\n\r\n    /**\r\n     * Maps a function to functor (list etc.).\r\n     * @function module:_jsPlatform_array.map\r\n     * @param fn {Function}\r\n     * @param functor {Array|{map: {Function}}}\r\n     * @returns {Array|{map: {Function}}}\r\n     */\r\n    map = fPureTakesOne('map'),\r\n\r\n    /**\r\n     * Filters a functor (list etc.) with passed in function.\r\n     * @function module:_jsPlatform_array.filter\r\n     * @param fn {Function}\r\n     * @param functor {Array|{filter: {Function}}}\r\n     * @returns {Array|{filter: {Function}}}\r\n     */\r\n    filter = fPureTakesOne('filter'),\r\n\r\n    /**\r\n     * Reduces a foldable (list etc.) with passed in function.\r\n     * @function module:_jsPlatform_array.reduce\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduce: {Function}}}\r\n     * @returns {Array|{reduce: {Function}}}\r\n     */\r\n    reduce = fPureTakes2('reduce'),\r\n\r\n    /**\r\n     * Reduces a foldable (list etc.) from the right with passed in function.\r\n     * @function module:_jsPlatform_array.reduceRight\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduceRight: {Function}}}\r\n     * @returns {Array|{reduceRight: {Function}}}\r\n     */\r\n    reduceRight = fPureTakes2('reduceRight'),\r\n\r\n    /**\r\n     * For each on functor (Array|Object|etc.).\r\n     * @param fn {Function}\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type of object you pass in unless it doesn't have a `forEach` method.\r\n     * @throws {Error} - When passed in functor doesn't have a `forEach` method.\r\n     */\r\n    forEach = fPureTakesOne('forEach'),\r\n\r\n    /**\r\n     * Returns `true` if `fn` (predicate) returns true for at least one item\r\n     * in functor else returns `false`.\r\n     * @param fn {Function} - Predicate.\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have a `some` method.\r\n     */\r\n    some = fPureTakesOne('some'),\r\n\r\n    /**\r\n     * Returns `true` if `fn` (predicate) returns true for all items in functor else returns `false`.\r\n     * @param fn {Function} - Predicate.\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have an `every` method.\r\n     */\r\n    every = fPureTakesOne('every'),\r\n\r\n    /**\r\n     * Array.prototype.join\r\n     * @function module:listPrelude.join\r\n     * @param separator {String|RegExp}\r\n     * @param arr {Array}\r\n     * @returns {String}\r\n     */\r\n    join = fPureTakesOne('join'),\r\n\r\n    /**\r\n     * Same as Array.prototype.push\r\n     * @param item {*}\r\n     * @param arr {Array}\r\n     * @returns {Number}\r\n     */\r\n    push = fPureTakesOneOrMore('push'),\r\n\r\n    /**\r\n     * Reverses an list (shimmed if not exists).\r\n     * @function module:listPrelude.reverse\r\n     * @return {Array}\r\n     */\r\n    reverse = defineReverse();\r\n","/**\r\n * Created by elydelacruz on 9/6/2017.\r\n */\r\n\r\nimport {fPureTakesOne} from '../utils';\r\n\r\n/**\r\n * Functional version of `String.prototype.split`.\r\n * @function module:_string.split\r\n * @param separator {String|RegExp}\r\n * @param str {String}\r\n * @returns {Array}\r\n */\r\nexport const split = fPureTakesOne('split');\r\n","/**\r\n * @module jsPlatform_\r\n * @private\r\n */\r\nexport * from './jsPlatform/object';\r\nexport * from './jsPlatform/array';\r\nexport * from './jsPlatform/list';\r\nexport * from './jsPlatform/string';\r\nexport * from './jsPlatform/function';\r\n","/**\r\n * List operations module.\r\n * @module list\r\n */\r\nimport {concat as listAppend, indexOf, slice, includes} from './jsPlatform/list';\r\nimport {apply}              from './jsPlatform/function';\r\nimport {negateF3, negateF2}   from './function/negate';\r\nimport {isTruthy, isFalsy}  from './boolean';\r\nimport {lookup, length}       from './object';\r\nimport map                  from './list/map';\r\nimport {curry} from './function/curry';\r\n\r\nimport {\r\n    sliceFrom, sliceTo, lengths,\r\n    lengthsToSmallest, aggregateArr$,\r\n    reduceUntil, reduce, reduceRight, lastIndex,\r\n    findIndexWhere, findIndexWhereRight, findIndicesWhere,\r\n    findWhere, sliceCopy, genericAscOrdering\r\n}\r\n    from './list/utils';\r\nimport {fPureTakesOne, fPureTakesOneOrMore} from './utils';\r\n\r\nexport * from './list/range';\r\n\r\nexport {map};\r\n\r\nexport {slice, includes, indexOf, lastIndexOf, push} from './jsPlatform';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Append two, or more, lists, i.e.,\r\n     * @example\r\n     * expectEqual(append(take(13, alphabetString), drop(13, alphabetString)), alphabetString); // true\r\n     *\r\n     * // Another example\r\n     * const result = append(\r\n     *   alphabetStr.split(''),\r\n     *   alphabetStr.split('')\r\n     * ),\r\n     * expected = repeat(2, alphabetStr).split('');\r\n     *\r\n     * shallowEquals(result, expected) === true // `true`\r\n     *\r\n     * @function module:list.append\r\n     * @param [args] {...(Array|String|*)} - One or more lists or list likes (strings etc.).\r\n     * @returns {(Array|String|*)} - Same type as list like passed in.\r\n     */\r\n    append = (...args) => {\r\n        const len = length(args);\r\n        if (!len) { return []; }\r\n        else if (len === 1) { return sliceCopy(args[0]); }\r\n        if (len >= 2) { return apply(listAppend, args); }\r\n        throw new Error(`'\\`append\\` requires at 2 or more arguments.  ${length(args)} args given.`);\r\n    },\r\n\r\n    /**\r\n     * Returns head of list (first item of list).\r\n     * @haskellType `head :: [a] -> a`\r\n     * @function module:list.head\r\n     * @param x {Array|String}\r\n     * @returns {*} - First item from list\r\n     */\r\n    head = x => x[0],\r\n\r\n    /**\r\n     * Returns last item of list.\r\n     * @haskellType `last :: [a] -> a`\r\n     * @function module:list.last\r\n     * @param xs {Array|String}\r\n     * @returns {*}\r\n     */\r\n    last = xs => xs[lastIndex(xs)],\r\n\r\n    /**\r\n     * Returns tail part of list (everything after the first item as new list).\r\n     * @haskelType `tail :: [a] -> [a]`\r\n     * @function module:list.tail\r\n     * @param xs {Array}\r\n     * @returns {Array}\r\n     */\r\n    tail = xs => sliceFrom(1, xs),\r\n\r\n    /**\r\n     * Returns everything except last item of list as new list.\r\n     * @haskellType `init :: [a] -> [a]`\r\n     * @function module:list.init\r\n     * @param xs {Array|String}\r\n     * @returns {Array|String}\r\n     */\r\n    init = xs => sliceTo(lastIndex(xs), xs),\r\n\r\n    /**\r\n     * Returns `head` and `tail` of passed in list/string in a tuple.\r\n     * @haskellType `uncons :: [a] -> Maybe (a, [a])`\r\n     * @function module:list.uncons\r\n     * @param xs {Array|String}\r\n     * @returns {Array|undefined}\r\n     */\r\n    uncons = xs =>\r\n        !xs || length(xs) === 0 ? undefined : [head(xs), tail(xs)],\r\n\r\n    /**\r\n     * Returns `tail` and `head` of passed in list/string in a tuple.\r\n     * @haskellType `unconsr :: [a] -> Maybe ([a], a)`\r\n     * @function module:list.unconsr\r\n     * @param xs {Array|String}\r\n     * @returns {Array|String|*|undefined}\r\n     */\r\n    unconsr = xs => !xs || length(xs) === 0 ? undefined : [init(xs), last(xs)],\r\n\r\n    /**\r\n     * Concatenates all the elements of a container of lists.\r\n     * @haskellType `concat :: Foldable t => t [a] -> [a]`\r\n     * @function module:list.concat\r\n     * @param xs {Array}\r\n     * @returns {Array}\r\n     */\r\n    concat = xs => !length(xs) ? sliceCopy(xs) : apply(append, xs),\r\n\r\n    /**\r\n     * Map a function over all the elements of a container and concatenate the resulting lists.\r\n     * @haskellType `concatMap :: Foldable t => (a -> [b]) -> t a -> [b]`\r\n     * @function module:list.concatMap\r\n     * @param fn {Function}\r\n     * @param foldableOfA {Array}\r\n     * @returns {Array}\r\n     */\r\n    concatMap = curry((fn, foldableOfA) => concat(map(fn, foldableOfA))),\r\n\r\n    /**\r\n     * Returns a copy of the passed in list reverses.\r\n     * @haskellType `reverse :: [a] -> [a]`\r\n     * @function module:list.reverse\r\n     * @param x {Array}\r\n     * @returns {Array}\r\n     */\r\n    reverse = x => foldr((agg, item) => (agg.push(item), agg), [], x),\r\n\r\n    /**\r\n     * Takes an element and a list and `intersperses' that element between the elements of the list. For example\r\n     * @function module:list.intersperse\r\n     * @note In our version of the function javascript is loosely typed so, so is our function (to much overhead to make\r\n     *  it typed) so `between` can be any value.\r\n     * @param between {*} - Should be of the same type of elements contained in list.\r\n     * @param arr {Array} - List.\r\n     * @returns {Array}\r\n     */\r\n    intersperse = curry((between, arr) => {\r\n        const limit = length(arr),\r\n            lastInd = limit - 1,\r\n            out = [];\r\n        if (!limit) {\r\n            return out;\r\n        }\r\n        return foldl((agg, item, ind) => (\r\n                ind === lastInd ?\r\n                    agg.push(item) :\r\n                    agg.push(item, between),\r\n                agg\r\n            ), out, arr);\r\n    }),\r\n\r\n    /**\r\n     * `intercalate xs xss` is equivalent to (concat (intersperse xs xss)). It inserts the list xs in between the lists in xss and concatenates the result.\r\n     * @haskellType `intercalate :: [a] -> [[a]] -> [a]`\r\n     * @function module:list.intercalate\r\n     * @param xs {Array}\r\n     * @param xss {Array}\r\n     * @returns {Array}\r\n     */\r\n    intercalate = curry((xs, xss) => concat(intersperse(xs, xss))),\r\n\r\n    /**\r\n     * Transposes rows and columns into lists by index;  E.g.,\r\n     * Haskell example:\r\n     * ```\r\n     *  transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]\r\n     *\r\n     *  -- Notice the shorter arrays are ignored after their last index is copied over:\r\n     *  transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]\r\n     * ```\r\n     * @note from columns to rows.\r\n     * @note Empty lists are ignored.\r\n     * @todo upgrade this function to support lists of strings.\r\n     * @haskellType `transpose :: [[a]] -> [[a]]`\r\n     * @function module:list.transpose\r\n     * @param xss {Array}\r\n     * @returns {Array}\r\n     */\r\n    transpose = xss => {\r\n        let numLists = length(xss),\r\n            ind = 0, ind2;\r\n        if (!numLists) {\r\n            return [];\r\n        }\r\n        const listLengths = apply(lengths, xss),\r\n            longestListLen = maximum(listLengths),\r\n            outLists = [];\r\n        for (; ind < longestListLen; ind += 1) {\r\n            const outList = [];\r\n            for (ind2 = 0; ind2 < numLists; ind2 += 1) {\r\n                if (listLengths[ind2] < ind + 1) {\r\n                    continue;\r\n                }\r\n                outList.push(xss[ind2][ind]);\r\n            }\r\n            outLists.push(outList);\r\n        }\r\n        return filter(x => length(x), outLists);\r\n    },\r\n\r\n    /**\r\n     * Generates 2^n sub-sequences for passed in sequence (string/list) (`n` is\r\n     * the length of the passed in sequence so: 2^length(xs)).\r\n     * Note: The return value doubles per index/character passed in so use with caution!\r\n     *  Also note that for 2^16 (or for a sequence of 16 characters) this algorithm\r\n     *  will generate 65536 sub-sequences!  So caution should be taken to not\r\n     *  use this with sequences above a certain length on certain platform (the browser thread in specific).\r\n     * @function module:list.subsequences\r\n     * @jsperftest https://jsperf.com/subsequences\r\n     * @param xs {Array|String}\r\n     * @returns {Array.<Array>}\r\n     */\r\n    subsequences = xs => {\r\n        const listLen = length(xs),\r\n            len = Math.pow(2, listLen),\r\n            out = [];\r\n        for (let i = 0; i < len; i += 1) {\r\n            let entry = [];\r\n            for (let j = 0; j < listLen; j += 1) {\r\n                if (i & (1 << j)) {\r\n                    entry.push(xs[j]);\r\n                }\r\n            }\r\n            out.push(entry);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Returns an array with the given indices swapped.\r\n     * @function module:list.swapped\r\n     * @param ind1 {Number}\r\n     * @param ind2 {Number}\r\n     * @param list {Array}\r\n     * @returns {Array} - Copy of incoming with swapped values at indices.\r\n     */\r\n    swapped = curry((ind1, ind2, list) => {\r\n        const out = sliceCopy(list),\r\n            tmp = out[ind1];\r\n        out[ind1] = out[ind2];\r\n        out[ind2] = tmp;\r\n        return out;\r\n    }),\r\n\r\n    /**\r\n     * Returns a list of permutations for passed in list.\r\n     *  Use caution with lists above a length of 15 (will take long due to nature of\r\n     *  algorithm).\r\n     * @function module:list.permutations\r\n     * @param xs {Array} - List.\r\n     * @returns {Array<Array|String|*>} - Array of permutations.\r\n     */\r\n    permutations = xs => {\r\n        const limit = length(xs);\r\n\r\n        if (!limit || limit === 1) {\r\n            return [xs];\r\n        }\r\n\r\n        let list = sliceCopy(xs),\r\n            c = repeat(limit, 0),\r\n            i = 0;\r\n\r\n        const out = [list];\r\n\r\n        for (; i < limit; i++) {\r\n            if (c[i] < i) {\r\n                list = swapped(i % 2 === 0 ? 0 : c[i], i, list);\r\n                out.push(list);\r\n                c[i] += 1;\r\n                i = 0;\r\n                continue;\r\n            }\r\n            c[i] = 0;\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Left associative fold.  Reduces a container of elements down by the given operation (same as [].reduce).\r\n     * @function module:list.foldl\r\n     * @param fn {Function}\r\n     * @param zero {*} - Aggregator.\r\n     * @param functor {Array}\r\n     * @returns {*} - Whatever type is lastly returned from `fn`.\r\n     */\r\n    foldl = reduce,\r\n\r\n    /**\r\n     * Right associative fold.  Reduces a container of elements down by the given operation (same as [].reduceRight).\r\n     * @function module:list.foldr\r\n     * @param fn {Function}\r\n     * @param zero {*} - Aggregator.\r\n     * @param functor {Array}\r\n     * @returns {*} - Whatever type is lastly returned from `fn`.\r\n     */\r\n    foldr = reduceRight,\r\n\r\n    /**\r\n     * A variant of `foldl` except that this one doesn't require the starting point.  The starting point/value will be pulled\r\n     * out from a copy of the container.\r\n     * @function module:list.foldl1\r\n     * @param op {Function}\r\n     * @param xs {Array}\r\n     * @returns {*} - Whatever type is lastly returned from `op`.\r\n     */\r\n    foldl1 = curry((op, xs) => {\r\n        const parts = uncons(xs);\r\n        return !parts ? [] : reduce(op, parts[0], parts[1]);\r\n    }),\r\n\r\n    /**\r\n     * A variant of `foldr` except that this one doesn't require the starting point/value.  The starting point/value will be pulled\r\n     * out from a copy of the container.\r\n     * @function module:list.foldr1\r\n     * @param op {Function}\r\n     * @param xs {Array}\r\n     * @returns {*} - Whatever type is lastly returned from `op`.\r\n     */\r\n    foldr1 = curry((op, xs) => {\r\n        const parts = unconsr(xs);\r\n        return !parts ? [] : reduceRight(op, parts[1], parts[0]);\r\n    }),\r\n\r\n    /**\r\n     * Performs a map then a reduce all in one (from left-to-right). Returns a tuple\r\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\r\n     * @function module:list.mapAccumL\r\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\r\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\r\n     * @param xs {Array} - list type.\r\n     * @return {Array} - [aggregated, list]\r\n     */\r\n    mapAccumL = curry((op, zero, xs) => {\r\n        const list = sliceCopy(xs),\r\n            limit = length(xs);\r\n        if (!limit) {\r\n            return [zero, list];\r\n        }\r\n        let ind = 0,\r\n            agg = zero,\r\n            mapped = [],\r\n            tuple;\r\n        for (; ind < limit; ind++) {\r\n            tuple = op(agg, list[ind], ind);\r\n            agg = tuple[0];\r\n            mapped = tuple[1];\r\n        }\r\n        return [agg, mapped];\r\n    }),\r\n\r\n    /**\r\n     * Performs a map and a reduce all in one (from right-to-left). Returns a tuple\r\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\r\n     * @function module:list.mapAccumR\r\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\r\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\r\n     * @param xs {Array} - list type.\r\n     * @return {Array} - [aggregated, list]\r\n     */\r\n    mapAccumR = curry((op, zero, xs) => {\r\n        const list = sliceCopy(xs),\r\n            limit = length(xs);\r\n        if (!limit) {\r\n            return [zero, list];\r\n        }\r\n        let ind = limit - 1,\r\n            agg = zero,\r\n            mapped = [],\r\n            tuple;\r\n        for (; ind >= 0; ind--) {\r\n            tuple = op(agg, list[ind], ind);\r\n            agg = tuple[0];\r\n            mapped = tuple[1];\r\n        }\r\n        return [agg, mapped];\r\n    }),\r\n\r\n    /**\r\n     * iterate f x returns an infinite list of repeated applications of f to x.\r\n     * @function module:list.iterate\r\n     * @example `iterate(5, f, x) == [x, f(x), f(f(x)), ...]`\r\n     * @param limit {Number}\r\n     * @param op {Function} - Operation.\r\n     * @param x {*} - Starting point.\r\n     * @returns {*}\r\n     */\r\n    iterate = curry((limit, op, x) => {\r\n        let ind = 0,\r\n            out = [],\r\n            lastX = x;\r\n        for (; ind < limit; ind += 1) {\r\n            out.push(lastX);\r\n            lastX = op(lastX, ind);\r\n        }\r\n        return out;\r\n    }),\r\n\r\n    /**\r\n     * Repeats `x` `limit` number of times.\r\n     * @function module:list.repeat\r\n     * @param limit {Number}\r\n     * @param x {*}\r\n     * @return {Array}\r\n     */\r\n    repeat = curry((limit, x) => iterate(limit, a => a, x)),\r\n\r\n    /**\r\n     * Same as `repeat` due to the nature of javascript (see haskell version for usage).\r\n     * @function module:list.replicate\r\n     * @param limit {Number}\r\n     * @param x {*}\r\n     * @return {Array}\r\n     */\r\n    replicate = repeat,\r\n\r\n    /**\r\n     * Replicates a list `limit` number of times and appends the results (concat)\r\n     * @function module:list.cycle\r\n     * @param limit {Number}\r\n     * @param xs {Array}\r\n     * @returns {Array}\r\n     */\r\n    cycle = curry((limit, xs) => concat(replicate(limit, xs))),\r\n\r\n    /**\r\n     * Unfolds a value into a list of somethings.\r\n     * @haskellType `unfoldr :: (b -> Maybe (a, b)) -> b -> [a]`\r\n     * @function module:list.unfoldr\r\n     * @param op {Function} - Operation to perform (should return a two component tuple (item to aggregate and item to unfold in next iteration).\r\n     * @param x {*} - Starting parameter to unfold from.\r\n     * @returns {Array} - An array of whatever you return from `op` yielded.\r\n     */\r\n    unfoldr = curry((op, x) => {\r\n        let ind = 0,\r\n            out = [],\r\n            resultTuple = op(x, ind, out);\r\n        while (resultTuple) {\r\n            out.push(resultTuple[0]);\r\n            resultTuple = op(resultTuple[1], ++ind, out);\r\n        }\r\n        return out;\r\n    }),\r\n\r\n    /**\r\n     * Finds index in string or list (alias for `findIndex`).\r\n     * @function module:list.findIndex\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    findIndex = findIndexWhere,\r\n\r\n    /**\r\n     * @function module:list.findIndices\r\n     * @param pred {Function}\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {Array|undefined}\r\n     */\r\n    findIndices = findIndicesWhere,\r\n\r\n    /**\r\n     * @function module:list.elemIndex\r\n     * @param x {*} - Element to search for.\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    elemIndex = curry((x, xs) => {\r\n        const foundInd = indexOf(x, xs);\r\n        return foundInd !== -1 ? foundInd : undefined;\r\n    }),\r\n\r\n    /**\r\n     * @function module:list.elemIndices\r\n     * @param value {*} - Element to search for.\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    elemIndices = curry((value, xs) => findIndices(x => x === value, xs)),\r\n\r\n    /**\r\n     * Takes `n` items from start of list to `limit` (exclusive).\r\n     * @function module:list.take\r\n     * @param list {Array|String}\r\n     * @param limit {Number}\r\n     * @returns {String|Array} - Passed in type's type\r\n     */\r\n    take = sliceTo,\r\n\r\n    /**\r\n     * Drops `n` items from start of list to `count` (exclusive).\r\n     * @function module:list.drop\r\n     * @param list {Array|String}\r\n     * @param count {Number}\r\n     * @returns {String|Array} - Passed in type's type\r\n     */\r\n    drop = sliceFrom,\r\n\r\n    /**\r\n     * Splits `x` in two at given `index` (exclusive (includes element/character at\r\n     * given index in second part of returned list)).\r\n     * @function module:list.splitAt\r\n     * @param ind {Number} - Index to split at.\r\n     * @param list {Array|String} - functor (list or string) to split.\r\n     * @returns {Array|String} - List like type passed\r\n     */\r\n    splitAt = (ind, list) => [ sliceTo(ind, list), sliceFrom(ind, list) ],\r\n\r\n    /**\r\n     * Gives an list with passed elements while predicate was true.\r\n     * @function module:list.takeWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @returns {Array}\r\n     */\r\n    takeWhile = curry((pred, list) =>\r\n        reduceUntil(\r\n            negateF3(pred),  // predicate\r\n            aggregateArr$,   // operation\r\n            [],             // aggregator\r\n            list\r\n        )),\r\n\r\n    /**\r\n     * Returns an list without elements that match predicate.\r\n     * @function module:list.dropWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @refactor\r\n     * @returns {Array|String}\r\n     */\r\n    dropWhile = curry((pred, list) => {\r\n        const limit = length(list),\r\n            splitPoint =\r\n                findIndexWhere((item, ind, list2) =>\r\n                    !pred(list[ind], ind, list2), list);\r\n\r\n        return splitPoint === -1 ?\r\n            sliceTo(limit, list) :\r\n            slice(splitPoint, limit, list);\r\n    }),\r\n\r\n    /**\r\n     * @function module:list.dropWhileEnd\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @refactor\r\n     * @returns {Array|String}\r\n     */\r\n    dropWhileEnd = curry((pred, list) => {\r\n        const limit = length(list),\r\n            splitPoint =\r\n                findIndexWhereRight((item, ind, list2) =>\r\n                    !pred(list[ind], ind, list2), list);\r\n\r\n        return splitPoint === -1 ?\r\n            sliceTo(limit, list) :\r\n            sliceTo(splitPoint + 1, list);\r\n    }),\r\n\r\n    /**\r\n     * Gives a span such that the first list (in returned tuple) is the span of items matching upto `not predicate` and\r\n     * the second list in the tuple is a list of the remaining elements in the given list.\r\n     * **@Note: Not the same as `partition`.  Read descriptions closely!!!\r\n     * @function module:list.span\r\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\r\n     * @param list {Array} - Predicate<item, index, originalArrayOrString>\r\n     * @returns {Array} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\r\n     */\r\n    span = curry((pred, list) => {\r\n        const splitPoint = findIndexWhere(negateF3(pred), list);\r\n        return splitPoint === -1 ?\r\n            splitAt(0, list) : splitAt(splitPoint, list);\r\n    }),\r\n\r\n    /**\r\n     * breakOnList, applied to a predicate p and a list xs, returns a tuple\r\n     * where first element is longest prefix (possibly empty) of xs of elements\r\n     * that do not satisfy p and second element is the remainder of the list:\r\n     * @haskellExample\r\n     * Replace `break` with `breakOnList` for our version.\r\n     * ```\r\n     * break (> 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])\r\n     * break (< 9) [1,2,3] == ([],[1,2,3])\r\n     * break (> 9) [1,2,3] == ([1,2,3],[])\r\n     * ```\r\n     * @function module:list.breakOnList\r\n     * @param pred {Function}\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    breakOnList = curry((pred, list) => {\r\n        const splitPoint = findIndexWhere(pred, list);\r\n        return splitPoint === -1 ?\r\n            splitAt(0, list) : splitAt(splitPoint, list);\r\n    }),\r\n\r\n    /**\r\n     * Gets item at index.\r\n     * @function module:list.at\r\n     * @param ind {Number} - Index.\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {*|undefined} - Item or `undefined`.\r\n     */\r\n    at = lookup,\r\n\r\n    /**\r\n     * Find an item in structure of elements based on given predicate (`pred`).\r\n     * @function module:list.find\r\n     * @param pred {Function}\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {*} - Found item.\r\n     */\r\n    find = findWhere,\r\n\r\n    /**\r\n     * Filters a structure of elements using given predicate (`pred`) (same as `[].filter`).\r\n     * @function module:list.filter\r\n     * @param pred {Function}\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {Array} - Structure of filtered elements.\r\n     */\r\n    filter = curry((pred, xs) => {\r\n        let ind = 0,\r\n            limit = length(xs),\r\n            out = [];\r\n        if (!limit) {\r\n            return out;\r\n        }\r\n        for (; ind < limit; ind++) {\r\n            if (pred(xs[ind], ind, xs)) {\r\n                out.push(xs[ind]);\r\n            }\r\n        }\r\n        return out;\r\n    }),\r\n\r\n    /**\r\n     * Partitions a list on a predicate;  Items that match predicate are in first list in tuple;  Items that\r\n     * do not match the tuple are in second list in the returned tuple.\r\n     *  Essentially `[filter(p, xs), filter(negateF3(p), xs)]`.\r\n     * @function module:list.partition\r\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\r\n     * @param list {Array}\r\n     * @returns {Array|String} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\r\n     */\r\n    partition = curry((pred, list) =>\r\n        !length(list) ?\r\n            [[], []] :\r\n                [filter(pred, list), filter(negateF3(pred), list)]),\r\n\r\n    /**\r\n     * Returns a boolean indicating whether an element exists in given structure of elements.\r\n     * @function module:list.elem\r\n     * @param element {*}\r\n     * @param xs {Array}\r\n     * @returns {Boolean}\r\n     */\r\n    elem = includes,\r\n\r\n    /**\r\n     * The opposite of `elem` - Returns a boolean indicating whether an element exists in given list.\r\n     * @function module:list.notElem\r\n     * @param element {*}\r\n     * @param xs {Array}\r\n     * @returns {Boolean}\r\n     */\r\n    notElem = negateF2(includes),\r\n\r\n    /**\r\n     * Checks if list `xs1` is a prefix of list `xs2`\r\n     * @function module:list.isPrefixOf\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {boolean}\r\n     */\r\n    isPrefixOf = curry((xs1, xs2) => {\r\n        const limit1 = length(xs1),\r\n            limit2 = length(xs2);\r\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\r\n            return false;\r\n        }\r\n        let ind = 0;\r\n        for (; ind < limit1; ind++) {\r\n            if (xs1[ind] !== xs2[ind]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }),\r\n\r\n    /**\r\n     * Checks if list `xs1` is a suffix of list `xs2`\r\n     * @function module:list.isSuffixOf\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {boolean}\r\n     */\r\n    isSuffixOf = curry((xs1, xs2) => {\r\n        const limit1 = length(xs1),\r\n            limit2 = length(xs2);\r\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\r\n            return false;\r\n        }\r\n        let ind1 = limit1 - 1,\r\n            ind2 = limit2 - 1;\r\n        for (; ind1 >= 0; ind1--) {\r\n            if (xs1[ind1] !== xs2[ind2]) {\r\n                return false;\r\n            }\r\n            ind2 -= 1;\r\n        }\r\n        return true;\r\n    }),\r\n\r\n    /**\r\n     * Checks if list `xs1` is an infix of list `xs2`\r\n     * @function module:list.isInfixOf\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {boolean}\r\n     */\r\n    isInfixOf = curry((xs1, xs2) => {\r\n        const limit1 = length(xs1),\r\n            limit2 = length(xs2);\r\n        if (limit2 < limit1 || !limit1 || !limit2) {\r\n            return false;\r\n        }\r\n        let ind1,\r\n            foundLen,\r\n            ind = 0;\r\n        for (; ind < limit2; ind += 1) {\r\n            foundLen = 0;\r\n            for (ind1 = 0; ind1 < limit1; ind1 += 1) {\r\n                if (xs2[ind1 + ind] === xs1[ind1]) {\r\n                    foundLen += 1;\r\n                }\r\n                if (foundLen === limit1) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }),\r\n\r\n    /**\r\n     * Checks if list `xs1` is a sub-sequence of list `xs2`\r\n     * @function module:list.isSubsequenceOf\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {boolean}\r\n     */\r\n    isSubsequenceOf = curry((xs1, xs2) => {\r\n        const len = Math.pow(2, length(xs2)),\r\n            lenXs1 = length(xs1);\r\n        let foundLen,\r\n            i;\r\n        for (i = 0; i < len; i += 1) {\r\n            foundLen = 0;\r\n            for (let j = 0; j < len; j += 1) {\r\n                if (i & (1 << j) && indexOf(xs2[j], xs1) > -1) {\r\n                    foundLen += 1;\r\n                }\r\n                if (foundLen === lenXs1) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }),\r\n\r\n    /**\r\n     * The group function takes a list and returns a list of lists such that\r\n     *  the concatenation of the result is equal to the argument. Moreover, each\r\n     *  sublist in the result contains only equal elements. For example,\r\n     * `group \"Mississippi\" = [\"M\",\"i\",\"ss\",\"i\",\"ss\",\"i\",\"pp\",\"i\"]`\r\n     * It is a special case of groupBy, which allows the programmer to supply\r\n     *  their own equality test.\r\n     * @haskellType `group :: Eq a => [a] -> [[a]]`\r\n     * @function module:list.group\r\n     * @param xs {Array|String}\r\n     * @returns {Array<Array|String|*>|*}\r\n     */\r\n    group = xs => groupBy((a, b) => a === b, xs),\r\n\r\n    /**\r\n     * Allows you to group items in a list based on your supplied equality check.\r\n     * @note Sames `group` but allows you to specify equality operation.\r\n     * @haskellType `groupBy :: (a -> a -> Bool) -> [a] -> [[a]]`\r\n     * @function module:list.groupBy\r\n     * @param equalityOp {Function}\r\n     * @param xs {Array}\r\n     * @returns {*}\r\n     */\r\n    groupBy = curry((equalityOp, xs) => {\r\n        const limit = length(xs);\r\n        if (!limit) {\r\n            return sliceCopy(xs);\r\n        }\r\n        let ind = 0,\r\n            prevItem,\r\n            item,\r\n            predOp = x => {\r\n                if (equalityOp(x, prevItem)) {\r\n                    ind++;\r\n                }\r\n                if (equalityOp(x, item)) {\r\n                    prevItem = x;\r\n                    return true;\r\n                }\r\n                return false;\r\n            },\r\n            agg = [];\r\n        for (; ind < limit; ind += 1) {\r\n            item = xs[ind];\r\n            agg.push(takeWhile(predOp, slice(ind, limit, xs)));\r\n        }\r\n        return agg;\r\n    }),\r\n\r\n    /**\r\n     * The inits function returns all initial segments of the argument, shortest first. For example,\r\n     * ```\r\n     * shallowEquals(inits('abc'), ['','a','ab','abc'])\r\n     * ```\r\n     * @function module:list.inits\r\n     * @haskellType `inits :: [a] -> [[a]]`\r\n     * @param xs {Array}\r\n     * @returns {Array}\r\n     */\r\n    inits = xs => {\r\n        let limit = length(xs),\r\n            ind = 0,\r\n            agg = [];\r\n        if (!limit) {\r\n            return [];\r\n        }\r\n        for (; ind <= limit; ind += 1) {\r\n            agg.push(sliceTo(ind, xs));\r\n        }\r\n        return agg;\r\n    }, //map(list => init(list), xs),\r\n\r\n    /**\r\n     * The inits function returns all initial segments of the argument, shortest first. For example,\r\n     * ```\r\n     * shallowEquals(tails('abc'), ['abc', 'bc', 'c',''])\r\n     * ```\r\n     * @function module:list.tails\r\n     * @haskellType `tails :: [a] -> [[a]]`\r\n     * @param xs {Array}\r\n     * @returns {Array}\r\n     */\r\n    tails = xs => {\r\n        let limit = length(xs),\r\n            ind = 0,\r\n            agg = [];\r\n        if (!limit) {\r\n            return [];\r\n        }\r\n        for (; ind <= limit; ind += 1) {\r\n            agg.push(slice(ind, limit, xs));\r\n        }\r\n        return agg;\r\n    }, //map(list => tail(list), xs),\r\n\r\n    /**\r\n     * Strips prefix list from given list\r\n     * @function module:list.stripPrefix\r\n     * @param prefix {Array|String|*}\r\n     * @param list {Array|string|*}\r\n     * @returns {Array|*}\r\n     */\r\n    stripPrefix = curry((prefix, list) =>\r\n        isPrefixOf(prefix, list) ?\r\n            splitAt(length(prefix), list)[1] :\r\n            sliceCopy(list)),\r\n\r\n    /**\r\n     * zip takes two lists and returns a list of corresponding pairs.\r\n     * If one input list is short, excess elements of the longer list are discarded.\r\n     * @haskellType `zip :: [a] -> [b] -> [(a, b)]`\r\n     * @function module:list.zip\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip = curry((arr1, arr2) => {\r\n        if (!length(arr1) || !length(arr2)) {\r\n            return [];\r\n        }\r\n        const [a1, a2] = lengthsToSmallest(arr1, arr2);\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArr$(agg, [item, a2[ind]]),\r\n            [], a1);\r\n    }),\r\n\r\n    /**\r\n     * zipN takes one or more lists and returns a list containing lists of all indices\r\n     * at a given index, index by index.\r\n     * If one input list is short, excess elements of the longer list are discarded.\r\n     * @function module:list.zipN\r\n     * @param lists {Array|String} - One ore more lists of the same type.\r\n     * @returns {Array}\r\n     */\r\n    zipN = (...lists) => {\r\n        const trimmedLists = apply(lengthsToSmallest, filter(length, lists)),\r\n            lenOfTrimmed = length(trimmedLists);\r\n        if (!lenOfTrimmed) {\r\n            return [];\r\n        }\r\n        else if (lenOfTrimmed === 1) {\r\n            return sliceTo(length(trimmedLists[0]), trimmedLists[0]);\r\n        }\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArr$(agg, map(xs => xs[ind], trimmedLists)),\r\n            [], trimmedLists[0]);\r\n    },\r\n\r\n    /**\r\n     * @haskellType `zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]`\r\n     * @function module:list.zip3\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip3 = curry((arr1, arr2, arr3) => zipN(arr1, arr2, arr3)),\r\n\r\n    /**\r\n     * @haskellType `zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]`\r\n     * @function module:list.zip4\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @param arr4 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip4 = curry((arr1, arr2, arr3, arr4) => zipN(arr1, arr2, arr3, arr4)),\r\n\r\n    /**\r\n     * @haskellType `zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]`\r\n     * @function module:list.zip5\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @param arr4 {Array}\r\n     * @param arr5 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip5 = curry((arr1, arr2, arr3, arr4, arr5) => zipN(arr1, arr2, arr3, arr4, arr5)),\r\n\r\n    /**\r\n     * zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\r\n     * zipWith generalises zip by zipping with the function given as the\r\n     * first argument, instead of a function tupling function (function that returns a tuple). For example,\r\n     * zipWith (+) is applied to two lists to produce the list of corresponding sums.\r\n     * @note `_|_` means bottom or perpetual (@see\r\n     *  - https://wiki.haskell.org/Bottom\r\n     *  - https://stackoverflow.com/questions/19794681/what-does-this-syntax-mean-in-haskell-or\r\n     *  )\r\n     * @example\r\n     * ```\r\n     * zipWith f [] _|_ = []\r\n     * ```\r\n     * @haskellType `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`\r\n     * @function module:list.zipWith\r\n     * @param op {Function} - Takes two parts of a tuple and returns a tuple.\r\n     *  E.g., ` op :: a -> b -> (a, b)`\r\n     * @param xs1 {Array}\r\n     * @param xs2 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith = curry((op, xs1, xs2) => {\r\n        if (!length(xs1) || !length(xs2)) {\r\n            return [];\r\n        }\r\n        const [a1, a2] = lengthsToSmallest(xs1, xs2);\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArr$(agg, op(item, a2[ind])),\r\n            [], a1);\r\n    }),\r\n\r\n    /**\r\n     * Zips all given lists with tupling function. Note: Haskell types do not have\r\n     *  a way (that I know of) to show one or more for params in a function so `@haskellType` below\r\n     *  is left there for general purpose not for exactness as is told by aforementioned.\r\n     * @haskellType `zipWithN :: (a -> b -> c) -> [a] -> [b] -> [c]` - Where `N` is the number\r\n     *  of lists to zip.\r\n     * @function module:list.zipWithN\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\r\n     * @param lists ...{Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWithN = (op, ...lists) => {\r\n        const trimmedLists = apply(lengthsToSmallest, lists),\r\n            lenOfTrimmed = length(trimmedLists);\r\n        if (!lenOfTrimmed) {\r\n            return [];\r\n        }\r\n        else if (lenOfTrimmed === 1) {\r\n            return sliceTo(length(trimmedLists[0]), trimmedLists[0]);\r\n        }\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArr$(agg, apply(op, map(xs => xs[ind], trimmedLists))),\r\n            [], trimmedLists[0]);\r\n    },\r\n\r\n    /**\r\n     * Zips 3 lists with tupling function.\r\n     * @haskellType `zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]`\r\n     * @function module:list.zipWith3\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\r\n     * @param xs1 {Array}\r\n     * @param xs2 {Array}\r\n     * @param xs3 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith3 = curry((op, xs1, xs2, xs3) => zipWithN(op, xs1, xs2, xs3)),\r\n\r\n    /**\r\n     * Zips 4 lists with tupling function.\r\n     * @haskellType `zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c]  -> [d] -> [e]`\r\n     * @function module:list.zipWith4\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> d -> (a, b, c, d)`\r\n     * @param xs1 {Array}\r\n     * @param xs2 {Array}\r\n     * @param xs3 {Array}\r\n     * @param xs4 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith4 = curry((op, xs1, xs2, xs3, xs4) => zipWithN(op, xs1, xs2, xs3, xs4)),\r\n\r\n    /**\r\n     * Zips 5 lists.\r\n     * @haskellType `zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c]  -> [d] -> [e] -> [f]`\r\n     * @function module:list.zipWith5\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> d -> e -> (a, b, c, d, e)`\r\n     * @param xs1 {Array}\r\n     * @param xs2 {Array}\r\n     * @param xs3 {Array}\r\n     * @param xs4 {Array}\r\n     * @param xs5 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith5 = curry((op, xs1, xs2, xs3, xs4, xs5) => zipWithN(op, xs1, xs2, xs3, xs4, xs5)),\r\n\r\n    /**\r\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\r\n     * @haskellType `unzip :: [(a, b)] -> ([a], [b])`\r\n     * @todo Should support other list types (should not have `push` hard coded instead should use `mappend` (if available)).\r\n     * @function module:list.unzip\r\n     * @param arr {Array|*}\r\n     * @returns {Array|*}\r\n     */\r\n    unzip = arr =>\r\n        foldl((agg, item) => {\r\n            agg[0].push(item[0]);\r\n            agg[1].push(item[1]);\r\n            return agg;\r\n        }, [[], []], arr),\r\n\r\n    /**\r\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\r\n     * @sudoHaskellType `unzipN :: [(a, b, ...x)] -> ([a], [b], ...[x])`\r\n     * @todo Should support other list types (should not have `push` hard coded instead should use `mappend` (if available)).\r\n     * @function module:list.unzipN\r\n     * @param list {Array|*} - List of tuples (lists).\r\n     * @returns {Array|*}\r\n     */\r\n    unzipN = list => {\r\n        if (!length(list)) {\r\n            return [];\r\n        }\r\n        const lenItem0 = length(list[0]);\r\n        let zero = lenItem0 ?\r\n            unfoldr(numLists => numLists-- ? [[], numLists] : undefined, lenItem0) :\r\n            [];\r\n        return foldl((agg, item) => {\r\n            agg.forEach((outList, ind) => outList.push(item[ind]));\r\n            return agg;\r\n        }, zero, list);\r\n    },\r\n\r\n    /**\r\n     * Returns true if any item in container passes predicate `p`.\r\n     * @function module:list.any\r\n     * @param p {Function} - Predicate.\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    any = curry((p, xs) => {\r\n        let ind = 0,\r\n            limit = length(xs);\r\n        if (!limit) {\r\n            return false;\r\n        }\r\n        for (; ind < limit; ind += 1) {\r\n            if (p(xs[ind])) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }),\r\n\r\n    /**\r\n     * Returns true if all items in container pass predicate `p`.\r\n     * @function module:list.all\r\n     * @param p {Function} - Predicate.\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    all = curry((p, xs) => {\r\n        const limit = length(xs);\r\n        let ind = 0;\r\n        if (limit === 0) {\r\n            return false;\r\n        }\r\n        for (; ind < limit; ind++) {\r\n            if (!p(xs[ind], ind, xs)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }),\r\n\r\n    /**\r\n     * Conjuction of container of bools (or truthy and/or falsy values);  Returns\r\n     * `true` if all in container are 'truthy' else returns `false`\r\n     * @function module:list.and\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    and = xs => all(isTruthy, xs),\r\n\r\n    /**\r\n     * Returns a boolean indicating whether any item in container is 'truthy' or not.\r\n     * **Note** The haskell type for this function only takes two items, but here\r\n     * we allow the passing of more than one item (may change later to adhere to the haskell type).\r\n     * @function module:list.or\r\n     * @haskellType `or :: Bool -> Bool -> Bool`\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    or = xs => any(isTruthy, xs),\r\n\r\n    /**\r\n     * Returns a boolean indicating whether all items in container are 'falsy' or not.\r\n     * **Note** The haskell type for this function only takes two items, but here\r\n     * we allow the passing of more than one item (may change later to adhere to the haskell type).\r\n     * @function module:list.not\r\n     * @haskellType `not :: Bool -> Bool`\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    not = xs => all(isFalsy, xs),\r\n\r\n    /**\r\n     * Computes the sum of the numbers of a structure.\r\n     * @function module:list.sum\r\n     * @haskellType `sum :: (List t, Num a) => t a -> a`\r\n     * @param list {Array|String}\r\n     * @returns {Number}\r\n     */\r\n    sum = list => foldl((agg, x) => agg + x, 0, list),\r\n\r\n    /**\r\n     * Computes the product of the numbers of a structure.\r\n     * @function module:list.product\r\n     * @haskellType `product :: (List t, Num a) => t a -> a`\r\n     * @param list {Array|String}\r\n     * @returns {Number}\r\n     */\r\n    product = list => foldl((agg, x) => agg * x, 1, list),\r\n\r\n    /**\r\n     * Returns the largest element in a non-empty structure of elements.\r\n     * @function module:list.maximum\r\n     * @haskellType `maximum :: forall a . Ord a => t a -> a`\r\n     * @param list {Array|String}\r\n     * @returns {*} - Whatever type the array is made of (if any).\r\n     */\r\n    maximum = list => last(sortBy(genericAscOrdering, list)),\r\n\r\n    /**\r\n     * Returns the smallest element in a non-empty structure of elements.\r\n     * @function module:list.minimum\r\n     * @haskellType `minimum :: forall a . Ord a => t a -> a`\r\n     * @param list {Array|String}\r\n     * @returns {*} - Whatever type the array is made of (if any).\r\n     */\r\n    minimum = list => head(sortBy(genericAscOrdering, list)),\r\n\r\n    /**\r\n     * scanl is similar to foldl, but returns a list of successive reduced values from the left:\r\n     * ```\r\n     * scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]\r\n     * ```\r\n     * Also note that:\r\n     * ```\r\n     * last (scanl f z xs) == foldl f z xs.\r\n     * ```\r\n     * @function module:list.scanl\r\n     * @param fn {Function}\r\n     * @param zero {*}\r\n     * @param xs {Array}\r\n     * @returns {Array|*}\r\n     */\r\n    scanl = curry((fn, zero, xs) => {\r\n        if (!xs || !length(xs)) {\r\n            return [];\r\n        }\r\n        const limit = length(xs);\r\n        let ind = 0,\r\n            result = zero,\r\n            out = [];\r\n        while (ind < limit) {\r\n            result = fn(result, xs[ind], ind, xs);\r\n            out.push(result);\r\n            ind++;\r\n        }\r\n        return out;\r\n    }),\r\n\r\n    /**\r\n     * `scanl1` is a variant of `scanl` that has no starting value argument:\r\n     * `shallowCompare(scanl1(fn, [x1, x2, ...]), [x1, fn(x1, x2), ...]) // true`\r\n     * @function module:list.scanl1\r\n     * @param fn {Function}\r\n     * @param xs {Array}\r\n     * @returns {Array|*}\r\n     */\r\n    scanl1 = curry((fn, xs) => {\r\n        if (!xs || !xs.length) { return []; }\r\n        return scanl(fn, head(xs), tail(xs));\r\n    }),\r\n\r\n    /**\r\n     * Same as `scanl` but from the right (similiar to `foldr`'s relationship to `foldl`).\r\n     * Note also `scanr`'s relationship ot `foldr`:\r\n     * `head (scanr(fn, z, xs)) === foldr(fn, z, xs).\r\n     * @function module:list.scanr\r\n     * @param fn {Function}\r\n     * @param zero {*}\r\n     * @param xs {Array}\r\n     * @returns {Array|*}\r\n     */\r\n    scanr = curry((fn, zero, xs) => {\r\n        if (!xs || !length(xs)) {\r\n            return [];\r\n        }\r\n        const limit = length(xs);\r\n        let ind = limit - 1,\r\n            result = xs[0],\r\n            out = [];\r\n        while (ind > -1) {\r\n            result = fn(result, xs[ind], ind, xs);\r\n            out.push(result);\r\n            ind--;\r\n        }\r\n        return out;\r\n    }),\r\n\r\n    /**\r\n     * Same as `scanr` but takes no zero/accumulator value.\r\n     * @function module:list.scanr1\r\n     * @param fn {Function}\r\n     * @param xs {Array}\r\n     * @returns {Array|*}\r\n     */\r\n    scanr1 = curry((fn, xs) => {\r\n        if (!xs || !xs.length) { return []; }\r\n        return scanr(fn, last(xs), init(xs));\r\n    }),\r\n\r\n    /**\r\n     * The nub function removes duplicate elements from a list.\r\n     * In particular, it keeps only the first occurrence of each element.\r\n     * (The name nub means `essence'.) It is a special case of nubBy, which\r\n     * allows the programmer to supply their own equality test.\r\n     * ```shallowCompare( nub ([1,2,3,4,3,2,1,2,4,3,5]), [1,2,3,4,5] )```\r\n     * @function module:list.nub\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    nub = list => nubBy((a, b) => a === b, list),\r\n\r\n    /**\r\n     * `remove(x, xs)` removes the first occurrence of `x` from `xs`.\r\n     * For example, `remove('a', 'banana') === 'bnana';`\r\n     * @function module:list.remove\r\n     * @param x {*}\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    remove = curry((x, list) => removeBy((a, b) => a === b, x, list)),\r\n\r\n    /**\r\n     * The sort function implements a stable sorting algorithm.\r\n     * It is a special case of sortBy, which allows the programmer\r\n     * to supply their own comparison function.\r\n     * ```shallowCompare(sort ([1,6,4,3,2,5]), [1,2,3,4,5,6]) // true```\r\n     * @function module:list.sort\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    sort = xs => sortBy(genericAscOrdering, xs),\r\n\r\n    /**\r\n     * Sort a list by comparing the results of a key function applied to each\r\n     * element. sortOn f is equivalent to sortBy (comparing f), but has the\r\n     * performance advantage of only evaluating f once for each element in the\r\n     * input list. This is called the decorate-sort-undecorate paradigm, or\r\n     * Schwartzian transform.\r\n     *\r\n     * Elements are arranged from from lowest to highest, keeping duplicates\r\n     * in the order they appeared in the input.\r\n     *\r\n     * Ex:\r\n     * ```\r\n     * shallowEquals(\r\n     *  sortOn (head, [[2, \"world\"], [4, \"!\"], [1, \"Hello\"]]),\r\n     *  [[1,\"Hello\"],[2,\"world\"],[4,\"!\"]]\r\n     * ) // true\r\n     * ```\r\n     * @function module:list.sortOn\r\n     * @param valueFn {Function}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    sortOn = curry((valueFn, xs) =>\r\n\r\n        // Un-decorate\r\n        map(decorated => decorated[1],\r\n\r\n            // Decorate and sort\r\n            sortBy(\r\n                // Ordering\r\n                ([a0], [b0]) => genericAscOrdering(a0, b0),\r\n\r\n                // Decorate\r\n                map(item => [valueFn(item), item], xs)\r\n            )\r\n        )\r\n    ),\r\n\r\n    /**\r\n     * The sortBy function is the non-overloaded (in haskell terms) version of sort.\r\n     * @haskellExample ```\r\n     *  >>> sortBy (\\(a,_) (b,_) -> compare a b) [(2, \"world\"), (4, \"!\"), (1, \"Hello\")]\r\n     *  [(1,\"Hello\"),(2,\"world\"),(4,\"!\")]\r\n     * ```\r\n     * @function module:list.sortBy\r\n     * @param orderingFn {Function}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    sortBy = curry((orderingFn, xs) => sliceCopy(xs).sort(orderingFn || genericAscOrdering)),\r\n\r\n    /**\r\n     * The insert function takes an element and a list and inserts the element\r\n     * into the list at the first position where it is less than or equal to the\r\n     * next element. In particular, if the list is sorted before the call, the\r\n     * result will also be sorted. It is a special case of insertBy, which allows\r\n     * the programmer to supply their own comparison function.\r\n     * @function module:list.insert\r\n     * @param x {*}\r\n     * @param xs {Array|*}\r\n     * @returns {Array}\r\n     */\r\n    insert = curry((x, xs) => {\r\n        if (!length(xs)) {\r\n            return [x];\r\n        }\r\n        const foundIndex = findIndex(item => x <= item, xs);\r\n        return foundIndex === -1 ? [x] :\r\n            concat(intersperse([x], splitAt(foundIndex, xs)));\r\n    }),\r\n\r\n    /**\r\n     * A version of `insert` that allows you to specify the ordering of the inserted\r\n     * item;  Before/at, or after\r\n     * @function module:list.insertBy\r\n     * @haskellType `insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]`\r\n     * @note `Ordering` === // something that is order-able\r\n     * @todo Optimize and work the logic of this function;  Think about the types that will be\r\n     *  operated on by this functions logic.\r\n     * @param orderingFn {Function} - A function that returns `-1`, `0`, or 1`.\r\n     * @param x {*} - Value to insert.\r\n     * @param xs {Array} - List to insert into (note new list is returned)\r\n     * @returns {Array} - New list.\r\n     */\r\n    insertBy = curry((orderingFn, x, xs) => {\r\n        const limit = length(xs);\r\n        if (!limit) {\r\n            return [x];\r\n        }\r\n        let ind = 0;\r\n        for (; ind < limit; ind += 1) {\r\n            if (orderingFn(x, xs[ind]) <= 0) {\r\n                const parts = splitAt(ind, xs);\r\n                return concat([parts[0], [x], parts[1]]);\r\n            }\r\n        }\r\n        return aggregateArr$(sliceCopy(xs), x);\r\n    }),\r\n\r\n    /**\r\n     * The nubBy function behaves just like nub, except it uses a user-supplied equality predicate.\r\n     * @function module:list.nubBy\r\n     * @param pred {Function}\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    nubBy = curry((pred, list) => {\r\n        if (!length(list)) {\r\n            return [];\r\n        }\r\n        const limit = length(list);\r\n        let ind = 0,\r\n            currItem,\r\n            out = [],\r\n            anyOp = storedItem => pred(currItem, storedItem);\r\n        for (; ind < limit; ind += 1) {\r\n            currItem = list[ind];\r\n            if (any(anyOp, out)) {\r\n                continue;\r\n            }\r\n            out.push(currItem);\r\n        }\r\n        return out;\r\n    }),\r\n\r\n    /**\r\n     * Behaves the same as `remove`, but takes a user-supplied equality predicate.\r\n     * @function module:list.removeBy\r\n     * @param pred {Function}\r\n     * @param x {*}\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    removeBy = curry((pred, x, list) => { // @todo optimize this implementation\r\n        const foundIndex = findIndex(item => pred(x, item), list),\r\n            parts = splitAt(foundIndex > -1 ? foundIndex : 0, list); // @todo correct this implementation\r\n        return append(parts[0], tail(parts[1]));\r\n    }),\r\n\r\n    /**\r\n     * The `removeFirstsBy` function takes a predicate and two lists and returns the first list with the first\r\n     * occurrence of each element of the second list removed.\r\n     * @function module:list.removeFirstBy\r\n     * @param pred {Function}\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    removeFirstsBy = curry((pred, xs1, xs2) =>\r\n        foldl((agg, x2) => removeBy(pred, x2, agg), xs1, xs2)),\r\n\r\n    /**\r\n     * Returns the union on elements matching boolean check passed in.\r\n     * @function module:list.unionBy\r\n     * @param pred {Function} - `pred :: a -> a -> Bool`\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @returns {Array}\r\n     */\r\n    unionBy = curry((pred, arr1, arr2) =>\r\n        foldl((agg, b) => {\r\n                const alreadyAdded = any(a => pred(a, b), agg);\r\n                return !alreadyAdded ? (agg.push(b), agg) : agg;\r\n            }, sliceCopy(arr1), arr2\r\n        )),\r\n\r\n    /**\r\n     * Creates a union on matching elements from array1.\r\n     * @function module:list.union\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @returns {Array}\r\n     */\r\n    union = curry((arr1, arr2) =>\r\n        append(arr1,\r\n            filter(elm => !includes(elm, arr1), arr2))),\r\n\r\n    /**\r\n     * Performs an intersection on list 1 with  elements from list 2.\r\n     * @function module:list.intersect\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @returns {Array}\r\n     */\r\n    intersect = curry((arr1, arr2) =>\r\n        !arr1 || !arr2 || (!arr1 && !arr2) ? [] :\r\n            filter(elm => includes(elm, arr2), arr1)),\r\n\r\n    /**\r\n     * Returns an intersection by predicate.\r\n     * @function module:list.intersectBy\r\n     * @param pred {Function} - `pred :: a -> b -> Bool`\r\n     * @param list1 {Array}\r\n     * @param list2 {Array}\r\n     * @return {Array}\r\n     */\r\n    intersectBy = curry((pred, list1, list2) =>\r\n        foldl((agg, a) =>\r\n                any(b => pred(a, b), list2) ? (agg.push(a), agg) : agg\r\n            , [], list1)),\r\n\r\n    /**\r\n     * Returns the difference of list 1 from list 2.\r\n     * @note The `difference` operation here is non-associative;  E.g., `a - b` is not equal to `b - a`;\r\n     * @function module:list.difference\r\n     * @param array1 {Array}\r\n     * @param array2 {Array}\r\n     * @returns {Array}\r\n     */\r\n    difference = curry((array1, array2) => { // augment this with max length and min length ordering on op\r\n        if (array1 && !array2) {\r\n            return sliceCopy(array1);\r\n        }\r\n        else if (!array1 && array2 || (!array1 && !array2)) {\r\n            return [];\r\n        }\r\n        return reduce((agg, elm) =>\r\n                !includes(elm, array2) ? (agg.push(elm), agg) : agg\r\n            , [], array1);\r\n    }),\r\n\r\n    /**\r\n     * Returns the complement of list 0 and the reset of the passed in arrays.\r\n     * @function module:list.complement\r\n     * @param arr0 {Array}\r\n     * @param arrays {...Array}\r\n     * @returns {Array}\r\n     */\r\n    complement = (arr0, ...arrays) =>\r\n        reduce((agg, arr) => append(agg, difference(arr, arr0)), [], arrays);\r\n\r\n/**\r\n * Same as `Array.prototype.slice` though is functional version.\r\n * @function module:object.slice\r\n * @param fromIndex {Number}\r\n * @param toIndex {Number}\r\n * @param arr {Array}\r\n * @returns {Array}\r\n */\r\n\r\n/**\r\n * Same as `Array.prototype.includes` (functional version).\r\n * @function module:list.includes\r\n * @param value {*} - Value to search for.\r\n * @param xs {Array|String}\r\n * @returns {Boolean}\r\n */\r\n\r\n/**\r\n * Same as `Array.prototype.indexOf`.\r\n * @function module:list.indexOf\r\n * @param x {*} - Element to search for.\r\n * @param xs {Array|String|*} - list or list like to look in.\r\n * @returns {Number} - `-1` if element not found else index at which it is found.\r\n */\r\n\r\n/**\r\n * Same as `Array.prototype.lastIndexOf` (fp version).\r\n * @function module:list.lastIndexOf\r\n * @param x {*} - Element to search for.\r\n * @param xs {Array|String|*} - list or list like to look in.\r\n * @returns {Number} - `-1` if element not found else index at which it is found.\r\n */\r\n\r\n/**\r\n * Same as Array.prototype.push (though is functional version).\r\n * @function module:list.push\r\n * @param item {*}\r\n * @param arr {Array}\r\n * @returns {Number}\r\n */\r\n","import {assignDeep} from './assignDeep';\r\nimport {hasOwnProperty, keys} from '../jsPlatform/object';\r\nimport {foldl} from '../list';\r\nimport {curry} from '../function/curry';\r\n\r\nexport const\r\n\r\n    objUnion = curry((obj1, obj2) => assignDeep(obj1, obj2)),\r\n\r\n    objIntersect = curry((obj1, obj2) => foldl((agg, key) => {\r\n        if (hasOwnProperty(key, obj2)) {\r\n            agg[key] = obj2[key];\r\n        }\r\n        return agg;\r\n    }, {}, keys(obj1))),\r\n\r\n    objDifference = curry((obj1, obj2) => foldl((agg, key) => {\r\n        if (!hasOwnProperty(key, obj2)) {\r\n            agg[key] = obj1[key];\r\n        }\r\n        return agg;\r\n    }, {}, keys(obj1))),\r\n\r\n    objComplement = (obj0, ...objs) => foldl((agg, obj) =>\r\n        assignDeep(agg, objDifference(obj, obj0)), {}, objs);\r\n","/**\r\n * @module console\r\n * @description Console exports.\r\n */\r\nexport const\r\n\r\n    /**\r\n     * `Console.log` method.\r\n     * @function module:console.log\r\n     * @params args {...*}\r\n     * @returns {void}\r\n     */\r\n    log = console.log.bind(console),\r\n\r\n    /**\r\n     * `Console.error` method.\r\n     * @function module:console.error\r\n     * @params args {...*}\r\n     * @returns {void}\r\n     */\r\n    error = console.error.bind(console),\r\n\r\n    /**\r\n     * Peeks (console.log) at incoming value(s) and returns the last value.\r\n     * @function module:console.peek\r\n     * @param args {...*}\r\n     * @returns {*} Last given value (if one or more values) else first value.\r\n     */\r\n    peek = (...args) => (log(...args), args.pop())\r\n\r\n;\r\n","export const\r\n\r\n    /**\r\n     * Clones and object or array using `JSON.parse(JSON.stringify(...))` pattern.\r\n     * @function module:object.jsonClone\r\n     * @param x {*}\r\n     * @returns {*}\r\n     */\r\n    jsonClone = x => JSON.parse(JSON.stringify(x))\r\n\r\n;\r\n","import {isArray, isType} from './is';\r\nimport {keys} from '../jsPlatform/object';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns an associated list from given object.\r\n     * @note Useful for working with plain javascript objects.\r\n     * @function module:object.toAssocList\r\n     * @param obj {(Object|Array|*)}\r\n     * @returns {Array.<*, *>}\r\n     */\r\n    toAssocList = obj => keys(obj).map(key => [key, obj[key]]),\r\n\r\n    /**\r\n     * Returns an associated list from given object (deeply (on incoming object's type)).\r\n     * @note Does deep conversion on all values of passed in type's type.\r\n     * @function module:object.toAssocListDeep\r\n     * @param obj {*}\r\n     * @param [TypeConstraint = Object] {(Constructor|Function)} - Type constraint to convert on.\r\n     * @returns {*}\r\n     */\r\n    toAssocListDeep = (obj, TypeConstraint = Object) => keys(obj).map(key =>\r\n        TypeConstraint && isType(TypeConstraint, obj[key]) ?\r\n            [key, toAssocListDeep(obj[key], TypeConstraint)] :\r\n            [key, obj[key]]\r\n    ),\r\n\r\n    /**\r\n     * From associated list to object.\r\n     * @function module:object.fromAssocList\r\n     * @param xs {Array.<Array>} - Associated list.\r\n     * @param [OutType = Object] {Constructor|Function} - Output type.  Default `Object`.\r\n     * @returns {*} - Default is `Object`\r\n     */\r\n    fromAssocList = (xs, OutType = Object) => xs.reduce((agg, [key, value]) => {\r\n        agg[key] = value;\r\n        return agg;\r\n    }, new OutType()),\r\n\r\n    /**\r\n     * From associated list to object (deep conversion on associative lists (array of 2 value arrays)).\r\n     * @note Considers array of arrays associated lists.\r\n     * @function module:object.fromAssocListDeep\r\n     * @param xs {Array.<Array>} - Associated list.\r\n     * @param [OutType = Object] {Constructor|Function} - Output type.  Default `Object`.\r\n     * @returns {*} - Default is `Object`\r\n     */\r\n    fromAssocListDeep = (xs, OutType = Object) => xs.reduce((agg, [key, value]) => {\r\n        if (isArray(value) && isArray(value[0]) && value[0].length === 2) {\r\n            agg[key] = fromAssocListDeep(value, OutType);\r\n            return agg;\r\n        }\r\n        agg[key] = value;\r\n        return agg;\r\n    }, new OutType())\r\n;\r\n","import {typeOf} from './typeOf';\r\nimport {toAssocList} from './assocList';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Converts incoming value to an array.\r\n     * @note For `WeakMap`, `WeakSet`, `Map` and `Set` result is the same as calling `Array.from` on such.\r\n     * @note For `null`, `undefined`, `NaN`, `Number{}`, `Symbol{}`, `Boolean{}` returns an empty array.\r\n     * @note Method does a shallow conversion;\r\n     * @function module:object.toArray\r\n     * @param x {*} - Thing to convert from.\r\n     * @returns {Array}\r\n     */\r\n    toArray = x => {\r\n        switch (typeOf(x)) {\r\n            case 'Null':\r\n            case 'Undefined':\r\n                return [];\r\n            case String.name:\r\n            case Array.name:\r\n            case 'WeakMap':\r\n            case 'WeakSet':\r\n            case 'Map':\r\n            case 'Set':\r\n                return Array.from(x);\r\n            case Object.name:\r\n            default:\r\n                return toAssocList(x);\r\n        }\r\n    }\r\n\r\n;\r\n","/**\r\n * @module object\r\n * @description Object operations/combinators.\r\n */\r\n\r\nexport * from './jsPlatform/object';\r\nexport * from './object/lookup';\r\nexport * from './object/typeOf';\r\nexport * from './object/copy';\r\nexport * from './object/is';\r\nexport * from './object/of';\r\nexport * from './object/searchObj';\r\nexport * from './object/assignDeep';\r\nexport * from './object/setTheory';\r\nexport * from './object/console';\r\nexport * from './object/jsonClone';\r\nexport * from './object/toArray';\r\nexport * from './object/assocList';\r\n\r\n/**\r\n* Returns whether constructor has derived object.\r\n* @function module:object.instanceOf\r\n* @param instanceConstructor {Function} - Constructor.\r\n* @param instance {*}\r\n* @returns {Boolean}\r\n*/\r\n\r\n/**\r\n * @function module:object.hasOwnProperty\r\n * @param propName {*}\r\n * @param typeInstance {*}\r\n * @returns {Boolean}\r\n */\r\n\r\n/**\r\n * @function module:object.length\r\n * @param x {*}\r\n * @returns {Number}\r\n * @throws {Error} - Throws an error if value doesn't have a `length` property (\r\n *  `null`, `undefined`, {Boolean}, Symbol, et. al.).\r\n */\r\n\r\n/**\r\n * Gets own enumerable keys of passed in object (`Object.keys`).\r\n * @function module:object.keys\r\n * @param obj {*}\r\n * @returns {Array<String>}\r\n */\r\n\r\n/**\r\n * Defined as `Object.assign` else is the same thing but shimmed.\r\n * @function module:object.assign\r\n * @param objs {...{*}}\r\n * @returns {Object}\r\n*/\r\n","import {reduceRight} from '../jsPlatform/array';\r\n\r\n/**\r\n * Composes all functions passed in from right to left passing each functions return value to\r\n * the function on the left of itself.\r\n * @function module:function.compose\r\n * @type {Function}\r\n * @param args {...{Function}}\r\n * @returns {Function}\r\n */\r\nexport const compose = (...args) =>\r\n        arg0 => reduceRight((value, fn) => fn(value), arg0, args);\r\n","import {reverse} from '../jsPlatform/array';\r\nimport {apply, call} from '../jsPlatform/function';\r\nimport {curry, curry2} from './curry';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns a curried function requiring given functions arguments in reverse\r\n     * (returned function expects 2 or more variables (curried at 2 or more args)).\r\n     * @function module:function.flipN\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     * @curried\r\n     */\r\n    flipN = fn => curry2((...args) => apply(fn, reverse(args))),\r\n\r\n    /**\r\n     * Flips a function's first and second arguments and and returns a new function requiring said arguments in reverse.\r\n     * @function module:function.flip\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    flip = fn => curry((b, a) => call(fn, a, b));\r\n","/**\r\n * @memberOf function\r\n */\r\n\r\n/**\r\n * Returns passed in parameter.\r\n * @haskellType `id :: a -> a`\r\n * @function module:function.id\r\n * @param x {*}\r\n * @returns {*}\r\n */\r\nexport const id = x => x;\r\n","import {curry} from './curry';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Run `operation` until predicate returns `true`.\r\n     * @function module:function.until\r\n     * @param predicate {Function} :: a -> Boolean\r\n     * @param operation {Function} :: a -> a\r\n     * @param typeInstance {*} :: * - A monoidal zero or some starting point.\r\n     * @returns {*} - What ever type `typeInstance` is\r\n     */\r\n    until = curry((predicate, operation, typeInstance) => {\r\n        let result = typeInstance;\r\n        while (!predicate(result)) {\r\n            result = operation(result);\r\n        }\r\n        return result;\r\n    });\r\n","/**\r\n * @module function\r\n */\r\nexport * from './jsPlatform/function';\r\nexport * from './function/compose';\r\nexport * from './function/curry';\r\nexport * from './function/flip';\r\nexport * from './function/id';\r\nexport * from './function/negate';\r\nexport * from './function/until';\r\nexport * from './function/fnOrError';\r\n","/**\r\n * @module errorThrowing\r\n * @description Contains error throwing facilities for when a value doesn't match a type.\r\n */\r\nimport {typeOf} from './object/typeOf';\r\nimport {isArray, toTypeRef, toTypeRefName, isOfType} from './object/is';\r\nimport {curry} from './function/curry';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Pretty prints an array of types/type-strings for use by error messages;\r\n     * Outputs \"`SomeTypeName`, ...\" from [SomeType, 'SomeTypeName', etc...]\r\n     * @function module:errorThrowing.typeRefsToStringOrError\r\n     * @param types {Array|TypesArray}\r\n     * @return {String}\r\n     * @private\r\n     */\r\n    typeRefsToStringOrError = types => types.length ?\r\n        types.map(type => `\\`${toTypeRefName(type)}\\``).join(', ') : '',\r\n\r\n    /**\r\n     * Prints a message from an object.  Object signature:\r\n     * {contextName, valueName, value, expectedTypeName, foundTypeName, messageSuffix}\r\n     * @function module:errorThrowing.defaultErrorMessageCall\r\n     * @param tmplContext {Object|TemplateContext} - Object to use in error template.\r\n     * @returns {string}\r\n     * @private\r\n     */\r\n    defaultErrorMessageCall = tmplContext => {\r\n        const {\r\n                contextName, valueName, value, expectedTypeName,\r\n                foundTypeName, messageSuffix\r\n            } = tmplContext,\r\n            isMultiTypeNames = isArray(expectedTypeName),\r\n            typesCopy = isMultiTypeNames ? 'of type' : 'of one of the types',\r\n            typesToMatchCopy = isMultiTypeNames ? typeRefsToStringOrError(expectedTypeName) : expectedTypeName;\r\n        return (contextName ? `\\`${contextName}.` : '`') +\r\n            `${valueName}\\` is not ${typesCopy}: ${typesToMatchCopy}.  ` +\r\n            `Type received: ${foundTypeName}.  Value: ${value};` +\r\n            `${messageSuffix ?  '  ' + messageSuffix + ';' : ''}`;\r\n    },\r\n\r\n    /**\r\n     * Gets the error message thrower seeded with passed in errorMessage template call.\r\n     * @function module:errorThrowing.getErrorIfNotTypeThrower$\r\n     * @param errorMessageCall {Function|ErrorMessageCall}\r\n     * @param typeChecker {Function|TypeChecker} - Function<Type, value>:Boolean\r\n     * @returns {Function|ErrorIfNotType}\r\n     * @private\r\n     */\r\n    _getErrorIfNotTypeThrower = (errorMessageCall, typeChecker = isOfType) =>\r\n        (ValueType, contextName, valueName, value, messageSuffix = null) => {\r\n            const expectedTypeName = toTypeRef(ValueType),\r\n                foundTypeName = typeOf(value);\r\n            if (typeChecker(ValueType, value)) { return value; } // Value matches type\r\n            throw new Error(errorMessageCall(\r\n                {contextName, valueName, value, expectedTypeName, foundTypeName, messageSuffix}\r\n            ));\r\n        },\r\n\r\n    /**\r\n     * Gets the error message thrower seeded with passed in errorMessage template call.\r\n     * @function module:errorThrowing.getErrorIfNotTypesThrower$\r\n     * @param errorMessageCall {Function|ErrorMessageCall}\r\n     * @param typeChecker {Function|TypeChecker} - Function<Type, value>:Boolean\r\n     * @returns {Function|ErrorIfNotTypes}\r\n     * @private\r\n     */\r\n    _getErrorIfNotTypesThrower = (errorMessageCall, typeChecker = isOfType) =>\r\n        (valueTypes, contextName, valueName, value, messageSuffix = null) => {\r\n            const expectedTypeNames = valueTypes.map(toTypeRef),\r\n                matchFound = valueTypes.some(ValueType => typeChecker(ValueType, value)),\r\n                foundTypeName = typeOf(value);\r\n            if (matchFound) { return value; }\r\n            throw new Error(\r\n                errorMessageCall({\r\n                    contextName, valueName, value,\r\n                    expectedTypeName: expectedTypeNames, foundTypeName,\r\n                    messageSuffix\r\n                })\r\n            );\r\n        },\r\n\r\n    /**\r\n     * Checks that passed in `value` is of given `type`.  Throws an error if value\r\n     * is not of given `type`.  This is the un-curried version.  For the curried version\r\n     * see `module:errorThrowing.errorIfNotType`.\r\n     * @function module:errorThrowing.errorIfNotType$\r\n     * @param type {String|Function} - Type's name or type itself.\r\n     * @param contextName {String} - Name of context to attribute errors if thrown.\r\n     * @param valueName {String} - String rep of value.\r\n     * @param value {*}\r\n     * @param [messageSuffix=null] {String} - Optional.\r\n     * @returns {*} - Given `value` if `value` matches passed in type.\r\n     * @private\r\n     */\r\n    _errorIfNotType = _getErrorIfNotTypeThrower(defaultErrorMessageCall),\r\n\r\n    /**\r\n     * Checks that passed in `value` is of one of the given `types`.  Throws an error if value\r\n     *  is not of one of the given `types`.  This is the un-curried version.  For the curried version\r\n     * see `module:errorThrowing.errorIfNotTypes`.\r\n     * @type {Function|module:errorThrowing.errorIfNotTypes}\r\n     * @function module:errorThrowing.errorIfNotTypes$\r\n     * @param types {Array} - Array of one or more types or type names themselves.\r\n     * @param contextName {String} - Name of context to attribute errors if thrown.\r\n     * @param valueName {String} - String rep of value.\r\n     * @param value {*}\r\n     * @returns {*} - Given `value` if `value` matches passed in type.\r\n     * @private\r\n     */\r\n    _errorIfNotTypes = _getErrorIfNotTypesThrower(defaultErrorMessageCall),\r\n\r\n    /**\r\n     * Returns a function that can be used to ensure that values are of a given type.\r\n     *   Also throws informative error messages containing the value types, names, expected type names,\r\n     *   etc.\r\n     * @function module:errorThrowing.getErrorIfNotTypeThrower\r\n     * @param errorMessageCall {Function|ErrorMessageCall} - Template function (takes an info-object and returns a printed string).\r\n     * @returns {Function|ErrorIfNotType} - Returns a function with the same signature as `errorIfNotType` though curried.\r\n     */\r\n    getErrorIfNotTypeThrower = errorMessageCall => curry(_getErrorIfNotTypeThrower(errorMessageCall)),\r\n\r\n    /**\r\n     * Returns a function that can be used to ensure that a value is of one or more given types.\r\n     *   The returned function is used in cases where informative error messages\r\n     *   containing the value types, names, expected type names, are-required/should-be-used etc.\r\n     * @function module:errorThrowing.getErrorIfNotTypesThrower\r\n     * @param errorMessageCall {Function|ErrorMessageCall} - Template function (takes an info-object and returns a printed string).\r\n     * @returns {Function|ErrorIfNotTypes} - Returns a function with the same signature as `errorIfNotTypes` though curried.\r\n     */\r\n    getErrorIfNotTypesThrower = errorMessageCall => curry(_getErrorIfNotTypesThrower(errorMessageCall)),\r\n\r\n    /**\r\n     * Checks that passed in `value` is of given `type`.  Throws an error if value\r\n     * is not of given `type`.  Curried.\r\n     * @function module:errorThrowing.errorIfNotType\r\n     * @param type {String|Function} - Type's name or type itself.\r\n     * @param contextName {String} - Name of context to attribute errors if thrown.\r\n     * @param valueName {String} - String rep of value.\r\n     * @param value {*}\r\n     * @param [messageSuffix=null] {String} - Optional.\r\n     * @returns {*} - Given `value` if `value` matches passed in type.\r\n     * @curried\r\n     */\r\n    errorIfNotType = curry(_errorIfNotType),\r\n\r\n    /**\r\n     * Checks that passed in `value` is of one of the given `types`.  Throws an error if value\r\n     *  is not of one of the given `types`.  Curried.\r\n     * @function module:errorThrowing.errorIfNotTypes\r\n     * @param types {Array} - Array of one or more types or type names themselves.\r\n     * @param contextName {String} - Name of context to attribute errors if thrown.\r\n     * @param valueName {String} - String rep of value.\r\n     * @param value {*}\r\n     * @returns {*} - Given `value` if `value` matches passed in type.\r\n     * @curried\r\n     */\r\n    errorIfNotTypes = curry(_errorIfNotTypes)\r\n;\r\n\r\n/**\r\n * @typedef {*} Any - Synonym for 'any value'.\r\n */\r\n\r\n/**\r\n * @typedef {String|Function} TypeRef\r\n * @description Type reference.  Type itself or Type's name;  E.g., `Type.name`;\r\n */\r\n\r\n/**\r\n * @typedef {Object<value, valueName, expectedTypeName, foundTypeName, messageSuffix>} TemplateContext\r\n * @description Template context used for error message renderers (functions that take a context obj and return a string).\r\n * @property value {*}\r\n * @property valueName {String}\r\n * @property expectedTypeName {String} - Expected name of constructor of `value`;  E.g., usually `SomeConstructor.name`;\r\n * @property foundTypeName {String} - Found types name;  E.g., `FoundConstructor.name`;\r\n * @property [messageSuffix=null] {*} - Message suffix (sometimes an extra hint or instructions for\r\n *  directing user to fix where his/her error has occurred).  Optional.\r\n */\r\n\r\n/**\r\n * @typedef {Array<(String|Function)>} TypesArray\r\n */\r\n\r\n/**\r\n * @typedef {Function} TypeChecker\r\n * @description Checks whether a value is of given type.\r\n * @param Type {TypeRef} - a Type or it's name;  E.g., `Type.name`.\r\n * @param value {*}\r\n * @returns {Boolean}\r\n */\r\n\r\n/**\r\n * @typedef {Function} ErrorMessageCall\r\n * @description Error message template function.\r\n * @param tmplContext {TemplateContext}\r\n * @returns {String}\r\n */\r\n\r\n/**\r\n * @typedef {Function} ErrorIfNotType\r\n * @description Used to ensure value matches passed in type.\r\n * @param type {TypeRef} - Constructor name or constructor.\r\n * @param contextName {String}\r\n * @param valueName {String}\r\n * @param value {*}\r\n * @throws {Error} - If value doesn't match type.\r\n * @returns {*} - What ever value is.\r\n */\r\n\r\n/**\r\n * @typedef {Function} ErrorIfNotTypes\r\n * @description Used to ensure a value matches one of one or more types passed in.\r\n * @param valueTypes {TypesArray} - Array of constructor names or constructors.\r\n * @param contextName {String}\r\n * @param valueName {String}\r\n * @param value {*}\r\n * @throws {Error} - If value doesn't match type.\r\n * @returns {*} - Whatever value is.\r\n */\r\n","/**\r\n * @module string\r\n * @description Contains functions for strings.\r\n */\r\nimport {intercalate, map, filter} from './list';\r\nimport {split} from './jsPlatform/string';\r\nimport {compose} from './function/compose';\r\nimport {join} from './jsPlatform/array';\r\nimport {_errorIfNotType} from './errorThrowing';\r\n\r\nexport {split};\r\n\r\nexport const\r\n\r\n    /**\r\n     * Splits a string on all '\\n', '\\r', '\\n\\r', or '\\r\\n' characters.\r\n     * @function module:string.lines\r\n     * @param str {String}\r\n     * @returns {Array}\r\n     */\r\n    lines = split(/[\\n\\r]/gm),\r\n\r\n    /**\r\n     * Splits a string on all '\\s' and/or all '\\t' characters.\r\n     * @function module:string.words\r\n     * @param str{String}\r\n     * @returns {Array}\r\n     */\r\n    words = split(/[\\s\\t]/gm),\r\n\r\n    /**\r\n     * Intersperse an array of strings with '\\s' and then concats them.\r\n     * @function module:string.unwords\r\n     * @param arr {String}\r\n     * @returns {Array}\r\n     */\r\n    unwords = intercalate(' '),\r\n\r\n    /**\r\n     * Intersperses a '\\n' character into a list of strings and then concats it.\r\n     * @function module:string.unlines\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    unlines = intercalate('\\n'),\r\n\r\n    /**\r\n     * Lower cases first character of a non-empty string.\r\n     * @function module:string.lcaseFirst\r\n     * @param xs {String}\r\n     * @returns {string}\r\n     * @throws {Error} - Throws error if receiving anything that is not a string.\r\n     */\r\n    lcaseFirst = xs => {\r\n        _errorIfNotType(String, 'lcaseFirst', 'xs', xs);\r\n        return xs[0].toLowerCase() + xs.substring(1);\r\n    },\r\n\r\n    /**\r\n     * Upper cases first character of a non-empty string.\r\n     * @function module:string.ucaseFirst\r\n     * @param xs {String}\r\n     * @returns {string}\r\n     * @throws {Error} - Throws error if receiving anything that is not a string.\r\n     */\r\n    ucaseFirst = xs => {\r\n        _errorIfNotType(String, 'ucaseFirst', 'xs', xs);\r\n        return xs[0].toUpperCase() + xs.substring(1);\r\n    },\r\n\r\n    /**\r\n     * Camel cases (class case) a string.\r\n     * @function module:string.camelCase\r\n     * @param xs {String}\r\n     * @param [pattern=/[^a-z\\d/i]/] {RegExp} - Pattern to split on.  Optional.\r\n     * @throws {Error} - Throws error if param `xs` is not a string.\r\n     * @returns {string}\r\n     * @curried\r\n     */\r\n    camelCase = (xs, pattern = /[^a-z\\d]/i) => compose(\r\n            join(''),\r\n            map(str => ucaseFirst(str.toLowerCase())),\r\n            filter(x => !!x),\r\n            split(pattern)\r\n        )(_errorIfNotType(String, 'camelCase', 'xs', xs)),\r\n\r\n    /**\r\n     * Class cases a string.  Uses pattern /[^a-z\\d/i]/ to split on.\r\n     * If you require a different pattern use `string.camelCase(str, pattern)`\r\n     * and then upper case first character (`ucaseFirst`).\r\n     * @function module:string.classCase\r\n     * @param xs {String}\r\n     * @returns {string}\r\n     * @throws {Error} - Throws error if `xs` is not a string (via `camelCase` call).\r\n     */\r\n    classCase = compose(ucaseFirst, camelCase)\r\n\r\n;\r\n\r\n/**\r\n * Functional version of `String.prototype.split`.\r\n * @function module:string.split\r\n * @param separator {String|RegExp}\r\n * @param str {String}\r\n * @returns {Array}\r\n */\r\n","/**\r\n * @module fjl\r\n * @description Exports all module methods (object, list, string modules etc.).\r\n * @goal to include everything from haskell's Prelude where it makes sense in order to create\r\n *  a subset of functions which can make the javascript developer more efficient and make his/her\r\n *  code more concise (and functional).\r\n * @motivation preludejs, lodash/fp, RamdaJs, Haskell.\r\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html\r\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-List.html\r\n */\r\nexport * from './object';\r\nexport * from './boolean';\r\nexport * from './function';\r\nexport * from './list';\r\nexport * from './string';\r\nexport * from './utils';\r\nexport * from './errorThrowing';\r\nexport * from './list/utils';\r\n"],"names":["_Number","Number","name","_NaN","_Null","_Undefined","typeOf","value","retVal","undefined","constructorName","constructor","isNaN","fnOrError","symbolName","f","Function","Error","curryNotFnErrPrefix","curryN","executeArity","fn","curriedArgs","args","concatedArgs","concat","canBeCalled","length","apply","curry","argsToCurry","curry2","curry3","curry4","curry5","fPureTakesOne","arg","fPureTakes2","arg1","arg2","fPureTakes3","arg3","fPureTakes4","arg4","fPureTakes5","arg5","fPureTakesOneOrMore","instanceConstructor","instance","hasOwnProperty","x","keys","Object","assign","obj0","objs","reduce","topAgg","obj","agg","key","_String","String","_Object","_Boolean","Boolean","_Function","_Array","Array","_Symbol","_Map","_Set","_WeakMap","_WeakSet","toTypeRef","type","toTypeRefName","ref","Type","isFunction","instanceOf","isType","isOfType","isClass","test","substr","isCallable","isArray","isObject","isBoolean","isNumber","isString","isMap","isSet","isWeakMap","isWeakSet","isUndefined","isNull","isSymbol","isUsableImmutablePrimitive","typeOfX","isset","some","isEmptyList","isEmptyObject","isEmptyCollection","size","isEmpty","typeOfValue","lookup","call","of","copy","out","slice","Symbol","Promise","from","searchObj","nsString","indexOf","parts","split","limit","ind","parent","node","assignDeep","propDescription","getOwnPropertyDescriptor","get","set","writable","includes","prototype","xs","lastIndexOf","negateF","negateF2","a","b","negateF3","c","negateFN","isTruthy","isFalsy","alwaysTrue","alwaysFalse","map","push","aggregateArr$","item","sliceFrom","startInd","arr","sliceTo","toInd","sliceCopy","genericAscOrdering","lengths","lists","lengthsToSmallest","listLengths","smallLen","Math","min","list","reduceUntil","pred","op","result","reduceRightUntil","reduceRight","lastIndex","len","findIndexWhere","predicateFulfilled","findIndexWhereRight","findIndicesWhere","findWhere","elm","normalizeStep","to","step","range","i","defineReverse","reverse","filter","forEach","every","join","append","listAppend","head","last","tail","init","uncons","unconsr","concatMap","foldableOfA","foldr","intersperse","between","lastInd","foldl","intercalate","xss","transpose","numLists","ind2","longestListLen","maximum","outLists","outList","subsequences","listLen","pow","entry","j","swapped","ind1","tmp","permutations","repeat","foldl1","foldr1","mapAccumL","zero","mapped","tuple","mapAccumR","iterate","lastX","replicate","cycle","unfoldr","resultTuple","findIndex","findIndices","elemIndex","foundInd","elemIndices","take","drop","splitAt","takeWhile","dropWhile","splitPoint","list2","dropWhileEnd","span","breakOnList","at","find","partition","elem","notElem","isPrefixOf","xs1","xs2","limit1","limit2","isSuffixOf","isInfixOf","foundLen","isSubsequenceOf","lenXs1","group","groupBy","equalityOp","prevItem","predOp","inits","tails","stripPrefix","prefix","zip","arr1","arr2","a1","a2","zipN","trimmedLists","lenOfTrimmed","zip3","arr3","zip4","arr4","zip5","arr5","zipWith","zipWithN","zipWith3","xs3","zipWith4","xs4","zipWith5","xs5","unzip","unzipN","lenItem0","any","p","all","and","or","not","sum","product","sortBy","minimum","scanl","scanl1","scanr","scanr1","nub","nubBy","remove","removeBy","sort","sortOn","valueFn","decorated","a0","b0","orderingFn","insert","foundIndex","insertBy","currItem","anyOp","storedItem","removeFirstsBy","x2","unionBy","alreadyAdded","union","intersect","intersectBy","list1","difference","array1","array2","complement","arr0","arrays","objUnion","obj1","obj2","objIntersect","objDifference","objComplement","log","console","bind","error","peek","pop","jsonClone","JSON","parse","stringify","toAssocList","toAssocListDeep","TypeConstraint","fromAssocList","OutType","fromAssocListDeep","toArray","compose","arg0","flipN","flip","id","until","predicate","operation","typeInstance","typeRefsToStringOrError","types","defaultErrorMessageCall","contextName","tmplContext","valueName","expectedTypeName","foundTypeName","messageSuffix","isMultiTypeNames","typesCopy","typesToMatchCopy","_getErrorIfNotTypeThrower","errorMessageCall","typeChecker","ValueType","_getErrorIfNotTypesThrower","valueTypes","expectedTypeNames","matchFound","_errorIfNotType","_errorIfNotTypes","getErrorIfNotTypeThrower","getErrorIfNotTypesThrower","errorIfNotType","errorIfNotTypes","lines","words","unwords","unlines","lcaseFirst","toLowerCase","substring","ucaseFirst","toUpperCase","camelCase","pattern","str","classCase"],"mappings":"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"}