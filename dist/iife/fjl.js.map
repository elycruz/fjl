{"version":3,"file":"fjl.js","sources":["../../src/object/typeOf.js","../../src/function/fnOrError.js","../../src/function/curry.js","../../src/utils.js","../../src/jsPlatform/object.js","../../src/object/is.js","../../src/object/prop.js","../../src/jsPlatform/function.js","../../src/object/of.js","../../src/object/copy.js","../../src/object/searchObj.js","../../src/object/assignDeep.js","../../src/jsPlatform/list.js","../../src/function/negate.js","../../src/boolean.js","../../src/list/map.js","../../src/list/aggregation.js","../../src/list/utils.js","../../src/jsPlatform/array.js","../../src/jsPlatform/string.js","../../src/jsPlatform.js","../../src/list.js","../../src/object/setTheory.js","../../src/object/console.js","../../src/object/errorThrowing.js","../../src/object/jsonClone.js","../../src/object/assocList.js","../../src/object/toArray.js","../../src/object.js","../../src/function/compose.js","../../src/function/_curry.js","../../src/function/flip.js","../../src/function/id.js","../../src/function/until.js","../../src/function.js","../../src/string.js","../../src/fjl.js"],"sourcesContent":["/**\n * Created by elyde on 12/18/2016.\n * @memberOf object\n */\nconst _Number = Number.name,\n    _NaN = 'NaN',\n    _Null = 'Null',\n    _Undefined = 'Undefined';\n\n/**\n * Returns the constructor/class/type name of a value.\n * @note Returns 'NaN' if value is of type `Number` and value is `isNaN`.\n * @note Returns 'Undefined' if value is `undefined`\n * @note Returns 'Null' if value is `null`\n * For values that have no concrete constructors and/or casters\n * (null, NaN, and undefined) we returned normalized names for them ('Null', 'NaN', 'Number')\n * @function module:object.typeOf\n * @param value {*}\n * @returns {string} - Constructor's name or derived name (in the case of `null`, `undefined`, or `NaN` (whose\n *  normalized names are 'Null', 'Undefined', 'NaN' respectively).\n */\nexport function typeOf (value) {\n    let retVal;\n    if (value === undefined) {\n        retVal = _Undefined;\n    }\n    else if (value === null) {\n        retVal = _Null;\n    }\n    else {\n        let constructorName = (value).constructor.name;\n        retVal = constructorName === _Number && isNaN(value) ?\n            _NaN : constructorName;\n    }\n    return retVal;\n}\n","import {typeOf} from '../object/typeOf';\n\nconst\n\n    /**\n     * Throws error if `f` is not a function, else returns it (`f`).\n     * @private\n     * @param symbolName {String}\n     * @param f {*} - Expected function.\n     * @returns {Function}\n     */\n    fnOrError = (symbolName, f) => {\n        if (!f || typeof f !== 'function') {\n            throw new Error(`${symbolName} should be a function. ` +\n                `Type received: ${typeOf(f)};  Value received: ${f}.`);\n        }\n        return f;\n    }\n\n;\n\nexport default fnOrError;\n","import fnOrError from './fnOrError';\n\n/**\n * @author elydelacruz\n * @created 12/6/2016.\n * @memberOf function\n * @description \"Curry strict\" and \"curry arbitrarily\" functions (`curry`, `curryN`).\n */\n\nexport const\n\n    /**\n     * @private\n     * @type {string}\n     */\n    curryNotFnErrPrefix = '`fn` in `curry(fn, ...args)`',\n\n    /**\n     * Curries a function up to a given arity.\n     * @function module:function.curryN\n     * @param executeArity {Number}\n     * @param fn {Function}\n     * @param curriedArgs {...*}\n     * @returns {Function}\n     */\n    curryN = (executeArity, fn, ...curriedArgs) => {\n        return (...args) => {\n            let concatedArgs = curriedArgs.concat(args),\n                canBeCalled = (concatedArgs.length >= executeArity) || !executeArity;\n            return !canBeCalled ? curryN.apply(null, [executeArity, fnOrError(curryNotFnErrPrefix, fn)].concat(concatedArgs)) :\n                fnOrError(curryNotFnErrPrefix, fn).apply(null, concatedArgs);\n        };\n    },\n\n    /**\n     * Curries a function based on it's defined arity (argument's arrayOps expected length).\n     * @function module:function.curry\n     * @param fn {Function}\n     * @param argsToCurry {...*}\n     * @returns {Function}\n     */\n    curry = (fn, ...argsToCurry) => curryN(fnOrError(curryNotFnErrPrefix, fn).length, fn, ...argsToCurry),\n\n    /**\n     * Curries a function up to an arity of 2 (won't call function until 2 or more args).\n     * @function module:function.curry2\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry2 = fn => curryN(2, fn),\n\n    /**\n     * Curries a function up to an arity of 3 (won't call function until 3 or more args).\n     * @function module:function.curry3\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry3 = fn => curryN(3, fn),\n\n    /**\n     * Curries a function up to an arity of 4 (won't call function until 4 or more args).\n     * @function module:function.curry4\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry4 = fn => curryN(4, fn),\n\n    /**\n     * Curries a function up to an arity of 5 (won't call function until 5 or more args).\n     * @function module:function.curry5\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry5 = fn => curryN(5, fn);\n","import {typeOf} from './object/typeOf';\nimport {curry, curry2} from './function/curry';\n\nexport const\n\n    fPureTakesOne = name => curry((arg, f) => f[name](arg)),\n\n    fPureTakes2 = name => curry((arg1, arg2, f) => f[name](arg1, arg2)),\n\n    fPureTakes3 = name => curry((arg1, arg2, arg3, f) => f[name](arg1, arg2, arg3)),\n\n    fPureTakes4 = name => curry((arg1, arg2, arg3, arg4, f) => f[name](arg1, arg2, arg3, arg4)),\n\n    fPureTakes5 = name => curry((arg1, arg2, arg3, arg4, arg5, f) => f[name](arg1, arg2, arg3, arg4, arg5)),\n\n    fPureTakesOneOrMore = name => curry2((f, ...args) => f[name](...args)),\n\n    fnOrError = (symbolName, f) => {\n        if (!f || typeof f !== 'function') {\n            throw new Error (`${symbolName} should be a function. ` +\n                `Type received: ${typeOf(f)};  Value received: ${f}.`);\n        }\n        return f;\n    };\n","/**\n * Created by elydelacruz on 9/6/2017.\n * Defines some of the platform methods for objects (the ones used within `fjl`) uncurried for use\n * throughout the library.  @note Doesn't include all methods for objects just the ones used in\n *  the library.\n * @todo change all files named '*UnCurried' to '*_'.\n */\n\nimport {fPureTakesOne} from '../utils';\nimport {curry} from '../function/curry';\n\nexport const\n\n    /**\n     * Returns whether constructor has derived object.\n     * @function module:_jsPlatformobject.instanceOf\n     * @param instanceConstructor {Function} - Constructor.\n     * @param instance {*}\n     * @instance {*}\n     * @returns {Boolean}\n     */\n    instanceOf = curry((instanceConstructor, instance) =>\n        instance instanceof instanceConstructor),\n\n    /**\n     * @function module:_jsPlatformobject.hasOwnProperty\n     * @param propName {*}\n     * @param typeInstance {*}\n     * @returns {Boolean}\n     */\n    hasOwnProperty = fPureTakesOne('hasOwnProperty'),\n\n    /**\n     * @function module:_jsPlatformobject.length\n     * @param x {*}\n     * @returns {Number}\n     * @throws {Error} - Throws an error if value doesn't have a `length` property (\n     *  `null`, `undefined`, {Boolean}, Symbol, et. al.).\n     */\n    length = x => x.length,\n\n    /**\n     * Gets own enumerable keys of passed in object (`Object.keys`).\n     * @function module:_jsPlatformobject.keys\n     * @param obj {*}\n     * @returns {Array<String>}\n     */\n    {keys} = Object,\n\n    /**\n     * Defined as `Object.assign` else is the same thing but shimmed.\n     * @function module:_jsPlatformobject.assign\n     * @param obj0 {Object}\n     * @param objs {...{Object}}\n     * @returns {Object}\n     */\n    assign = (() => Object.assign ?\n            (obj0, ...objs) => Object.assign(obj0, ...objs) :\n            (obj0, ...objs) => objs.reduce((topAgg, obj) => {\n                return keys(obj).reduce((agg, key) => {\n                    agg[key] = obj[key];\n                    return agg;\n                }, topAgg);\n            }, obj0)\n        )();\n","/**\n * Created by elyde on 12/18/2016.\n * @memberOf object\n */\n\nimport {typeOf} from './typeOf';\nimport {instanceOf, length, keys, hasOwnProperty} from '../jsPlatform/object';\nimport {curry} from '../function/curry';\n\nlet _String = String.name,\n    _Number = Number.name,\n    _Object = Object.name,\n    _Boolean = Boolean.name,\n    _Function = Function.name,\n    _Array = Array.name,\n    _Symbol = 'Symbol',\n    _Map = 'Map',\n    _Set = 'Set',\n    _WeakMap = 'WeakMap',\n    _WeakSet = 'WeakSet',\n    _Null = 'Null',\n    _Undefined = 'Undefined';\n\nexport const\n\n    /**\n     * Returns whether a value is a function or not.\n     * @function module:object.isFunction\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isFunction = instanceOf(Function),\n\n    /**\n     * Type checker.  Note** The `Type` passed in, if a constructor, should\n     * be a named constructor/function-instance;  E.g.,\n     * ```\n     *  function SomeName () {} // or\n     *  var SomeName = function SomeName () {} // or\n     *  class SomeName {}\n     * ```\n     * @function module:object.isType\n     * @param type {Function|ObjectConstructor|String} - Constructor or constructor name\n     * @param obj {*}\n     * @return {Boolean}\n     */\n    isType = curry((type, obj) => typeOf(obj) === (isFunction(type) ? type.name : type)),\n\n    /**\n     * Checks if `value` is an es2015 `class`.\n     * @function module:object.isClass\n     * @param x {*}\n     * @returns {boolean}\n     */\n    isClass = x => x && /^\\s{0,3}class\\s{1,3}/.test((x + '').substr(0, 10)),\n\n    /**\n     * Returns a boolean depicting whether a value is callable or not.\n     * @function module:object.isCallable\n     * @tentative\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isCallable = x => isFunction(x) && !isClass(x),\n\n    /**\n     * Checks if value is an array (same as `Array.isArray`).\n     * @function module:object.isArray\n     * @param value {*}\n     * @returns {boolean}\n     */\n    {isArray} = Array,\n\n    /**\n     * Checks whether value is an object or not.\n     * @function module:object.isObject\n     * @param value\n     * @returns {Boolean}\n     */\n    isObject = isType(_Object),\n\n    /**\n     * Checks if value is a boolean.\n     * @function module:object.isBoolean\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isBoolean = isType(_Boolean),\n\n    /**\n     * Checks if value is a valid number (also checks if isNaN so that you don't have to).\n     * @function module:object.isNumber\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isNumber = isType(_Number),\n\n    /**\n     * Checks whether value is a string or not.\n     * @function module:object.isString\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isString = isType(_String),\n\n    /**\n     * Checks whether value is of `Map` or not.\n     * @function module:object.isMap\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isMap = isType(_Map),\n\n    /**\n     * Checks whether value is of `Set` or not.\n     * @function module:object.isSet\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isSet = isType(_Set),\n\n    /**\n     * Checks whether value is of `WeakMap` or not.\n     * @function module:object.isWeakMap\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isWeakMap =isType(_WeakMap),\n\n    /**\n     * Checks whether value is of `WeakSet` or not.\n     * @function module:object.isWeakSet\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isWeakSet = isType(_WeakSet),\n\n    /**\n     * Checks if value is undefined.\n     * @function module:object.isUndefined\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isUndefined = isType(_Undefined),\n\n    /**\n     * Checks if value is null.\n     * @function module:object.isNull\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isNull = isType(_Null),\n\n    /**\n     * Checks if value is a `Symbol`.\n     * @function module:object.isSymbol\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isSymbol = isType(_Symbol),\n\n    /**\n     * Checks if given `x` is set and of one of\n     *  [String, Boolean, Number, Symbol] (null and undefined are immutable\n     *  but are not \"usable\" (usually not what we want to operate on).\n     * @function module:object.isUsableImmutablePrimitive\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isUsableImmutablePrimitive = x => {\n        const typeOfX = typeOf(x);\n        return isset(x) &&\n            [_String, _Number, _Boolean, _Symbol]\n                .some(Type => Type === typeOfX);\n    },\n\n    /**\n     * Checks if !length.\n     * @function module:object.isEmptyList\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isEmptyList = x => !length(x),\n\n    /**\n     * Checks if object has own properties/enumerable-props or not.\n     * @function module:object.isEmptyObject\n     * @param obj {*}\n     * @returns {Boolean}\n     */\n    isEmptyObject = obj => isEmptyList(keys(obj)),\n\n    /**\n     * Checks if collection is empty or not (Map, WeakMap, WeakSet, Set etc.).\n     * @function module:object.isEmptyCollection\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isEmptyCollection = x => x.size === 0,\n\n    /**\n     * Checks to see if passed in value is empty;  I.e.,\n     *  check for one of '', 0, `null`, `undefined`, `false`, empty array, empty object, empty function (zero arity),\n     *  or empty collection (es6 Map, Set, WeakMap, or WeakSet etc. (`!value.size`);\n     * @function module:object.isEmpty\n     * @param value {*} - Value to check.\n     * @returns {Boolean}\n     */\n    isEmpty = value => {\n        let retVal;\n        if (!value) { // if '', 0, `null`, `undefined`, or `false` then is empty\n            retVal = true;\n        }\n        const typeOfValue = typeOf(value);\n        if (typeOfValue === _Array || typeOfValue === _Function) {\n            retVal = isEmptyList(value);\n        }\n        else if (typeOfValue === _Number) {\n            retVal = false;\n        }\n        else if (typeOfValue === _Object) {\n            retVal = isEmptyObject(value);\n        }\n        else if (hasOwnProperty('size', value) && isNumber(value.size)) {\n            retVal = isEmptyCollection(value);\n        }\n        else {\n            retVal = !value;\n        }\n        return retVal;\n    },\n\n    /**\n     * Returns whether passed in values is defined and not null or not.\n     * @function module:object.isset\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isset = x => x !== null && x !== undefined;\n","/**\n * @memberOf object\n */\n\nimport {isset} from './is';\nimport {curry} from '../function/curry';\n\n/**\n * Returns property value if found; Else `undefined`.\n * @note This method is null/undefined safe (will not throw on `null` or `undefined`).\n * @function module:object.prop\n * @param name {String} - Key to search on `obj`\n * @param obj {Object} - Object to search `name` on.\n * @returns {*}\n */\nexport const prop = curry((name, obj) => isset(obj) ? obj[name] : undefined);\n","import {curry} from '../function/curry';\n\n/**\n * Created by elydelacruz on 9/7/2017.\n * @module _jsPlatform_function\n * @private\n */\nexport const\n\n    /**\n     * Functional `apply` function (takes no context).\n     * @function module:_jsPlatform_function.apply\n     * @param fn {Function}\n     * @param args {Array|*}\n     * @returns {*}\n     */\n    apply = curry((fn, args) => fn.apply(null, args)),\n\n    /**\n     * Functional `call` function (takes no context).\n     * @function module:_jsPlatform_function.call\n     * @param fn {Function}\n     * @param args {...*}\n     * @returns {*}\n     */\n    call = (fn, ...args) => apply(fn, args);\n","import {isFunction, isset, isUsableImmutablePrimitive} from './is';\nimport {hasOwnProperty} from '../jsPlatform/object';\nimport {apply} from '../jsPlatform/function';\n\n/**\n * Creates a value `of` given type;  Checks for one of the following construction strategies (in order listed):\n * ```\n * // - If exists `(value).constructor.of` uses this.\n * // - If value is of one String, Boolean, Symbol, or Number types calls it's\n * //      constructor as a function (in cast form;  E.g., `constructor(...args)` )\n * // - Else if constructor is a function, thus far, then calls constructor using\n * //      the `new` keyword (with any passed in args).\n * ```\n * @function module:object.of\n * @param x {*} - Value to derive returned value's type from.\n * @param [args] {...*} - Any args to pass in to matched construction strategy.\n * @returns {*|undefined} - New value of given value's type else `undefined`.\n */\nexport const of = (x, ...args) => {\n    if (!isset(x)) { return undefined; }\n    const constructor = x.constructor;\n    if (hasOwnProperty('of', constructor)) {\n        return apply(constructor.of, args);\n    }\n    else if (isUsableImmutablePrimitive(x)) {\n        return apply(constructor, args);\n    }\n    else if (isFunction(constructor)) {\n        return new constructor(...args);\n    }\n    return undefined;\n};\n","import {typeOf} from './typeOf';\nimport {of} from './of';\n\nexport const\n\n    /**\n     * Make a copy of a value or optionally copy incoming value onto an outgoing value (second parameter).\n     * @note If incoming thing is an immmutable primitive (string, number, symbol, null, undefined, boolean)\n     *  it is returned as is.\n     * @function module:object.copy\n     * @param x {*} - Thing to copy.\n     * @param [out = undefined] {*} - Optional value to copy on to.  Not required.\n     * @returns {*} - Copied thing or optionally outgoing value copied onto.\n     */\n    copy = (x, out) => {\n        // if `null`, `undefined`, `''`, `0`, `false` return\n        if (!x) { return x; }\n        switch (typeOf(x)) {\n            case Array.name:\n                return !out ? x.slice(0) : Object.assign(out, x);\n\n            // If immutable primitive, return it\n            case Symbol.name:\n            case Boolean.name:\n            case String.name:\n            case Number.name:\n            case Promise.name:\n            case Function.name:\n            case 'NaN':\n            case 'Null':\n            case 'Undefined':\n                return x;\n\n            case 'Map':\n            case 'Set':\n            case 'WeakMap':\n            case 'WeakSet':\n                return new x.constructor(Array.from(x));\n\n            // Else make copy\n            default:\n                return Object.assign(!out ? of(x) : out, x);\n        }\n    }\n;\n\nexport default copy;\n","import {isset} from './is';\nimport {curry} from '../function/curry';\n\nexport const\n\n    /**\n     * Gives you value at key/namespace-key within `obj`;  E.g.,\n     * searchObj('all.your.base', {all: {your: {base: 99}}}) === 99 // `true`\n     * @note If key is unreachable (undefined) returns `undefined`.\n     *  Useful in cases where we do not want to check each key along the way before getting/checking value;  E.g.,\n     * @example\n     * ```\n     * if (obj && obj.all && obj.all.your && obj.all.your.base) {\n     *   // Thing we want to do\n     * }\n     *\n     * // So with our function becomes\n     * if (searchObj('all.your.base', obj)) {\n     *   // Thing we want to do\n     * }\n     * ```\n     * @function module:object.searchObj\n     * @param nsString {String}\n     * @param obj {*}\n     * @returns {*}\n     */\n    searchObj = curry((nsString, obj) => {\n        if (!obj) { return obj; }\n        if (nsString.indexOf('.') === -1) {\n            return obj[nsString];\n        }\n        const parts = nsString.split('.'),\n            limit = parts.length;\n        let ind = 0,\n            parent = obj;\n        for (; ind < limit; ind += 1) {\n            const node = parent[parts[ind]];\n            if (!isset(node)) {\n                return node;\n            }\n            parent = node;\n        }\n        return parent;\n    })\n;\n","\nimport {isObject} from './is';\nimport {keys, hasOwnProperty} from '../jsPlatform/object';\n\nexport const\n    /**\n     * Merges all objects down into one (takes two or more args).\n     * @function module:object.assignDeep\n     * @param obj0 {Object}\n     * @param [objs] {...{Object}} - One or more objects to merge onto `obj0`.\n     * @returns {Object}\n     */\n    assignDeep = (obj0, ...objs) =>\n        !obj0 ? obj0 : objs.reduce((topAgg, obj) =>\n            !obj ? topAgg : keys(obj).reduce((agg, key) => {\n                let propDescription = Object.getOwnPropertyDescriptor(agg, key);\n                // If property is not writable move to next item in collection\n                if (hasOwnProperty(key, agg) && propDescription &&\n                    !(propDescription.get && propDescription.set) &&\n                    !propDescription.writable) {\n                    return agg;\n                }\n                if (isObject(agg[key]) && isObject(obj[key])) {\n                    assignDeep(agg[key], obj[key]);\n                }\n                else { agg[key] = obj[key]; }\n                return agg;\n            }, topAgg)\n        , obj0);\n","/**\n *  List operations that overlap (apart from globally overlapping props and functions like `length`)\n *      on both strings and arrays.\n */\n\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from '../utils';\n\nexport const\n\n    /**\n     * Concats/appends all functors onto the end of first functor.\n     * Note:  functors passed in after the first one must be of the same type.\n     * @function module:_jsPlatform_list.concat\n     * @param functor {Array|Object|*}\n     * @param ...functor {Array|Object|*}\n     * @return {*|Array|Object} - The type passed.\n     * @throws {Error} - When passed in object doesn't have an `every` method.\n     */\n    concat = fPureTakesOneOrMore('concat'),\n\n    /**\n     * Same as Array.prototype.slice\n     * @function module:_jsPlatform_list.slice\n     * @param separator {String|RegExp}\n     * @param arr{Array}\n     * @returns {Array}\n     */\n    slice = fPureTakes2('slice'),\n\n    /**\n     * `Array.prototype.includes` or shim.\n     * @function module:_jsPlatform_list.includes\n     * @param value {*}\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    includes = (() => 'includes' in Array.prototype ?\n            fPureTakesOne('includes') :\n            (value, xs) => xs.indexOf(value) > -1)(),\n\n    /**\n     * Searches list/list-like for given element `x`.\n     * @function module:_jsPlatform_list.indexOf\n     * @param x {*} - Element to search for.\n     * @param xs {Array|String|*} - list or list like to look in.\n     * @returns {Number} - `-1` if element not found else index at which it is found.\n     */\n    indexOf = fPureTakesOne('indexOf'),\n\n    /**\n     * Last index of (`Array.prototype.lastIndexOf`).\n     * @function module:_jsPlatform_list.lastIndexOf\n     * @param x {*} - Element to search for.\n     * @param xs {Array|String|*} - list or list like to look in.\n     * @returns {Number} - `-1` if element not found else index at which it is found.\n     */\n    lastIndexOf = fPureTakesOne('lastIndexOf')\n\n;\n","/**\n * @memberOf function\n */\n\nimport {apply} from '../jsPlatform/function';\nimport {curry} from './curry';\n\nexport const\n\n    /**\n     * Negates a function that takes one/no argument.\n     * @function module:function.negateF\n     * @param fn {Function}\n     * @returns {function(*=): boolean}\n     */\n    negateF = fn => x => !fn(x),\n\n    /**\n     * Takes a function that takes two parameters and returns a negated version of given\n     * function.\n     * @function module:_negate.negateF2\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    negateF2 = fn => curry((a, b) => !fn(a, b)),\n\n    /**\n     * Takes a function that takes three parameters and returns a\n     * negated version of given function.\n     * @function module:_negate.negateF3\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    negateF3 = fn => curry((a, b, c) => !fn(a, b, c)),\n\n    /**\n     * Returns a negated version of given function.\n     * Returned function is variadiac (takes one or more arguments).\n     * @note function returned is uncurried.\n     * @uncurried\n     * @function module:function.negateFN\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    negateFN = fn => (...args) => !apply(fn, args);\n","/**\n * @module boolean\n * @description Contains functional version of 'always-true', 'always-false', 'is-truthy', and 'is-falsy'.\n */\n\nexport const\n\n    /**\n     * Returns whether `value` is 'truthy' or not\n     * @function module:boolean.isTruthy\n     * @param value\n     * @returns {Boolean}\n     */\n    isTruthy = value => !!value,\n\n    /**\n     * Returns whether `value` is 'falsy' or not\n     * @function module:boolean.isFalsy\n     * @param value\n     * @returns {Boolean}\n     */\n    isFalsy = value => !value,\n\n    /**\n     * Returns `true`.\n     * @function module:boolean.alwaysTrue\n     * @returns {Boolean}\n     */\n    alwaysTrue = () => true,\n\n    /**\n     * Returns `false`.\n     * @function module:boolean.alwaysFalse\n     * @returns {Boolean}\n     */\n    alwaysFalse = () => false;\n","import {length} from '../jsPlatform/object';\nimport {curry} from '../function/curry';\n\n/**\n * @function module:list.map\n * @param fn {Function} - Function to map on array.\n * @param xs {Array}\n * @returns {Array}\n */\nconst map = curry((fn, xs) =>  {\n    let ind = 0,\n        limit = length(xs),\n        out = [];\n    if (!limit) { return out; }\n    while (ind < limit) {\n        out.push(fn(xs[ind], ind, xs));\n        ind += 1;\n    }\n    return out;\n});\n\nexport default map;\n","\nexport const\n\n    /**\n     * Pushes incoming `item` onto array (`agg`) and return array (`agg`).\n     * @private\n     * @param agg {Array}\n     * @param item {*}\n     * @returns {Array}\n     */\n    aggregateArr$ = (agg, item) => {\n        agg.push(item);\n        return agg;\n    }\n\n;\n","/**\n * List operator utils module.\n * @module _listOpUtils\n * @private\n */\nimport {apply}          from '../jsPlatform/function';  // un-curried version\nimport {slice}          from '../jsPlatform/list';      // un-curried version good for both strings and arrays\nimport {length}         from '../jsPlatform/object';\nimport {alwaysFalse}    from '../boolean';\nimport map              from './map';\nimport {curry}          from '../function/curry';\n\nexport * from './aggregation';\n\nexport const\n\n    /**\n     * Returns a slice of the given list from `startInd` to the end of the list.\n     * @function module:listUtils.sliceFrom\n     * @param startInd {Number}\n     * @param arr {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    sliceFrom = curry((startInd, arr) => slice(startInd, undefined, arr)),\n\n    /**\n     * Slices from index `0` to given index.\n     * @function module:listUtils.sliceTo\n     * @param toInd {Number}\n     * @param xs {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    sliceTo = curry((toInd, xs) => slice(0, toInd, xs)),\n\n    /**\n     * Slices a copy of list.\n     * @function _listOpUtils.sliceCopy\n     * @param xs {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    sliceCopy = sliceFrom(0),\n\n    /**\n     * Generic 'ascending order' ordering function (use by the likes of `list.sort` etc.)\n     * @function module:listUtils.genericAscOrdering\n     * @param a {*}\n     * @param b {*}\n     * @returns {number}\n     */\n    genericAscOrdering = curry((a, b) => {\n        if (a > b) { return 1; }\n        else if (a < b) { return -1; }\n        return 0;\n    }),\n\n    /**\n     * Returns length of all passed lists in list.\n     * @function module:listUtils.lengths\n     * @param lists ...{Array|String|*}\n     * @returns {Array|String|*}\n     */\n    lengths = (...lists) => length(lists) ? map(length, lists) : [],\n\n    /**\n     * @function module:listUtils.lengthsToSmallest\n     * @param lists {...(Array|String|*)}\n     * @returns {Array|String|*}\n     */\n    lengthsToSmallest = (...lists) => {\n        const listLengths = apply(lengths, lists),\n            smallLen = Math.min.apply(Math, listLengths);\n        return map((list, ind) => listLengths[ind] > smallLen ?\n            sliceTo(smallLen, list) : sliceCopy(list), lists);\n    },\n\n    /**\n     * Reduces until predicate.\n     * @param pred\n     * @param op\n     * @param agg\n     * @param arr\n     * @returns {*}\n     */\n    reduceUntil = curry((pred, op, agg, arr) => {\n        const limit = length(arr);\n        if (!limit) { return agg; }\n        let ind = 0,\n            result = agg;\n        for (; ind < limit; ind++) {\n            if (pred(arr[ind], ind, arr)) { break; }\n            result = op(result, arr[ind], ind, arr);\n        }\n        return result;\n    }),\n\n    /**\n     * Reduces until predicate (from the right).\n     * @param pred\n     * @param op\n     * @param agg\n     * @param arr\n     * @returns {*}\n     */\n    reduceRightUntil = curry((pred, op, agg, arr) => {\n        const limit = length(arr);\n        if (!limit) { return agg; }\n        let ind = limit - 1,\n            result = agg;\n        for (; ind >= 0; ind--) {\n            if (pred(arr[ind], ind, arr)) { break; }\n            result = op(result, arr[ind], ind, arr);\n        }\n        return result;\n    }),\n\n    reduce = reduceUntil(alwaysFalse),\n\n    reduceRight = reduceRightUntil(alwaysFalse),\n\n    /**\n     * Gets last index of a list/list-like (Array|String|Function etc.).\n     * @function module:listOpUtilslastIndex\n     * @param x {Array|String|*} - list like or list.\n     * @returns {Number} - `-1` if no element found.\n     */\n    lastIndex = x => { const len = length(x); return len ? len - 1 : 0; },\n\n    /**\n     * Finds index in string or list.\n     * @function module:listOpUtilsfindIndexWhere\n     * @param pred {Function} - Predicate<element, index, arr>.\n     * @param arr {Array|String}\n     * @returns {Number} - `-1` if predicate not matched else `index` found\n     */\n    findIndexWhere = curry((pred, arr) => {\n        let ind = -1,\n            predicateFulfilled = false;\n        const limit = length(arr);\n        while (ind < limit && !predicateFulfilled) {\n            predicateFulfilled = pred(arr[++ind], ind, arr);\n        }\n        return ind;\n    }),\n\n    /**\n     * Finds index in list from right to left.\n     * @function module:listOpUtilsfindIndexWhereRight\n     * @param pred {Function} - Predicate<element, index, arr>.\n     * @param arr {Array|String}\n     * @returns {Number} - `-1` if predicate not matched else `index` found\n     */\n    findIndexWhereRight = curry((pred, arr) => {\n        const limit = length(arr);\n        let ind = limit,\n            predicateFulfilled = false;\n        for (; ind >= 0 && !predicateFulfilled; --ind) {\n            predicateFulfilled = pred(arr[ind], ind, arr);\n        }\n        return ind;\n    }),\n\n    /**\n     * @param pred {Function}\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {Array|undefined}\n     */\n    findIndicesWhere = curry((pred, xs) => {\n        if (!xs || !xs.length) { return undefined; }\n        const limit = length(xs);\n        let ind = 0,\n            out = [];\n        for (; ind < limit; ind++) {\n            if (pred(xs[ind], ind, xs)) { out.push(ind); }\n        }\n        return out.length ? out : undefined;\n    }),\n\n    /**\n     * @function module:listOpUtilsfind\n     * @param pred {Function}\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {*}\n     */\n    findWhere = curry((pred, xs) => {\n        let ind = 0,\n            limit = length(xs);\n        if (!limit) { return; }\n        for (; ind < limit; ind++) {\n            let elm = xs[ind];\n            if (pred(elm, ind, xs)) { return elm; }\n        }\n    })\n\n;\n","/**\n * Created by elyde on 7/20/2017.\n * Functional versions of common array methods (`map`, `filter`, etc.) (un-curried);\n * @module _jsPlatform_arrayOps\n * @private\n * @todo updated doc blocks to list correct/updated module name.\n */\n\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from '../utils';\n\nexport const\n\n    /**\n     * Array.prototype.reverse generator (generates a function that calls the prototype version or a\n     * shimmed version if it doesn't exist).\n     * @returns {Function}\n     */\n    defineReverse = () =>\n        Array.prototype.reverse ? x => x.reverse() :\n            x => x.reduceRight((agg, item) => {\n                agg.push(item);\n                return agg;\n            }, []),\n\n    /**\n     * Maps a function to functor (list etc.).\n     * @function module:_jsPlatform_array.map\n     * @param fn {Function}\n     * @param functor {Array|{map: {Function}}}\n     * @returns {Array|{map: {Function}}}\n     */\n    map = fPureTakesOne('map'),\n\n    /**\n     * Filters a functor (list etc.) with passed in function.\n     * @function module:_jsPlatform_array.filter\n     * @param fn {Function}\n     * @param functor {Array|{filter: {Function}}}\n     * @returns {Array|{filter: {Function}}}\n     */\n    filter = fPureTakesOne('filter'),\n\n    /**\n     * Reduces a foldable (list etc.) with passed in function.\n     * @function module:_jsPlatform_array.reduce\n     * @param fn {Function}\n     * @param functor {Array|{reduce: {Function}}}\n     * @returns {Array|{reduce: {Function}}}\n     */\n    reduce = fPureTakes2('reduce'),\n\n    /**\n     * Reduces a foldable (list etc.) from the right with passed in function.\n     * @function module:_jsPlatform_array.reduceRight\n     * @param fn {Function}\n     * @param functor {Array|{reduceRight: {Function}}}\n     * @returns {Array|{reduceRight: {Function}}}\n     */\n    reduceRight = fPureTakes2('reduceRight'),\n\n    /**\n     * For each on functor (Array|Object|etc.).\n     * @param fn {Function}\n     * @param functor {Array|Object|*}\n     * @return {*|Array|Object} - The type of object you pass in unless it doesn't have a `forEach` method.\n     * @throws {Error} - When passed in functor doesn't have a `forEach` method.\n     */\n    forEach = fPureTakesOne('forEach'),\n\n    /**\n     * Returns `true` if `fn` (predicate) returns true for at least one item\n     * in functor else returns `false`.\n     * @param fn {Function} - Predicate.\n     * @param functor {Array|Object|*}\n     * @return {*|Array|Object} - The type passed.\n     * @throws {Error} - When passed in object doesn't have a `some` method.\n     */\n    some = fPureTakesOne('some'),\n\n    /**\n     * Returns `true` if `fn` (predicate) returns true for all items in functor else returns `false`.\n     * @param fn {Function} - Predicate.\n     * @param functor {Array|Object|*}\n     * @return {*|Array|Object} - The type passed.\n     * @throws {Error} - When passed in object doesn't have an `every` method.\n     */\n    every = fPureTakesOne('every'),\n\n    /**\n     * Array.prototype.join\n     * @function module:listPrelude.join\n     * @param separator {String|RegExp}\n     * @param arr {Array}\n     * @returns {String}\n     */\n    join = fPureTakesOne('join'),\n\n    /**\n     * Same as Array.prototype.push\n     * @param item {*}\n     * @param arr {Array}\n     * @returns {Number}\n     */\n    push = fPureTakesOneOrMore('push'),\n\n    /**\n     * Reverses an list (shimmed if not exists).\n     * @function module:listPrelude.reverse\n     * @return {Array}\n     */\n    reverse = defineReverse();\n","/**\n * Created by elydelacruz on 9/6/2017.\n */\n\nimport {fPureTakesOne} from '../utils';\n\n/**\n * Functional version of `String.prototype.split`.\n * @function module:_string.split\n * @param separator {String|RegExp}\n * @param str {String}\n * @returns {Array}\n */\nexport const split = fPureTakesOne('split');\n","/**\n * @module jsPlatform_\n * @private\n */\nexport * from './jsPlatform/object';\nexport * from './jsPlatform/array';\nexport * from './jsPlatform/list';\nexport * from './jsPlatform/string';\nexport * from './jsPlatform/function';\n","/**\n * List operations module (un-curried version).\n * @module list\n */\nimport {concat as listAppend, indexOf, slice, includes} from './jsPlatform/list';\nimport {apply}              from './jsPlatform/function';\nimport {negateF3, negateF2}   from './function/negate';\nimport {isTruthy, isFalsy}  from './boolean';\nimport {prop, length}       from './object';\nimport map                  from './list/map';\nimport {curry} from './function/curry';\n\nimport {\n    sliceFrom, sliceTo, lengths,\n    lengthsToSmallest, aggregateArr$,\n    reduceUntil, reduce, reduceRight, lastIndex,\n    findIndexWhere, findIndexWhereRight, findIndicesWhere,\n    findWhere, sliceCopy, genericAscOrdering\n}\n    from './list/utils';\n\nexport {map};\n\nexport {slice, includes, indexOf, lastIndexOf, split, push} from './jsPlatform';\n\nexport const\n\n    /**\n     * Append two, or more, lists, i.e.,\n     * @example\n     * expectEqual(append(take(13, alphabetString), drop(13, alphabetString)), alphabetString); // true\n     *\n     * // Another example\n     * const result = append(\n     *   alphabetStr.split(''),\n     *   alphabetStr.split('')\n     * ),\n     * expected = repeat(2, alphabetStr).split('');\n     *\n     * shallowEquals(result, expected) === true // `true`\n     *\n     * @function module:list.append\n     * @param [args] {...(Array|String|*)} - One or more lists or list likes (strings etc.).\n     * @returns {(Array|String|*)} - Same type as list like passed in.\n     */\n    append = (...args) => {\n        const len = length(args);\n        if (!len) { return []; }\n        else if (len === 1) { return sliceCopy(args[0]); }\n        if (len >= 2) { return apply(listAppend, args); }\n        throw new Error(`'\\`append\\` requires at 2 or more arguments.  ${length(args)} args given.`);\n    },\n\n    /**\n     * Returns head of list (first item of list).\n     * @haskellType `head :: [a] -> a`\n     * @function module:list.head\n     * @param x {Array|String}\n     * @returns {*} - First item from list\n     */\n    head = x => x[0],\n\n    /**\n     * Returns last item of list.\n     * @haskellType `last :: [a] -> a`\n     * @function module:list.last\n     * @param xs {Array|String}\n     * @returns {*}\n     */\n    last = xs => xs[lastIndex(xs)],\n\n    /**\n     * Returns tail part of list (everything after the first item as new list).\n     * @haskelType `tail :: [a] -> [a]`\n     * @function module:list.tail\n     * @param xs {Array}\n     * @returns {Array}\n     */\n    tail = xs => sliceFrom(1, xs),\n\n    /**\n     * Returns everything except last item of list as new list.\n     * @haskellType `init :: [a] -> [a]`\n     * @function module:list.init\n     * @param xs {Array|String}\n     * @returns {Array|String}\n     */\n    init = xs => sliceTo(lastIndex(xs), xs),\n\n    /**\n     * Returns `head` and `tail` of passed in list/string in a tuple.\n     * @haskellType `uncons :: [a] -> Maybe (a, [a])`\n     * @function module:list.uncons\n     * @param xs {Array|String}\n     * @returns {Array|undefined}\n     */\n    uncons = xs =>\n        !xs || length(xs) === 0 ? undefined : [head(xs), tail(xs)],\n\n    /**\n     * Returns `tail` and `head` of passed in list/string in a tuple.\n     * @haskellType `unconsr :: [a] -> Maybe ([a], a)`\n     * @function module:list.unconsr\n     * @param xs {Array|String}\n     * @returns {Array|String|*|undefined}\n     */\n    unconsr = xs => !xs || length(xs) === 0 ? undefined : [init(xs), last(xs)],\n\n    /**\n     * Concatenates all the elements of a container of lists.\n     * @haskellType `concat :: Foldable t => t [a] -> [a]`\n     * @function module:list.concat\n     * @param xs {Array}\n     * @returns {Array}\n     */\n    concat = xs => !length(xs) ? sliceCopy(xs) : apply(append, xs),\n\n    /**\n     * Map a function over all the elements of a container and concatenate the resulting lists.\n     * @haskellType `concatMap :: Foldable t => (a -> [b]) -> t a -> [b]`\n     * @function module:list.concatMap\n     * @param fn {Function}\n     * @param foldableOfA {Array}\n     * @returns {Array}\n     */\n    concatMap = curry((fn, foldableOfA) => concat(map(fn, foldableOfA))),\n\n    /**\n     * Returns a copy of the passed in list reverses.\n     * @haskellType `reverse :: [a] -> [a]`\n     * @function module:list.reverse\n     * @param x {Array}\n     * @returns {Array}\n     */\n    reverse = x => foldr((agg, item) => (agg.push(item), agg), [], x),\n\n    /**\n     * Takes an element and a list and `intersperses' that element between the elements of the list. For example\n     * @function module:list.intersperse\n     * @note In our version of the function javascript is loosely typed so, so is our function (to much overhead to make\n     *  it typed) so `between` can be any value.\n     * @param between {*} - Should be of the same type of elements contained in list.\n     * @param arr {Array} - List.\n     * @returns {Array}\n     */\n    intersperse = curry((between, arr) => {\n        const limit = length(arr),\n            lastInd = limit - 1,\n            out = [];\n        if (!limit) {\n            return out;\n        }\n        return foldl((agg, item, ind) => (\n                ind === lastInd ?\n                    agg.push(item) :\n                    agg.push(item, between),\n                agg\n            ), out, arr);\n    }),\n\n    /**\n     * `intercalate xs xss` is equivalent to (concat (intersperse xs xss)). It inserts the list xs in between the lists in xss and concatenates the result.\n     * @haskellType `intercalate :: [a] -> [[a]] -> [a]`\n     * @function module:list.intercalate\n     * @param xs {Array}\n     * @param xss {Array}\n     * @returns {Array}\n     */\n    intercalate = curry((xs, xss) => concat(intersperse(xs, xss))),\n\n    /**\n     * Transposes rows and columns into lists by index;  E.g.,\n     * Haskell example:\n     * ```\n     *  transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]\n     *\n     *  -- Notice the shorter arrays are ignored after their last index is copied over:\n     *  transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]\n     * ```\n     * @note from columns to rows.\n     * @note Empty lists are ignored.\n     * @todo upgrade this function to support lists of strings.\n     * @haskellType `transpose :: [[a]] -> [[a]]`\n     * @function module:list.transpose\n     * @param xss {Array}\n     * @returns {Array}\n     */\n    transpose = xss => {\n        let numLists = length(xss),\n            ind = 0, ind2;\n        if (!numLists) {\n            return [];\n        }\n        const listLengths = apply(lengths, xss),\n            longestListLen = maximum(listLengths),\n            outLists = [];\n        for (; ind < longestListLen; ind += 1) {\n            const outList = [];\n            for (ind2 = 0; ind2 < numLists; ind2 += 1) {\n                if (listLengths[ind2] < ind + 1) {\n                    continue;\n                }\n                outList.push(xss[ind2][ind]);\n            }\n            outLists.push(outList);\n        }\n        return filter(x => length(x), outLists);\n    },\n\n    /**\n     * Generates 2^n sub-sequences for passed in sequence (string/list) (`n` is\n     * the length of the passed in sequence so: 2^length(xs)).\n     * Note: The return value doubles per index/character passed in so use with caution!\n     *  Also note that for 2^16 (or for a sequence of 16 characters) this algorithm\n     *  will generate 65536 sub-sequences!  So caution should be taken to not\n     *  use this with sequences above a certain length on certain platform (the browser thread in specific).\n     * @function module:list.subsequences\n     * @jsperftest https://jsperf.com/subsequences\n     * @param xs {Array|String}\n     * @returns {Array.<Array>}\n     */\n    subsequences = xs => {\n        const listLen = length(xs),\n            len = Math.pow(2, listLen),\n            out = [];\n        for (let i = 0; i < len; i += 1) {\n            let entry = [];\n            for (let j = 0; j < listLen; j += 1) {\n                if (i & (1 << j)) {\n                    entry.push(xs[j]);\n                }\n            }\n            out.push(entry);\n        }\n        return out;\n    },\n\n    /**\n     * Returns an array with the given indices swapped.\n     * @function module:list.swapped\n     * @param ind1 {Number}\n     * @param ind2 {Number}\n     * @param list {Array}\n     * @returns {Array} - Copy of incoming with swapped values at indices.\n     */\n    swapped = curry((ind1, ind2, list) => {\n        const out = sliceCopy(list),\n            tmp = out[ind1];\n        out[ind1] = out[ind2];\n        out[ind2] = tmp;\n        return out;\n    }),\n\n    /**\n     * Returns a list of permutations for passed in list.\n     *  Use caution with lists above a length of 15 (will take long due to nature of\n     *  algorithm).\n     * @function module:list.permutations\n     * @param xs {Array} - List.\n     * @returns {Array<Array|String|*>} - Array of permutations.\n     */\n    permutations = xs => {\n        const limit = length(xs);\n\n        if (!limit || limit === 1) {\n            return [xs];\n        }\n\n        let list = sliceCopy(xs),\n            c = repeat(limit, 0),\n            i = 0;\n\n        const out = [list];\n\n        for (; i < limit; i++) {\n            if (c[i] < i) {\n                list = swapped(i % 2 === 0 ? 0 : c[i], i, list);\n                out.push(list);\n                c[i] += 1;\n                i = 0;\n                continue;\n            }\n            c[i] = 0;\n        }\n\n        return out;\n    },\n\n    /**\n     * Left associative fold.  Reduces a container of elements down by the given operation (same as [].reduce).\n     * @function module:list.foldl\n     * @param fn {Function}\n     * @param zero {*} - Aggregator.\n     * @param functor {Array}\n     * @returns {*} - Whatever type is lastly returned from `fn`.\n     */\n    foldl = reduce,\n\n    /**\n     * Right associative fold.  Reduces a container of elements down by the given operation (same as [].reduceRight).\n     * @function module:list.foldr\n     * @param fn {Function}\n     * @param zero {*} - Aggregator.\n     * @param functor {Array}\n     * @returns {*} - Whatever type is lastly returned from `fn`.\n     */\n    foldr = reduceRight,\n\n    /**\n     * A variant of `foldl` except that this one doesn't require the starting point.  The starting point/value will be pulled\n     * out from a copy of the container.\n     * @function module:list.foldl1\n     * @param op {Function}\n     * @param xs {Array}\n     * @returns {*} - Whatever type is lastly returned from `op`.\n     */\n    foldl1 = curry((op, xs) => {\n        const parts = uncons(xs);\n        return !parts ? [] : reduce(op, parts[0], parts[1]);\n    }),\n\n    /**\n     * A variant of `foldr` except that this one doesn't require the starting point/value.  The starting point/value will be pulled\n     * out from a copy of the container.\n     * @function module:list.foldr1\n     * @param op {Function}\n     * @param xs {Array}\n     * @returns {*} - Whatever type is lastly returned from `op`.\n     */\n    foldr1 = curry((op, xs) => {\n        const parts = unconsr(xs);\n        return !parts ? [] : reduceRight(op, parts[1], parts[0]);\n    }),\n\n    /**\n     * Performs a map then a reduce all in one (from left-to-right). Returns a tuple\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\n     * @function module:list.mapAccumL\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\n     * @param xs {Array} - list type.\n     * @return {Array} - [aggregated, list]\n     */\n    mapAccumL = curry((op, zero, xs) => {\n        const list = sliceCopy(xs),\n            limit = length(xs);\n        if (!limit) {\n            return [zero, list];\n        }\n        let ind = 0,\n            agg = zero,\n            mapped = [],\n            tuple;\n        for (; ind < limit; ind++) {\n            tuple = op(agg, list[ind], ind);\n            agg = tuple[0];\n            mapped = tuple[1];\n        }\n        return [agg, mapped];\n    }),\n\n    /**\n     * Performs a map and a reduce all in one (from right-to-left). Returns a tuple\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\n     * @function module:list.mapAccumR\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\n     * @param xs {Array} - list type.\n     * @return {Array} - [aggregated, list]\n     */\n    mapAccumR = curry((op, zero, xs) => {\n        const list = sliceCopy(xs),\n            limit = length(xs);\n        if (!limit) {\n            return [zero, list];\n        }\n        let ind = limit - 1,\n            agg = zero,\n            mapped = [],\n            tuple;\n        for (; ind >= 0; ind--) {\n            tuple = op(agg, list[ind], ind);\n            agg = tuple[0];\n            mapped = tuple[1];\n        }\n        return [agg, mapped];\n    }),\n\n    /**\n     * iterate f x returns an infinite list of repeated applications of f to x.\n     * @function module:list.iterate\n     * @example `iterate(5, f, x) == [x, f(x), f(f(x)), ...]`\n     * @param limit {Number}\n     * @param op {Function} - Operation.\n     * @param x {*} - Starting point.\n     * @returns {*}\n     */\n    iterate = curry((limit, op, x) => {\n        let ind = 0,\n            out = [],\n            lastX = x;\n        for (; ind < limit; ind += 1) {\n            out.push(lastX);\n            lastX = op(lastX, ind);\n        }\n        return out;\n    }),\n\n    /**\n     * Repeats `x` `limit` number of times.\n     * @function module:list.repeat\n     * @param limit {Number}\n     * @param x {*}\n     * @return {Array}\n     */\n    repeat = curry((limit, x) => iterate(limit, a => a, x)),\n\n    /**\n     * Same as `repeat` due to the nature of javascript (see haskell version for usage).\n     * @function module:list.replicate\n     * @param limit {Number}\n     * @param x {*}\n     * @return {Array}\n     */\n    replicate = repeat,\n\n    /**\n     * Replicates a list `limit` number of times and appends the results (concat)\n     * @function module:list.cycle\n     * @param limit {Number}\n     * @param xs {Array}\n     * @returns {Array}\n     */\n    cycle = curry((limit, xs) => concat(replicate(limit, xs))),\n\n    /**\n     * Unfolds a value into a list of somethings.\n     * @haskellType `unfoldr :: (b -> Maybe (a, b)) -> b -> [a]`\n     * @function module:list.unfoldr\n     * @param op {Function} - Operation to perform (should return a two component tuple (item to aggregate and item to unfold in next iteration).\n     * @param x {*} - Starting parameter to unfold from.\n     * @returns {Array} - An array of whatever you return from `op` yielded.\n     */\n    unfoldr = curry((op, x) => {\n        let ind = 0,\n            out = [],\n            resultTuple = op(x, ind, out);\n        while (resultTuple) {\n            out.push(resultTuple[0]);\n            resultTuple = op(resultTuple[1], ++ind, out);\n        }\n        return out;\n    }),\n\n    /**\n     * Finds index in string or list (alias for `findIndex`).\n     * @function module:list.findIndex\n     * @param pred {Function} - Predicate<element, index, arr>.\n     * @param arr {Array|String}\n     * @returns {Number} - `-1` if predicate not matched else `index` found\n     */\n    findIndex = findIndexWhere,\n\n    /**\n     * @function module:list.findIndices\n     * @param pred {Function}\n     * @param xs {Array} - list or list like.\n     * @returns {Array|undefined}\n     */\n    findIndices = findIndicesWhere,\n\n    /**\n     * @function module:list.elemIndex\n     * @param x {*} - Element to search for.\n     * @param xs {Array} - list or list like.\n     * @returns {*}\n     */\n    elemIndex = curry((x, xs) => {\n        const foundInd = indexOf(x, xs);\n        return foundInd !== -1 ? foundInd : undefined;\n    }),\n\n    /**\n     * @function module:list.elemIndices\n     * @param value {*} - Element to search for.\n     * @param xs {Array} - list or list like.\n     * @returns {*}\n     */\n    elemIndices = curry((value, xs) => findIndices(x => x === value, xs)),\n\n    /**\n     * Takes `n` items from start of list to `limit` (exclusive).\n     * @function module:list.take\n     * @param list {Array|String}\n     * @param limit {Number}\n     * @returns {String|Array} - Passed in type's type\n     */\n    take = sliceTo,\n\n    /**\n     * Drops `n` items from start of list to `count` (exclusive).\n     * @function module:list.drop\n     * @param list {Array|String}\n     * @param count {Number}\n     * @returns {String|Array} - Passed in type's type\n     */\n    drop = sliceFrom,\n\n    /**\n     * Splits `x` in two at given `index` (exclusive (includes element/character at\n     * given index in second part of returned list)).\n     * @function module:list.splitAt\n     * @param ind {Number} - Index to split at.\n     * @param list {Array} - functor (list or string) to split.\n     * @returns {Array} - Array of whatever type `x` was when passed in\n     */\n    splitAt = (ind, list) => [ sliceTo(ind, list), sliceFrom(ind, list) ],\n\n    /**\n     * Gives an list with passed elements while predicate was true.\n     * @function module:list.takeWhile\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @returns {Array}\n     */\n    takeWhile = curry((pred, list) =>\n        reduceUntil(\n            negateF3(pred),  // predicate\n            aggregateArr$,   // operation\n            [],             // aggregator\n            list\n        )),\n\n    /**\n     * Returns an list without elements that match predicate.\n     * @function module:list.dropWhile\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @refactor\n     * @returns {Array|String}\n     */\n    dropWhile = curry((pred, list) => {\n        const limit = length(list),\n            splitPoint =\n                findIndexWhere((item, ind, list2) =>\n                    !pred(list[ind], ind, list2), list);\n\n        return splitPoint === -1 ?\n            sliceTo(limit, list) :\n            slice(splitPoint, limit, list);\n    }),\n\n    /**\n     * @function module:list.dropWhileEnd\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @refactor\n     * @returns {Array|String}\n     */\n    dropWhileEnd = curry((pred, list) => {\n        const limit = length(list),\n            splitPoint =\n                findIndexWhereRight((item, ind, list2) =>\n                    !pred(list[ind], ind, list2), list);\n\n        return splitPoint === -1 ?\n            sliceTo(limit, list) :\n            sliceTo(splitPoint + 1, list);\n    }),\n\n    /**\n     * Gives a span such that the first list (in returned tuple) is the span of items matching upto `not predicate` and\n     * the second list in the tuple is a list of the remaining elements in the given list.\n     * **@Note: Not the same as `partition`.  Read descriptions closely!!!\n     * @function module:list.span\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\n     * @param list {Array} - Predicate<item, index, originalArrayOrString>\n     * @returns {Array} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\n     */\n    span = curry((pred, list) => {\n        const splitPoint = findIndexWhere(negateF3(pred), list);\n        return splitPoint === -1 ?\n            splitAt(0, list) : splitAt(splitPoint, list);\n    }),\n\n    /**\n     * breakOnList, applied to a predicate p and a list xs, returns a tuple\n     * where first element is longest prefix (possibly empty) of xs of elements\n     * that do not satisfy p and second element is the remainder of the list:\n     * @haskellExample\n     * Replace `break` with `breakOnList` for our version.\n     * ```\n     * break (> 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])\n     * break (< 9) [1,2,3] == ([],[1,2,3])\n     * break (> 9) [1,2,3] == ([1,2,3],[])\n     * ```\n     * @function module:list.breakOnList\n     * @param pred {Function}\n     * @param list {Array|String|*}\n     * @returns {Array}\n     */\n    breakOnList = curry((pred, list) => {\n        const splitPoint = findIndexWhere(pred, list);\n        return splitPoint === -1 ?\n            splitAt(0, list) : splitAt(splitPoint, list);\n    }),\n\n    /**\n     * Gets item at index.\n     * @function module:list.at\n     * @param ind {Number} - Index.\n     * @param xs {Array} - list or list like.\n     * @returns {*|undefined} - Item or `undefined`.\n     */\n    at = prop,\n\n    /**\n     * Find an item in structure of elements based on given predicate (`pred`).\n     * @function module:list.find\n     * @param pred {Function}\n     * @param xs {Array} - list or list like.\n     * @returns {*} - Found item.\n     */\n    find = findWhere,\n\n    /**\n     * Filters a structure of elements using given predicate (`pred`) (same as `[].filter`).\n     * @function module:list.filter\n     * @param pred {Function}\n     * @param xs {Array} - list or list like.\n     * @returns {Array} - Structure of filtered elements.\n     */\n    filter = curry((pred, xs) => {\n        let ind = 0,\n            limit = length(xs),\n            out = [];\n        if (!limit) {\n            return out;\n        }\n        for (; ind < limit; ind++) {\n            if (pred(xs[ind], ind, xs)) {\n                out.push(xs[ind]);\n            }\n        }\n        return out;\n    }),\n\n    /**\n     * Partitions a list on a predicate;  Items that match predicate are in first list in tuple;  Items that\n     * do not match the tuple are in second list in the returned tuple.\n     *  Essentially `[filter(p, xs), filter(negateF3(p), xs)]`.\n     * @function module:list.partition\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\n     * @param list {Array}\n     * @returns {Array|String} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\n     */\n    partition = curry((pred, list) =>\n        !length(list) ?\n            [[], []] :\n                [filter(pred, list), filter(negateF3(pred), list)]),\n\n    /**\n     * Returns a boolean indicating whether an element exists in given structure of elements.\n     * @function module:list.elem\n     * @param element {*}\n     * @param xs {Array}\n     * @returns {Boolean}\n     */\n    elem = includes,\n\n    /**\n     * The opposite of `elem` - Returns a boolean indicating whether an element exists in given list.\n     * @function module:list.notElem\n     * @param element {*}\n     * @param xs {Array}\n     * @returns {Boolean}\n     */\n    notElem = negateF2(includes),\n\n    /**\n     * Same as list.at - Returns property value at key/indice.\n     * @function module:object.lookup\n     * @type {module:object.prop}\n     */\n    lookup = at,\n\n    /**\n     * Checks if list `xs1` is a prefix of list `xs2`\n     * @function module:list.isPrefixOf\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @returns {boolean}\n     */\n    isPrefixOf = curry((xs1, xs2) => {\n        const limit1 = length(xs1),\n            limit2 = length(xs2);\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\n            return false;\n        }\n        let ind = 0;\n        for (; ind < limit1; ind++) {\n            if (xs1[ind] !== xs2[ind]) {\n                return false;\n            }\n        }\n        return true;\n    }),\n\n    /**\n     * Checks if list `xs1` is a suffix of list `xs2`\n     * @function module:list.isSuffixOf\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @returns {boolean}\n     */\n    isSuffixOf = curry((xs1, xs2) => {\n        const limit1 = length(xs1),\n            limit2 = length(xs2);\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\n            return false;\n        }\n        let ind1 = limit1 - 1,\n            ind2 = limit2 - 1;\n        for (; ind1 >= 0; ind1--) {\n            if (xs1[ind1] !== xs2[ind2]) {\n                return false;\n            }\n            ind2 -= 1;\n        }\n        return true;\n    }),\n\n    /**\n     * Checks if list `xs1` is an infix of list `xs2`\n     * @function module:list.isInfixOf\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @returns {boolean}\n     */\n    isInfixOf = curry((xs1, xs2) => {\n        const limit1 = length(xs1),\n            limit2 = length(xs2);\n        if (limit2 < limit1 || !limit1 || !limit2) {\n            return false;\n        }\n        let ind1,\n            foundLen,\n            ind = 0;\n        for (; ind < limit2; ind += 1) {\n            foundLen = 0;\n            for (ind1 = 0; ind1 < limit1; ind1 += 1) {\n                if (xs2[ind1 + ind] === xs1[ind1]) {\n                    foundLen += 1;\n                }\n                if (foundLen === limit1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }),\n\n    /**\n     * Checks if list `xs1` is a sub-sequence of list `xs2`\n     * @function module:list.isSubsequenceOf\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @returns {boolean}\n     */\n    isSubsequenceOf = curry((xs1, xs2) => {\n        const len = Math.pow(2, length(xs2)),\n            lenXs1 = length(xs1);\n        let foundLen,\n            i;\n        for (i = 0; i < len; i += 1) {\n            foundLen = 0;\n            for (let j = 0; j < len; j += 1) {\n                if (i & (1 << j) && indexOf(xs2[j], xs1) > -1) {\n                    foundLen += 1;\n                }\n                if (foundLen === lenXs1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }),\n\n    /**\n     * The group function takes a list and returns a list of lists such that\n     *  the concatenation of the result is equal to the argument. Moreover, each\n     *  sublist in the result contains only equal elements. For example,\n     * `group \"Mississippi\" = [\"M\",\"i\",\"ss\",\"i\",\"ss\",\"i\",\"pp\",\"i\"]`\n     * It is a special case of groupBy, which allows the programmer to supply\n     *  their own equality test.\n     * @haskellType `group :: Eq a => [a] -> [[a]]`\n     * @function module:list.group\n     * @param xs {Array}\n     * @returns {Array<Array|String|*>|*}\n     */\n    group = xs => groupBy((a, b) => a === b, xs),\n\n    /**\n     * Allows you to group items in a list based on your supplied equality check.\n     * @note Sames `group` but allows you to specify equality operation.\n     * @haskellType `groupBy :: (a -> a -> Bool) -> [a] -> [[a]]`\n     * @function module:list.groupBy\n     * @param equalityOp {Function}\n     * @param xs {Array}\n     * @returns {*}\n     */\n    groupBy = curry((equalityOp, xs) => {\n        const limit = length(xs);\n        if (!limit) {\n            return sliceCopy(xs);\n        }\n        let ind = 0,\n            prevItem,\n            item,\n            predOp = x => {\n                if (equalityOp(x, prevItem)) {\n                    ind++;\n                }\n                if (equalityOp(x, item)) {\n                    prevItem = x;\n                    return true;\n                }\n                return false;\n            },\n            agg = [];\n        for (; ind < limit; ind += 1) {\n            item = xs[ind];\n            agg.push(takeWhile(predOp, slice(ind, limit, xs)));\n        }\n        return agg;\n    }),\n\n    /**\n     * The inits function returns all initial segments of the argument, shortest first. For example,\n     * ```\n     * shallowEquals(inits('abc'), ['','a','ab','abc'])\n     * ```\n     * @function module:list.inits\n     * @haskellType `inits :: [a] -> [[a]]`\n     * @param xs {Array}\n     * @returns {Array}\n     */\n    inits = xs => {\n        let limit = length(xs),\n            ind = 0,\n            agg = [];\n        if (!limit) {\n            return [];\n        }\n        for (; ind <= limit; ind += 1) {\n            agg.push(sliceTo(ind, xs));\n        }\n        return agg;\n    }, //map(list => init(list), xs),\n\n    /**\n     * The inits function returns all initial segments of the argument, shortest first. For example,\n     * ```\n     * shallowEquals(tails('abc'), ['abc', 'bc', 'c',''])\n     * ```\n     * @function module:list.tails\n     * @haskellType `tails :: [a] -> [[a]]`\n     * @param xs {Array}\n     * @returns {Array}\n     */\n    tails = xs => {\n        let limit = length(xs),\n            ind = 0,\n            agg = [];\n        if (!limit) {\n            return [];\n        }\n        for (; ind <= limit; ind += 1) {\n            agg.push(slice(ind, limit, xs));\n        }\n        return agg;\n    }, //map(list => tail(list), xs),\n\n    /**\n     * Strips prefix list from given list\n     * @function module:list.stripPrefix\n     * @param prefix {Array|String|*}\n     * @param list {Array|string|*}\n     * @returns {Array|*}\n     */\n    stripPrefix = curry((prefix, list) =>\n        isPrefixOf(prefix, list) ?\n            splitAt(length(prefix), list)[1] :\n            sliceCopy(list)),\n\n    /**\n     * zip takes two lists and returns a list of corresponding pairs.\n     * If one input list is short, excess elements of the longer list are discarded.\n     * @haskellType `zip :: [a] -> [b] -> [(a, b)]`\n     * @function module:list.zip\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip = curry((arr1, arr2) => {\n        if (!length(arr1) || !length(arr2)) {\n            return [];\n        }\n        const [a1, a2] = lengthsToSmallest(arr1, arr2);\n        return reduce((agg, item, ind) =>\n                aggregateArr$(agg, [item, a2[ind]]),\n            [], a1);\n    }),\n\n    /**\n     * zipN takes one or more lists and returns a list containing lists of all indices\n     * at a given index, index by index.\n     * If one input list is short, excess elements of the longer list are discarded.\n     * @function module:list.zipN\n     * @param lists {Array|String} - One ore more lists of the same type.\n     * @returns {Array}\n     */\n    zipN = (...lists) => {\n        const trimmedLists = apply(lengthsToSmallest, filter(length, lists)),\n            lenOfTrimmed = length(trimmedLists);\n        if (!lenOfTrimmed) {\n            return [];\n        }\n        else if (lenOfTrimmed === 1) {\n            return sliceTo(length(trimmedLists[0]), trimmedLists[0]);\n        }\n        return reduce((agg, item, ind) =>\n                aggregateArr$(agg, map(xs => xs[ind], trimmedLists)),\n            [], trimmedLists[0]);\n    },\n\n    /**\n     * @haskellType `zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]`\n     * @function module:list.zip3\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @param arr3 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip3 = curry((arr1, arr2, arr3) => zipN(arr1, arr2, arr3)),\n\n    /**\n     * @haskellType `zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]`\n     * @function module:list.zip4\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @param arr3 {Array}\n     * @param arr4 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip4 = curry((arr1, arr2, arr3, arr4) => zipN(arr1, arr2, arr3, arr4)),\n\n    /**\n     * @haskellType `zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]`\n     * @function module:list.zip5\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @param arr3 {Array}\n     * @param arr4 {Array}\n     * @param arr5 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip5 = curry((arr1, arr2, arr3, arr4, arr5) => zipN(arr1, arr2, arr3, arr4, arr5)),\n\n    /**\n     * zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\n     * zipWith generalises zip by zipping with the function given as the\n     * first argument, instead of a function tupling function (function that returns a tuple). For example,\n     * zipWith (+) is applied to two lists to produce the list of corresponding sums.\n     * @note `_|_` means bottom or perpetual (@see\n     *  - https://wiki.haskell.org/Bottom\n     *  - https://stackoverflow.com/questions/19794681/what-does-this-syntax-mean-in-haskell-or\n     *  )\n     * @example\n     * ```\n     * zipWith f [] _|_ = []\n     * ```\n     * @haskellType `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`\n     * @function module:list.zipWith\n     * @param op {Function} - Takes two parts of a tuple and returns a tuple.\n     *  E.g., ` op :: a -> b -> (a, b)`\n     * @param xs1 {Array}\n     * @param xs2 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith = curry((op, xs1, xs2) => {\n        if (!length(xs1) || !length(xs2)) {\n            return [];\n        }\n        const [a1, a2] = lengthsToSmallest(xs1, xs2);\n        return reduce((agg, item, ind) =>\n                aggregateArr$(agg, op(item, a2[ind])),\n            [], a1);\n    }),\n\n    /**\n     * Zips all given lists with tupling function. Note: Haskell types do not have\n     *  a way (that I know of) to show one or more for params in a function so `@haskellType` below\n     *  is left there for general purpose not for exactness as is told by aforementioned.\n     * @haskellType `zipWithN :: (a -> b -> c) -> [a] -> [b] -> [c]` - Where `N` is the number\n     *  of lists to zip.\n     * @function module:list.zipWithN\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\n     * @param lists ...{Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWithN = (op, ...lists) => {\n        const trimmedLists = apply(lengthsToSmallest, lists),\n            lenOfTrimmed = length(trimmedLists);\n        if (!lenOfTrimmed) {\n            return [];\n        }\n        else if (lenOfTrimmed === 1) {\n            return sliceTo(length(trimmedLists[0]), trimmedLists[0]);\n        }\n        return reduce((agg, item, ind) =>\n                aggregateArr$(agg, apply(op, map(xs => xs[ind], trimmedLists))),\n            [], trimmedLists[0]);\n    },\n\n    /**\n     * Zips 3 lists with tupling function.\n     * @haskellType `zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]`\n     * @function module:list.zipWith3\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\n     * @param xs1 {Array}\n     * @param xs2 {Array}\n     * @param xs3 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith3 = curry((op, xs1, xs2, xs3) => zipWithN(op, xs1, xs2, xs3)),\n\n    /**\n     * Zips 4 lists with tupling function.\n     * @haskellType `zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c]  -> [d] -> [e]`\n     * @function module:list.zipWith4\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> d -> (a, b, c, d)`\n     * @param xs1 {Array}\n     * @param xs2 {Array}\n     * @param xs3 {Array}\n     * @param xs4 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith4 = curry((op, xs1, xs2, xs3, xs4) => zipWithN(op, xs1, xs2, xs3, xs4)),\n\n    /**\n     * Zips 5 lists.\n     * @haskellType `zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c]  -> [d] -> [e] -> [f]`\n     * @function module:list.zipWith5\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> d -> e -> (a, b, c, d, e)`\n     * @param xs1 {Array}\n     * @param xs2 {Array}\n     * @param xs3 {Array}\n     * @param xs4 {Array}\n     * @param xs5 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith5 = curry((op, xs1, xs2, xs3, xs4, xs5) => zipWithN(op, xs1, xs2, xs3, xs4, xs5)),\n\n    /**\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\n     * @haskellType `unzip :: [(a, b)] -> ([a], [b])`\n     * @todo Should support other list types (should not have `push` hard coded instead should use `mappend` (if available)).\n     * @function module:list.unzip\n     * @param arr {Array|*}\n     * @returns {Array|*}\n     */\n    unzip = arr =>\n        foldl((agg, item) => {\n            agg[0].push(item[0]);\n            agg[1].push(item[1]);\n            return agg;\n        }, [[], []], arr),\n\n    /**\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\n     * @sudoHaskellType `unzipN :: [(a, b, ...x)] -> ([a], [b], ...[x])`\n     * @todo Should support other list types (should not have `push` hard coded instead should use `mappend` (if available)).\n     * @function module:list.unzipN\n     * @param list {Array|*} - List of tuples (lists).\n     * @returns {Array|*}\n     */\n    unzipN = list => {\n        if (!length(list)) {\n            return [];\n        }\n        const lenItem0 = length(list[0]);\n        let zero = lenItem0 ?\n            unfoldr(numLists => numLists-- ? [[], numLists] : undefined, lenItem0) :\n            [];\n        return foldl((agg, item) => {\n            agg.forEach((outList, ind) => outList.push(item[ind]));\n            return agg;\n        }, zero, list);\n    },\n\n    /**\n     * Returns true if any item in container passes predicate `p`.\n     * @function module:list.any\n     * @param p {Function} - Predicate.\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    any = curry((p, xs) => {\n        let ind = 0,\n            limit = length(xs);\n        if (!limit) {\n            return false;\n        }\n        for (; ind < limit; ind += 1) {\n            if (p(xs[ind])) {\n                return true;\n            }\n        }\n        return false;\n    }),\n\n    /**\n     * Returns true if all items in container pass predicate `p`.\n     * @function module:list.all\n     * @param p {Function} - Predicate.\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    all = curry((p, xs) => {\n        const limit = length(xs);\n        let ind = 0;\n        if (limit === 0) {\n            return false;\n        }\n        for (; ind < limit; ind++) {\n            if (!p(xs[ind], ind, xs)) {\n                return false;\n            }\n        }\n        return true;\n    }),\n\n    /**\n     * Conjuction of container of bools (or truthy and/or falsy values);  Returns\n     * `true` if all in container are 'truthy' else returns `false`\n     * @function module:list.and\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    and = xs => all(isTruthy, xs),\n\n    /**\n     * Returns a boolean indicating whether any item in container is 'truthy' or not.\n     * **Note** The haskell type for this function only takes two items, but here\n     * we allow the passing of more than one item (may change later to adhere to the haskell type).\n     * @function module:list.or\n     * @haskellType `or :: Bool -> Bool -> Bool`\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    or = xs => any(isTruthy, xs),\n\n    /**\n     * Returns a boolean indicating whether all items in container are 'falsy' or not.\n     * **Note** The haskell type for this function only takes two items, but here\n     * we allow the passing of more than one item (may change later to adhere to the haskell type).\n     * @function module:list.not\n     * @haskellType `not :: Bool -> Bool`\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    not = xs => all(isFalsy, xs),\n\n    /**\n     * Computes the sum of the numbers of a structure.\n     * @function module:list.sum\n     * @haskellType `sum :: (List t, Num a) => t a -> a`\n     * @param list {Array|String}\n     * @returns {Number}\n     */\n    sum = list => foldl((agg, x) => agg + x, 0, list),\n\n    /**\n     * Computes the product of the numbers of a structure.\n     * @function module:list.product\n     * @haskellType `product :: (List t, Num a) => t a -> a`\n     * @param list {Array|String}\n     * @returns {Number}\n     */\n    product = list => foldl((agg, x) => agg * x, 1, list),\n\n    /**\n     * Returns the largest element in a non-empty structure of elements.\n     * @function module:list.maximum\n     * @haskellType `maximum :: forall a . Ord a => t a -> a`\n     * @param list {Array|String}\n     * @returns {*} - Whatever type the array is made of (if any).\n     */\n    maximum = list => last(sortBy(genericAscOrdering, list)),\n\n    /**\n     * Returns the smallest element in a non-empty structure of elements.\n     * @function module:list.minimum\n     * @haskellType `minimum :: forall a . Ord a => t a -> a`\n     * @param list {Array|String}\n     * @returns {*} - Whatever type the array is made of (if any).\n     */\n    minimum = list => head(sortBy(genericAscOrdering, list)),\n\n    /**\n     * scanl is similar to foldl, but returns a list of successive reduced values from the left:\n     * ```\n     * scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]\n     * ```\n     * Also note that:\n     * ```\n     * last (scanl f z xs) == foldl f z xs.\n     * ```\n     * @function module:list.scanl\n     * @param fn {Function}\n     * @param zero {*}\n     * @param xs {Array}\n     * @returns {Array|*}\n     */\n    scanl = curry((fn, zero, xs) => {\n        if (!xs || !length(xs)) {\n            return [];\n        }\n        const limit = length(xs);\n        let ind = 0,\n            result = zero,\n            out = [];\n        while (ind < limit) {\n            result = fn(result, xs[ind], ind, xs);\n            out.push(result);\n            ind++;\n        }\n        return out;\n    }),\n\n    /**\n     * `scanl1` is a variant of `scanl` that has no starting value argument:\n     * `shallowCompare(scanl1(fn, [x1, x2, ...]), [x1, fn(x1, x2), ...]) // true`\n     * @function module:list.scanl1\n     * @param fn {Function}\n     * @param xs {Array}\n     * @returns {Array|*}\n     */\n    scanl1 = curry((fn, xs) => {\n        if (!xs || !xs.length) { return []; }\n        return scanl(fn, head(xs), tail(xs));\n    }),\n\n    /**\n     * Same as `scanl` but from the right (similiar to `foldr`'s relationship to `foldl`).\n     * Note also `scanr`'s relationship ot `foldr`:\n     * `head (scanr(fn, z, xs)) === foldr(fn, z, xs).\n     * @function module:list.scanr\n     * @param fn {Function}\n     * @param zero {*}\n     * @param xs {Array}\n     * @returns {Array|*}\n     */\n    scanr = curry((fn, zero, xs) => {\n        if (!xs || !length(xs)) {\n            return [];\n        }\n        const limit = length(xs);\n        let ind = limit - 1,\n            result = xs[0],\n            out = [];\n        while (ind > -1) {\n            result = fn(result, xs[ind], ind, xs);\n            out.push(result);\n            ind--;\n        }\n        return out;\n    }),\n\n    /**\n     * Same as `scanr` but takes no zero/accumulator value.\n     * @function module:list.scanr1\n     * @param fn {Function}\n     * @param xs {Array}\n     * @returns {Array|*}\n     */\n    scanr1 = curry((fn, xs) => {\n        if (!xs || !xs.length) { return []; }\n        return scanr(fn, last(xs), init(xs));\n    }),\n\n    /**\n     * The nub function removes duplicate elements from a list.\n     * In particular, it keeps only the first occurrence of each element.\n     * (The name nub means `essence'.) It is a special case of nubBy, which\n     * allows the programmer to supply their own equality test.\n     * ```shallowCompare( nub ([1,2,3,4,3,2,1,2,4,3,5]), [1,2,3,4,5] )```\n     * @function module:list.nub\n     * @param list {Array|String|*}\n     * @returns {Array}\n     */\n    nub = list => nubBy((a, b) => a === b, list),\n\n    /**\n     * `remove(x, xs)` removes the first occurrence of `x` from `xs`.\n     * For example, `remove('a', 'banana') === 'bnana';`\n     * @function module:list.remove\n     * @param x {*}\n     * @param list {Array|String|*}\n     * @returns {Array}\n     */\n    remove = curry((x, list) => removeBy((a, b) => a === b, x, list)),\n\n    /**\n     * The sort function implements a stable sorting algorithm.\n     * It is a special case of sortBy, which allows the programmer\n     * to supply their own comparison function.\n     * ```shallowCompare(sort ([1,6,4,3,2,5]), [1,2,3,4,5,6]) // true```\n     * @function module:list.sort\n     * @param xs {Array|String|*}\n     * @returns {Array}\n     */\n    sort = xs => sortBy(genericAscOrdering, xs),\n\n    /**\n     * Sort a list by comparing the results of a key function applied to each\n     * element. sortOn f is equivalent to sortBy (comparing f), but has the\n     * performance advantage of only evaluating f once for each element in the\n     * input list. This is called the decorate-sort-undecorate paradigm, or\n     * Schwartzian transform.\n     *\n     * Elements are arranged from from lowest to highest, keeping duplicates\n     * in the order they appeared in the input.\n     *\n     * Ex:\n     * ```\n     * shallowEquals(\n     *  sortOn (head, [[2, \"world\"], [4, \"!\"], [1, \"Hello\"]]),\n     *  [[1,\"Hello\"],[2,\"world\"],[4,\"!\"]]\n     * ) // true\n     * ```\n     * @function module:list.sortOn\n     * @param valueFn {Function}\n     * @param xs {Array|String|*}\n     * @returns {Array}\n     */\n    sortOn = curry((valueFn, xs) =>\n\n        // Un-decorate\n        map(decorated => decorated[1],\n\n            // Decorate and sort\n            sortBy(\n                // Ordering\n                ([a0], [b0]) => genericAscOrdering(a0, b0),\n\n                // Decorate\n                map(item => [valueFn(item), item], xs)\n            )\n        )\n    ),\n\n    /**\n     * The sortBy function is the non-overloaded (in haskell terms) version of sort.\n     * @haskellExample ```\n     *  >>> sortBy (\\(a,_) (b,_) -> compare a b) [(2, \"world\"), (4, \"!\"), (1, \"Hello\")]\n     *  [(1,\"Hello\"),(2,\"world\"),(4,\"!\")]\n     * ```\n     * @function module:list.sortBy\n     * @param orderingFn {Function}\n     * @param xs {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    sortBy = curry((orderingFn, xs) => sliceCopy(xs).sort(orderingFn || genericAscOrdering)),\n\n    /**\n     * The insert function takes an element and a list and inserts the element\n     * into the list at the first position where it is less than or equal to the\n     * next element. In particular, if the list is sorted before the call, the\n     * result will also be sorted. It is a special case of insertBy, which allows\n     * the programmer to supply their own comparison function.\n     * @function module:list.insert\n     * @param x {*}\n     * @param xs {Array|*}\n     * @returns {Array}\n     */\n    insert = curry((x, xs) => {\n        if (!length(xs)) {\n            return [x];\n        }\n        const foundIndex = findIndex(item => x <= item, xs);\n        return foundIndex === -1 ? [x] :\n            concat(intersperse([x], splitAt(foundIndex, xs)));\n    }),\n\n    /**\n     * A version of `insert` that allows you to specify the ordering of the inserted\n     * item;  Before/at, or after\n     * @function module:list.insertBy\n     * @haskellType `insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]`\n     * @note `Ordering` === // something that is order-able\n     * @todo Optimize and work the logic of this function;  Think about the types that will be\n     *  operated on by this functions logic.\n     * @param orderingFn {Function} - A function that returns `-1`, `0`, or 1`.\n     * @param x {*} - Value to insert.\n     * @param xs {Array} - List to insert into (note new list is returned)\n     * @returns {Array} - New list.\n     */\n    insertBy = curry((orderingFn, x, xs) => {\n        const limit = length(xs);\n        if (!limit) {\n            return [x];\n        }\n        let ind = 0;\n        for (; ind < limit; ind += 1) {\n            if (orderingFn(x, xs[ind]) <= 0) {\n                const parts = splitAt(ind, xs);\n                return concat([parts[0], [x], parts[1]]);\n            }\n        }\n        return aggregateArr$(sliceCopy(xs), x);\n    }),\n\n    /**\n     * The nubBy function behaves just like nub, except it uses a user-supplied equality predicate.\n     * @function module:list.nubBy\n     * @param pred {Function}\n     * @param list {Array|String|*}\n     * @returns {Array}\n     */\n    nubBy = curry((pred, list) => {\n        if (!length(list)) {\n            return [];\n        }\n        const limit = length(list);\n        let ind = 0,\n            currItem,\n            out = [],\n            anyOp = storedItem => pred(currItem, storedItem);\n        for (; ind < limit; ind += 1) {\n            currItem = list[ind];\n            if (any(anyOp, out)) {\n                continue;\n            }\n            out.push(currItem);\n        }\n        return out;\n    }),\n\n    /**\n     * Behaves the same as `remove`, but takes a user-supplied equality predicate.\n     * @function module:list.removeBy\n     * @param pred {Function}\n     * @param x {*}\n     * @param list {Array|String|*}\n     * @returns {Array}\n     */\n    removeBy = curry((pred, x, list) => { // @todo optimize this implementation\n        const foundIndex = findIndex(item => pred(x, item), list),\n            parts = splitAt(foundIndex > -1 ? foundIndex : 0, list); // @todo correct this implementation\n        return append(parts[0], tail(parts[1]));\n    }),\n\n    /**\n     * The `removeFirstsBy` function takes a predicate and two lists and returns the first list with the first\n     * occurrence of each element of the second list removed.\n     * @function module:list.removeFirstBy\n     * @param pred {Function}\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @returns {Array}\n     */\n    removeFirstsBy = curry((pred, xs1, xs2) =>\n        foldl((agg, x2) => removeBy(pred, x2, agg), xs1, xs2)),\n\n    /**\n     * Returns the union on elements matching boolean check passed in.\n     * @function module:list.unionBy\n     * @param pred {Function} - `pred :: a -> a -> Bool`\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @returns {Array}\n     */\n    unionBy = curry((pred, arr1, arr2) =>\n        foldl((agg, b) => {\n                const alreadyAdded = any(a => pred(a, b), agg);\n                return !alreadyAdded ? (agg.push(b), agg) : agg;\n            }, sliceCopy(arr1), arr2\n        )),\n\n    /**\n     * Creates a union on matching elements from array1.\n     * @function module:list.union\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @returns {Array}\n     */\n    union = curry((arr1, arr2) =>\n        append(arr1,\n            filter(elm => !includes(elm, arr1), arr2))),\n\n    /**\n     * Performs an intersection on list 1 with  elements from list 2.\n     * @function module:list.intersect\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @returns {Array}\n     */\n    intersect = curry((arr1, arr2) =>\n        !arr1 || !arr2 || (!arr1 && !arr2) ? [] :\n            filter(elm => includes(elm, arr2), arr1)),\n\n    /**\n     * Returns an intersection by predicate.\n     * @function module:list.intersectBy\n     * @param pred {Function} - `pred :: a -> b -> Bool`\n     * @param list1 {Array}\n     * @param list2 {Array}\n     * @return {Array}\n     */\n    intersectBy = curry((pred, list1, list2) =>\n        foldl((agg, a) =>\n                any(b => pred(a, b), list2) ? (agg.push(a), agg) : agg\n            , [], list1)),\n\n    /**\n     * Returns the difference of list 1 from list 2.\n     * @note The `difference` operation here is non-associative;  E.g., `a - b` is not equal to `b - a`;\n     * @function module:list.difference\n     * @param array1 {Array}\n     * @param array2 {Array}\n     * @returns {Array}\n     */\n    difference = curry((array1, array2) => { // augment this with max length and min length ordering on op\n        if (array1 && !array2) {\n            return sliceCopy(array1);\n        }\n        else if (!array1 && array2 || (!array1 && !array2)) {\n            return [];\n        }\n        return reduce((agg, elm) =>\n                !includes(elm, array2) ? (agg.push(elm), agg) : agg\n            , [], array1);\n    }),\n\n    /**\n     * Returns the complement of list 0 and the reset of the passed in arrays.\n     * @function module:list.complement\n     * @param arr0 {Array}\n     * @param arrays {...Array}\n     * @returns {Array}\n     */\n    complement = (arr0, ...arrays) =>\n        reduce((agg, arr) => append(agg, difference(arr, arr0)), [], arrays);\n","import {assignDeep} from './assignDeep';\nimport {hasOwnProperty, keys} from '../jsPlatform/object';\nimport {foldl} from '../list';\nimport {curry} from '../function/curry';\n\nexport const\n\n    objUnion = curry((obj1, obj2) => assignDeep(obj1, obj2)),\n\n    objIntersect = curry((obj1, obj2) => foldl((agg, key) => {\n        if (hasOwnProperty(key, obj2)) {\n            agg[key] = obj2[key];\n        }\n        return agg;\n    }, {}, keys(obj1))),\n\n    objDifference = curry((obj1, obj2) => foldl((agg, key) => {\n        if (!hasOwnProperty(key, obj2)) {\n            agg[key] = obj1[key];\n        }\n        return agg;\n    }, {}, keys(obj1))),\n\n    objComplement = (obj0, ...objs) => foldl((agg, obj) =>\n        assignDeep(agg, objDifference(obj, obj0)), {}, objs);\n","export const\n\n    /**\n     * `Console.log` method.\n     * @function module:object.log\n     * @params args {...*}\n     * @returns {void}\n     */\n    log = console.log.bind(console),\n\n    /**\n     * `Console.error` method.\n     * @function module:object.error\n     * @params args {...*}\n     * @returns {void}\n     */\n    error = console.error.bind(console),\n\n    /**\n     * Peeks at incoming value(s) and returns the last value.\n     * @function module:object.peek\n     * @param args {...*}\n     * @returns {*} - Last given value (if one or more values) else first value.\n     */\n    peek = (...args) => (log(...args), args.pop())\n\n;\n","/**\n * @module object\n * @description Contains error throwing facilities for when a value doesn't match a type.\n *  In addition gives you curried and uncurried versions of the multi arity functions.\n */\nimport {typeOf} from './typeOf';\nimport {isset, isType, isString, isArray, isFunction} from './is';\nimport {curry, curry4} from '../function/curry';\n\nexport const\n\n    /**\n     * Checks if `type` is a string or a function (constructor or constructor name)\n     * @function module:object.isCheckableType\n     * @param type {TypeRef}\n     * @returns {Boolean}\n     * @private\n     */\n    isCheckableType = type => isString(type) || isFunction(type),\n\n    /**\n     * Throws an error if `type` is not a checkable type (can't be checked by the `TypeChecker` type)\n     * @function module:object.errorIfNotCheckableType\n     * @param contextName {String}\n     * @param type {TypeRef}\n     * @returns {TypeRef} - Type passed in if `type` is checkable\n     * @private\n     */\n    errorIfNotCheckableType = (contextName, type) => {\n        if (!isCheckableType(type)) {\n            throw new Error (`${contextName} expects \\`type\\` to be of type \\`String\\` or \\`Function\\`.` +\n                `  Type received \\`${typeOf(type)}\\`.  Value \\`${type}\\`.`);\n        }\n        return type;\n    },\n\n    /**\n     * Resolves/normalizes a type name from either a string or a constructor.\n     * @function module:object.getTypeName\n     * @param type {Function|String} - String or function representing a type.\n     * @returns {String}\n     * @private\n     */\n    getTypeName = type => {\n        errorIfNotCheckableType('getTypeName', type);\n        return type.name || type;\n    },\n\n    /**\n     * Returns a boolean indicating whether given value matches given type.\n     * @function module:object.defaultTypeChecker$\n     * @param Type {String|Function} - Type name, constructor and/or class.\n     * @param value {*}\n     * @returns {Boolean}\n     * @private\n     */\n    _defaultTypeChecker = (Type, value) => isType(getTypeName(Type), value) || (\n        isFunction(Type) && isset(value) && value instanceof Type),\n\n    /**\n     * Pretty prints an array of types/type-strings for use by error messages;\n     * Outputs \"`SomeTypeName`, ...\" from [SomeType, 'SomeTypeName', etc...]\n     * @function module:object.multiTypesToString\n     * @param types {Array|TypesArray}\n     * @return {String}\n     * @private\n     */\n    multiTypesToString = types => types.length ?\n             types.map(type => `\\`${getTypeName(type)}\\``).join(', ') : '',\n\n    /**\n     * Prints a message from an object.  Object signature:\n     * {contextName, valueName, value, expectedTypeName, foundTypeName, messageSuffix}\n     * @function module:object.defaultErrorMessageCall\n     * @param tmplContext {Object|TemplateContext} - Object to use in error template.\n     * @returns {string}\n     * @private\n     */\n    defaultErrorMessageCall = tmplContext => {\n        const {\n            contextName, valueName, value, expectedTypeName,\n            foundTypeName, messageSuffix\n        } = tmplContext,\n            isMultiTypeNames = isArray(expectedTypeName),\n            typesCopy = isMultiTypeNames ? 'of type' : 'of one of the types',\n            typesToMatchCopy = isMultiTypeNames ? multiTypesToString(expectedTypeName) : expectedTypeName;\n        return (contextName ? `\\`${contextName}.` : '`') +\n            `${valueName}\\` is not ${typesCopy}: ${typesToMatchCopy}.  ` +\n            `Type received: ${foundTypeName}.  Value: ${value};` +\n            `${messageSuffix ?  '  ' + messageSuffix + ';' : ''}`;\n    },\n\n    /**\n     * Gets the error message thrower seeded with passed in errorMessage template call.\n     * @function module:object.getErrorIfNotTypeThrower$\n     * @param errorMessageCall {Function|ErrorMessageCall}\n     * @param typeChecker {Function|TypeChecker} - Function<Type, value>:Boolean\n     * @returns {Function|ErrorIfNotType}\n     */\n    _getErrorIfNotTypeThrower = (errorMessageCall, typeChecker = _defaultTypeChecker) =>\n      (ValueType, contextName, valueName, value, messageSuffix = null) => {\n        const expectedTypeName = getTypeName(ValueType),\n            foundTypeName = typeOf(value);\n        if (typeChecker(ValueType, value)) { return value; } // Value matches type\n        throw new Error(errorMessageCall(\n            {contextName, valueName, value, expectedTypeName, foundTypeName, messageSuffix}\n        ));\n    },\n\n    /**\n     * Gets the error message thrower seeded with passed in errorMessage template call.\n     * @function module:object.getErrorIfNotTypesThrower$\n     * @param errorMessageCall {Function|ErrorMessageCall}\n     * @param typeChecker {Function|TypeChecker} - Function<Type, value>:Boolean\n     * @returns {Function|ErrorIfNotTypes}\n     */\n    _getErrorIfNotTypesThrower = (errorMessageCall, typeChecker = _defaultTypeChecker) =>\n      (valueTypes, contextName, valueName, value) => {\n            const expectedTypeNames = valueTypes.map(getTypeName),\n                matchFound = valueTypes.some(ValueType => typeChecker(ValueType, value)),\n                foundTypeName = typeOf(value);\n            if (matchFound) { return value; }\n            throw new Error(\n                errorMessageCall({\n                    contextName, valueName, value,\n                    expectedTypeName: expectedTypeNames, foundTypeName\n                })\n            );\n        },\n\n    /**\n     * Checks that passed in `value` is of given `type`.  Throws an error if value\n     * is not of given `type`.  This is the un-curried version.  For the curried version\n     * see `module:object.errorIfNotType`.\n     * @function module:object.errorIfNotType$\n     * @param type {String|Function} - Type's name or type itself.\n     * @param contextName {String} - Name of context to attribute errors if thrown.\n     * @param valueName {String} - String rep of value.\n     * @param value {*}\n     * @param [messageSuffix=null] {String} - Optional.\n     * @returns {undefined}\n     * @uncurried\n     */\n    _errorIfNotType = _getErrorIfNotTypeThrower(defaultErrorMessageCall),\n\n    /**\n     * Checks that passed in `value` is of one of the given `types`.  Throws an error if value\n     *  is not of one of the given `types`.  This is the un-curried version.  For the curried version\n     * see `module:object.errorIfNotTypes`.\n     * @type {Function|module:object.errorIfNotTypes}\n     * @function module:object.errorIfNotTypes$\n     * @param types {Array} - Array of one or more types or type names themselves.\n     * @param contextName {String} - Name of context to attribute errors if thrown.\n     * @param valueName {String} - String rep of value.\n     * @param value {*}\n     * @returns {undefined}\n     * @uncurried\n     */\n    _errorIfNotTypes = _getErrorIfNotTypesThrower(defaultErrorMessageCall),\n\n    /**\n     * Same as `defaultTypeChecker$` except curried:\n     *  \"Returns a boolean indicating whether given value matches given type\".\n     * @curried\n     * @function module:object.defaultTypeChecker\n     * @param Type {String|Function} - Type name, constructor and/or class.\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    defaultTypeChecker = curry(_defaultTypeChecker),\n\n    /**\n     * Checks that passed in `value` is of given `type`.  Throws an error if value\n     * is not of given `type`.  Curried.\n     * @function module:object.errorIfNotType\n     * @param type {String|Function} - Type's name or type itself.\n     * @param contextName {String} - Name of context to attribute errors if thrown.\n     * @param valueName {String} - String rep of value.\n     * @param value {*}\n     * @param [messageSuffix=null] {String} - Optional.\n     * @returns {undefined}\n     * @curried\n     */\n    errorIfNotType = curry(_errorIfNotType),\n\n    /**\n     * Checks that passed in `value` is of one of the given `types`.  Throws an error if value\n     *  is not of one of the given `types`.  Curried.\n     * @function module:object.errorIfNotTypes\n     * @param types {Array} - Array of one or more types or type names themselves.\n     * @param contextName {String} - Name of context to attribute errors if thrown.\n     * @param valueName {String} - String rep of value.\n     * @param value {*}\n     * @returns {undefined}\n     * @curried\n     */\n    errorIfNotTypes = curry4(_errorIfNotTypes),\n\n    /**\n     * Returns a function that can be used to ensure that values are of a given type.\n     *   Also throws informative error messages containing the value types, names, expected type names,\n     *   etc.\n     * @function module:object.getErrorIfNotTypeThrower\n     * @param errorMessageCall {Function|ErrorMessageCall} - Template function (takes an info-object and returns a printed string).\n     * @returns {Function|ErrorIfNotType} - Returns a function with the same signature as `errorIfNotType` though curried.\n     */\n    getErrorIfNotTypeThrower = errorMessageCall => curry(_getErrorIfNotTypeThrower(errorMessageCall)),\n\n    /**\n     * Returns a function that can be used to ensure that a value is of one or more given types.\n     *   The returned function is used in cases where informative error messages\n     *   containing the value types, names, expected type names, are-required/should-be-used etc.\n     * @function module:object.getErrorIfNotTypesThrower\n     * @param errorMessageCall {Function|ErrorMessageCall} - Template function (takes an info-object and returns a printed string).\n     * @returns {Function|ErrorIfNotTypes} - Returns a function with the same signature as `errorIfNotTypes` though curried.\n     */\n    getErrorIfNotTypesThrower = errorMessageCall => curry4(_getErrorIfNotTypesThrower(errorMessageCall))\n;\n\n/**\n * @typedef {*} Any - Synonym for 'any value'.\n */\n\n/**\n * @typedef {String|Function} TypeRef\n * @description Type reference.  Type itself or Type's name;  E.g., `Type.name`;\n */\n\n/**\n * @typedef {Object<value, valueName, expectedTypeName, foundTypeName, messageSuffix>} TemplateContext\n * @description Template context used for error message renderers (functions that take a context obj and return a string).\n * @property value {*}\n * @property valueName {String}\n * @property expectedTypeName {String} - Expected name of constructor of `value`;  E.g., usually `SomeConstructor.name`;\n * @property foundTypeName {String} - Found types name;  E.g., `FoundConstructor.name`;\n * @property [messageSuffix=null] {*} - Message suffix (sometimes an extra hint or instructions for\n *  directing user to fix where his/her error has occurred).  Optional.\n */\n\n/**\n * @typedef {Array<(String|Function)>} TypesArray\n */\n\n/**\n * @typedef {Function} TypeChecker\n * @description Checks whether a value is of given type.\n * @param Type {TypeRef} - a Type or it's name;  E.g., `Type.name`.\n * @param value {*}\n * @returns {Boolean}\n */\n\n/**\n * @typedef {Function} ErrorMessageCall\n * @description Error message template function.\n * @param tmplContext {TemplateContext}\n * @returns {String}\n */\n\n/**\n * @typedef {Function} ErrorIfNotType\n * @description Used to ensure value matches passed in type.\n * @param type {TypeRef} - Constructor name or constructor.\n * @param contextName {String}\n * @param valueName {String}\n * @param value {*}\n * @throws {Error} - If value doesn't match type.\n * @returns {*} - What ever value is.\n */\n\n/**\n * @typedef {Function} ErrorIfNotTypes\n * @description Used to ensure a value matches one of one or more types passed in.\n * @param valueTypes {TypesArray} - Array of constructor names or constructors.\n * @param contextName {String}\n * @param valueName {String}\n * @param value {*}\n * @throws {Error} - If value doesn't match type.\n * @returns {*} - Whatever value is.\n */\n","export const\n\n    /**\n     * Clones and object or array using `JSON.parse(JSON.stringify(...))` pattern.\n     * @function module:object.jsonClone\n     * @param x {*}\n     * @returns {*}\n     */\n    jsonClone = x => JSON.parse(JSON.stringify(x))\n\n;\n","import {isArray, isType} from './is';\nimport {keys} from '../jsPlatform/object';\n\nexport const\n\n    /**\n     * Returns an associated list from given object.\n     * @note Useful for working with plain javascript objects.\n     * @function module:object.toAssocList\n     * @param obj {(Object|Array|*)}\n     * @returns {Array.<*, *>}\n     */\n    toAssocList = obj => keys(obj).map(key => [key, obj[key]]),\n\n    /**\n     * Returns an associated list from given object (deeply (on incoming object's type)).\n     * @note Does deep conversion on all values of passed in type's type.\n     * @function module:object.toAssocListDeep\n     * @param obj {*}\n     * @param [TypeConstraint = Object] {(Constructor|Function)} - Type constraint to convert on.\n     * @returns {*}\n     */\n    toAssocListDeep = (obj, TypeConstraint = Object) => keys(obj).map(key =>\n        TypeConstraint && isType(TypeConstraint, obj[key]) ?\n            [key, toAssocListDeep(obj[key], TypeConstraint)] :\n            [key, obj[key]]\n    ),\n\n    /**\n     * From associated list to object.\n     * @function module:object.fromAssocList\n     * @param xs {Array.<Array>} - Associated list.\n     * @param [OutType = Object] {Constructor|Function} - Output type.  Default `Object`.\n     * @returns {*} - Default is `Object`\n     */\n    fromAssocList = (xs, OutType = Object) => xs.reduce((agg, [key, value]) => {\n        agg[key] = value;\n        return agg;\n    }, new OutType()),\n\n    /**\n     * From associated list to object (deep conversion on associative lists (array of 2 value arrays)).\n     * @note Considers array of arrays associated lists.\n     * @function module:object.fromAssocListDeep\n     * @param xs {Array.<Array>} - Associated list.\n     * @param [OutType = Object] {Constructor|Function} - Output type.  Default `Object`.\n     * @returns {*} - Default is `Object`\n     */\n    fromAssocListDeep = (xs, OutType = Object) => xs.reduce((agg, [key, value]) => {\n        if (isArray(value) && isArray(value[0]) && value[0].length === 2) {\n            agg[key] = fromAssocListDeep(value, OutType);\n            return agg;\n        }\n        agg[key] = value;\n        return agg;\n    }, new OutType())\n;\n","import {typeOf} from './typeOf';\nimport {toAssocList} from './assocList';\n\nexport const\n\n    /**\n     * Converts incoming value to an array.\n     * @note For `WeakMap`, `WeakSet`, `Map` and `Set` result is the same as calling `Array.from` on such.\n     * @note For `null`, `undefined`, `NaN`, `Number{}`, `Symbol{}`, `Boolean{}` returns an empty array.\n     * @note Method does a shallow conversion;\n     * @function module:object.toArray\n     * @param x {*} - Thing to convert from.\n     * @returns {Array}\n     */\n    toArray = x => {\n        switch (typeOf(x)) {\n            case 'Null':\n            case 'Undefined':\n                return [];\n            case String.name:\n            case Array.name:\n            case 'WeakMap':\n            case 'WeakSet':\n            case 'Map':\n            case 'Set':\n                return Array.from(x);\n            case Object.name:\n            default:\n                return toAssocList(x);\n        }\n    }\n\n;\n","/**\n * @module object\n * @description Object operations/combinators.\n */\nexport * from './jsPlatform/object';\nexport * from './object/prop';\nexport * from './object/typeOf';\nexport * from './object/copy';\nexport * from './object/is';\nexport * from './object/of';\nexport * from './object/searchObj';\nexport * from './object/assignDeep';\nexport * from './object/setTheory';\nexport * from './object/console';\nexport * from './object/errorThrowing';\nexport * from './object/jsonClone';\nexport * from './object/toArray';\nexport * from './object/assocList';\n","import {reduceRight} from '../jsPlatform/array';\n\n/**\n * Composes all functions passed in from right to left passing each functions return value to\n * the function on the left of itself.\n * @function module:function.compose\n * @type {Function}\n * @param args {...{Function}}\n * @returns {Function}\n */\nexport const compose = (...args) =>\n        arg0 => reduceRight((value, fn) => fn(value), arg0, args);\n","/**\n * @memberOf function\n * @description Curry implementation with place holder concept (`__`).\n */\n\nimport fnOrError from './fnOrError';\n\n/**\n * PlaceHolder (__) constructor.\n * @constructor PlaceHolder\n * @private\n */\nconst PlaceHolder = function PlaceHolder() {},\n\n    notFnErrPrefix = '`fn` in `curry_(fn, ...args)`',\n\n    /**\n     * Placeholder instance.\n     * @type {PlaceHolder}\n     * @private\n     */\n    placeHolderInstance = new PlaceHolder();\n\n/**\n * Checks to see if value is a `PlaceHolder`.\n * @param instance {*}\n * @returns {boolean}\n * @private\n */\nfunction isPlaceHolder (instance) {\n    return instance instanceof PlaceHolder;\n}\n\n/**\n * Replaces `placeholder` values in `list`.\n * @function replacePlaceHolder\n * @private\n * @param array {Array} - Array to replace placeholders in.\n * @param args {Array} - Args from to choose from to replace placeholders.\n * @returns {Array|*} - Returns passed in `list` with placeholders replaced by values in `args`.\n */\nfunction replacePlaceHolders (array, args) {\n    let out = array.map(element => {\n            if (!isPlaceHolder(element)) { return element; }\n            else if (args.length) { return args.shift(); }\n            return element;\n        });\n    return args.length ? out.concat(args) : out;\n}\n\n/**\n * Curries passed in function up to given arguments length (can enforce arity via placeholder values (`__`)).\n * @function module:function.curry_\n * @param fn {Function}\n * @param argsToCurry {...*}\n * @returns {Function}\n */\nexport function curry_ (fn, ...argsToCurry) {\n    return curryN_(fnOrError(notFnErrPrefix, fn).length, fn, ...argsToCurry);\n}\n\n/**\n * Curries a function up to given arity also enforces arity via placeholder values (`__`).\n * @function module:function.curryN_\n * @param executeArity {Number}\n * @param fn {Function}\n * @param curriedArgs {...*} - Allows `Placeholder` (`__`) values.\n * @returns {Function} - Passed in function wrapped in a function for currying.\n */\nexport function curryN_ (executeArity, fn, ...curriedArgs) {\n    return (...args) => {\n        let concatedArgs = replacePlaceHolders(curriedArgs, args),\n            placeHolders = concatedArgs.filter(isPlaceHolder),\n            canBeCalled = (concatedArgs.length - placeHolders.length >= executeArity) || !executeArity;\n        return !canBeCalled ?\n            curryN_.apply(null, [executeArity, fnOrError(notFnErrPrefix, fn)].concat(concatedArgs)) :\n            fnOrError(notFnErrPrefix, fn).apply(null, concatedArgs);\n    };\n}\n\n/**\n * Place holder object (frozen) used by curry.\n * @memberOf function\n * @type {PlaceHolder}\n */\nexport let __ = Object.freeze ? Object.freeze(placeHolderInstance) : placeHolderInstance,\n\n    /**\n     * Curries a function up to an arity of 2 (takes into account placeholders `__` (arity enforcers)) (won't call function until 2 or more args).\n     * @function module:function.curry2_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry2_ = fn => curryN_(2, fn),\n\n    /**\n     * Curries a function up to an arity of 3 (takes into account placeholders `__` (arity enforcers)) (won't call function until 3 or more args).\n     * @function module:function.curry3_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry3_ = fn => curryN_(3, fn),\n\n    /**\n     * Curries a function up to an arity of 4 (takes into account placeholders `__` (arity enforcers))  (won't call function until 4 or more args).\n     * @function module:function.curry4_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry4_ = fn => curryN_(4, fn),\n\n    /**\n     * Curries a function up to an arity of 5  (takes into account placeholders `__` (arity enforcers))  (won't call function until 5 or more args).\n     * @function module:function.curry5_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry5_ = fn => curryN_(5, fn)\n\n;\n","import {reverse} from '../jsPlatform/array';\nimport {apply, call} from '../jsPlatform/function';\nimport {curry, curry2} from './curry';\n\nexport const\n\n    /**\n     * Returns a curried function requiring given functions arguments in reverse\n     * (returned function expects 2 or more variables (curried at 2 or more args)).\n     * @function module:function.flipN\n     * @param fn {Function}\n     * @returns {Function}\n     * @curried\n     */\n    flipN = fn => curry2((...args) => apply(fn, reverse(args))),\n\n    /**\n     * Flips a function's first and second arguments and and returns a new function requiring said arguments in reverse.\n     * @function module:function.flip\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    flip = fn => curry((b, a) => call(fn, a, b));\n","/**\n * @memberOf function\n */\n\n/**\n * Returns passed in parameter.\n * @haskellType `id :: a -> a`\n * @function module:function.id\n * @param x {*}\n * @returns {*}\n */\nexport const id = x => x;\n","import {curry} from './curry';\n\nexport const\n\n    /**\n     * Run `operation` until predicate returns `true`.\n     * @function module:function.until\n     * @param predicate {Function} :: a -> Boolean\n     * @param operation {Function} :: a -> a\n     * @param typeInstance {*} :: * - A monoidal zero or some starting point.\n     * @returns {*} - What ever type `typeInstance` is\n     */\n    until = curry((predicate, operation, typeInstance) => {\n        let result = typeInstance;\n        while (!predicate(result)) {\n            result = operation(result);\n        }\n        return result;\n    });\n","/**\n * @module function\n */\nexport * from './jsPlatform/function';\nexport * from './function/compose';\nexport * from './function/curry';\nexport * from './function/_curry';\nexport * from './function/flip';\nexport * from './function/id';\nexport * from './function/negate';\nexport * from './function/until';\n","/**\n * Contains functions for operating strings.\n * @author elyde\n * @created 7/9/2017.\n * @module string\n */\nimport {intercalate, map, filter} from './list';\nimport {split} from './jsPlatform/string';\nimport {compose} from './function/compose';\nimport {join} from './jsPlatform/array';\nimport {_errorIfNotType} from './object/errorThrowing';\n\nexport const\n\n    /**\n     * Splits a string on all '\\n', '\\r', '\\n\\r', or '\\r\\n' characters.\n     * @function module:string.lines\n     * @param str {String}\n     * @returns {Array}\n     */\n    lines = split(/[\\n\\r]/gm),\n\n    /**\n     * Splits a string on all '\\s' and/or all '\\t' characters.\n     * @function module:string.words\n     * @param str{String}\n     * @returns {Array}\n     */\n    words = split(/[\\s\\t]/gm),\n\n    /**\n     * Intersperse an array of strings with '\\s' and then concats them.\n     * @function module:string.unwords\n     * @param arr {String}\n     * @returns {Array}\n     */\n    unwords = intercalate(' '),\n\n    /**\n     * Intersperses a '\\n' character into a list of strings and then concats it.\n     * @function module:string.unlines\n     * @param list {Array|String|*}\n     * @returns {Array}\n     */\n    unlines = intercalate('\\n'),\n\n    /**\n     * Lower cases first character of a non-empty string.\n     * @function module:string.lcaseFirst\n     * @param xs {String}\n     * @returns {string}\n     * @throws {Error} - Throws error if receiving anything that is not a string.\n     */\n    lcaseFirst = xs => {\n        _errorIfNotType(String, 'lcaseFirst', 'xs', xs);\n        return xs[0].toLowerCase() + xs.substring(1);\n    },\n\n    /**\n     * Upper cases first character of a non-empty string.\n     * @function module:string.ucaseFirst\n     * @param xs {String}\n     * @returns {string}\n     * @throws {Error} - Throws error if receiving anything that is not a string.\n     */\n    ucaseFirst = xs => {\n        _errorIfNotType(String, 'ucaseFirst', 'xs', xs);\n        return xs[0].toUpperCase() + xs.substring(1);\n    },\n\n    /**\n     * Camel cases (class case) a string.\n     * @function module:string.camelCase\n     * @param xs {String}\n     * @param [pattern=/[^a-z\\d/i]/] {RegExp} - Pattern to split on.  Optional.\n     * @throws {Error} - Throws error if param `xs` is not a string.\n     * @returns {string}\n     * @curried\n     */\n    camelCase = (xs, pattern = /[^a-z\\d]/i) => compose(\n            join(''),\n            map(str => ucaseFirst(str.toLowerCase())),\n            filter(x => !!x),\n            split(pattern)\n        )(_errorIfNotType(String, 'camelCase', 'xs', xs)),\n\n    /**\n     * Class cases a string.  Uses pattern /[^a-z\\d/i]/ to split on.\n     * If you require a different pattern use `string.camelCase(str, pattern)`\n     * and then upper case first character (`ucaseFirst`).\n     * @function module:string.classCase\n     * @param xs {String}\n     * @returns {string}\n     * @throws {Error} - Throws error if `xs` is not a string (via `camelCase` call).\n     */\n    classCase = compose(ucaseFirst, camelCase)\n\n;\n","/**\n * @module fjl\n * @description Exports all module methods (object, list, string modules etc.).\n * @goal to include everything from haskell's Prelude where it makes sense in order to create\n *  a subset of functions which can make the javascript developer more efficient and make his/her\n *  code more concise (and functional).\n * @motivation preludejs, lodash/fp, RamdaJs, Haskell.\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-List.html\n */\nexport * from './object';\nexport * from './boolean';\nexport * from './function';\nexport * from './list';\nexport * from './string';\nexport * from './utils';\nexport * from './list/utils';\n"],"names":["_Number","Number","name","_NaN","_Null","_Undefined","typeOf","value","retVal","undefined","constructorName","constructor","isNaN","fnOrError","symbolName","f","Error","curryNotFnErrPrefix","curryN","executeArity","fn","curriedArgs","args","concatedArgs","concat","canBeCalled","length","apply","curry","argsToCurry","curry2","curry3","curry4","curry5","fPureTakesOne","arg","fPureTakes2","arg1","arg2","fPureTakes3","arg3","fPureTakes4","arg4","fPureTakes5","arg5","fPureTakesOneOrMore","instanceConstructor","instance","hasOwnProperty","x","keys","Object","assign","obj0","objs","reduce","topAgg","obj","agg","key","_String","String","_Object","_Boolean","Boolean","_Function","Function","_Array","Array","_Symbol","_Map","_Set","_WeakMap","_WeakSet","instanceOf","isType","type","isFunction","isClass","test","substr","isCallable","isArray","isObject","isBoolean","isNumber","isString","isMap","isSet","isWeakMap","isWeakSet","isUndefined","isNull","isSymbol","isUsableImmutablePrimitive","typeOfX","isset","some","Type","isEmptyList","isEmptyObject","isEmptyCollection","size","isEmpty","typeOfValue","prop","call","of","copy","out","slice","Symbol","Promise","from","searchObj","nsString","indexOf","parts","split","limit","ind","parent","node","assignDeep","propDescription","getOwnPropertyDescriptor","get","set","writable","includes","prototype","xs","lastIndexOf","negateF","negateF2","a","b","negateF3","c","negateFN","isTruthy","isFalsy","alwaysTrue","alwaysFalse","map","push","aggregateArr$","item","sliceFrom","startInd","arr","sliceTo","toInd","sliceCopy","genericAscOrdering","lengths","lists","lengthsToSmallest","listLengths","smallLen","Math","min","list","reduceUntil","pred","op","result","reduceRightUntil","reduceRight","lastIndex","len","findIndexWhere","predicateFulfilled","findIndexWhereRight","findIndicesWhere","findWhere","elm","defineReverse","reverse","filter","forEach","every","join","append","listAppend","head","last","tail","init","uncons","unconsr","concatMap","foldableOfA","foldr","intersperse","between","lastInd","foldl","intercalate","xss","transpose","numLists","ind2","longestListLen","maximum","outLists","outList","subsequences","listLen","pow","i","entry","j","swapped","ind1","tmp","permutations","repeat","foldl1","foldr1","mapAccumL","zero","mapped","tuple","mapAccumR","iterate","lastX","replicate","cycle","unfoldr","resultTuple","findIndex","findIndices","elemIndex","foundInd","elemIndices","take","drop","splitAt","takeWhile","dropWhile","splitPoint","list2","dropWhileEnd","span","breakOnList","at","find","partition","elem","notElem","lookup","isPrefixOf","xs1","xs2","limit1","limit2","isSuffixOf","isInfixOf","foundLen","isSubsequenceOf","lenXs1","group","groupBy","equalityOp","prevItem","predOp","inits","tails","stripPrefix","prefix","zip","arr1","arr2","a1","a2","zipN","trimmedLists","lenOfTrimmed","zip3","arr3","zip4","arr4","zip5","arr5","zipWith","zipWithN","zipWith3","xs3","zipWith4","xs4","zipWith5","xs5","unzip","unzipN","lenItem0","any","p","all","and","or","not","sum","product","sortBy","minimum","scanl","scanl1","scanr","scanr1","nub","nubBy","remove","removeBy","sort","sortOn","valueFn","decorated","a0","b0","orderingFn","insert","foundIndex","insertBy","currItem","anyOp","storedItem","removeFirstsBy","x2","unionBy","alreadyAdded","union","intersect","intersectBy","list1","difference","array1","array2","complement","arr0","arrays","objUnion","obj1","obj2","objIntersect","objDifference","objComplement","log","console","bind","error","peek","pop","isCheckableType","errorIfNotCheckableType","contextName","getTypeName","_defaultTypeChecker","multiTypesToString","types","defaultErrorMessageCall","tmplContext","valueName","expectedTypeName","foundTypeName","messageSuffix","isMultiTypeNames","typesCopy","typesToMatchCopy","_getErrorIfNotTypeThrower","errorMessageCall","typeChecker","ValueType","_getErrorIfNotTypesThrower","valueTypes","expectedTypeNames","matchFound","_errorIfNotType","_errorIfNotTypes","defaultTypeChecker","errorIfNotType","errorIfNotTypes","getErrorIfNotTypeThrower","getErrorIfNotTypesThrower","jsonClone","JSON","parse","stringify","toAssocList","toAssocListDeep","TypeConstraint","fromAssocList","OutType","fromAssocListDeep","toArray","compose","arg0","PlaceHolder","notFnErrPrefix","placeHolderInstance","isPlaceHolder","replacePlaceHolders","array","element","shift","curry_","curryN_","placeHolders","__","freeze","curry2_","curry3_","curry4_","curry5_","flipN","flip","id","until","predicate","operation","typeInstance","lines","words","unwords","unlines","lcaseFirst","toLowerCase","substring","ucaseFirst","toUpperCase","camelCase","pattern","str","classCase"],"mappings":"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"}