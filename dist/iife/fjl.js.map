{"version":3,"file":"fjl.js","sources":["../../src/uncurried/_objectOps/_typeOf.js","../../src/uncurried/_utils.js","../../src/uncurried/_jsPlatform/_object.js","../../src/uncurried/_jsPlatform/_array.js","../../src/uncurried/_jsPlatform/_list.js","../../src/uncurried/_jsPlatform/_string.js","../../src/uncurried/_jsPlatform/_function.js","../../src/uncurried/_jsPlatform.js","../../src/uncurried/_functionOps/_curry.js","../../src/uncurried/_objectOps/_prop.js","../../src/uncurried/_objectOps/_is.js","../../src/uncurried/_objectOps/_assignDeep.js","../../src/uncurried/_functionOps/_negate.js","../../src/booleanOps.js","../../src/uncurried/_objectOps/_of.js","../../src/uncurried/_objectOps.js","../../src/uncurried/_listOps/_map.js","../../src/uncurried/_listOps/_aggregation.js","../../src/uncurried/_listOps/_utils.js","../../src/uncurried/_listOps.js","../../src/uncurried/_objectOps/_setTheory.js","../../src/objectOps.js","../../src/uncurried/_functionOps/_until.js","../../src/uncurried/_functionOps/_flip.js","../../src/uncurried/_functionOps/__curry.js","../../src/uncurried/_functionOps/_id.js","../../src/uncurried/_functionOps/_compose.js","../../src/functionOps.js","../../src/uncurried/_functionOps.js","../../src/utils.js","../../src/jsPlatform/array.js","../../src/jsPlatform/list.js","../../src/jsPlatform/string.js","../../src/jsPlatform.js","../../src/listOps.js","../../src/stringOps.js","../../src/fjl.js"],"sourcesContent":["/**\n * Created by elyde on 12/18/2016.\n * @memberOf _objectOps\n */\nconst _Number = Number.name,\n    _NaN = 'NaN',\n    _Null = 'Null',\n    _Undefined = 'Undefined';\n\n/**\n * Returns the constructor/class/type name of a value.\n * @note Returns 'NaN' if value is of type `Number` and value is `isNaN`.\n * @note Returns 'Undefined' if value is `undefined`\n * @note Returns 'Null' if value is `null`\n * For values that have no concrete constructors and/or casters\n * (null, NaN, and undefined) we returned normalized names for them ('Null', 'NaN', 'Number')\n * @function module:_objectOps.typeOf\n * @param value {*}\n * @returns {string} - Constructor's name or derived name (in the case of `null`, `undefined`, or `NaN` (whose\n *  normalized names are 'Null', 'Undefined', 'NaN' respectively).\n */\nexport function typeOf (value) {\n    let retVal;\n    if (value === undefined) {\n        retVal = _Undefined;\n    }\n    else if (value === null) {\n        retVal = _Null;\n    }\n    else {\n        let constructorName = (value).constructor.name;\n        retVal = constructorName === _Number && isNaN(value) ?\n            _NaN : constructorName;\n    }\n    return retVal;\n}\n","import {typeOf} from './_objectOps/_typeOf';\n\nexport const\n\n    fPureTakesOne = name => (arg, f) => f[name](arg),\n\n    fPureTakes2 = name => (arg1, arg2, f) => f[name](arg1, arg2),\n\n    fPureTakes3 = name => (arg1, arg2, arg3, f) => f[name](arg1, arg2, arg3),\n\n    fPureTakes4 = name => (arg1, arg2, arg3, arg4, f) => f[name](arg1, arg2, arg3, arg4),\n\n    fPureTakes5 = name => (arg1, arg2, arg3, arg4, arg5, f) => f[name](arg1, arg2, arg3, arg4, arg5),\n\n    fPureTakesOneOrMore = name => (f, ...args) => f[name](...args),\n\n    fnOrError = (symbolName, f) => {\n        if (!f || f.constructor !== Function) {\n            throw new Error (`${symbolName} should be a function. ` +\n                `Type received: ${typeOf(f)};  Value received: ${f}.`);\n        }\n        return f;\n    };\n","/**\n * Created by elydelacruz on 9/6/2017.\n * Defines some of the platform methods for objects (the ones used within `fjl`) uncurried for use\n * throughout the library.  @note Doesn't include all methods for objects just the ones used in\n *  the library.\n * @todo change all files named '*UnCurried' to '*_'.\n */\n\nimport {fPureTakesOne} from '../_utils';\n\nexport const\n\n    /**\n     * Returns whether constructor has derived _objectOps.\n     * @function module:_jsPlatform_objectOps.instanceOf\n     * @param instanceConstructor {Function} - Constructor.\n     * @param instance {*}\n     * @instance {*}\n     * @returns {Boolean}\n     */\n    instanceOf = (instanceConstructor, instance) =>\n        instance instanceof instanceConstructor,\n\n    /**\n     * @function module:_jsPlatform_objectOps.hasOwnProperty\n     * @param propName {*}\n     * @param typeInstance {*}\n     * @returns {Boolean}\n     */\n    hasOwnProperty = fPureTakesOne('hasOwnProperty'),\n\n    /**\n     * @function module:_jsPlatform_objectOps.length\n     * @param x {*}\n     * @returns {Number}\n     * @throws {Error} - Throws an error if value doesn't have a `length` property (\n     *  `null`, `undefined`, {Boolean}, Symbol, et. al.).\n     */\n    length = x => x.length,\n\n    /**\n     * Gets own enumerable keys of passed in object (`Object.keys`).\n     * @function module:_jsPlatform_objectOps.keys\n     * @param obj {*}\n     * @returns {Array<String>}\n     */\n    keys = obj => Object.keys(obj),\n\n    /**\n     * Defined as `Object.assign` else is the same thing but shimmed.\n     * @function module:_jsPlatform_objectOps.assign\n     * @param obj0 {Object}\n     * @param objs {...{Object}}\n     * @returns {Object}\n     */\n    assign = (() => Object.assign ?\n            (obj0, ...objs) => Object.assign(obj0, ...objs) :\n            (obj0, ...objs) => objs.reduce((topAgg, obj) => {\n                return keys(obj).reduce((agg, key) => {\n                    agg[key] = obj[key];\n                    return agg;\n                }, topAgg);\n            }, obj0)\n        )();\n","/**\n * Created by elyde on 7/20/2017.\n * Functional versions of common array methods (`map`, `filter`, etc.) (un-curried);\n * @module _jsPlatform_arrayOps\n * @private\n * @todo updated doc blocks to list correct/updated module name.\n */\n\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from '../_utils';\n\nexport const\n\n    /**\n     * Array.prototype.reverse generator (generates a _functionOps that calls the prototype version or a\n     * shimmed version if it doesn't exist).\n     * @returns {Function}\n     */\n    defineReverse = () =>\n        Array.prototype.reverse ? x => x.reverse() :\n            x => x.reduceRight((agg, item) => {\n                agg.push(item);\n                return agg;\n            }, []),\n\n    /**\n     * Maps a _functionOps to functor (_listOps etc.).\n     * @function module:_jsPlatform_array.map\n     * @param fn {Function}\n     * @param functor {Array|{map: {Function}}}\n     * @returns {Array|{map: {Function}}}\n     */\n    map = fPureTakesOne('map'),\n\n    /**\n     * Filters a functor (_listOps etc.) with passed in _functionOps.\n     * @function module:_jsPlatform_array.filter\n     * @param fn {Function}\n     * @param functor {Array|{filter: {Function}}}\n     * @returns {Array|{filter: {Function}}}\n     */\n    filter = fPureTakesOne('filter'),\n\n    /**\n     * Reduces a foldable (_listOps etc.) with passed in _functionOps.\n     * @function module:_jsPlatform_array.reduce\n     * @param fn {Function}\n     * @param functor {Array|{reduce: {Function}}}\n     * @returns {Array|{reduce: {Function}}}\n     */\n    reduce = fPureTakes2('reduce'),\n\n    /**\n     * Reduces a foldable (_listOps etc.) from the right with passed in _functionOps.\n     * @function module:_jsPlatform_array.reduceRight\n     * @param fn {Function}\n     * @param functor {Array|{reduceRight: {Function}}}\n     * @returns {Array|{reduceRight: {Function}}}\n     */\n    reduceRight = fPureTakes2('reduceRight'),\n\n    /**\n     * For each on functor (Array|Object|etc.).\n     * @param fn {Function}\n     * @param functor {Array|Object|*}\n     * @return {*|Array|Object} - The type of object you pass in unless it doesn't have a `forEach` method.\n     * @throws {Error} - When passed in functor doesn't have a `forEach` method.\n     */\n    forEach = fPureTakesOne('forEach'),\n\n    /**\n     * Returns `true` if `fn` (predicate) returns true for at least one item\n     * in functor else returns `false`.\n     * @param fn {Function} - Predicate.\n     * @param functor {Array|Object|*}\n     * @return {*|Array|Object} - The type passed.\n     * @throws {Error} - When passed in object doesn't have a `some` method.\n     */\n    some = fPureTakesOne('some'),\n\n    /**\n     * Returns `true` if `fn` (predicate) returns true for all items in functor else returns `false`.\n     * @param fn {Function} - Predicate.\n     * @param functor {Array|Object|*}\n     * @return {*|Array|Object} - The type passed.\n     * @throws {Error} - When passed in object doesn't have an `every` method.\n     */\n    every = fPureTakesOne('every'),\n\n    /**\n     * Array.prototype.join\n     * @function module:listPrelude.join\n     * @param separator {String|RegExp}\n     * @param arr {Array}\n     * @returns {String}\n     */\n    join = fPureTakesOne('join'),\n\n    /**\n     * Same as Array.prototype.push\n     * @param item {*}\n     * @param arr {Array}\n     * @returns {Number}\n     */\n    push = fPureTakesOneOrMore('push'),\n\n    /**\n     * Reverses an _listOps (shimmed if not exists).\n     * @function module:listPrelude.reverse\n     * @return {Array}\n     */\n    reverse = defineReverse();\n","/**\n *  List operations that overlap (apart from globally overlapping props and functions like `length`)\n *      on both strings and arrays.\n */\n\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from '../_utils';\n\nexport const\n\n    /**\n     * Concats/appends all functors onto the end of first functor.\n     * Note:  functors passed in after the first one must be of the same type.\n     * @function module:_jsPlatform_list.concat\n     * @param functor {Array|Object|*}\n     * @param ...functor {Array|Object|*}\n     * @return {*|Array|Object} - The type passed.\n     * @throws {Error} - When passed in object doesn't have an `every` method.\n     */\n    concat = fPureTakesOneOrMore('concat'),\n\n    /**\n     * Same as Array.prototype.slice\n     * @function module:_jsPlatform_list.slice\n     * @param separator {String|RegExp}\n     * @param arr{Array}\n     * @returns {Array}\n     */\n    slice = fPureTakes2('slice'),\n\n    /**\n     * `Array.prototype.includes` or shim.\n     * @function module:_jsPlatform_list.includes\n     * @param value {*}\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    includes = (() => 'includes' in Array.prototype ?\n            fPureTakesOne('includes') :\n            (value, xs) => xs.indexOf(value) > -1)(),\n\n    /**\n     * Searches list/list-like for given element `x`.\n     * @function module:_jsPlatform_list.indexOf\n     * @param x {*} - Element to search for.\n     * @param xs {Array|String|*} - list or list like to look in.\n     * @returns {Number} - `-1` if element not found else index at which it is found.\n     */\n    indexOf = fPureTakesOne('indexOf'),\n\n    /**\n     * Last index of (`Array.prototype.lastIndexOf`).\n     * @function module:_jsPlatform_list.lastIndexOf\n     * @param x {*} - Element to search for.\n     * @param xs {Array|String|*} - list or list like to look in.\n     * @returns {Number} - `-1` if element not found else index at which it is found.\n     */\n    lastIndexOf = fPureTakesOne('lastIndexOf')\n\n;\n","/**\n * Created by elydelacruz on 9/6/2017.\n */\n\nimport {fPureTakesOne} from '../_utils';\n\n/**\n * Functional version of `String.prototype.split`.\n * @function module:_stringOps.split\n * @param separator {String|RegExp}\n * @param str {String}\n * @returns {Array}\n */\nexport const split = fPureTakesOne('split');\n","/**\n * Created by elydelacruz on 9/7/2017.\n * @module _jsPlatform_function\n * @private\n */\nexport const\n\n    /**\n     * Functional `apply` function (takes no context).\n     * @function module:_jsPlatform_function.apply\n     * @param fn {Function}\n     * @param args {Array|*}\n     * @returns {*}\n     */\n    apply = (fn, args) => fn.apply(null, args),\n\n    /**\n     * Functional `call` function (takes no context).\n     * @function module:_jsPlatform_function.call\n     * @param fn {Function}\n     * @param args {...*}\n     * @returns {*}\n     */\n    call = (fn, ...args) => apply(fn, args);\n","/**\n * @module jsPlatform_\n * @private\n */\nexport * from './_jsPlatform/_object';\nexport * from './_jsPlatform/_array';\nexport * from './_jsPlatform/_list';\nexport * from './_jsPlatform/_string';\nexport * from './_jsPlatform/_function';\n","/**\n * @author elydelacruz\n * @created 12/6/2016.\n * @memberOf _functionOps\n * @description \"Curry strict\" and \"curry arbitrarily\" functions (`curry`, `curryN`).\n */\nimport {apply, length, concat} from '../_jsPlatform';\nimport {fnOrError} from '../_utils';\n\nconst notFnErrPrefix = '`fn` in `curry(fn, ...args)`';\n\nexport const\n\n    /**\n     * Curries a functionOps based on it's defined arity (argument's arrayOps expected length).\n     * @function module:_functionOps.curry\n     * @param fn {Function}\n     * @param argsToCurry {...*}\n     * @returns {Function}\n     */\n    curry = (fn, ...argsToCurry) => curryN(fnOrError(notFnErrPrefix, fn).length, fn, ...argsToCurry),\n\n    /**\n     * Curries a functionOps up to a given arity.\n     * @function module:_functionOps.curryN\n     * @param executeArity {Number}\n     * @param fn {Function}\n     * @param curriedArgs {...*}\n     * @returns {Function}\n     */\n    curryN = (executeArity, fn, ...curriedArgs) => {\n        return (...args) => {\n            let concatedArgs = concat(curriedArgs, args),\n                canBeCalled = (length(concatedArgs) >= executeArity) || !executeArity;\n            return !canBeCalled ? apply(curryN, concat([executeArity, fnOrError(notFnErrPrefix, fn)], concatedArgs)) :\n                apply(fnOrError(notFnErrPrefix, fn), concatedArgs);\n        };\n    },\n\n    /**\n     * Curries a _functionOps up to an arity of 2 (won't call _functionOps until 2 or more args).\n     * @function module:_functionOps.curry2\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry2 = fn => curryN(2, fn),\n\n    /**\n     * Curries a _functionOps up to an arity of 3 (won't call _functionOps until 3 or more args).\n     * @function module:_functionOps.curry3\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry3 = fn => curryN(3, fn),\n\n    /**\n     * Curries a _functionOps up to an arity of 4 (won't call _functionOps until 4 or more args).\n     * @function module:_functionOps.curry4\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry4 = fn => curryN(4, fn),\n\n    /**\n     * Curries a _functionOps up to an arity of 5 (won't call _functionOps until 5 or more args).\n     * @function module:_functionOps.curry5\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry5 = fn => curryN(5, fn);\n","/**\n * @memberOf _objectOps\n */\n\n/**\n * Returns property value if found; Else `undefined`.\n * @function module:_objectOps.prop\n * @param name {String} - Key to search on `obj`\n * @param obj {Object} - Object to search `name` on.\n * @returns {*}\n */\nexport const prop = (name, obj) => obj[name];\n","/**\n * Created by elyde on 12/18/2016.\n * @memberOf _objectOps\n */\n\nimport {typeOf} from './_typeOf';\nimport {instanceOf, length, keys, hasOwnProperty} from '../_jsPlatform/_object';\n\nlet _String = String.name,\n    _Number = Number.name,\n    _Object = Object.name,\n    _Boolean = Boolean.name,\n    _Function = Function.name,\n    _Array = Array.name,\n    _Symbol = 'Symbol',\n    _Map = 'Map',\n    _Set = 'Set',\n    _WeakMap = 'WeakMap',\n    _WeakSet = 'WeakSet',\n    _Null = 'Null',\n    _Undefined = 'Undefined';\n\nexport const\n\n    /**\n     * Returns whether a value is a _functionOps or not.\n     * @function module:_objectOps._isFunction\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isFunction = value => instanceOf(Function, value),\n\n    /**\n     * Type checker.  Note** The `Type` passed in, if a constructor, should\n     * be a named constructor/_functionOps-instance;  E.g.,\n     * ```\n     *  _functionOps SomeName () {} // or\n     *  var SomeName = _functionOps SomeName () {} // or\n     *  class SomeName {}\n     * ```\n     * @function module:_objectOps._isType\n     * @param type {Function|String} - Constructor or constructor name\n     * @param obj {*}\n     * @return {Boolean}\n     */\n    isType = (type, obj) => typeOf(obj) === (isFunction(type) ? type.name : type),\n\n    /**\n     * Checks if `value` is an es2015 `class`.\n     * @function module:_objectOps._isClass\n     * @param x {*}\n     * @returns {boolean}\n     */\n    isClass = x => x && /^\\s{0,3}class\\s{1,3}/.test((x + '').substr(0, 10)),\n\n    /**\n     * Returns a boolean depicting whether a value is callable or not.\n     * @function module:_objectOps._isCallable\n     * @tentative\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isCallable = x => isFunction(x) && !isClass(x),\n\n    /**\n     * Checks if value is an array (same as `Array.isArray`).\n     * @function module:_objectOps._isArray\n     * @param value {*}\n     * @returns {boolean}\n     */\n    {isArray} = Array,\n\n    /**\n     * Checks whether value is an object or not.\n     * @function module:_objectOps._isObject\n     * @param value\n     * @returns {Boolean}\n     */\n    isObject = value => isType(_Object, value),\n\n    /**\n     * Checks if value is a boolean.\n     * @function module:_objectOps._isBoolean\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isBoolean = value => isType(_Boolean, value),\n\n    /**\n     * Checks if value is a valid number (also checks if isNaN so that you don't have to).\n     * @function module:_objectOps._isNumber\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isNumber = value => isType(_Number, value),\n\n    /**\n     * Checks whether value is a stringOps or not.\n     * @function module:_objectOps._isString\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isString = value => isType(_String, value),\n\n    /**\n     * Checks whether value is of `Map` or not.\n     * @function module:_objectOps._isMap\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isMap = value => isType(_Map, value),\n\n    /**\n     * Checks whether value is of `Set` or not.\n     * @function module:_objectOps._isSet\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isSet = value => isType(_Set, value),\n\n    /**\n     * Checks whether value is of `WeakMap` or not.\n     * @function module:_objectOps._isWeakMap\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isWeakMap = value => isType(_WeakMap, value),\n\n    /**\n     * Checks whether value is of `WeakSet` or not.\n     * @function module:_objectOps._isWeakSet\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isWeakSet = value => isType(_WeakSet, value),\n\n    /**\n     * Checks if value is undefined.\n     * @function module:_objectOps._isUndefined\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isUndefined = value => isType(_Undefined, value),\n\n    /**\n     * Checks if value is null.\n     * @function module:_objectOps._isNull\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isNull = value => isType(_Null, value),\n\n    /**\n     * Checks if value is a `Symbol`.\n     * @function module:_objectOps._isSymbol\n     * @param value {*}\n     * @returns {Boolean}\n     */\n    isSymbol = value => isType(_Symbol, value),\n\n    /**\n     * Checks if given `x` is set and of one of\n     *  [String, Boolean, Number, Symbol] (null and undefined are immutable\n     *  but are not \"usable\" (usually not what we want to operate on).\n     * @deprecated If needed copy&paste implementation to your project.\n     * @function module:_objectOps._isUsableImmutablePrimitive\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isUsableImmutablePrimitive = x => {\n        const typeOfX = typeOf(x);\n        return isset(x) &&\n            [_String, _Number, _Boolean, _Symbol]\n                .some(Type => Type === typeOfX);\n    },\n\n    /**\n     * Checks if !length.\n     * @function module:_objectOps._isEmptyList\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isEmptyList = x => !length(x),\n\n    /**\n     * Checks if object has own properties/enumerable-props or not.\n     * @function module:_objectOps._isEmptyObject\n     * @param obj {*}\n     * @returns {Boolean}\n     */\n    isEmptyObject = obj => isEmptyList(keys(obj)),\n\n    /**\n     * Checks if collection is empty or not (Map, WeakMap, WeakSet, Set etc.).\n     * @function module:_objectOps._isEmptyCollection\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isEmptyCollection = x => x.size === 0,\n\n    /**\n     * Checks to see if passed in value is empty;  I.e.,\n     *  check for one of '', 0, `null`, `undefined`, `false`, empty array, empty object, empty function (zero arity),\n     *  or empty collection (es6 Map, Set, WeakMap, or WeakSet etc. (`!value.size`);\n     * @function module:_objectOps._isEmpty\n     * @param value {*} - Value to check.\n     * @returns {Boolean}\n     */\n    isEmpty = value => {\n        let typeOfValue = typeOf(value),\n            retVal;\n        if (!value) { // if '', 0, `null`, `undefined`, or `false` then is empty\n            retVal = true;\n        }\n        else if (typeOfValue === _Array || typeOfValue === _Function) {\n            retVal = isEmptyList(value);\n        }\n        else if (typeOfValue === _Number) {\n            retVal = false;\n        }\n        else if (typeOfValue === _Object) {\n            retVal = isEmptyObject(value);\n        }\n        else if (hasOwnProperty('size', value) && isNumber(value.size)) {\n            retVal = isEmptyCollection(value);\n        }\n        else {\n            retVal = !value;\n        }\n        return retVal;\n    },\n\n    /**\n     * Returns whether passed in values is defined and not null or not.\n     * @function module:_objectOps._isset\n     * @param x {*}\n     * @returns {Boolean}\n     */\n    isset = x => x !== null && x !== undefined;\n","\nimport {isObject} from './_is';\n\nimport {keys, hasOwnProperty} from '../_jsPlatform/_object';\n\nexport const\n    /**\n     * Merges all objects down into one.\n     * @function module:jsPlatform._objectOps.assignDeep\n     * @param obj0 {Object}\n     * @param objs {...{Object}}\n     * @returns {Object}\n     */\n    assignDeep = (obj0, ...objs) =>\n        objs.reduce((topAgg, obj) =>\n                keys(obj).reduce((agg, key) => {\n                    let propDescription = Object.getOwnPropertyDescriptor(agg, key);\n                    // If property is not writable move to next item in collection\n                    if (hasOwnProperty(key, agg) && propDescription &&\n                        !(propDescription.get && propDescription.set) &&\n                        !propDescription.writable) {\n                        return agg;\n                    }\n                    if (isObject(agg[key]) && isObject(obj[key])) {\n                        assignDeep(agg[key], obj[key]);\n                    }\n                    else { agg[key] = obj[key]; }\n                    return agg;\n                }, topAgg)\n            , obj0);\n","/**\n * @memberOf _functionOps\n */\n\nimport {apply} from '../_jsPlatform/_function';\n\nexport const\n\n    /**\n     * Takes a function that takes two parameters and returns a negated version of given\n     * function.\n     * @function module:_negate.negateF\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    negateF = fn => (a, b) => !fn(a, b),\n\n    /**\n     * Takes a function that takes three parameters and returns a\n     * negated version of given function.\n     * @function module:_negate.negateF3\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    negateF3 = fn => (a, b, c) => !fn(a, b, c),\n\n    /**\n     * Takes a function that takes four parameters and returns a\n     * negated version of given function.\n     * @function module:_negate.negateF4\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    negateF4 = fn => (a, b, c, d) => !fn(a, b, c, d),\n\n    /**\n     * Takes a function that takes four parameters and returns a\n     * negated version of given function.\n     * @function module:_negate.negateF5\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    negateF5 = fn => (a, b, c, d, e) => !fn(a, b, c, d, e),\n\n    /**\n     * Negates a javascript-'generic' predicate; `Function<element, index, list>`.\n     * @function module:_functionOps.negateP\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    negateP = negateF3,\n\n    /**\n     * Returns a new function which is the dual of `fn` (or the negated version of `fn`).\n     * @function module:_functionOps.negateFMany\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    negateFMany = fn => (...args) => !apply(fn, args);\n","/**\n * Created by elyde on 7/15/2017.\n * @module booleanOps\n */\n\nexport const\n\n    /**\n     * Returns whether `value` is 'truthy' or not\n     * @function module:booleanOps.isTruthy\n     * @param value\n     * @returns {Boolean}\n     */\n    isTruthy = value => !!value,\n\n    /**\n     * Returns whether `value` is 'falsy' or not\n     * @function module:booleanOps.isFalsy\n     * @param value\n     * @returns {Boolean}\n     */\n    isFalsy = value => !value,\n\n    /**\n     * Returns `true`.\n     * @function module:booleanOps.alwaysTrue\n     * @returns {Boolean}\n     */\n    alwaysTrue = () => true,\n\n    /**\n     * Returns `false`.\n     * @function module:booleanOps.alwaysFalse\n     * @returns {Boolean}\n     */\n    alwaysFalse = () => false;\n","import {isFunction, isset} from './_is';\nimport {hasOwnProperty} from '../_jsPlatform/_object';\nimport {apply} from '../_jsPlatform/_function';\nimport {typeOf} from './_typeOf';\n\n/**\n * Checks if given `x` is set and of one of\n *  [String, Boolean, Number, or Symbol] (null and undefined are immutable\n *   but are not \"usable\" or 'not what we usually want to operate on'.\n * @private\n * @param x {*}\n * @returns {Boolean}\n */\nfunction isUsableImmutablePrimitive (x) {\n    const typeOfX = typeOf(x);\n    return isset(x) &&\n        [String.name, Number.name, Boolean.name, Symbol.name]\n            .some(Type => Type === typeOfX);\n}\n\n/**\n * Creates a value `of` given type;  Checks for one of the following construction strategies (in order listed):\n * ```\n * // - If exists `(value).constructor.of` uses this.\n * // - If value is of one String, Boolean, Symbol, or Number types calls it's\n * //      constructor as a function (in cast form;  E.g., `constructor(...args)` )\n * // - Else if constructor is a function, thus far, then calls constructor using\n * //      the `new` keyword (with any passed in args).\n * ```\n * @function module:_objectOps.of\n * @param x {*} - Value to derive returned value's type from.\n * @param [args] {...*} - Any args to pass in to matched construction strategy.\n * @returns {*|undefined} - New value of given value's type else `undefined`.\n */\nexport const of = (x, ...args) => {\n    if (!isset(x)) { return undefined; }\n    const constructor = x.constructor;\n    if (hasOwnProperty('of', constructor)) {\n        return apply(constructor.of, args);\n    }\n    else if (isUsableImmutablePrimitive(x)) {\n        return apply(constructor, args);\n    }\n    else if (isFunction(constructor)) {\n        return new constructor(...args);\n    }\n    return undefined;\n};\n","/**\n * @module _objectOps\n * @description Object operations (uncurried).\n * @private\n */\nexport * from './_jsPlatform/_object';\nexport * from './_objectOps/_prop';\nexport * from './_objectOps/_typeOf';\nexport * from './_objectOps/_is';\nexport * from './_objectOps/_of';\nexport * from './_objectOps/_assignDeep';\nexport * from './_objectOps/_setTheory';\n\nimport {typeOf} from './_objectOps/_typeOf';\n\nexport const\n\n    toArrayMap = obj => Object.keys(obj).map(key => [key, obj[key]]),\n\n    fromArrayMap = xs => xs.reduce((agg, [key, value]) => {\n        agg[key] = value;\n        return agg;\n    }, {}),\n\n    toArray = x => {\n        let out;\n        switch (typeOf(x)) {\n            case 'Null':\n            case 'Undefined':\n                out = [];\n                break;\n            case String.name:\n            case Array.name:\n            case 'WeakMap':\n            case 'WeakSet':\n            case 'Map':\n            case 'Set':\n                out = Array.from(x);\n                break;\n            case Object.name:\n            default:\n                out = toArrayMap(x);\n                break;\n        }\n        return out;\n    }\n\n;\n","import {length} from '../_jsPlatform/_object';\n\n/**\n * @function module:_listOps.map\n * @param fn {Function} - Function to map on array.\n * @param xs {Array}\n * @returns {Array}\n */\nexport default function _map (fn, xs) {\n    let ind = 0,\n        limit = length(xs),\n        out = [];\n    if (!limit) { return out; }\n    while (ind < limit) {\n        out.push(fn(xs[ind], ind, xs));\n        ind += 1;\n    }\n    return out;\n}\n","import {typeOf} from '../_objectOps';\n\nexport const\n\n    aggregateStr = (agg, item) => agg + item,\n\n    aggregateArr = (agg, item) => {\n        agg.push(item);\n        return agg;\n    },\n\n    aggregateObj = (agg, item, ind) => {\n        agg[ind] = item;\n        return agg;\n    },\n\n    aggregatorByType = x => {\n        switch (typeOf(x)) {\n            case 'String': return aggregateStr;\n            case 'Array': return aggregateArr;\n            case 'Object':\n            default: return aggregateObj;\n        }\n    };\n","/**\n * List operator utils module.\n * @module _listOpUtils\n * @private\n */\nimport {apply}              from '../_jsPlatform/_function';  // un-curried version\nimport {slice}              from '../_jsPlatform/_list';      // un-curried version good for both strings and arrays\nimport {length}             from '../_jsPlatform/_object';\nimport {alwaysFalse}        from '../../booleanOps';\nimport _map                 from './_map';\n\nexport * from './_aggregation';\n\nexport const\n\n    /**\n     * Returns a slice of the given list from `startInd` to the end of the list.\n     * @function module:_listOpsUtils.sliceFrom\n     * @param startInd {Number}\n     * @param arr {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    sliceFrom = (startInd, arr) => slice(startInd, undefined, arr),\n\n    /**\n     * Slices from index `0` to given index.\n     * @function module:_listOpsUtils.sliceTo\n     * @param toInd {Number}\n     * @param xs {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    sliceTo = (toInd, xs) => slice(0, toInd, xs),\n\n    /**\n     * Slices a copy of list.\n     * @function _listOpUtils.sliceFrom\n     * @param xs {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    copy = xs => sliceFrom(0, xs),\n\n    /**\n     * Slices a copy of list.\n     * @function _listOpUtils.sliceCopy\n     * @param xs {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    sliceCopy = copy,\n\n    /**\n     * Generic 'ascending order' ordering function (use by the likes of `list.sort` etc.)\n     * @function module:_listOpsUtils.genericAscOrdering\n     * @param a {*}\n     * @param b {*}\n     * @returns {number}\n     */\n    genericAscOrdering = (a, b) => {\n        if (a > b) { return 1; }\n        else if (a < b) { return -1; }\n        return 0;\n    },\n\n    /**\n     * Returns length of all passed lists in list.\n     * @function module:_listOpsUtils.lengths\n     * @param lists ...{Array|String|*}\n     * @returns {Array|String|*}\n     */\n    lengths = (...lists) => length(lists) ? _map(length, lists) : [],\n\n    /**\n     * @function module:_listOpsUtils.lengthsToSmallest\n     * @param lists {...(Array|String|*)}\n     * @returns {Array|String|*}\n     */\n    lengthsToSmallest = (...lists) => {\n        const listLengths = apply(lengths, lists),\n            smallLen = Math.min.apply(Math, listLengths);\n        return _map((list, ind) => listLengths[ind] > smallLen ?\n            sliceTo(smallLen, list) : copy(list), lists);\n    },\n\n    /**\n     * Reduces until predicate.\n     * @param pred\n     * @param op\n     * @param agg\n     * @param arr\n     * @returns {*}\n     */\n    reduceUntil = (pred, op, agg, arr) => {\n        const limit = length(arr);\n        if (!limit) { return agg; }\n        let ind = 0,\n            result = agg;\n        for (; ind < limit; ind++) {\n            if (pred(arr[ind], ind, arr)) { break; }\n            result = op(result, arr[ind], ind, arr);\n        }\n        return result;\n    },\n\n    /**\n     * Reduces until predicate (from the right).\n     * @param pred\n     * @param op\n     * @param agg\n     * @param arr\n     * @returns {*}\n     */\n    reduceRightUntil = (pred, op, agg, arr) => {\n        const limit = length(arr);\n        if (!limit) { return agg; }\n        let ind = limit - 1,\n            result = agg;\n        for (; ind >= 0; ind--) {\n            if (pred(arr[ind], ind, arr)) { break; }\n            result = op(result, arr[ind], ind, arr);\n        }\n        return result;\n    },\n\n    reduce = (operation, agg, arr) =>\n        reduceUntil(\n            alwaysFalse,            // until-predicate\n            operation,              // operation\n            agg,                    // aggregator\n            arr),                   // list\n\n    reduceRight = (operation, agg, arr) =>\n        reduceRightUntil(\n            alwaysFalse,            // until-predicate\n            operation,              // operation\n            agg,                    // aggregator\n            arr),                   // list\n\n    /**\n     * Gets last index of a list/list-like (Array|String|Function etc.).\n     * @function module:_listOpUtilslastIndex\n     * @param x {Array|String|*} - list like or list.\n     * @returns {Number} - `-1` if no element found.\n     */\n    lastIndex = x => { const len = length(x); return len ? len - 1 : 0; },\n\n    /**\n     * Finds index in string or list.\n     * @function module:_listOpUtilsfindIndexWhere\n     * @param pred {Function} - Predicate<element, index, arr>.\n     * @param arr {Array|String}\n     * @returns {Number} - `-1` if predicate not matched else `index` found\n     */\n    findIndexWhere = (pred, arr) => {\n        let ind = -1,\n            predicateFulfilled = false;\n        const limit = length(arr);\n        while (ind < limit && !predicateFulfilled) {\n            predicateFulfilled = pred(arr[++ind], ind, arr);\n        }\n        return ind;\n    },\n\n    /**\n     * Finds index in list from right to left.\n     * @function module:_listOpUtilsfindIndexWhereRight\n     * @param pred {Function} - Predicate<element, index, arr>.\n     * @param arr {Array|String}\n     * @returns {Number} - `-1` if predicate not matched else `index` found\n     */\n    findIndexWhereRight = (pred, arr) => {\n        const limit = length(arr);\n        let ind = limit,\n            predicateFulfilled = false;\n        for (; ind >= 0 && !predicateFulfilled; --ind) {\n            predicateFulfilled = pred(arr[ind], ind, arr);\n        }\n        return ind;\n    },\n\n    /**\n     * @param pred {Function}\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {Array|undefined}\n     */\n    findIndicesWhere = (pred, xs) => {\n        if (!xs || !xs.length) { return undefined; }\n        const limit = length(xs);\n        let ind = 0,\n            out = [];\n        for (; ind < limit; ind++) {\n            if (pred(xs[ind], ind, xs)) { out.push(ind); }\n        }\n        return out.length ? out : undefined;\n    },\n\n    /**\n     * @function module:_listOpUtilsfind\n     * @param pred {Function}\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {*}\n     */\n    findWhere = (pred, xs) => {\n        let ind = 0,\n            limit = length(xs);\n        if (!limit) { return; }\n        for (; ind < limit; ind++) {\n            let elm = xs[ind];\n            if (pred(elm, ind, xs)) { return elm; }\n        }\n    }\n\n;\n","/**\n * List operations module.\n * @module _listOps\n * @todo decide whether to throw errors where functions cannot function without a specific type or to return undefined (and also determine which cases are ok for just returning undefined).\n * @private\n */\nimport {\n    concat as listAppend,\n    indexOf, slice, includes\n}\n    from './_jsPlatform/_list';\n\nimport {apply} from './_jsPlatform/_function';\nimport {negateP, negateF} from './_functionOps/_negate';\nimport {isTruthy, isFalsy} from '../booleanOps';\nimport {prop, length} from './_objectOps';\nimport _map from './_listOps/_map';\n\nimport {\n    sliceFrom, sliceTo, lengths,\n    lengthsToSmallest, aggregateArr,\n    reduceUntil, reduce, reduceRight, lastIndex,\n    findIndexWhere, findIndexWhereRight, findIndicesWhere,\n    findWhere, copy, genericAscOrdering\n}\n    from './_listOps/_utils';\n\n// Exported imports\nexport {_map};\n\n// Exported internals\nexport const\n\n    /**\n     * Append two lists, i.e.,\n     * ```\n     * append([x1, ..., xm], [y1, ..., yn]) // outputs: [x1, ..., xm, y1, ..., yn]\n     * append([x1, ..., xm], [y1, ...]) // outputs: [x1, ..., xm, y1, ...]\n     * ```\n     * If the first list is not finite, the result is the first list.\n     * @haskellType `append :: List a => a -> a -> a`\n     * @function module:_listOps.append\n     * @param xs1 {Array} - list or list like.\n     * @param xs2 {Array} - list or list like.\n     * @returns {Array} - Same type as list like passed in.\n     */\n    append = listAppend,\n\n    /**\n     * Append two or more lists, i.e., same as `append` but for two ore more lists.\n     * @haskellType `appendMany :: List a => a -> [a] -> a\n     * @note In `@haskellType` we wrote `[a]` only to keep the haskell type valid though note in javascript\n     *  this is actually different since the function converts the zero ore more parameters into an array containing such for us.\n     * @function module:_listOps.appendMany\n     * @param args ...{Array} - Lists or lists likes.\n     * @returns {Array} - Same type as first list or list like passed in.\n     */\n    appendMany = (...args) => {\n        if (length(args)) { return apply(listAppend, args); }\n        throw new Error('`appendMany` requires at least one arg.');\n    },\n\n    /**\n     * Returns head of list (first item of list).\n     * @haskellType `head :: [a] -> a`\n     * @function module:_listOps.head\n     * @param x {Array|String}\n     * @returns {*} - First item from list\n     */\n    head = x => x[0],\n\n    /**\n     * Returns last item of list.\n     * @haskellType `last :: [a] -> a`\n     * @function module:_listOps.last\n     * @param xs {Array|String}\n     * @returns {*}\n     */\n    last = xs => xs[lastIndex(xs)],\n\n    /**\n     * Returns tail part of list (everything after the first item as new list).\n     * @haskelType `tail :: [a] -> [a]`\n     * @function module:_listOps.tail\n     * @param xs {Array}\n     * @returns {Array}\n     */\n    tail = xs => sliceFrom(1, xs),\n\n    /**\n     * Returns everything except last item of list as new list.\n     * @haskellType `init :: [a] -> [a]`\n     * @function module:_listOps.init\n     * @param xs {Array|String}\n     * @returns {Array|String}\n     */\n    init = xs => sliceTo(lastIndex(xs), xs),\n\n    /**\n     * Returns `head` and `tail` of passed in list/string in a tuple.\n     * @haskellType `uncons :: [a] -> Maybe (a, [a])`\n     * @function module:_listOps.uncons\n     * @param xs {Array|String}\n     * @returns {Array|undefined}\n     */\n    uncons = xs =>\n        !xs || length(xs) === 0 ? undefined : [head(xs), tail(xs)],\n\n    /**\n     * Returns `tail` and `head` of passed in list/string in a tuple.\n     * @haskellType `unconsr :: [a] -> Maybe ([a], a)`\n     * @function module:_listOps.unconsr\n     * @param xs {Array|String}\n     * @returns {Array|String|*|undefined}\n     */\n    unconsr = xs => !xs || length(xs) === 0 ? undefined : [init(xs), last(xs)],\n    \n    /**\n     * Concatenates all the elements of a container of lists.\n     * @haskellType `concat :: Foldable t => t [a] -> [a]`\n     * @function module:_listOps.concat\n     * @param xs {Array}\n     * @returns {Array}\n     */\n    concat = xs => !length(xs) ? copy(xs) : apply(appendMany, xs),\n\n    /**\n     * Map a function over all the elements of a container and concatenate the resulting lists.\n     * @haskellType `concatMap :: Foldable t => (a -> [b]) -> t a -> [b]`\n     * @function module:_listOps.concatMap\n     * @param fn {Function}\n     * @param foldableOfA {Array}\n     * @returns {Array}\n     */\n    concatMap = (fn, foldableOfA) => concat(_map(fn, foldableOfA)),\n\n    /**\n     * Returns a copy of the passed in list reverses.\n     * @haskellType `reverse :: [a] -> [a]`\n     * @function module:_listOps.reverse\n     * @param x {Array}\n     * @returns {Array}\n     */\n    reverse = x => foldr((agg, item) => (agg.push(item), agg), [], x),\n\n    /**\n     * Takes an element and a list and `intersperses' that element between the elements of the list. For example\n     * @function module:_listOps.intersperse\n     * @note In our version of the function javascript is loosely typed so, so is our function (to much overhead to make\n     *  it typed) so `between` can be any value.\n     * @param between {*} - Should be of the same type of elements contained in list.\n     * @param arr {Array} - List.\n     * @returns {Array}\n     */\n    intersperse = (between, arr) => {\n        const limit = length(arr),\n            lastInd = limit - 1,\n            out = [];\n        if (!limit) {\n            return out;\n        }\n        return foldl((agg, item, ind) => (\n                ind === lastInd ?\n                    agg.push(item) :\n                    agg.push(item, between),\n                agg\n            ), out, arr);\n    },\n\n    /**\n     * `intercalate xs xss` is equivalent to (concat (intersperse xs xss)). It inserts the list xs in between the lists in xss and concatenates the result.\n     * @haskellType `intercalate :: [a] -> [[a]] -> [a]`\n     * @function module:_listOps.intercalate\n     * @param xs {Array}\n     * @param xss {Array}\n     * @returns {Array}\n     */\n    intercalate = (xs, xss) => concat(intersperse(xs, xss)),\n\n    /**\n     * Transposes rows and columns into lists by index;  E.g.,\n     * Haskell example:\n     * ```\n     *  transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]\n     *\n     *  -- Notice the shorter arrays are ignored after their last index is copied over:\n     *  transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]\n     * ```\n     * @note from columns to rows.\n     * @note Empty lists are ignored.\n     * @todo upgrade this function to support lists of strings.\n     * @haskellType `transpose :: [[a]] -> [[a]]`\n     * @function module:_listOps.transpose\n     * @param xss {Array}\n     * @returns {Array}\n     */\n    transpose = xss => {\n        let numLists = length(xss),\n            ind = 0, ind2;\n        if (!numLists) {\n            return [];\n        }\n        const listLengths = apply(lengths, xss),\n            longestListLen = maximum(listLengths),\n            outLists = [];\n        for (; ind < longestListLen; ind += 1) {\n            const outList = [];\n            for (ind2 = 0; ind2 < numLists; ind2 += 1) {\n                if (listLengths[ind2] < ind + 1) {\n                    continue;\n                }\n                outList.push(xss[ind2][ind]);\n            }\n            outLists.push(outList);\n        }\n        return filter(x => length(x), outLists);\n    },\n\n    /**\n     * Generates 2^n sub-sequences for passed in sequence (string/list) (`n` is\n     * the length of the passed in sequence so: 2^length(xs)).\n     * Note: The return value doubles per index/character passed in so use with caution!\n     *  Also note that for 2^16 (or for a sequence of 16 characters) this algorithm\n     *  will generate 65536 sub-sequences!  So caution should be taken to not\n     *  use this with sequences above a certain length on certain platform (the browser thread in specific).\n     * @function module:_listOps.subsequences\n     * @jsperftest https://jsperf.com/subsequences\n     * @param xs {Array|String}\n     * @returns {Array.<Array>}\n     */\n    subsequences = xs => {\n        const listLen = length(xs),\n            len = Math.pow(2, listLen),\n            out = [];\n        for (let i = 0; i < len; i += 1) {\n            let entry = [];\n            for (let j = 0; j < listLen; j += 1) {\n                if (i & (1 << j)) {\n                    entry.push(xs[j]);\n                }\n            }\n            out.push(entry);\n        }\n        return out;\n    },\n\n    /**\n     * Same as `subsequences` but returns an `Array.<Type>` instead\n     *  of an array of arrays.  **Note:** `Type` here means\n     *  a string, an instance of array, or some indexable-like type.\n     * @function module:_listOps.subsequences1\n     * @jsperftest https://jsperf.com/subsequences\n     * @param xs {Array|String}\n     * @returns {Array.<(Array|String|*)>}\n     */\n    subsequences1 = xs => {\n        const listLen = length(xs),\n            len = Math.pow(2, listLen),\n            out = [];\n        for (let i = 0; i < len; i += 1) {\n            let entry = [];\n            for (let j = 0; j < listLen; j += 1) {\n                if (i & (1 << j)) {\n                    entry.push(xs[j]);\n                }\n            }\n            out.push(entry);\n        }\n        return out;\n    },\n\n    swapped = (ind1, ind2, list) => {\n        const out = copy(list),\n            tmp = out[ind1];\n        out[ind1] = out[ind2];\n        out[ind2] = tmp;\n        return out;\n    },\n\n    /**\n     * Returns a list of permutations for passed in list.\n     *  Use caution with lists above a length of 15 (will take long due to nature of\n     *  algorithm).\n     * @function module:_listOps.permutations\n     * @param xs {Array} - List.\n     * @returns {Array<Array|String|*>} - Array of permutations.\n     */\n    permutations = xs => {\n        const limit = length(xs);\n\n        if (!limit || limit === 1) {\n            return [xs];\n        }\n\n        let list = copy(xs),\n            c = repeat(limit, 0),\n            i = 0;\n\n        const out = [list];\n\n        for (; i < limit; i++) {\n            if (c[i] < i) {\n                list = swapped(i % 2 === 0 ? 0 : c[i], i, list);\n                out.push(list);\n                c[i] += 1;\n                i = 0;\n                continue;\n            }\n            c[i] = 0;\n        }\n\n        return out;\n    },\n\n    /**\n     * Left associative fold.  Reduces a container of elements down by the given operation (same as [].reduce).\n     * @function module:_listOps.foldl\n     * @param fn {Function}\n     * @param zero {*} - Aggregator.\n     * @param functor {Array}\n     * @returns {*} - Whatever type is lastly returned from `fn`.\n     */\n    foldl = reduce,\n\n    /**\n     * Right associative fold.  Reduces a container of elements down by the given operation (same as [].reduceRight).\n     * @function module:_listOps.foldr\n     * @param fn {Function}\n     * @param zero {*} - Aggregator.\n     * @param functor {Array}\n     * @returns {*} - Whatever type is lastly returned from `fn`.\n     */\n    foldr = reduceRight,\n\n    /**\n     * A variant of `foldl` except that this one doesn't require the starting point.  The starting point/value will be pulled\n     * out from a copy of the container.\n     * @function module:_listOps.foldl1\n     * @param op {Function}\n     * @param xs {Array}\n     * @returns {*} - Whatever type is lastly returned from `op`.\n     */\n    foldl1 = (op, xs) => {\n        const parts = uncons(xs);\n        return !parts ? [] : reduce(op, parts[0], parts[1]);\n    },\n\n    /**\n     * A variant of `foldr` except that this one doesn't require the starting point/value.  The starting point/value will be pulled\n     * out from a copy of the container.\n     * @function module:_listOps.foldr1\n     * @param op {Function}\n     * @param xs {Array}\n     * @returns {*} - Whatever type is lastly returned from `op`.\n     */\n    foldr1 = (op, xs) => {\n        const parts = unconsr(xs);\n        return !parts ? [] : reduceRight(op, parts[1], parts[0]);\n    },\n\n    /**\n     * Performs a map then a reduce all in one (from left-to-right). Returns a tuple\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\n     * @function module:_listOps.mapAccumL\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\n     * @param xs {Array} - list type.\n     * @return {Array} - [aggregated, list]\n     */\n    mapAccumL = (op, zero, xs) => {\n        const list = copy(xs),\n            limit = length(xs);\n        if (!limit) {\n            return [zero, list];\n        }\n        let ind = 0,\n            agg = zero,\n            mapped = [],\n            tuple;\n        for (; ind < limit; ind++) {\n            tuple = op(agg, list[ind], ind);\n            agg = tuple[0];\n            mapped = tuple[1];\n        }\n        return [agg, mapped];\n    },\n\n    /**\n     * Performs a map and a reduce all in one (from right-to-left). Returns a tuple\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\n     * @function module:_listOps.mapAccumR\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\n     * @param xs {Array} - list type.\n     * @return {Array} - [aggregated, list]\n     */\n    mapAccumR = (op, zero, xs) => {\n        const list = copy(xs),\n            limit = length(xs);\n        if (!limit) {\n            return [zero, list];\n        }\n        let ind = limit - 1,\n            agg = zero,\n            mapped = [],\n            tuple;\n        for (; ind >= 0; ind--) {\n            tuple = op(agg, list[ind], ind);\n            agg = tuple[0];\n            mapped = tuple[1];\n        }\n        return [agg, mapped];\n    },\n\n    /**\n     * iterate f x returns an infinite list of repeated applications of f to x.\n     * @function module:_listOps.iterate\n     * @example `iterate(5, f, x) == [x, f(x), f(f(x)), ...]`\n     * @param limit {Number}\n     * @param op {Function} - Operation.\n     * @param x {*} - Starting point.\n     * @returns {*}\n     */\n    iterate = (limit, op, x) => {\n        let ind = 0,\n            out = [],\n            lastX = x;\n        for (; ind < limit; ind += 1) {\n            out.push(lastX);\n            lastX = op(lastX);\n        }\n        return out;\n    },\n\n    /**\n     * Repeats `x` `limit` number of times.\n     * @function module:_listOps.repeat\n     * @param limit {Number}\n     * @param x {*}\n     * @return {Array}\n     */\n    repeat = (limit, x) => iterate(limit, a => a, x),\n\n    /**\n     * Same as `repeat` due to the nature of javascript (see haskell version for usage).\n     * @function module:_listOps.replicate\n     * @param limit {Number}\n     * @param x {*}\n     * @return {Array}\n     */\n    replicate = repeat,\n\n    /**\n     * Replicates a list `limit` number of times and appends the results (concat)\n     * @function module:_listOps.cycle\n     * @param limit {Number}\n     * @param xs {Array}\n     * @returns {Array}\n     */\n    cycle = (limit, xs) => concat(replicate(limit, xs)),\n\n    /**\n     * Unfolds a value into a list of somethings.\n     * @haskellType `unfoldr :: (b -> Maybe (a, b)) -> b -> [a]`\n     * @function module:_listOps.unfoldr\n     * @param op {Function} - Operation to perform (should return a two component tuple (item to aggregate and item to unfold in next iteration).\n     * @param x {*} - Starting parameter to unfold from.\n     * @returns {Array} - An array of whatever you return from `op` yielded.\n     */\n    unfoldr = (op, x) => {\n        let ind = 0,\n            out = [],\n            resultTuple = op(x, ind, out);\n        while (resultTuple) {\n            out.push(resultTuple[0]);\n            resultTuple = op(resultTuple[1], ++ind, out);\n        }\n        return out;\n    },\n\n    /**\n     * Finds index in string or list (alias for `findIndex`).\n     * @function module:_listOps.findIndex\n     * @param pred {Function} - Predicate<element, index, arr>.\n     * @param arr {Array|String}\n     * @returns {Number} - `-1` if predicate not matched else `index` found\n     */\n    findIndex = findIndexWhere,\n\n    /**\n     * @function module:_listOps.findIndices\n     * @param pred {Function}\n     * @param xs {Array} - list or list like.\n     * @returns {Array|undefined}\n     */\n    findIndices = findIndicesWhere,\n\n    /**\n     * @function module:_listOps.elemIndex\n     * @param x {*} - Element to search for.\n     * @param xs {Array} - list or list like.\n     * @returns {*}\n     */\n    elemIndex = (x, xs) => {\n        const foundInd = indexOf(x, xs);\n        return foundInd !== -1 ? foundInd : undefined;\n    },\n\n    /**\n     * @function module:_listOps.elemIndices\n     * @param value {*} - Element to search for.\n     * @param xs {Array} - list or list like.\n     * @returns {*}\n     */\n    elemIndices = (value, xs) => findIndices(x => x === value, xs),\n\n    /**\n     * Takes `n` items from start of list to `limit` (exclusive).\n     * @function module:_listOps.take\n     * @param list {Array|String}\n     * @param limit {Number}\n     * @returns {String|Array} - Passed in type's type\n     */\n    take = (limit, list) => sliceTo(limit, list),\n\n    /**\n     * Drops `n` items from start of list to `count` (exclusive).\n     * @function module:_listOps.take\n     * @param list {Array|String}\n     * @param count {Number}\n     * @returns {String|Array} - Passed in type's type\n     */\n    drop = (count, list) => sliceFrom(count, list),\n\n    /**\n     * Splits `x` in two at given `index` (exclusive (includes element/character at\n     * given index in second part of returned list)).\n     * @function module:_listOps.splitAt\n     * @param ind {Number} - Index to split at.\n     * @param list {Array} - functor (list or string) to split.\n     * @returns {Array} - Array of whatever type `x` was when passed in\n     */\n    splitAt = (ind, list) => [ sliceTo(ind, list), sliceFrom(ind, list) ],\n\n    /**\n     * Gives an list with passed elements while predicate was true.\n     * @function module:_listOps.takeWhile\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @returns {Array}\n     */\n    takeWhile = (pred, list) =>\n        reduceUntil(\n            negateP(pred),  // predicate\n            aggregateArr,   // operation\n            [],             // aggregator\n            list\n        ),\n\n    /**\n     * Returns an list without elements that match predicate.\n     * @function module:_listOps.dropWhile\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @refactor\n     * @returns {Array|String}\n     */\n    dropWhile = (pred, list) => {\n        const limit = length(list),\n            splitPoint =\n                findIndexWhere((item, ind, list2) =>\n                    !pred(list[ind], ind, list2), list);\n\n        return splitPoint === -1 ?\n            sliceTo(limit, list) :\n            slice(splitPoint, limit, list);\n    },\n\n    /**\n     * @function module:_listOps.dropWhile\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @refactor\n     * @returns {Array|String}\n     */\n    dropWhileEnd = (pred, list) => {\n        const limit = length(list),\n            splitPoint =\n                findIndexWhereRight((item, ind, list2) =>\n                    !pred(list[ind], ind, list2), list);\n\n        return splitPoint === -1 ?\n            sliceTo(limit, list) :\n            sliceTo(splitPoint + 1, list);\n    },\n\n    /**\n     * Gives a span such that the first list (in returned tuple) is the span of items matching upto `not predicate` and\n     * the second list in the tuple is a list of the remaining elements in the given list.\n     * **@Note: Not the same as `partition`.  Read descriptions closely!!!\n     * @function module:_listOps.partition\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\n     * @param list {Array} - Predicate<item, index, originalArrayOrString>\n     * @returns {Array} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\n     */\n    span = (pred, list) => {\n        const splitPoint = findIndexWhere(negateP(pred), list);\n        return splitPoint === -1 ?\n            splitAt(0, list) : splitAt(splitPoint, list);\n    },\n\n    breakOnList = (pred, list) => {\n        const splitPoint = findIndexWhere(pred, list);\n        return splitPoint === -1 ?\n            splitAt(0, list) : splitAt(splitPoint, list);\n    },\n\n    /**\n     * Gets item at index.\n     * @function module:_listOps.at\n     * @param ind {Number} - Index.\n     * @param xs {Array} - list or list like.\n     * @returns {*|undefined} - Item or `undefined`.\n     */\n    at = prop,\n\n    /**\n     * Find an item in structure of elements based on given predicate (`pred`).\n     * @function module:_listOps.find\n     * @param pred {Function}\n     * @param xs {Array} - list or list like.\n     * @returns {*} - Found item.\n     */\n    find = findWhere,\n\n    /**\n     * Filters a structure of elements using given predicate (`pred`) (same as `[].filter`).\n     * @function module:_listOps.filter\n     * @param pred {Function}\n     * @param xs {Array} - list or list like.\n     * @returns {Array} - Structure of filtered elements.\n     */\n    filter = (pred, xs) => {\n        let ind = 0,\n            limit = length(xs),\n            out = [];\n        if (!limit) {\n            return out;\n        }\n        for (; ind < limit; ind++) {\n            if (pred(xs[ind], ind, xs)) {\n                out.push(xs[ind]);\n            }\n        }\n        return out;\n    },\n\n    /**\n     * Partitions a list on a predicate;  Items that match predicate are in first list in tuple;  Items that\n     * do not match the tuple are in second list in the returned tuple.\n     *  Essentially `[filter(p, xs), filter(negateP(p), xs)]`.\n     * @function module:_listOps.partition\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\n     * @param list {Array}\n     * @returns {Array|String} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\n     */\n    partition = (pred, list) =>\n        !length(list) ?\n            [[], []] :\n                [filter(pred, list), filter(negateP(pred), list)],\n\n    /**\n     * Returns a boolean indicating whether an element exists in given structure of elements.\n     * @function module:_listOps.elem\n     * @param element {*}\n     * @param xs {Array}\n     * @returns {Boolean}\n     */\n    elem = includes,\n\n    /**\n     * The opposite of `elem` - Returns a boolean indicating whether an element exists in given list.\n     * @function module:_listOps.elem\n     * @param element {*}\n     * @param xs {Array}\n     * @returns {Boolean}\n     */\n    notElem = negateF(includes),\n\n    lookup = at,\n\n    isPrefixOf = (xs1, xs2) => {\n        const limit1 = length(xs1),\n            limit2 = length(xs2);\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\n            return false;\n        }\n        let ind = 0;\n        for (; ind < limit1; ind++) {\n            if (xs1[ind] !== xs2[ind]) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    isSuffixOf = (xs1, xs2) => {\n        const limit1 = length(xs1),\n            limit2 = length(xs2);\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\n            return false;\n        }\n        let ind1 = limit1 - 1,\n            ind2 = limit2 - 1;\n        for (; ind1 >= 0; ind1--) {\n            if (xs1[ind1] !== xs2[ind2]) {\n                return false;\n            }\n            ind2 -= 1;\n        }\n        return true;\n    },\n\n    isInfixOf = (xs1, xs2) => {\n        const limit1 = length(xs1),\n            limit2 = length(xs2);\n        if (limit2 < limit1 || !limit1 || !limit2) {\n            return false;\n        }\n        let ind1,\n            foundLen,\n            ind = 0;\n        for (; ind < limit2; ind += 1) {\n            foundLen = 0;\n            for (ind1 = 0; ind1 < limit1; ind1 += 1) {\n                if (xs2[ind1 + ind] === xs1[ind1]) {\n                    foundLen += 1;\n                }\n                if (foundLen === limit1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    },\n\n    isSubsequenceOf = (xs1, xs2) => {\n        const len = Math.pow(2, length(xs2)),\n            lenXs1 = length(xs1);\n        let foundLen,\n            i;\n        for (i = 0; i < len; i += 1) {\n            foundLen = 0;\n            for (let j = 0; j < len; j += 1) {\n                if (i & (1 << j) && indexOf(xs2[j], xs1) > -1) {\n                    foundLen += 1;\n                }\n                if (foundLen === lenXs1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    },\n\n    /**\n     * The group function takes a list and returns a list of lists such that\n     *  the concatenation of the result is equal to the argument. Moreover, each\n     *  sublist in the result contains only equal elements. For example,\n     * `group \"Mississippi\" = [\"M\",\"i\",\"ss\",\"i\",\"ss\",\"i\",\"pp\",\"i\"]`\n     * It is a special case of groupBy, which allows the programmer to supply\n     *  their own equality test.\n     * @haskellType `group :: Eq a => [a] -> [[a]]`\n     * @function module:_listOps.group\n     * @param xs {Array}\n     * @returns {Array<Array|String|*>|*}\n     */\n    group = xs => groupBy((a, b) => a === b, xs),\n\n    /**\n     * Allows you to group items in a list based on your supplied equality check.\n     * @note Sames `group` but allows you to specify equality operation.\n     * @haskellType `groupBy :: (a -> a -> Bool) -> [a] -> [[a]]`\n     * @function module:_listOps.groupBy\n     * @param equalityOp {Function}\n     * @param xs {Array}\n     * @returns {*}\n     */\n    groupBy = (equalityOp, xs) => {\n        const limit = length(xs);\n        if (!limit) {\n            return copy(xs);\n        }\n        let ind = 0,\n            prevItem,\n            item,\n            predOp = x => {\n                if (equalityOp(x, prevItem)) {\n                    ind++;\n                }\n                if (equalityOp(x, item)) {\n                    prevItem = x;\n                    return true;\n                }\n                return false;\n            },\n            agg = [];\n        for (; ind < limit; ind += 1) {\n            item = xs[ind];\n            agg.push(takeWhile(predOp, slice(ind, limit, xs)));\n        }\n        return agg;\n    },\n\n    /**\n     * The inits function returns all initial segments of the argument, shortest first. For example,\n     * ```\n     * shallowEquals(inits('abc'), ['','a','ab','abc'])\n     * ```\n     * @function module:_listOps.inits\n     * @haskellType `inits :: [a] -> [[a]]`\n     * @param xs {Array}\n     * @returns {Array}\n     */\n    inits = xs => {\n        let limit = length(xs),\n            ind = 0,\n            agg = [];\n        if (!limit) {\n            return [];\n        }\n        for (; ind <= limit; ind += 1) {\n            agg.push(sliceTo(ind, xs));\n        }\n        return agg;\n    }, //_map(list => init(list), xs),\n\n    /**\n     * The inits function returns all initial segments of the argument, shortest first. For example,\n     * ```\n     * shallowEquals(tails('abc'), ['abc', 'bc', 'c',''])\n     * ```\n     * @function module:_listOps.tails\n     * @haskellType `tails :: [a] -> [[a]]`\n     * @param xs {Array}\n     * @returns {Array}\n     */\n    tails = xs => {\n        let limit = length(xs),\n            ind = 0,\n            agg = [];\n        if (!limit) {\n            return [];\n        }\n        for (; ind <= limit; ind += 1) {\n            agg.push(slice(ind, limit, xs));\n        }\n        return agg;\n    }, //_map(list => tail(list), xs),\n\n    stripPrefix = (prefix, list) =>\n        isPrefixOf(prefix, list) ?\n            splitAt(length(prefix), list)[1] :\n            copy(list),\n\n    /**\n     * zip takes two lists and returns a list of corresponding pairs.\n     * If one input list is short, excess elements of the longer list are discarded.\n     * @haskellType `zip :: [a] -> [b] -> [(a, b)]`\n     * @function module:_listOps.zip\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip = (arr1, arr2) => {\n        if (!length(arr1) || !length(arr2)) {\n            return [];\n        }\n        const [a1, a2] = lengthsToSmallest(arr1, arr2);\n        return reduce((agg, item, ind) =>\n                aggregateArr(agg, [item, a2[ind]]),\n            [], a1);\n    },\n\n    /**\n     * zipN takes one or more lists and returns a list containing lists of all indices\n     * at a given index, index by index.\n     * If one input list is short, excess elements of the longer list are discarded.\n     * @function module:_listOps.zipN\n     * @param lists {Array|String} - One ore more lists of the same type.\n     * @returns {Array}\n     */\n    zipN = (...lists) => {\n        const trimmedLists = apply(lengthsToSmallest, filter(length, lists)),\n            lenOfTrimmed = length(trimmedLists);\n        if (!lenOfTrimmed) {\n            return [];\n        }\n        else if (lenOfTrimmed === 1) {\n            return sliceTo(length(trimmedLists[0]), trimmedLists[0]);\n        }\n        return reduce((agg, item, ind) =>\n                aggregateArr(agg, _map(xs => xs[ind], trimmedLists)),\n            [], trimmedLists[0]);\n    },\n\n    /**\n     * @haskellType `zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]`\n     * @function module:_listOps.zip3\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @param arr3 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip3 = (arr1, arr2, arr3) => zipN(arr1, arr2, arr3),\n\n    /**\n     * @haskellType `zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]`\n     * @function module:_listOps.zip4\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @param arr3 {Array}\n     * @param arr4 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip4 = (arr1, arr2, arr3, arr4) => zipN(arr1, arr2, arr3, arr4),\n\n    /**\n     * @haskellType `zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]`\n     * @function module:_listOps.zip5\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @param arr3 {Array}\n     * @param arr4 {Array}\n     * @param arr5 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip5 = (arr1, arr2, arr3, arr4, arr5) => zipN(arr1, arr2, arr3, arr4, arr5),\n\n    /**\n     * zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\n     * zipWith generalises zip by zipping with the function given as the\n     * first argument, instead of a function tupling function (function that returns a tuple). For example,\n     * zipWith (+) is applied to two lists to produce the list of corresponding sums.\n     * @note `_|_` means bottom or perpetual (@see\n     *  - https://wiki.haskell.org/Bottom\n     *  - https://stackoverflow.com/questions/19794681/what-does-this-syntax-mean-in-haskell-or\n     *  )\n     * @example\n     * ```\n     * zipWith f [] _|_ = []\n     * ```\n     * @haskellType `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`\n     * @function module:_listOps.zipWith\n     * @param op {Function} - Takes two parts of a tuple and returns a tuple.\n     *  E.g., ` op :: a -> b -> (a, b)`\n     * @param xs1 {Array}\n     * @param xs2 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith = (op, xs1, xs2) => {\n        if (!length(xs1) || !length(xs2)) {\n            return [];\n        }\n        const [a1, a2] = lengthsToSmallest(xs1, xs2);\n        return reduce((agg, item, ind) =>\n                aggregateArr(agg, op(item, a2[ind])),\n            [], a1);\n    },\n\n    /**\n     * Zips all given lists with tupling function. Note: Haskell types do not have\n     *  a way (that I know of) to show one or more for params in a function so `@haskellType` below\n     *  is left there for general purpose not for exactness as is told by aforementioned.\n     * @haskellType `zipWithN :: (a -> b -> c) -> [a] -> [b] -> [c]` - Where `N` is the number\n     *  of lists to zip.\n     * @function module:_listOps.zipWithN\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\n     * @param lists ...{Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWithN = (op, ...lists) => {\n        const trimmedLists = apply(lengthsToSmallest, lists),\n            lenOfTrimmed = length(trimmedLists);\n        if (!lenOfTrimmed) {\n            return [];\n        }\n        else if (lenOfTrimmed === 1) {\n            return sliceTo(length(trimmedLists[0]), trimmedLists[0]);\n        }\n        return reduce((agg, item, ind) =>\n                aggregateArr(agg, apply(op, _map(xs => xs[ind], trimmedLists))),\n            [], trimmedLists[0]);\n    },\n\n    /**\n     * Zips 3 lists with tupling function.\n     * @haskellType `zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]`\n     * @function module:_listOps.zipWith3\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\n     * @param xs1 {Array}\n     * @param xs2 {Array}\n     * @param xs3 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith3 = (op, xs1, xs2, xs3) => zipWithN(op, xs1, xs2, xs3),\n\n    /**\n     * Zips 4 lists with tupling function.\n     * @haskellType `zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c]  -> [d] -> [e]`\n     * @function module:_listOps.zipWith4\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> d -> (a, b, c, d)`\n     * @param xs1 {Array}\n     * @param xs2 {Array}\n     * @param xs3 {Array}\n     * @param xs4 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith4 = (op, xs1, xs2, xs3, xs4) => zipWithN(op, xs1, xs2, xs3, xs4),\n\n    /**\n     * Zips 5 lists.\n     * @haskellType `zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c]  -> [d] -> [e] -> [f]`\n     * @function module:_listOps.zipWith5\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> d -> e -> (a, b, c, d, e)`\n     * @param xs1 {Array}\n     * @param xs2 {Array}\n     * @param xs3 {Array}\n     * @param xs4 {Array}\n     * @param xs5 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith5 = (op, xs1, xs2, xs3, xs4, xs5) => zipWithN(op, xs1, xs2, xs3, xs4, xs5),\n\n    /**\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\n     * @haskellType `unzip :: [(a, b)] -> ([a], [b])`\n     * @todo Should support other list types (should not have `push` hard coded instead should use `mappend` (if available)).\n     * @function module:_listOps.unzip\n     * @param arr {Array|*}\n     * @returns {Array|*}\n     */\n    unzip = arr =>\n        foldl((agg, item) => {\n            agg[0].push(item[0]);\n            agg[1].push(item[1]);\n            return agg;\n        }, [[], []], arr),\n\n    /**\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\n     * @sudoHaskellType `unzipN :: [(a, b, ...x)] -> ([a], [b], ...[x])`\n     * @todo Should support other list types (should not have `push` hard coded instead should use `mappend` (if available)).\n     * @function module:_listOps.unzip\n     * @param list {Array|*} - List of tuples (lists).\n     * @returns {Array|*}\n     */\n    unzipN = list => {\n        if (!length(list)) {\n            return [];\n        }\n        const lenItem0 = length(list[0]);\n        let zero = lenItem0 ?\n            unfoldr(numLists => numLists-- ? [[], numLists] : undefined, lenItem0) :\n            [];\n        return foldl((agg, item) => {\n            agg.forEach((outList, ind) => outList.push(item[ind]));\n            return agg;\n        }, zero, list);\n    },\n\n    /**\n     * Returns true if any item in container passes predicate `p`.\n     * @function module:_listOps.any\n     * @param p {Function} - Predicate.\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    any = (p, xs) => {\n        let ind = 0,\n            limit = length(xs);\n        if (!limit) {\n            return false;\n        }\n        for (; ind < limit; ind += 1) {\n            if (p(xs[ind])) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    /**\n     * Returns true if all items in container pass predicate `p`.\n     * @function module:_listOps.all\n     * @param p {Function} - Predicate.\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    all = (p, xs) => {\n        const limit = length(xs);\n        let ind = 0;\n        if (limit === 0) {\n            return false;\n        }\n        for (; ind < limit; ind++) {\n            if (!p(xs[ind], ind, xs)) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    /**\n     * Conjuction of container of bools (or truthy and/or falsy values);  Returns\n     * `true` if all in container are 'truthy' else returns `false`\n     * @function module:_listOps.and\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    and = xs => all(isTruthy, xs),\n\n    /**\n     * Returns a boolean indicating whether any item in container is 'truthy' or not.\n     * **Note** The haskell type for this function only takes two items, but here\n     * we allow the passing of more than one item (may change later to adhere to the haskell type).\n     * @function module:_listOps.or\n     * @haskellType `or :: Bool -> Bool -> Bool`\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    or = xs => any(isTruthy, xs),\n\n    /**\n     * Returns a boolean indicating whether all items in container are 'falsy' or not.\n     * **Note** The haskell type for this function only takes two items, but here\n     * we allow the passing of more than one item (may change later to adhere to the haskell type).\n     * @function module:_listOps.not\n     * @haskellType `not :: Bool -> Bool`\n     * @param xs {Array|String}\n     * @returns {Boolean}\n     */\n    not = xs => all(isFalsy, xs),\n\n    /**\n     * Computes the sum of the numbers of a structure.\n     * @function module:_listOps.sum\n     * @haskellType `sum :: (List t, Num a) => t a -> a`\n     * @param list {Array|String}\n     * @returns {Number}\n     */\n    sum = list => foldl((agg, x) => agg + x, 0, list),\n\n    /**\n     * Computes the product of the numbers of a structure.\n     * @function module:_listOps.product\n     * @haskellType `product :: (List t, Num a) => t a -> a`\n     * @param list {Array|String}\n     * @returns {Number}\n     */\n    product = list => foldl((agg, x) => agg * x, 1, list),\n\n    /**\n     * Returns the largest element in a non-empty structure of elements.\n     * @function module:_listOps.maximum\n     * @haskellType `maximum :: forall a . Ord a => t a -> a`\n     * @param list {Array|String}\n     * @returns {*} - Whatever type the array is made of (if any).\n     */\n    maximum = list => last(sortBy(genericAscOrdering, list)),\n\n    /**\n     * Returns the smallest element in a non-empty structure of elements.\n     * @function module:_listOps.minimum\n     * @haskellType `minimum :: forall a . Ord a => t a -> a`\n     * @param list {Array|String}\n     * @returns {*} - Whatever type the array is made of (if any).\n     */\n    minimum = list => head(sortBy(genericAscOrdering, list)),\n\n    /**\n     * @function module:_listOps.scanl\n     * @param fn {Function}\n     * @param zero {*}\n     * @param xs {Array}\n     * @returns {Array|*}\n     */\n    scanl = (fn, zero, xs) => {\n        if (!xs || !length(xs)) {\n            return [];\n        }\n        const limit = length(xs);\n        let ind = 0,\n            result = zero,\n            out = [];\n        while (ind < limit) {\n            result = fn(result, xs[ind], ind, xs);\n            out.push(result);\n            ind++;\n        }\n        return out;\n    },\n\n    scanl1 = (fn, xs) => {\n        if (!xs || !xs.length) { return []; }\n        return scanl(fn, head(xs), tail(xs));\n    },\n\n    scanr = (fn, zero, xs) => {\n        if (!xs || !length(xs)) {\n            return [];\n        }\n        const limit = length(xs);\n        let ind = limit - 1,\n            result = xs[0],\n            out = [];\n        while (ind > -1) {\n            result = fn(result, xs[ind], ind, xs);\n            out.push(result);\n            ind--;\n        }\n        return out;\n    },\n\n    scanr1 = (fn, xs) => {\n        if (!xs || !xs.length) { return []; }\n        return scanr(fn, last(xs), init(xs));\n    },\n\n    nub = list => nubBy((a, b) => a === b, list),\n\n    remove = (x, list) => removeBy((a, b) => a === b, x, list),\n\n    sort = xs => sortBy(genericAscOrdering, xs),\n\n    sortOn = (valueFn, xs) =>\n\n        // Un-decorate\n        _map(decorated => decorated[1],\n\n            // Decorate and sort\n            sortBy(\n                // Ordering\n                ([a0], [b0]) => genericAscOrdering(a0, b0),\n\n                // Decorate\n                _map(item => [valueFn(item), item], xs)\n            )\n        ),\n\n    sortBy = (orderingFn, xs) => copy(xs).sort(orderingFn || genericAscOrdering),\n\n    insert = (x, xs) => {\n        if (!length(xs)) {\n            return [x];\n        }\n        const foundIndex = findIndex(item => x <= item, xs);\n        return foundIndex === -1 ? [x] :\n            concat(intersperse([x], splitAt(foundIndex, xs)));\n    },\n\n    /**\n     * A version of `insert` that allows you to specify the ordering of the inserted\n     * item;  Before/at, or after\n     * @function module:_listOps.insertBy\n     * @haskellType `insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]`\n     * @note `Ordering` === // something that is order-able\n     * @todo Optimize and work the logic of this function;  Think about the types that will be\n     *  operated on by this functions logic.\n     * @param orderingFn {Function} - A function that returns `-1`, `0`, or 1`.\n     * @param x {*} - Value to insert.\n     * @param xs {Array} - List to insert into (note new list is returned)\n     * @returns {Array} - New list.\n     */\n    insertBy = (orderingFn, x, xs) => {\n        const limit = length(xs);\n        if (!limit) {\n            return [x];\n        }\n        let ind = 0;\n        for (; ind < limit; ind += 1) {\n            if (orderingFn(x, xs[ind]) <= 0) {\n                const parts = splitAt(ind, xs);\n                return concat([parts[0], [x], parts[1]]);\n            }\n        }\n        return aggregateArr(copy(xs), x);\n    },\n\n    nubBy = (pred, list) => {\n        if (!length(list)) {\n            return [];\n        }\n        const limit = length(list);\n        let ind = 0,\n            currItem,\n            out = [],\n            anyOp = storedItem => pred(currItem, storedItem);\n        for (; ind < limit; ind += 1) {\n            currItem = list[ind];\n            if (any(anyOp, out)) {\n                continue;\n            }\n            out.push(currItem);\n        }\n        return out;\n    },\n\n    removeBy = (pred, x, list) => { // @todo optimize this implementation\n        const foundIndex = findIndex(item => pred(x, item), list),\n            parts = splitAt(foundIndex > -1 ? foundIndex : 0, list); // @todo correct this implementation\n        return append(parts[0], tail(parts[1]));\n    },\n\n\n    removeFirstsBy = (pred, xs1, xs2) =>\n        foldl((agg, item) => removeBy(pred, item, agg), xs1, xs2),\n\n    /**\n     * Returns the union on elements matching boolean check passed in.\n     * @function module:_listOps.unionBy\n     * @param pred {Function} - `pred :: a -> a -> Bool`\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @returns {Array}\n     */\n    unionBy = (pred, arr1, arr2) =>\n        foldl((agg, b) => {\n                const alreadyAdded = any(a => pred(a, b), agg);\n                return !alreadyAdded ? (agg.push(b), agg) : agg;\n            }, copy(arr1), arr2\n        ),\n\n    /**\n     * Creates a union on matching elements from array1.\n     * @function module:_listOps.union\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @returns {Array}\n     */\n    union = (arr1, arr2) =>\n        append(arr1,\n            filter(elm => !includes(elm, arr1), arr2)),\n\n    /**\n     * Performs an intersection on list 1 with  elements from list 2.\n     * @function module:_listOps.intersect\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @returns {Array}\n     */\n    intersect = (arr1, arr2) =>\n        !arr1 || !arr2 || (!arr1 && !arr2) ? [] :\n            filter(elm => includes(elm, arr2), arr1),\n\n    /**\n     * Returns an intersection by predicate.\n     * @function module:_listOps.intersectBy\n     * @param pred {Function} - `pred :: a -> b -> Bool`\n     * @param list1 {Array}\n     * @param list2 {Array}\n     * @return {Array}\n     */\n    intersectBy = (pred, list1, list2) =>\n        foldl((agg, a) =>\n                any(b => pred(a, b), list2) ? (agg.push(a), agg) : agg\n            , [], list1),\n\n    /**\n     * Returns the difference of list 1 from list 2.\n     * @note The `difference` operation here is non-associative;  E.g., `a - b` is not equal to `b - a`;\n     * @function module:_listOps.difference\n     * @param array1 {Array}\n     * @param array2 {Array}\n     * @returns {Array}\n     */\n    difference = (array1, array2) => { // augment this with max length and min length ordering on op\n        if (array1 && !array2) {\n            return copy(array1);\n        }\n        else if (!array1 && array2 || (!array1 && !array2)) {\n            return [];\n        }\n        return reduce((agg, elm) =>\n                !includes(elm, array2) ? (agg.push(elm), agg) : agg\n            , [], array1);\n    },\n\n    /**\n     * Returns the complement of list 0 and the reset of the passed in arrays.\n     * @function module:_listOps.complement\n     * @param arr0 {Array}\n     * @param arrays {...Array}\n     * @returns {Array}\n     */\n    complement = (arr0, ...arrays) =>\n        reduce((agg, arr) => append(agg, difference(arr, arr0)), [], arrays);\n","import {assignDeep} from './_assignDeep';\nimport {hasOwnProperty, keys} from '../_jsPlatform/_object';\nimport {foldl} from '../_listOps';\n\nexport const\n\n    objUnion = (obj1, obj2) => assignDeep(obj1, obj2),\n\n    objIntersect = (obj1, obj2) => foldl((agg, key) => {\n        if (hasOwnProperty(key, obj2)) {\n            agg[key] = obj2[key];\n        }\n        return agg;\n    }, {}, keys(obj1)),\n\n    objDifference = (obj1, obj2) => foldl((agg, key) => {\n        if (!hasOwnProperty(key, obj2)) {\n            agg[key] = obj1[key];\n        }\n        return agg;\n    }, {}, keys(obj1)),\n\n    objComplement = (obj0, ...objs) => foldl((agg, obj) =>\n        assignDeep(agg, objDifference(obj, obj0)), {}, objs);\n","/**\n * @module objectOps\n */\nimport {curry, curry2} from './uncurried/_functionOps/_curry';\nimport {\n    instanceOf as _instanceOf,\n    hasOwnProperty as _hasOwnProperty,\n    assign as _assign} from './uncurried/_jsPlatform/_object';\nimport {prop as _prop} from './uncurried/_objectOps/_prop';\nimport {assignDeep as _assignDeep}      from './uncurried/_objectOps/_assignDeep';\nimport {\n    objUnion as _objUnion,\n    objComplement as _objComplement,\n    objIntersect as _objIntersect,\n    objDifference as _objDifference}    from './uncurried/_objectOps/_setTheory';\nimport {isType as _isType}\n    from './uncurried/_objectOps/_is';\n\nexport {length, keys} from './uncurried/_jsPlatform/_object';\nexport * from './uncurried/_objectOps/_typeOf';\nexport * from './uncurried/_objectOps/_of';\nexport {\n    isFunction, isClass, isCallable, isArray, isObject, isBoolean,\n    isNumber, isString, isMap, isSet, isWeakMap, isWeakSet, isUndefined,\n    isNull, isSymbol, isUsableImmutablePrimitive,\n    isEmptyList, isEmptyObject, isEmptyCollection, isEmpty, isset\n} from './uncurried/_objectOps/_is';\n\nexport {_instanceOf, _isType, _hasOwnProperty, _assign, _prop, _assignDeep, _objUnion,\n_objComplement, _objIntersect, _objDifference};\n\nexport const\n\n    /**\n     * Gives `undefined` or prop value if it is available.\n     * @function module:objectOps.prop\n     * @param propName {String}\n     * @param obj {*} - Object to search.\n     * @returns {*|undefined}\n     * @curried\n     */\n    prop = curry(_prop),\n\n    /**\n     * `instanceof` in function form.\n     * @function module:objectOps.instanceOf\n     * @param instance {*}\n     * @param Type {Function}\n     * @returns {Boolean}\n     * @curried\n     */\n    instanceOf = curry(_instanceOf),\n\n    /**\n     * `hasOwnProperty` as a method (takes object last).\n     * @function module:objectOps.hasOwnProperty\n     * @param propName {String}\n     * @param obj {*} - Object to search.\n     * @returns {Boolean}\n     * @curried\n     */\n    hasOwnProperty = curry(_hasOwnProperty),\n\n    /**\n     * `Object.assign` if it is available else a shim.\n     * @function module:objectOps.assign\n     * @param [...obj]{Object} - One or more objects to merge onto first object.\n     * @returns {Object}\n     * @curried - Called after having two or more args\n     */\n    assign = curry2(_assign),\n\n    /**\n     * Same as `Object.assign` except does a deep merge.\n     * @function module:objectOps.assignDeep\n     * @param [...obj]{Object} - One or more objects to deep merge onto first object.\n     * @returns {Object}\n     * @curried - Called after having two or more args\n     */\n    assignDeep = curry2(_assignDeep),\n\n    /**\n     * Cartesian union for objects (operates on two objects).\n     * @function module:objectOps.objUnion\n     * @param obj1 {Object}\n     * @param obj2 {Object}\n     * @returns {Object} - Unified obj.\n     * @curried\n     */\n    objUnion = curry(_objUnion),\n\n    /**\n     * Returns the cartesian intersection of two objects.\n     * @function module:objectOps.objIntersect\n     * @param obj1 {Object}\n     * @param obj2 {Object}\n     * @returns {Object} - Intersection of given objects.\n     * @curried\n     */\n    objIntersect = curry(_objIntersect),\n\n    /**\n     * Returns the cartesian difference of two objects.\n     * @function module:objectOps.objDifference\n     * @param obj1 {Object}\n     * @param obj2 {Object}\n     * @returns {Object} - Difference of given objects.\n     * @curried\n     */\n    objDifference = curry(_objDifference),\n\n    /**\n     * Returns the cartesian complement of one or more objects on given object.\n     * @function module:objectOps.objDifference\n     * @param obj {Object}\n     * @param [...obj]{Object} - One or more objects to calculate complement from.\n     * @returns {Object} - Complement of given objects.\n     * @curried\n     */\n    objComplement = curry2(_objComplement),\n\n    /**\n     * Returns a boolean indicating whether a value is of given type or not.\n     * @function module:objectOps.isType\n     * @param Type {Function|String} - Constructor or constructor name\n     * @param value {*}\n     * @return {Boolean}\n     */\n    isType = curry(_isType);\n\n    /**\n     * Returns whether a value is a function or not.\n     * @function module:objectOps.isFunction\n     * @param value {*}\n     * @returns {Boolean}\n     */\n\n    /**\n     * Checks if `value` is an es2015 `class`.\n     * @function module:objectOps.isClass\n     * @param x {*}\n     * @returns {boolean}\n     */\n\n    /**\n     * Returns a boolean depicting whether a value is callable or not.\n     * @function module:objectOps.isCallable\n     * @tentative\n     * @private\n     * @param x {*}\n     * @returns {Boolean}\n     */\n\n    /**\n     * Checks if value is an array.\n     * @function module:objectOps.isArray\n     * @param value {*}\n     * @returns {boolean}\n     */\n\n    /**\n     * Checks whether value is an object or not.\n     * @function module:objectOps.isObject\n     * @param value\n     * @returns {Boolean}\n     */\n\n    /**\n     * Checks if value is a boolean.\n     * @function module:objectOps.isBoolean\n     * @param value {*}\n     * @returns {Boolean}\n     */\n\n    /**\n     * Checks if value is a valid number (also checks if isNaN so that you don't have to).\n     * @function module:objectOps.isNumber\n     * @param value {*}\n     * @returns {Boolean}\n     */\n\n    /**\n     * Checks whether value is a string or not.\n     * @function module:objectOps.isString\n     * @param value {*}\n     * @returns {Boolean}\n     */\n\n    /**\n     * Checks whether value is of `Map` or not.\n     * @function module:objectOps.isMap\n     * @param value {*}\n     * @returns {Boolean}\n     */\n\n    /**\n     * Checks whether value is of `Set` or not.\n     * @function module:objectOps.isSet\n     * @param value {*}\n     * @returns {Boolean}\n     */\n\n    /**\n     * Checks whether value is of `WeakMap` or not.\n     * @function module:objectOps.isWeakMap\n     * @param value {*}\n     * @returns {Boolean}\n     */\n\n    /**\n     * Checks whether value is of `WeakSet` or not.\n     * @function module:objectOps.isWeakSet\n     * @param value {*}\n     * @returns {Boolean}\n     */\n\n    /**\n     * Checks if value is undefined.\n     * @function module:objectOps.isUndefined\n     * @param value {*}\n     * @returns {Boolean}\n     */\n\n    /**\n     * Checks if value is null.\n     * @function module:objectOps.isNull\n     * @param value {*}\n     * @returns {Boolean}\n     */\n\n    /**\n     * Checks if value is a `Symbol`.\n     * @function module:objectOps.isSymbol\n     * @param value {*}\n     * @returns {Boolean}\n     */\n\n    /**\n     * @tentative\n     * @private\n     */\n\n    /**\n     * Checks if given `x` is one of the four\n     * \"usable\" immutable JS primitives; I.e.,\n     *  One of [String, Boolean, Number, Symbol]\n     * @function module:objectOps.isUsableImmutablePrimitive\n     * @param x {*}\n     * @returns {Boolean}\n     */\n\n    /**\n     * Checks if !length.\n     * @function module:objectOps.isEmptyList\n     * @param x {*}\n     * @returns {Boolean}\n     */\n\n    /**\n     * Checks if object has own properties/enumerable-props or not.\n     * @function module:objectOps.isEmptyObject\n     * @param obj {*}\n     * @returns {Boolean}\n     */\n\n    /**\n     * Checks if collection is empty or not (Map, WeakMap, WeakSet, Set etc.).\n     * @function module:objectOps.isEmptyCollection\n     * @param x {*}\n     * @returns {Boolean}\n     */\n\n    /**\n     * Checks to see if passed in argument is empty.\n     * @function module:objectOps.isEmpty\n     * @param value {*} - Value to check.\n     * @returns {Boolean}\n     */\n\n    /**\n     * Returns whether passed in values is defined and not null.\n     * @function module:objectOps.isset\n     * @param x {*}\n     * @returns {Boolean}\n     */\n\n    /**\n     * Returns the constructor/class/type name of a value.\n     * @note Returns 'NaN' if value is of type `Number` and value is `isNaN`.\n     * @note Returns 'Undefined' if value is `undefined`\n     * @note Returns 'Null' if value is `null`\n     * For values that have no concrete constructors and/or casters\n     * (null, NaN, and undefined) we returned normalized names for them ('Null', 'NaN', 'Number')\n     * @function module:objectOps.typeOf\n     * @param value {*}\n     * @returns {string} - Constructor's name or derived name (in the case of `null`, `undefined`, or `NaN` (whose\n     *  normalized names are 'Null', 'Undefined', 'NaN' respectively).\n     */\n\n    /**\n     * Creates a value `of` given type;  Checks for one of the following construction strategies (in order listed):\n     * - If exists `(value).constructor.of` uses this.\n     * - If value is of one String, Boolean, Symbol, or Number types calls it's constructor as a function (in cast form;  E.g., `constructor(...args)` )\n     * - Else if constructor is a function, thus far, then calls constructor using the `new` keyword (with any passed in args).\n     * @function module:objectOps.of\n     * @param x {*} - Value to derive returned value's type from.\n     * @param [args] {...*} - Any args to pass in to matched construction strategy.\n     * @returns {*|undefined} - New value of given value's type else `undefined`.\n     */\n\n    /**\n     * @function module:objectOps.length\n     * @param x {*}\n     * @returns {Number}\n     * @throws {Error} - Throws an error if value doesn't have a `length` property (\n     *  `null`, `undefined`, {Boolean}, Symbol, et. al.).\n     */\n\n    /**\n     * Gets own enumerable keys of passed in object (same as `Object.keys`).\n     * @function module:objectOps.keys\n     * @param obj {*}\n     * @returns {Array<String>}\n     */\n","export const\n\n    /**\n     * Run `operation` until predicate returns `true`.\n     * @function module:_functionOps.until\n     * @param predicate {Function} :: a -> Boolean\n     * @param operation {Function} :: a -> a\n     * @param typeInstance {*} :: * - A monoidal zero or some starting point.\n     * @returns {*} - What ever type `typeInstance` is\n     */\n    until = (predicate, operation, typeInstance) => {\n        let result = typeInstance;\n        while (!predicate(result)) {\n            result = operation(result);\n        }\n        return result;\n    };\n","import {reverse} from '../_jsPlatform/_array';\nimport {apply, call} from '../_jsPlatform/_function';\n\nexport const\n\n    /**\n     * Flips a functions arguments order and returns a new functionOps requiring such (arguments in reverse order).\n     * @function module:_functionOps.flipN\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    flipN = fn => (...args) => apply(fn, reverse(args)),\n\n    /**\n     * Returns a function that receives 3 args in reverse (3, 2, 1 etc.).\n     * @function module:_functionOps.flip3\n     * @param fn {Function} - Function<a, b, c>\n     * @returns {Function} - Function<c, b, a>\n     */\n    flip3 = fn => (a, b, c) => call(fn, c, b, a),\n\n    /**\n     * Returns a function that receives 4 args in reverse (4, 3, 2, 1 etc.).\n     * @function module:_functionOps.flip4\n     * @param fn {Function} - Function<a, b, c, d>\n     * @returns {Function} - Function<d, c, b, a>\n     */\n    flip4 = fn => (a, b, c, d) => call(fn, d, c, b, a),\n\n    /**\n     * Returns a function that receives 5 args in reverse (5, 4, 3, 2, 1 etc.).\n     * @function module:_functionOps.flip5\n     * @param fn {Function} - Function<a, b, c, d, e>\n     * @returns {Function} - Function<e, d, c, b, a>\n     */\n    flip5 = fn => (a, b, c, d, e) => call(fn, e, d, c, b, a),\n\n    /**\n     * Flips a _functionOps's first and second arguments and and returns a new _functionOps requiring said arguments in reverse.\n     * @function module:_functionOps.flip\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    flip = fn => (b, a) => call(fn, a, b);\n","/**\n * @memberOf _functionOps\n * @author elydelacruz\n * @created 12/6/2016.\n * @description Curry implementation with place holder concept (`__`).\n * @todo Make code here more minimal (reuse small parts here).\n */\n\nimport {apply, concat, map, filter, length} from '../_jsPlatform';\nimport {fnOrError} from '../_utils';\n\n/**\n * PlaceHolder (__) constructor.\n * @constructor PlaceHolder\n * @private\n */\nconst PlaceHolder = function PlaceHolder() {},\n\n    notFnErrPrefix = '`fn` in `curry_(fn, ...args)`',\n\n    /**\n     * Placeholder instance.\n     * @type {PlaceHolder}\n     * @private\n     */\n    placeHolderInstance = new PlaceHolder();\n\n/**\n * Checks to see if value is a `PlaceHolder`.\n * @param instance {*}\n * @returns {boolean}\n * @private\n */\nfunction isPlaceHolder (instance) {\n    return instance instanceof PlaceHolder;\n}\n\n/**\n * Replaces `placeholder` values in `_listOps`.\n * @function replacePlaceHolder\n * @private\n * @param array {Array} - Array to replace placeholders in.\n * @param args {Array} - Args from to choose from to replace placeholders.\n * @returns {Array|*} - Returns passed in `_listOps` with placeholders replaced by values in `args`.\n */\nfunction replacePlaceHolders (array, args) {\n    let out = map(element => {\n            if (!isPlaceHolder(element)) { return element; }\n            else if (length(args)) { return args.shift(); }\n            return element;\n        }, array);\n    return length(args) ? concat(out, args) : out;\n}\n\n/**\n * Curries passed in functionOps up to given arguments length (can enforce arity via placeholder values (`__`)).\n * @function module:_functionOps.curry_\n * @param fn {Function}\n * @param argsToCurry {...*}\n * @returns {Function}\n */\nexport function curry_ (fn, ...argsToCurry) {\n    return curryN_(fnOrError(notFnErrPrefix, fn).length, fn, ...argsToCurry);\n}\n\n/**\n * Curries a _functionOps up to given arity also enforces arity via placeholder values (`__`).\n * @function module:_functionOps.curryN_\n * @param executeArity {Number}\n * @param fn {Function}\n * @param curriedArgs {...*} - Allows `Placeholder` (`__`) values.\n * @returns {Function} - Passed in _functionOps wrapped in a _functionOps for currying.\n */\nexport function curryN_ (executeArity, fn, ...curriedArgs) {\n    return (...args) => {\n        let concatedArgs = replacePlaceHolders(curriedArgs, args),\n            placeHolders = filter(isPlaceHolder, concatedArgs),\n            canBeCalled = (length(concatedArgs) - length(placeHolders) >= executeArity) || !executeArity;\n        return !canBeCalled ?\n            apply(curryN_, concat([executeArity, fnOrError(notFnErrPrefix, fn)], concatedArgs)) :\n            apply(fnOrError(notFnErrPrefix, fn), concatedArgs);\n    };\n}\n\n/**\n * Place holder object (frozen) used by curry.\n * @memberOf _functionOps\n * @type {PlaceHolder}\n */\nexport let __ = Object.freeze ? Object.freeze(placeHolderInstance) : placeHolderInstance,\n\n    /**\n     * Curries a _functionOps up to an arity of 2 (takes into account placeholders `__` (arity enforcers)) (won't call _functionOps until 2 or more args).\n     * @function module:_functionOps.curry2_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry2_ = fn => curryN_(2, fn),\n\n    /**\n     * Curries a _functionOps up to an arity of 3 (takes into account placeholders `__` (arity enforcers)) (won't call _functionOps until 3 or more args).\n     * @function module:_functionOps.curry3_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry3_ = fn => curryN_(3, fn),\n\n    /**\n     * Curries a _functionOps up to an arity of 4 (takes into account placeholders `__` (arity enforcers))  (won't call _functionOps until 4 or more args).\n     * @function module:_functionOps.curry4_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry4_ = fn => curryN_(4, fn),\n\n    /**\n     * Curries a _functionOps up to an arity of 5  (takes into account placeholders `__` (arity enforcers))  (won't call _functionOps until 5 or more args).\n     * @function module:_functionOps.curry5_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n    curry5_ = fn => curryN_(5, fn)\n\n;\n","/**\n * @memberOf _functionOps\n */\n\n/**\n * Returns passed in parameter.\n * @haskellType `id :: a -> a`\n * @function module:_functionOps.id\n * @param x {*}\n * @returns {*}\n */\nexport const id = x => x;\n","import {reduceRight} from '../_jsPlatform/_array';\n\n/**\n * Composes all functions passed in from right to left passing each functions return value to\n * the functionOps on the left of itself.\n * @function module:_functionOps.compose\n * @type {Function}\n * @param args {...{Function}}\n * @returns {Function}\n */\nexport const compose = (...args) =>\n        arg0 => reduceRight((value, fn) => fn(value), arg0, args);\n","/**\n * Function operations: `\n * @module functionOps\n */\n\nimport {curry, curry2, curry3} from './uncurried/_functionOps/_curry';\n\nimport {\n    apply as _apply,\n    call as _call, reverse\n} from './uncurried/_jsPlatform';\n\nimport {\n    until as _until\n} from './uncurried/_functionOps/_until';\n\nimport {\n    flip as _flip,\n    flipN as _flipN,\n    flip3 as _flip3,\n    flip4 as _flip4,\n    flip5 as _flip5\n} from './uncurried/_functionOps/_flip';\n\nexport * from './uncurried/_functionOps/_curry';\nexport * from './uncurried/_functionOps/__curry';\nexport * from './uncurried/_functionOps/_negate';\nexport * from './uncurried/_functionOps/_id';\nexport * from './uncurried/_functionOps/_compose';\n\nexport {_apply, _call, _until, _flip, _flip3, _flip4, _flip5,  _flipN};\n\nexport const\n\n    /**\n     * Functional `apply` function (takes no context).\n     * @function module:functionOps.apply\n     * @param fn {Function}\n     * @param [args] {Array<*>}\n     * @returns {*}\n     * @curried - Triggered at 2 or more args.\n     */\n    apply = curry(_apply),\n\n    /**\n     * Functional `call` function (takes no context).\n     * @function module:functionOps.call\n     * @param fn {Function}\n     * @param [args] {...*}\n     * @returns {*}\n     * @curried\n     */\n    call = curry2(_call),\n\n    /**\n     * Run `operation` `until` predicate returns `true`.\n     * @function module:functionOps.until\n     * @param predicate {Function} :: a -> Boolean\n     * @param operation {Function} :: a -> a\n     * @param typeInstance {*} :: * - A monoidal zero or some starting point.\n     * @returns {*} - What ever type `typeInstance` is\n     * @curried\n     */\n    until = curry(_until),\n\n    /**\n     * Flips a functions arguments order and returns a new function requiring such (arguments in reverse order).\n     * @function module:fnOperators.flipN\n     * @param fn {Function}\n     * @returns {Function}\n     * @curried - Triggered at 3 or more (args).\n     */\n    flipN = fn => curry3((...args) => apply(fn, reverse(args))),\n\n    /**\n     * Flips a function's first and second arguments and and returns a new function requiring said arguments in reverse.\n     * @function module:fnOperators.flip\n     * @param fn {Function}\n     * @returns {Function}\n     * @curried\n     */\n    flip = fn => curry(_flip(fn)),\n\n    /**\n     * Returns a function that receives 3 args in reverse (3, 2, 1 etc.).\n     * @function module:functionOps.flip3\n     * @param fn {Function} - Function<a, b, c>\n     * @returns {Function} - Function<c, b, a>\n     * @curried\n     */\n    flip3 = fn => curry(_flip3(fn)),\n\n    /**\n     * Returns a function that receives 4 args in reverse (4, 3, 2, 1 etc.).\n     * @function module:functionOps.flip4\n     * @param fn {Function} - Function<a, b, c, d>\n     * @returns {Function} - Function<d, c, b, a>\n     * @curried\n     */\n    flip4 = fn => curry(_flip4(fn)),\n\n    /**\n     * Returns a function that receives 5 args in reverse (5, 4, 3, 2, 1 etc.).\n     * @function module:functionOps.flip5\n     * @param fn {Function} - Function<a, b, c, d, e>\n     * @returns {Function} - Function<e, d, c, b, a>\n     * @curried\n     */\n    flip5 = fn => curry(_flip5(fn));\n\n    /**\n     * Curries a function based on it's defined arity (argument's arrayOps expected length).\n     * @function module:functionOps.curry\n     * @param fn {Function}\n     * @param argsToCurry {...*}\n     * @returns {Function}\n     * @curried\n     */\n\n    /**\n     * Curries a function up to a given arity.\n     * @function module:functionOps.curryN\n     * @param executeArity {Number}\n     * @param fn {Function}\n     * @param curriedArgs {...*}\n     * @returns {Function}\n     */\n\n    /**\n     * Curries a function up to an arity of 2 (won't call function until 2 or more args).\n     * @function module:functionOps.curry2\n     * @param fn {Function}\n     * @returns {Function}\n     */\n\n    /**\n     * Curries a function up to an arity of 3 (won't call function until 3 or more args).\n     * @function module:functionOps.curry3\n     * @param fn {Function}\n     * @returns {Function}\n     */\n\n    /**\n     * Curries a function up to an arity of 4 (won't call function until 4 or more args).\n     * @function module:functionOps.curry4\n     * @param fn {Function}\n     * @returns {Function}\n     */\n\n    /**\n     * Curries a function up to an arity of 5 (won't call function until 5 or more args).\n     * @function module:functionOps.curry5\n     * @param fn {Function}\n     * @returns {Function}\n     */\n\n    /**\n     * Curries passed in function up to given arguments length (can enforce arity via placeholder values (`__`)).\n     * @function module:functionOps.curry_\n     * @param fn {Function}\n     * @param argsToCurry {...*}\n     * @returns {Function}\n     */\n\n    /**\n     * Curries a function up to given arity also enforces arity via placeholder values (`__`).\n     * @function module:functionOps.curryN_\n     * @param executeArity {Number}\n     * @param fn {Function}\n     * @param curriedArgs {...*} - Allows `Placeholder` (`__`) values.\n     * @returns {Function} - Passed in function wrapped in a function for currying.\n     */\n\n    /**\n     * Place holder object (frozen) used by curry.\n     * @memberOf functionOps\n     * @type {PlaceHolder}\n     */\n\n    /**\n     * Curries a function up to an arity of 2 (takes into account placeholders `__` (arity enforcers))\n     * (won't call function until 2 or more args (not counting placeholder (`__`) value).\n     * @function module:functionOps.curry2_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n\n    /**\n     * Curries a function up to an arity of 3 (takes into account placeholders `__` (arity enforcers))\n     * (won't call function until 3 or more args (not counting placeholder (`__`) value).\n     * @function module:functionOps.curry3_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n\n    /**\n     * Curries a function up to an arity of 4 (takes into account placeholders `__` (arity enforcers))\n     * (won't call function until 4 or more args (not counting placeholder (`__`) value).\n     * @function module:functionOps.curry4_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n\n    /**\n     * Curries a function up to an arity of 5  (takes into account placeholders `__` (arity enforcers))\n     * (won't call function until 5 or more args (not counting placeholder (`__`) value).\n     * @function module:functionOps.curry5_\n     * @param fn {Function}\n     * @returns {Function}\n     */\n\n    /**\n     * Takes a function that takes two parameters and returns a negated version of given\n     * function.\n     * @function module:functionOps.negateF\n     * @param fn {Function}\n     * @returns {Function}\n     */\n\n    /**\n     * Takes a function that takes three parameters and returns a\n     * negated version of given function.\n     * @function module:functionOps.negateF3\n     * @param fn {Function}\n     * @returns {Function}\n     */\n\n    /**\n     * Takes a function that takes four parameters and returns a\n     * negated version of given function.\n     * @function module:functionOps.negateF4\n     * @param fn {Function}\n     * @returns {Function}\n     */\n\n    /**\n     * Takes a function that takes four parameters and returns a\n     * negated version of given function.\n     * @function module:functionOps.negateF5\n     * @param fn {Function}\n     * @returns {Function}\n     */\n\n    /**\n     * Negates a javascript-'generic' predicate; `Function<element, index, list>`.\n     * @function module:functionOps.negateP\n     * @param fn {Function}\n     * @returns {Function}\n     */\n\n    /**\n     * Returns a new function which is the dual of `fn` (or the negated version of `fn`).\n     * @function module:functionOps.negateFMany\n     * @param fn {Function}\n     * @returns {Function}\n     */\n\n    /**\n     * Returns passed in parameter.\n     * @haskellType `id :: a -> a`\n     * @function module:functionOps.id\n     * @param x {*}\n     * @returns {*}\n     */\n\n    /**\n     * Composes all functions passed in from right to left passing each functions return value to\n     * the function on the left of itself.\n     * @function module:functionOps.compose\n     * @param args {...Function}\n     * @returns {Function}\n     */\n","/**\n * @module _functionOps\n * @private\n */\nexport {apply, call} from './_jsPlatform/_function';\nexport * from './_functionOps/_compose';\nexport * from './_functionOps/_curry';\nexport * from './_functionOps/__curry';\nexport * from './_functionOps/_flip';\nexport * from './_functionOps/_id';\nexport * from './_functionOps/_negate';\nexport * from './_functionOps/_until';\n","/**\n * Created by elydelacruz on 7/22/2017.\n * @module utils\n * @private\n */\n\nimport {curry, curry2} from './uncurried/_functionOps/_curry';\nexport * from './uncurried/_utils';\nexport const\n\n    fPureTakesOne_ = name => curry((arg, f) => f[name](arg)),\n\n    fPureTakes2_ = name => curry((arg1, arg2, f) => f[name](arg1, arg2)),\n\n    fPureTakesOneOrMore_ = name => curry2((f, ...args) => f[name](...args))\n;\n","/**\n * Created by elyde on 7/20/2017.\n * Curried functional versions of common array methods (`filter`, `map`, etc.).\n * @module jsPlatform_array\n * @private\n */\n\nimport {fPureTakesOne_, fPureTakes2_, fPureTakesOneOrMore_} from '../utils';\n\n/**\n * Reverses a list (shimmed if not exists).\n * @function module:jsPlatform_array.reverse\n * @return {Array}\n */\nexport {reverse} from '../uncurried/_jsPlatform/_array';\n\nexport const\n\n    /**\n     * Maps a function to functor (lists etc.).\n     * @function module:jsPlatform_array.map\n     * @param fn {Function}\n     * @param functor {Array|{map: {Function}}}\n     * @returns {Array|{map: {Function}}}\n     */\n    map = fPureTakesOne_('map'),\n\n    /**\n     * Filters a functor (lists etc.) with passed in function.\n     * @function module:jsPlatform_array.filter\n     * @param fn {Function}\n     * @param functor {Array|{filter: {Function}}}\n     * @returns {Array|{filter: {Function}}}\n     */\n    filter = fPureTakesOne_('filter'),\n\n    /**\n     * Reduces a foldable (lists etc.) with passed in function.\n     * @function module:jsPlatform_array.reduce\n     * @param fn {Function}\n     * @param functor {Array|{reduce: {Function}}}\n     * @returns {Array|{reduce: {Function}}}\n     */\n    reduce = fPureTakes2_('reduce'),\n\n    /**\n     * Reduces a foldable (lists etc.) from the right with passed in function.\n     * @function module:jsPlatform_array.reduceRight\n     * @param fn {Function}\n     * @param functor {Array|{reduceRight: {Function}}}\n     * @returns {Array|{reduceRight: {Function}}}\n     */\n    reduceRight = fPureTakes2_('reduceRight'),\n\n    /**\n     * For each on functor (Array|Object|etc.).\n     * @function module:jsPlatform_array.forEach\n     * @param fn {Function}\n     * @param functor {Array|Object|*}\n     * @return {*|Array|Object} - The type of object you pass in unless it doesn't have a `forEach` method.\n     * @throws {Error} - When passed in functor doesn't have a `forEach` method.\n     */\n    forEach = fPureTakesOne_('forEach'),\n\n    /**\n     * Returns `true` if `fn` (predicate) returns true for at least one item\n     * in functor else returns `false`.\n     * @function module:jsPlatform_array.some\n     * @param fn {Function} - Predicate.\n     * @param functor {Array|Object|*}\n     * @return {*|Array|Object} - The type passed.\n     * @throws {Error} - When passed in object doesn't have a `some` method.\n     */\n    some = fPureTakesOne_('some'),\n\n    /**\n     * Returns `true` if `fn` (predicate) returns true for all items in functor else returns `false`.\n     * @function module:jsPlatform_array.every\n     * @param fn {Function} - Predicate.\n     * @param functor {Array|Object|*}\n     * @return {*|Array|Object} - The type passed.\n     * @throws {Error} - When passed in object doesn't have an `every` method.\n     */\n    every = fPureTakesOne_('every'),\n\n    /**\n     * Array.prototype.join\n     * @function module:jsPlatform_array.join\n     * @param separator {String|RegExp}\n     * @param arr {Array}\n     * @returns {String}\n     */\n    join = fPureTakesOne_('join'),\n\n    /**\n     * Same as Array.prototype.push\n     * @function module:jsPlatform_array.push\n     * @param item {*}\n     * @param arr {Array}\n     * @returns {Number}\n     */\n    push = fPureTakesOneOrMore_('push');\n","/**\n * List operations that overlap (apart from globally overlapping props and functions like `length`)\n * on both strings and arrays.\n * @module jsPlatform_list\n * @private\n */\n\nimport {curry} from '../uncurried/_functionOps/_curry';\n\nimport {\n    concat as concat_,\n    slice as slice_,\n    includes as includes_,\n    indexOf as indexOf_,\n    lastIndexOf as lastIndexOf_ } from '../uncurried/_jsPlatform/_list';\n\nexport const\n\n    /**\n     * Concats/appends all functors onto the end of first functor.\n     * Note:  functors passed in after the first one must be of the same type.\n     * @function module:jsPlatform_array.concat\n     * @param functor {Array|Object|*}\n     * @param ...functor {Array|Object|*}\n     * @return {*|Array|Object} - The type passed.\n     * @throws {Error} - When passed in object doesn't have an `every` method.\n     */\n    concat = curry(concat_),\n\n    /**\n     * Same as Array.prototype.slice\n     * @function module:jsPlatform_array.slice\n     * @param separator {String|RegExp}\n     * @param arr{Array}\n     * @returns {Array}\n     */\n    slice = curry(slice_),\n\n    includes = curry(includes_),\n\n    indexOf = curry(indexOf_),\n\n    lastIndexOf = curry(lastIndexOf_)\n\n;\n","/**\n * Created by elydelacruz on 9/6/2017.\n * @module jsPlatform_string\n * @private\n */\n\nimport {curry} from '../uncurried/_functionOps/_curry';\n\nimport {split as _split} from '../uncurried/_jsPlatform/_string';\n\n/**\n * Functional version of `String.prototype.split`.\n * @curried\n * @function module:jsPlatform_string.split\n * @param separator {String|RegExp}\n * @param str {String}\n * @returns {Array}\n */\nexport const split = curry(_split);\n","/**\n * @module jsPlatform\n * @private\n */\n\nexport * from './jsPlatform/array';\nexport * from './jsPlatform/list';\nexport * from './jsPlatform/string';\n","/**\n * List operators.\n * @module listOps\n * @todo decide whether to throw errors where functions cannot function without a specific type or to\n *  return undefined (and also determine which cases are ok for just returning undefined).\n * @todo code unperformant shorthand in `listOps`\n * @todo rename monoid functions to normal functions since we are not really defining methods for monoids here.\n */\nimport {curry, curry2, curry3, curry4, curry5, curryN} from './uncurried/_functionOps';\n\n// Uncurried methods import\nimport {\n    append as _append, appendMany as _appendMany, all as _all, any as _any, find as _find,\n    findIndex as _findIndex, findIndices as _findIndices, zip as _zip, zipN as _zipN, zipWith as _zipWith,\n    _map, mapAccumL as _mapAccumL, mapAccumR as _mapAccumR, zipWithN as _zipWithN,\n    elem as _elem, notElem as _notElem, elemIndex as _elemIndex, elemIndices as _elemIndices, lookup as _lookup,\n    intersperse as _intersperse, intercalate as _intercalate, iterate as _iterate,\n    repeat as _repeat, replicate as _replicate, cycle as _cycle, take as _take, drop as _drop, splitAt as _splitAt,\n    foldl as _foldl, foldl1 as _foldl1, foldr as _foldr, foldr1 as _foldr1, unfoldr as _unfoldr,\n    concatMap as _concatMap, takeWhile as _takeWhile, dropWhile as _dropWhile, dropWhileEnd as _dropWhileEnd,\n    partition as _partition, at as _at, span as _span, breakOnList as _breakOnList, stripPrefix as _stripPrefix,\n    isPrefixOf as _isPrefixOf, isSuffixOf as _isSuffixOf,\n    isInfixOf as _isInfixOf, isSubsequenceOf as _isSubsequenceOf, filter as _filter,\n    remove as _remove, insert as _insert, insertBy as _insertBy, nubBy as _nubBy, removeBy as _removeBy,\n    removeFirstsBy as _removeFirstsBy, unionBy as _unionBy, sortOn as _sortOn, sortBy as _sortBy,\n    complement as _complement, difference as _difference, union as _union, intersect as _intersect,\n    intersectBy as _intersectBy, groupBy as _groupBy,\n    scanl as _scanl, scanl1 as _scanl1, scanr as _scanr, scanr1 as _scanr1\n}\n    from './uncurried/_listOps';\n\nexport {slice, includes, indexOf, lastIndexOf, split, push} from './jsPlatform';\n\n// Single arity methods (and single or more arg functions)\nexport {\n    and, or, zipN, unzip, unzipN, head, last, init, tail, uncons, concat, reverse, transpose, subsequences,\n    permutations, group, inits, tails, sum, product, maximum, minimum, sort, nub\n}\n    from './uncurried/_listOps';\n\n// Uncurried methods export\nexport {\n    _append, _appendMany, _all, _any, _find, _findIndex, _findIndices, _zip, _zipN, _zipWith,\n    _map, _mapAccumL, _mapAccumR, _elem, _notElem, _elemIndex, _elemIndices, _lookup,\n    _intersperse, _intercalate, _iterate, _repeat, _replicate, _cycle, _take,\n    _drop, _splitAt, _foldl, _foldl1, _foldr, _foldr1, _unfoldr, _concatMap, _takeWhile, _dropWhile,\n    _dropWhileEnd, _partition, _at, _span, _breakOnList, _stripPrefix, _isPrefixOf,\n    _isSuffixOf, _isInfixOf, _isSubsequenceOf, _filter,\n    _remove, _insert, _insertBy, _nubBy, _removeBy, _removeFirstsBy, _unionBy, _sortOn, _sortBy,\n    _complement, _difference, _union, _intersect, _intersectBy, _groupBy\n};\n\n// Exported internals\nexport const\n\n    /**\n     * Append two lists, i.e.,\n     * ```\n     * append([x1, ..., xm], [y1, ..., yn]) // outputs: [x1, ..., xm, y1, ..., yn]\n     * append([x1, ..., xm], [y1, ...]) // outputs: [x1, ..., xm, y1, ...]\n     * ```\n     * If the first list is not finite, the result is the first list.\n     * @haskellType `append :: List a => a -> a -> a`\n     * @function module:listOps.append\n     * @param xs1 {Array|String|*} - list or list like.\n     * @param xs2 {Array|String|*} - list or list like.\n     * @returns {Array|String|*} - Same type as list like passed in.\n     */\n    append = curry(_append),\n\n    /**\n     * Append two or more lists, i.e., same as `append` but for two ore more lists.\n     * @haskellType `appendMany :: List a => a -> [a] -> a\n     * @note In `@haskellType` we wrote `[a]` only to keep the haskell type valid though note in javascript\n     *  this is actually different since the function converts the zero ore more parameters into an array containing such for us.\n     * @function module:listOps.appendMany\n     * @param x {Array|String|*}\n     * @param args ...{Array|String|*} - Lists or lists likes.\n     * @returns {Array|String|*} - Same type as first list or list like passed in.\n     */\n    appendMany = curry2(_appendMany),\n\n    /**\n     * Map a function over all the elements of a container and concatenate the resulting lists.\n     * @haskellType `concatMap :: Foldable t => (a -> [b]) -> t a -> [b]`\n     * @function module:listOps.concatMap\n     * @param fn {Function}\n     * @param foldableOfA {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    concatMap = curry2(_concatMap),\n\n    /**\n     * @function module:listOps.map\n     * @param fn {Function} - Function to map on functor item(s).\n     * @param xs {Array|String|*} - Functor.\n     * @returns {Array|String|*} - Functor type that is passed in.\n     */\n    map = curry(_map),\n\n    /**\n     * Takes an element and a list and `intersperses' that element between the elements of the list. For example\n     * @function module:listOps.intersperse\n     * @note In our version of the function javascript is loosely typed so, so is our function (to much overhead to make\n     *  it typed) so `between` can be any value.\n     * @param between {*} - Should be of the same type of elements contained in list.\n     * @param arr {Array|String|*} - List.\n     * @returns {Array|String|*}\n     */\n    intersperse = curry(_intersperse),\n\n    /**\n     * `intercalate xs xss` is equivalent to (concat (intersperse xs xss)). It inserts the list xs in between the lists in xss and concatenates the result.\n     * @haskellType `intercalate :: [a] -> [[a]] -> [a]`\n     * @function module:listOps.intercalate\n     * @param xs {Array|String|*}\n     * @param xss {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    intercalate = curry(_intercalate),\n\n    /**\n     * Reduces a foldable (list etc.) with passed in function.\n     * @function module:listOps.foldl\n     * @param fn {Function}\n     * @param zero {*} - Aggregator.\n     * @param functor {Array|String|*}\n     * @returns {*} - Usually same type as aggregate (`zero`) (depends on `fn`).\n     */\n    foldl = curry(_foldl),\n\n    /**\n     * Reduces a foldable (list etc.) from right to left with passed in function.\n     * @function module:listOps.foldr\n     * @param fn {Function}\n     * @param zero {*} - Aggregator.\n     * @param functor {Array|{reduce: {Function}}}\n     * @returns {*} - Usually same type as aggregate (`zero`) (depends on `fn`).\n     */\n    foldr = curry(_foldr),\n\n    /**\n     * Reduces a foldable (list etc.) with passed in function.\n     * @function module:listOps.foldl1\n     * @param fn {Function}\n     * @param functor {Array|{reduce: {Function}}}\n     * @returns {*}\n     */\n    foldl1 = curry(_foldl1),\n\n    /**\n     * Reduces a foldable (list etc.) from right to left with passed in function.\n     * @function module:listOps.foldr1\n     * @param fn {Function}\n     * @param functor {Array|{reduce: {Function}}}\n     * @returns {*}\n     */\n    foldr1 = curry(_foldr1),\n\n    /**\n     * Performs a map then a reduce all in one (from left-to-right). Returns a tuple\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\n     * @function module:listOps.mapAccumL\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\n     * @param xs {Array|String|*} - list type.\n     * @return {Array} - [aggregated, list]\n     */\n    mapAccumL = curry(_mapAccumL),\n\n    /**\n     * Performs a map and a reduce all in one (from right-to-left). Returns a tuple\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\n     * @function module:listOps.mapAccumR\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\n     * @param xs {Array|String|*} - list type.\n     * @return {Array} - [aggregated, list]\n     */\n    mapAccumR = curry(_mapAccumR),\n\n    /**\n     * Iterate on value (`x`) with `op` up to `limit`.\n     * @function module:listOps.iterate\n     * @param limit {Number}\n     * @param op {Function} - Operation\n     * @param x {*} - Starting point.\n     * @returns {*}\n     */\n    iterate = curry(_iterate),\n\n    repeat = curry(_repeat),\n\n    replicate = repeat,\n\n    cycle = curry(_cycle),\n\n    /**\n     * Unfolds a value into a list of somethings.\n     * @haskellType `unfoldr :: (b -> Maybe (a, b)) -> b -> [a]`\n     * @function module:listOps.unfoldr\n     * @param op {Function} - Operation to perform (should return a two component tuple (item to aggregate and item to unfold in next iteration).\n     * @param x {*} - Starting parameter to unfold from.\n     * @returns {Array} - An array of whatever you return from `op` yielded.\n     */\n    unfoldr = curry(_unfoldr),\n\n    /**\n     * Finds index in string or list (alias for `findIndex`).\n     * @function module:listOps.findIndex\n     * @param pred {Function} - Predicate<element, index, arr>.\n     * @param arr {Array|String}\n     * @returns {Number} - `-1` if predicate not matched else `index` found\n     */\n    findIndex = curry(_findIndex),\n\n    /**\n     * @function module:listOps.findIndices\n     * @param pred {Function}\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {Array|undefined}\n     */\n    findIndices = curry(_findIndices),\n\n    /**\n     * @function module:listOps.elemIndex\n     * @param x {*} - Element to search for.\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {*}\n     */\n    elemIndex = curry(_elemIndex),\n\n    /**\n     * @function module:listOps.elemIndices\n     * @param value {*} - Element to search for.\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {*}\n     */\n    elemIndices = curry(_elemIndices),\n\n    /**\n     * Takes `n` items from start of list to `limit` (exclusive).\n     * @function module:listOps.take\n     * @param list {Array|String}\n     * @param limit {Number}\n     * @returns {String|Array} - Passed in type's type\n     */\n    take = curry(_take),\n\n    /**\n     * Drops `n` items from start of list to `count` (exclusive).\n     * @function module:listOps.take\n     * @param list {Array|String}\n     * @param count {Number}\n     * @returns {String|Array} - Passed in type's type\n     */\n    drop = curry(_drop),\n\n    /**\n     * Splits `x` in two at given `index` (exclusive (includes element/character at\n     * given index in second part of returned list)).\n     * @function module:listOps.splitAt\n     * @param ind {Number} - Index to split at.\n     * @param list {Array|String|*} - functor (list or string) to split.\n     * @returns {Array} - Array of whatever type `x` was when passed in\n     */\n    splitAt = curry(_splitAt),\n\n    /**\n     * Gives an list with passed elements while predicate was true.\n     * @function module:listOps.takeWhile\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @returns {Array}\n     */\n    takeWhile = curry(_takeWhile),\n\n    /**\n     * Returns an list without elements that match predicate.\n     * @function module:listOps.dropWhile\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @refactor\n     * @returns {Array|String}\n     */\n    dropWhile = curry(_dropWhile),\n\n    /**\n     * @function module:listOps.dropWhile\n     * @param pred {Function} - Predicate<*, index, list|string>\n     * @param list {Array|String}\n     * @refactor\n     * @returns {Array|String}\n     */\n    dropWhileEnd = curry(_dropWhileEnd),\n\n    /**\n     * Gives a span such that the first list (in returned tuple) is the span of items matching upto `not predicate` and\n     * the second list in the tuple is a list of the remaining elements in the given list.\n     * **@Note: Not the same as `partition`.  Read descriptions closely!!!\n     * @function module:listOps.partition\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\n     * @param list {Array|String|*} - Predicate<item, index, originalArrayOrString>\n     * @returns {Array|String|*} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\n     */\n    span = curry(_span),\n\n    breakOnList = curry(_breakOnList),\n\n    /**\n     * @function module:listOps.at\n     * @param ind {Number} - Index.\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {*}\n     */\n    at = curry(_at),\n\n    /**\n     * @function module:listOps.find\n     * @param pred {Function}\n     * @param xs {Array|String|*} - list or list like.\n     * @returns {*}\n     */\n    find = curry(_find),\n\n    filter = curry(_filter),\n\n    /**\n     * Partitions a list on a predicate;  Items that match predicate are in first list in tuple;  Items that\n     * do not match the tuple are in second list in the returned tuple.\n     *  Essentially `[filter(p, xs), filter(negateP(p), xs)]`.\n     * @function module:listOps.partition\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\n     * @param list {Array|String|*}\n     * @returns {Array|String} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\n     */\n    partition = curry(_partition),\n\n    elem = curry(_elem),\n\n    notElem = curry2(_notElem),\n\n    lookup = at,\n\n    isPrefixOf = curry(_isPrefixOf),\n\n    isSuffixOf = curry(_isSuffixOf),\n\n    isInfixOf = curry(_isInfixOf),\n\n    isSubsequenceOf = curry(_isSubsequenceOf),\n\n    /**\n     * Allows you to group items in a list based on your supplied equality check.\n     * @note Sames `group` but allows you to specify equality operation.\n     * @haskellType `groupBy :: (a -> a -> Bool) -> [a] -> [[a]]`\n     * @function module:listOps.groupBy\n     * @param equalityOp {Function}\n     * @param xs {Array|String|*}\n     * @returns {*}\n     */\n    groupBy = curry(_groupBy),\n\n    stripPrefix = curry(_stripPrefix),\n\n    /**\n     * zip takes two lists and returns a list of corresponding pairs.\n     * If one input list is short, excess elements of the longer list are discarded.\n     * @haskellType `zip :: [a] -> [b] -> [(a, b)]`\n     * @function module:listOps.zip\n     * @param arr1 {Array}\n     * @param arr2 {Array}\n     * @returns {Array<Array<*,*>>}\n     */\n    zip = curry(_zip),\n\n    /**\n     * zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\n     * zipWith generalises zip by zipping with the function given as the\n     * first argument, instead of a function tupling function (function that returns a tuple). For example,\n     * zipWith (+) is applied to two lists to produce the list of corresponding sums.\n     * @note `_|_` means bottom or perpetual (@see\n     *  - https://wiki.haskell.org/Bottom\n     *  - https://stackoverflow.com/questions/19794681/what-does-this-syntax-mean-in-haskell-or\n     *  )\n     * @example\n     * ```\n     * zipWith f [] _|_ = []\n     * ```\n     * @haskellType `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`\n     * @function module:listOps.zipWith\n     * @param op {Function} - Takes two parts of a tuple and returns a tuple.\n     *  E.g., ` op :: a -> b -> (a, b)`\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith = curry(_zipWith),\n\n    /**\n     * Zips all given lists with tupling function. Note: Haskell types do not have\n     *  a way (that I know of) to show one or more for params in a function so `@haskellType` below\n     *  is left there for general purpose not for exactness as is told by aforementioned.\n     * @haskellType `zipWithN :: (a -> b -> c) -> [a] -> [b] -> [c]` - Where `N` is the number\n     *  of lists to zip.\n     * @function module:listOps.zipWithN\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\n     * @param lists ...{Array|String|*}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWithN = curry3(_zipWithN),\n\n    /**\n     * Zips 3 lists with tupling function.\n     * @haskellType `zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]`\n     * @function module:listOps.zipWith3\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @param xs3 {Array|String|*}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith3 = curry4(zipWithN),\n\n    /**\n     * Zips 4 lists with tupling function.\n     * @haskellType `zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c]  -> [d] -> [e]`\n     * @function module:listOps.zipWith4\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> d -> (a, b, c, d)`\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @param xs3 {Array|String|*}\n     * @param xs4 {Array|String|*}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith4 = curry5(zipWithN),\n\n    /**\n     * Zips 5 lists.\n     * @haskellType `zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c]  -> [d] -> [e] -> [f]`\n     * @function module:listOps.zipWith5\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\n     *  of said parts:\n     *  E.g., ` op :: a -> b -> c -> d -> e -> (a, b, c, d, e)`\n     * @param xs1 {Array|String|*}\n     * @param xs2 {Array|String|*}\n     * @param xs3 {Array|String|*}\n     * @param xs4 {Array|String|*}\n     * @param xs5 {Array|String|*}\n     * @returns {Array<Array<*,*>>}\n     */\n    zipWith5 = curryN(6, zipWithN),\n\n    any = curry(_any),\n\n    all = curry(_all),\n\n    scanl = curry(_scanl),\n\n    scanl1 = curry(_scanl1),\n\n    scanr = curry(_scanr),\n\n    scanr1 = curry(_scanr1),\n\n    remove = curry(_remove),\n\n    sortOn = curry(_sortOn),\n\n    sortBy = curry(_sortBy),\n\n    insert = curry(_insert),\n\n    /**\n     * A version of `insert` that allows you to specify the ordering of the inserted\n     * item;  Before/at, or after\n     * @function module:listOps.insertBy\n     * @haskellType `insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]`\n     * @note `Ordering` === // something that is order-able\n     * @todo Optimize and work the logic of this function;  Think about the types that will be\n     *  operated on by this functions logic.\n     * @param orderingFn {Function} - A function that returns `-1`, `0`, or 1`.\n     * @param x {*} - Value to insert.\n     * @param xs {Array|String|*} - List to insert into (note new list is returned)\n     * @returns {Array|String|*} - New list.\n     */\n    insertBy = curry(_insertBy),\n\n    nubBy = curry(_nubBy),\n\n    removeBy = curry(_removeBy),\n\n    removeFirstsBy = curry(_removeFirstsBy),\n\n    /**\n     * Returns the union on elements matching boolean check passed in.\n     * @function module:listOps.unionBy\n     * @param pred {Function} - `pred :: a -> a -> Bool`\n     * @param arr1 {Array|String|*}\n     * @param arr2 {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    unionBy = curry(_unionBy),\n\n    /**\n     * Creates a union on matching elements from array1.\n     * @function module:listOps.union\n     * @param arr1 {Array|String|*}\n     * @param arr2 {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    union = curry(_union),\n\n    /**\n     * Performs an intersection on list 1 with  elements from list 2.\n     * @function module:listOps.intersect\n     * @param arr1 {Array|String|*}\n     * @param arr2 {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    intersect = curry(_intersect),\n\n    /**\n     * Returns an intersection by predicate.\n     * @function module:listOps.intersectBy\n     * @param pred {Function} - `pred :: a -> b -> Bool`\n     * @param list1 {Array|String|*}\n     * @param list2 {Array|String|*}\n     * @return {Array|String|*}\n     */\n    intersectBy = curry(_intersectBy),\n\n    /**\n     * Returns the difference of list 1 from list 2.\n     * @note The `difference` operation here is non-associative;  E.g., `a - b` is not equal to `b - a`;\n     * @function module:listOps.difference\n     * @param array1 {Array|String|*}\n     * @param array2 {Array|String|*}\n     * @returns {Array|String|*}\n     */\n    difference = curry(_difference),\n\n    /**\n     * Returns the complement of list 0 and the reset of the passed in arrays.\n     * @function module:listOps.complement\n     * @param arr0 {Array}\n     * @param arrays {...Array}\n     * @returns {Array}\n     */\n    complement = curry2(_complement);\n","/**\n * Contains functions for operating strings.\n * @author elyde\n * @created 7/9/2017.\n * @module stringOps\n */\nimport {intercalate, _map, _splitAt} from './listOps';\n\nimport {split} from './jsPlatform/string';\n\nexport const\n\n    /**\n     * Splits a string on all '\\n', '\\r', '\\n\\r', or '\\r\\n' characters.\n     * @function module:stringOps.lines\n     * @param str {String}\n     * @returns {Array}\n     */\n    lines = split(/[\\n\\r]/gm),\n\n    /**\n     * Splits a string on all '\\s' and/or all '\\t' characters.\n     * @function module:stringOps.words\n     * @param str{String}\n     * @returns {Array}\n     */\n    words = split(/[\\s\\t]/gm),\n\n    /**\n     * Intersperse an array of strings with '\\s' and then concats them.\n     * @function module:stringOps.unwords\n     * @param arr {String}\n     * @returns {Array}\n     */\n    unwords = intercalate(' '),\n\n    /**\n     * Intersperses a '\\n' character into a list of strings and then concats it.\n     * @function module:stringOps.unlines\n     * @param list {Array|String|*}\n     * @returns {Array}\n     */\n    unlines = intercalate('\\n'),\n\n    /**\n     * Lower cases first character of string.\n     * @function module:stringOps.lcaseFirst\n     * @param xs {String}\n     * @returns {string}\n     */\n    lcaseFirst = xs => xs[0].toLowerCase() + xs.substring(1),\n\n    /**\n     * Upper cases first character of string.\n     * @function module:stringOps.ucaseFirst\n     * @param xs {String}\n     * @returns {string}\n     */\n    ucaseFirst = xs => xs[0].toUpperCase() + xs.substring(1),\n\n    /**\n     * Class cases a string.\n     * @function module:stringOps.camelCase\n     * @param xs {String}\n     * @param [pattern=/[^a-z\\d/i]/] {RegExp} - Optional.\n     * @returns {string}\n     */\n    camelCase = (xs, pattern) => _map(ucaseFirst, _splitAt(pattern || /[^a-z\\d]/i, xs))\n\n    ;\n","/**\n * Created by elyde on 12/6/2016.\n * @file fjl.js\n * @goal to include everything from haskell's Prelude where it makes sense in order to create\n *  a subset of functions which can make the javascript developer more efficient and make his/her\n *  code more concise (and functional).\n * @description Includes operations from haskell's Prelude.\n * @motivation preludejs, lodash/fp, RamdaJs, Haskell.\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-List.html\n * @module fjl\n */\nexport * from './objectOps';\nexport * from './booleanOps';\nexport * from './functionOps';\nexport * from './listOps';\nexport * from './stringOps';\nexport * from './utils';\nexport * from './uncurried/_listOps/_utils';\n"],"names":["_Number","Number","name","_NaN","_Null","_Undefined","typeOf","value","retVal","undefined","constructorName","constructor","isNaN","fPureTakesOne","arg","f","fPureTakes2","arg1","arg2","fPureTakes3","arg3","fPureTakes4","arg4","fPureTakes5","arg5","fPureTakesOneOrMore","args","fnOrError","symbolName","Function","Error","instanceOf","instanceConstructor","instance","hasOwnProperty","length","x","keys","Object","obj","assign","obj0","objs","reduce","topAgg","agg","key","defineReverse","Array","prototype","reverse","reduceRight","item","push","map","filter","forEach","some","every","join","concat","slice","includes","xs","indexOf","lastIndexOf","split","apply","fn","call","notFnErrPrefix","curry","argsToCurry","curryN","executeArity","curriedArgs","concatedArgs","canBeCalled","curry2","curry3","curry4","curry5","prop","_String","String","_Object","_Boolean","Boolean","_Function","_Array","_Symbol","_Map","_Set","_WeakMap","_WeakSet","isFunction","isType","type","isClass","test","substr","isCallable","isArray","isObject","isBoolean","isNumber","isString","isMap","isSet","isWeakMap","isWeakSet","isUndefined","isNull","isSymbol","isUsableImmutablePrimitive","typeOfX","isset","Type","isEmptyList","isEmptyObject","isEmptyCollection","size","isEmpty","typeOfValue","assignDeep","propDescription","getOwnPropertyDescriptor","get","set","writable","negateF","a","b","negateF3","c","negateF4","d","negateF5","e","negateP","negateFMany","isTruthy","isFalsy","alwaysTrue","alwaysFalse","Symbol","of","_map","ind","limit","out","aggregateStr","aggregateArr","aggregateObj","aggregatorByType","sliceFrom","startInd","arr","sliceTo","toInd","copy","sliceCopy","genericAscOrdering","lengths","lists","lengthsToSmallest","listLengths","smallLen","Math","min","list","reduceUntil","pred","op","result","reduceRightUntil","operation","lastIndex","len","findIndexWhere","predicateFulfilled","findIndexWhereRight","findIndicesWhere","findWhere","elm","append","listAppend","appendMany","head","last","tail","init","uncons","unconsr","concatMap","foldableOfA","foldr","intersperse","between","lastInd","foldl","intercalate","xss","transpose","numLists","ind2","longestListLen","maximum","outLists","outList","subsequences","listLen","pow","i","entry","j","swapped","ind1","tmp","permutations","repeat","foldl1","parts","foldr1","mapAccumL","zero","mapped","tuple","mapAccumR","iterate","lastX","replicate","cycle","unfoldr","resultTuple","findIndex","findIndices","elemIndex","foundInd","elemIndices","take","drop","count","splitAt","takeWhile","dropWhile","splitPoint","list2","dropWhileEnd","span","breakOnList","at","find","partition","elem","notElem","lookup","isPrefixOf","xs1","xs2","limit1","limit2","isSuffixOf","isInfixOf","foundLen","isSubsequenceOf","lenXs1","group","groupBy","equalityOp","prevItem","predOp","inits","tails","stripPrefix","prefix","zip","arr1","arr2","a1","a2","zipN","trimmedLists","lenOfTrimmed","zipWith","zipWithN","unzip","unzipN","lenItem0","any","p","all","and","or","sum","product","sortBy","minimum","scanl","scanl1","scanr","scanr1","nub","nubBy","remove","removeBy","sort","sortOn","valueFn","decorated","a0","b0","orderingFn","insert","foundIndex","insertBy","currItem","anyOp","storedItem","removeFirstsBy","unionBy","alreadyAdded","union","intersect","intersectBy","list1","difference","array1","array2","complement","arr0","arrays","objUnion","obj1","obj2","objIntersect","objDifference","objComplement","_prop","_instanceOf","_hasOwnProperty","_assign","_assignDeep","_objUnion","_objIntersect","_objDifference","_objComplement","_isType","until","predicate","typeInstance","flipN","flip3","flip4","flip5","flip","PlaceHolder","placeHolderInstance","isPlaceHolder","replacePlaceHolders","array","element","shift","curry_","curryN_","placeHolders","__","freeze","curry2_","curry3_","curry4_","curry5_","id","compose","arg0","_apply","_call","_until","_flip","_flip3","_flip4","_flip5","fPureTakesOne_","fPureTakes2_","fPureTakesOneOrMore_","concat_","slice_","includes_","indexOf_","lastIndexOf_","_split","_append","_appendMany","_concatMap","_intersperse","_intercalate","_foldl","_foldr","_foldl1","_foldr1","_mapAccumL","_mapAccumR","_iterate","_repeat","_cycle","_unfoldr","_findIndex","_findIndices","_elemIndex","_elemIndices","_take","_drop","_splitAt","_takeWhile","_dropWhile","_dropWhileEnd","_span","_breakOnList","_at","_find","_filter","_partition","_elem","_notElem","_isPrefixOf","_isSuffixOf","_isInfixOf","_isSubsequenceOf","_groupBy","_stripPrefix","_zip","_zipWith","_zipWithN","zipWith3","zipWith4","zipWith5","_any","_all","_scanl","_scanl1","_scanr","_scanr1","_remove","_sortOn","_sortBy","_insert","_insertBy","_nubBy","_removeBy","_removeFirstsBy","_unionBy","_union","_intersect","_intersectBy","_difference","_complement","lines","words","unwords","unlines","lcaseFirst","toLowerCase","substring","ucaseFirst","toUpperCase","camelCase","pattern"],"mappings":";;;AAAA;;;;AAIA,IAAMA,UAAUC,OAAOC,IAAvB;IACIC,OAAO,KADX;IAEIC,QAAQ,MAFZ;IAGIC,aAAa,WAHjB;;;;;;;;;;;;;;AAiBA,AAAO,SAASC,MAAT,CAAiBC,KAAjB,EAAwB;QACvBC,eAAJ;QACID,UAAUE,SAAd,EAAyB;iBACZJ,UAAT;KADJ,MAGK,IAAIE,UAAU,IAAd,EAAoB;iBACZH,KAAT;KADC,MAGA;YACGM,kBAAmBH,KAAD,CAAQI,WAAR,CAAoBT,IAA1C;iBACSQ,oBAAoBV,OAApB,IAA+BY,MAAML,KAAN,CAA/B,GACLJ,IADK,GACEO,eADX;;WAGGF,MAAP;;;AChCG,IAEHK,gBAAgB,SAAhBA,aAAgB;WAAQ,UAACC,GAAD,EAAMC,CAAN;eAAYA,EAAEb,IAAF,EAAQY,GAAR,CAAZ;KAAR;CAFb;IAIHE,cAAc,SAAdA,WAAc;WAAQ,UAACC,IAAD,EAAOC,IAAP,EAAaH,CAAb;eAAmBA,EAAEb,IAAF,EAAQe,IAAR,EAAcC,IAAd,CAAnB;KAAR;CAJX;IAMHC,cAAc,SAAdA,WAAc;WAAQ,UAACF,IAAD,EAAOC,IAAP,EAAaE,IAAb,EAAmBL,CAAnB;eAAyBA,EAAEb,IAAF,EAAQe,IAAR,EAAcC,IAAd,EAAoBE,IAApB,CAAzB;KAAR;CANX;IAQHC,cAAc,SAAdA,WAAc;WAAQ,UAACJ,IAAD,EAAOC,IAAP,EAAaE,IAAb,EAAmBE,IAAnB,EAAyBP,CAAzB;eAA+BA,EAAEb,IAAF,EAAQe,IAAR,EAAcC,IAAd,EAAoBE,IAApB,EAA0BE,IAA1B,CAA/B;KAAR;CARX;IAUHC,cAAc,SAAdA,WAAc;WAAQ,UAACN,IAAD,EAAOC,IAAP,EAAaE,IAAb,EAAmBE,IAAnB,EAAyBE,IAAzB,EAA+BT,CAA/B;eAAqCA,EAAEb,IAAF,EAAQe,IAAR,EAAcC,IAAd,EAAoBE,IAApB,EAA0BE,IAA1B,EAAgCE,IAAhC,CAArC;KAAR;CAVX;IAYHC,sBAAsB,SAAtBA,mBAAsB;WAAQ,UAACV,CAAD;0CAAOW,IAAP;gBAAA;;;eAAgBX,EAAEb,IAAF,WAAWwB,IAAX,CAAhB;KAAR;CAZnB;IAcHC,YAAY,SAAZA,SAAY,CAACC,UAAD,EAAab,CAAb,EAAmB;QACvB,CAACA,CAAD,IAAMA,EAAEJ,WAAF,KAAkBkB,QAA5B,EAAsC;cAC5B,IAAIC,KAAJ,CAAcF,UAAH,oDACKtB,OAAOS,CAAP,CADL,2BACoCA,CADpC,OAAX,CAAN;;WAGGA,CAAP;CAnBD;;ACFP;;;;;;;;AAQA,AAEO,IAUHgB,eAAa,SAAbA,UAAa,CAACC,mBAAD,EAAsBC,QAAtB;SACTA,oBAAoBD,mBADX;CAVV;IAmBHE,mBAAiBrB,cAAc,gBAAd,CAnBd;IA4BHsB,SAAS,SAATA,MAAS;SAAKC,EAAED,MAAP;CA5BN;IAoCHE,OAAO,SAAPA,IAAO;SAAOC,OAAOD,IAAP,CAAYE,GAAZ,CAAP;CApCJ;IA6CHC,WAAU;SAAMF,OAAOE,MAAP,GACR,UAACC,IAAD;sCAAUC,IAAV;UAAA;;;WAAmBJ,OAAOE,MAAP,gBAAcC,IAAd,SAAuBC,IAAvB,EAAnB;GADQ,GAER,UAACD,IAAD;uCAAUC,IAAV;UAAA;;;WAAmBA,KAAKC,MAAL,CAAY,UAACC,MAAD,EAASL,GAAT,EAAiB;aACrCF,KAAKE,GAAL,EAAUI,MAAV,CAAiB,UAACE,GAAD,EAAMC,GAAN,EAAc;YAC9BA,GAAJ,IAAWP,IAAIO,GAAJ,CAAX;eACOD,GAAP;OAFG,EAGJD,MAHI,CAAP;KADe,EAKhBH,IALgB,CAAnB;GAFE;CAAD,EA7CN;;ACVP;;;;;;;;AAQA,AAEO,IAOHM,gBAAgB,SAAhBA,aAAgB;SACZC,MAAMC,SAAN,CAAgBC,OAAhB,GAA0B;WAAKd,EAAEc,OAAF,EAAL;GAA1B,GACI;WAAKd,EAAEe,WAAF,CAAc,UAACN,GAAD,EAAMO,IAAN,EAAe;UAC1BC,IAAJ,CAASD,IAAT;aACOP,GAAP;KAFC,EAGF,EAHE,CAAL;GAFQ;CAPb;IAqBHS,MAAMzC,cAAc,KAAd,CArBH;IA8BH0C,SAAS1C,cAAc,QAAd,CA9BN;IAuCH8B,SAAS3B,YAAY,QAAZ,CAvCN;IAgDHmC,cAAcnC,YAAY,aAAZ,CAhDX;IAyDHwC,UAAU3C,cAAc,SAAd,CAzDP;IAmEH4C,OAAO5C,cAAc,MAAd,CAnEJ;IA4EH6C,QAAQ7C,cAAc,OAAd,CA5EL;IAqFH8C,OAAO9C,cAAc,MAAd,CArFJ;IA6FHwC,OAAO5B,oBAAoB,MAApB,CA7FJ;IAoGHyB,UAAUH,eApGP;;ACVP;;;;;AAKA,AAEO,IAWHa,SAASnC,oBAAoB,QAApB,CAXN;IAoBHoC,QAAQ7C,YAAY,OAAZ,CApBL;IA6BH8C,WAAY;SAAM,cAAcd,MAAMC,SAApB,GACVpC,cAAc,UAAd,CADU,GAEV,UAACN,KAAD,EAAQwD,EAAR;WAAeA,GAAGC,OAAH,CAAWzD,KAAX,IAAoB,CAAC,CAApC;GAFI;CAAD,EA7BR;IAwCHyD,UAAUnD,cAAc,SAAd,CAxCP;IAiDHoD,cAAcpD,cAAc,aAAd,CAjDX;;ACPP;;;;AAIA,AAEA;;;;;;;AAOA,AAAO,IAAMqD,QAAQrD,cAAc,OAAd,CAAd;;ACbP;;;;;AAKA,AAAO,IASHsD,QAAQ,SAARA,KAAQ,CAACC,EAAD,EAAK1C,IAAL;SAAc0C,GAAGD,KAAH,CAAS,IAAT,EAAezC,IAAf,CAAd;CATL;IAkBH2C,OAAO,SAAPA,IAAO,CAACD,EAAD;oCAAQ1C,IAAR;QAAA;;;SAAiByC,MAAMC,EAAN,EAAU1C,IAAV,CAAjB;CAlBJ;;ACLP;;;;;ACAA;;;;;;AAMA,AAGA,IAAM4C,iBAAiB,8BAAvB;;AAEA,AAAO,IASHC,QAAQ,SAARA,KAAQ,CAACH,EAAD;oCAAQI,WAAR;eAAA;;;SAAwBC,yBAAO9C,UAAU2C,cAAV,EAA0BF,EAA1B,EAA8BjC,MAArC,EAA6CiC,EAA7C,SAAoDI,WAApD,EAAxB;CATL;IAmBHC,SAAS,SAATA,MAAS,CAACC,YAAD,EAAeN,EAAf,EAAsC;qCAAhBO,WAAgB;eAAA;;;SACpC,YAAa;uCAATjD,IAAS;UAAA;;;QACZkD,eAAehB,OAAOe,WAAP,EAAoBjD,IAApB,CAAnB;QACImD,cAAe1C,OAAOyC,YAAP,KAAwBF,YAAzB,IAA0C,CAACA,YAD7D;WAEO,CAACG,WAAD,GAAeV,MAAMM,MAAN,EAAcb,OAAO,CAACc,YAAD,EAAe/C,UAAU2C,cAAV,EAA0BF,EAA1B,CAAf,CAAP,EAAsDQ,YAAtD,CAAd,CAAf,GACHT,MAAMxC,UAAU2C,cAAV,EAA0BF,EAA1B,CAAN,EAAqCQ,YAArC,CADJ;GAHJ;CApBD;IAkCHE,SAAS,SAATA,MAAS;SAAML,OAAO,CAAP,EAAUL,EAAV,CAAN;CAlCN;IA0CHW,SAAS,SAATA,MAAS;SAAMN,OAAO,CAAP,EAAUL,EAAV,CAAN;CA1CN;IAkDHY,SAAS,SAATA,MAAS;SAAMP,OAAO,CAAP,EAAUL,EAAV,CAAN;CAlDN;IA0DHa,SAAS,SAATA,MAAS;SAAMR,OAAO,CAAP,EAAUL,EAAV,CAAN;CA1DN;;ACXP;;;;;;;;;;;AAWA,AAAO,IAAMc,SAAO,SAAPA,IAAO,CAAChF,IAAD,EAAOqC,GAAP;SAAeA,IAAIrC,IAAJ,CAAf;CAAb;;ACXP;;;;;AAKA,AAGA,IAAIiF,UAAUC,OAAOlF,IAArB;IACIF,YAAUC,OAAOC,IADrB;IAEImF,UAAU/C,OAAOpC,IAFrB;IAGIoF,WAAWC,QAAQrF,IAHvB;IAIIsF,YAAY3D,SAAS3B,IAJzB;IAKIuF,SAASzC,MAAM9C,IALnB;IAMIwF,UAAU,QANd;IAOIC,OAAO,KAPX;IAQIC,OAAO,KARX;IASIC,WAAW,SATf;IAUIC,WAAW,SAVf;IAWI1F,UAAQ,MAXZ;IAYIC,eAAa,WAZjB;;;;;;;;AAsBI,iBAAa,SAAb0F,UAAa;SAAShE,aAAWF,QAAX,EAAqBtB,KAArB,CAAT;CAAb;IAeAyF,QAfA,GAeS,SAATA,MAAS,CAACC,IAAD,EAAO1D,GAAP;SAAejC,OAAOiC,GAAP,OAAiBwD,WAAWE,IAAX,IAAmBA,KAAK/F,IAAxB,GAA+B+F,IAAhD,CAAf;CAfT;IAuBAC,OAvBA,GAuBU,SAAVA,OAAU;SAAK9D,KAAK,uBAAuB+D,IAAvB,CAA4B,CAAC/D,IAAI,EAAL,EAASgE,MAAT,CAAgB,CAAhB,EAAmB,EAAnB,CAA5B,CAAV;CAvBV;IAgCAC,UAhCA,GAgCa,SAAbA,UAAa;SAAKN,WAAW3D,CAAX,KAAiB,CAAC8D,QAAQ9D,CAAR,CAAvB;CAhCb;IAwCCkE,OAxCD,GAwCYtD,KAxCZ,CAwCCsD,OAxCD;IAgDAC,QAhDA,GAgDW,SAAXA,QAAW;SAASP,SAAOX,OAAP,EAAgB9E,KAAhB,CAAT;CAhDX;IAwDAiG,SAxDA,GAwDY,SAAZA,SAAY;SAASR,SAAOV,QAAP,EAAiB/E,KAAjB,CAAT;CAxDZ;IAgEAkG,QAhEA,GAgEW,SAAXA,QAAW;SAAST,SAAOhG,SAAP,EAAgBO,KAAhB,CAAT;CAhEX;IAwEAmG,QAxEA,GAwEW,SAAXA,QAAW;SAASV,SAAOb,OAAP,EAAgB5E,KAAhB,CAAT;CAxEX;IAgFAoG,KAhFA,GAgFQ,SAARA,KAAQ;SAASX,SAAOL,IAAP,EAAapF,KAAb,CAAT;CAhFR;IAwFAqG,KAxFA,GAwFQ,SAARA,KAAQ;SAASZ,SAAOJ,IAAP,EAAarF,KAAb,CAAT;CAxFR;IAgGAsG,SAhGA,GAgGY,SAAZA,SAAY;SAASb,SAAOH,QAAP,EAAiBtF,KAAjB,CAAT;CAhGZ;IAwGAuG,SAxGA,GAwGY,SAAZA,SAAY;SAASd,SAAOF,QAAP,EAAiBvF,KAAjB,CAAT;CAxGZ;IAgHAwG,WAhHA,GAgHc,SAAdA,WAAc;SAASf,SAAO3F,YAAP,EAAmBE,KAAnB,CAAT;CAhHd;IAwHAyG,MAxHA,GAwHS,SAATA,MAAS;SAAShB,SAAO5F,OAAP,EAAcG,KAAd,CAAT;CAxHT;IAgIA0G,QAhIA,GAgIW,SAAXA,QAAW;SAASjB,SAAON,OAAP,EAAgBnF,KAAhB,CAAT;CAhIX;IA2IA2G,0BA3IA,GA2I6B,SAA7BA,0BAA6B,IAAK;MACxBC,UAAU7G,OAAO8B,CAAP,CAAhB;SACOgF,MAAMhF,CAAN,KACH,CAAC+C,OAAD,EAAUnF,SAAV,EAAmBsF,QAAnB,EAA6BI,OAA7B,EACKjC,IADL,CACU;WAAQ4D,SAASF,OAAjB;GADV,CADJ;CA7IJ;IAwJAG,WAxJA,GAwJc,SAAdA,WAAc;SAAK,CAACnF,OAAOC,CAAP,CAAN;CAxJd;IAgKAmF,aAhKA,GAgKgB,SAAhBA,aAAgB;SAAOD,YAAYjF,KAAKE,GAAL,CAAZ,CAAP;CAhKhB;IAwKAiF,iBAxKA,GAwKoB,SAApBA,iBAAoB;SAAKpF,EAAEqF,IAAF,KAAW,CAAhB;CAxKpB;IAkLAC,OAlLA,GAkLU,SAAVA,OAAU,QAAS;MACXC,cAAcrH,OAAOC,KAAP,CAAlB;MACIC,eADJ;MAEI,CAACD,KAAL,EAAY;;aACC,IAAT;GADJ,MAGK,IAAIoH,gBAAgBlC,MAAhB,IAA0BkC,gBAAgBnC,SAA9C,EAAyD;aACjD8B,YAAY/G,KAAZ,CAAT;GADC,MAGA,IAAIoH,gBAAgB3H,SAApB,EAA6B;aACrB,KAAT;GADC,MAGA,IAAI2H,gBAAgBtC,OAApB,EAA6B;aACrBkC,cAAchH,KAAd,CAAT;GADC,MAGA,IAAI2B,iBAAe,MAAf,EAAuB3B,KAAvB,KAAiCkG,SAASlG,MAAMkH,IAAf,CAArC,EAA2D;aACnDD,kBAAkBjH,KAAlB,CAAT;GADC,MAGA;aACQ,CAACA,KAAV;;SAEGC,MAAP;CAvMJ;IAgNA4G,KAhNA,GAgNQ,SAARA,KAAQ;SAAKhF,MAAM,IAAN,IAAcA,MAAM3B,SAAzB;CAhNR;;ACzBG,IAQHmH,eAAa,SAAbA,UAAa,CAACnF,IAAD;sCAAUC,IAAV;YAAA;;;WACTA,KAAKC,MAAL,CAAY,UAACC,MAAD,EAASL,GAAT;eACJF,KAAKE,GAAL,EAAUI,MAAV,CAAiB,UAACE,GAAD,EAAMC,GAAN,EAAc;gBACvB+E,kBAAkBvF,OAAOwF,wBAAP,CAAgCjF,GAAhC,EAAqCC,GAArC,CAAtB;;gBAEIZ,iBAAeY,GAAf,EAAoBD,GAApB,KAA4BgF,eAA5B,IACA,EAAEA,gBAAgBE,GAAhB,IAAuBF,gBAAgBG,GAAzC,CADA,IAEA,CAACH,gBAAgBI,QAFrB,EAE+B;uBACpBpF,GAAP;;gBAEA0D,SAAS1D,IAAIC,GAAJ,CAAT,KAAsByD,SAAShE,IAAIO,GAAJ,CAAT,CAA1B,EAA8C;2BAC/BD,IAAIC,GAAJ,CAAX,EAAqBP,IAAIO,GAAJ,CAArB;aADJ,MAGK;oBAAMA,GAAJ,IAAWP,IAAIO,GAAJ,CAAX;;mBACAD,GAAP;SAZJ,EAaGD,MAbH,CADI;KAAZ,EAeMH,IAfN,CADS;CARV;;ACLP;;;;AAIA,AAEO,IASHyF,UAAU,SAAVA,OAAU;SAAM,UAACC,CAAD,EAAIC,CAAJ;WAAU,CAAChE,GAAG+D,CAAH,EAAMC,CAAN,CAAX;GAAN;CATP;IAkBHC,WAAW,SAAXA,QAAW;SAAM,UAACF,CAAD,EAAIC,CAAJ,EAAOE,CAAP;WAAa,CAAClE,GAAG+D,CAAH,EAAMC,CAAN,EAASE,CAAT,CAAd;GAAN;CAlBR;IA2BHC,WAAW,SAAXA,QAAW;SAAM,UAACJ,CAAD,EAAIC,CAAJ,EAAOE,CAAP,EAAUE,CAAV;WAAgB,CAACpE,GAAG+D,CAAH,EAAMC,CAAN,EAASE,CAAT,EAAYE,CAAZ,CAAjB;GAAN;CA3BR;IAoCHC,WAAW,SAAXA,QAAW;SAAM,UAACN,CAAD,EAAIC,CAAJ,EAAOE,CAAP,EAAUE,CAAV,EAAaE,CAAb;WAAmB,CAACtE,GAAG+D,CAAH,EAAMC,CAAN,EAASE,CAAT,EAAYE,CAAZ,EAAeE,CAAf,CAApB;GAAN;CApCR;IA4CHC,UAAUN,QA5CP;IAoDHO,cAAc,SAAdA,WAAc;SAAM;sCAAIlH,IAAJ;UAAA;;;WAAa,CAACyC,MAAMC,EAAN,EAAU1C,IAAV,CAAd;GAAN;CApDX;;ACNP;;;;;AAKA,AAAO,IAQHmH,WAAW,SAAXA,QAAW;SAAS,CAAC,CAACtI,KAAX;CARR;IAgBHuI,UAAU,SAAVA,OAAU;SAAS,CAACvI,KAAV;CAhBP;IAuBHwI,aAAa,SAAbA,UAAa;SAAM,IAAN;CAvBV;IA8BHC,cAAc,SAAdA,WAAc;SAAM,KAAN;CA9BX;;ACAP;;;;;;;;AAQA,SAAS9B,4BAAT,CAAqC9E,CAArC,EAAwC;QAC9B+E,UAAU7G,OAAO8B,CAAP,CAAhB;WACOgF,MAAMhF,CAAN,KACH,CAACgD,OAAOlF,IAAR,EAAcD,OAAOC,IAArB,EAA2BqF,QAAQrF,IAAnC,EAAyC+I,OAAO/I,IAAhD,EACKuD,IADL,CACU;eAAQ4D,SAASF,OAAjB;KADV,CADJ;;;;;;;;;;;;;;;;;AAmBJ,AAAO,IAAM+B,KAAK,SAALA,EAAK,CAAC9G,CAAD,EAAgB;sCAATV,IAAS;YAAA;;;QAC1B,CAAC0F,MAAMhF,CAAN,CAAL,EAAe;eAAS3B,SAAP;;QACXE,cAAcyB,EAAEzB,WAAtB;QACIuB,iBAAe,IAAf,EAAqBvB,WAArB,CAAJ,EAAuC;eAC5BwD,MAAMxD,YAAYuI,EAAlB,EAAsBxH,IAAtB,CAAP;KADJ,MAGK,IAAIwF,6BAA2B9E,CAA3B,CAAJ,EAAmC;eAC7B+B,MAAMxD,WAAN,EAAmBe,IAAnB,CAAP;KADC,MAGA,IAAIqE,WAAWpF,WAAX,CAAJ,EAA6B;kDACnBA,WAAX,gBAA0Be,IAA1B;;WAEGjB,SAAP;CAZG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClCP;;;;;;ACEA;;;;;;AAMA,AAAe,SAAS0I,IAAT,CAAe/E,EAAf,EAAmBL,EAAnB,EAAuB;QAC9BqF,MAAM,CAAV;QACIC,QAAQlH,OAAO4B,EAAP,CADZ;QAEIuF,MAAM,EAFV;QAGI,CAACD,KAAL,EAAY;eAASC,GAAP;;WACPF,MAAMC,KAAb,EAAoB;YACZhG,IAAJ,CAASe,GAAGL,GAAGqF,GAAH,CAAH,EAAYA,GAAZ,EAAiBrF,EAAjB,CAAT;eACO,CAAP;;WAEGuF,GAAP;;;ACfG,IAEHC,eAAe,SAAfA,YAAe,CAAC1G,GAAD,EAAMO,IAAN;WAAeP,MAAMO,IAArB;CAFZ;IAIHoG,eAAe,SAAfA,YAAe,CAAC3G,GAAD,EAAMO,IAAN,EAAe;QACtBC,IAAJ,CAASD,IAAT;WACOP,GAAP;CAND;IASH4G,eAAe,SAAfA,YAAe,CAAC5G,GAAD,EAAMO,IAAN,EAAYgG,GAAZ,EAAoB;QAC3BA,GAAJ,IAAWhG,IAAX;WACOP,GAAP;CAXD;IAcH6G,mBAAmB,SAAnBA,gBAAmB,IAAK;YACZpJ,OAAO8B,CAAP,CAAR;aACS,QAAL;mBAAsBmH,YAAP;aACV,OAAL;mBAAqBC,YAAP;aACT,QAAL;;mBACgBC,YAAP;;CAnBd;;ACFP;;;;;AAKA,AAQO,IASHE,YAAY,SAAZA,SAAY,CAACC,QAAD,EAAWC,GAAX;WAAmBhG,MAAM+F,QAAN,EAAgBnJ,SAAhB,EAA2BoJ,GAA3B,CAAnB;CATT;IAkBHC,UAAU,SAAVA,OAAU,CAACC,KAAD,EAAQhG,EAAR;WAAeF,MAAM,CAAN,EAASkG,KAAT,EAAgBhG,EAAhB,CAAf;CAlBP;IA0BHiG,OAAO,SAAPA,IAAO;WAAML,UAAU,CAAV,EAAa5F,EAAb,CAAN;CA1BJ;IAkCHkG,YAAYD,IAlCT;IA2CHE,qBAAqB,SAArBA,kBAAqB,CAAC/B,CAAD,EAAIC,CAAJ,EAAU;QACvBD,IAAIC,CAAR,EAAW;eAAS,CAAP;KAAb,MACK,IAAID,IAAIC,CAAR,EAAW;eAAS,CAAC,CAAR;;WACX,CAAP;CA9CD;IAuDH+B,UAAU,SAAVA,OAAU;sCAAIC,KAAJ;aAAA;;;WAAcjI,OAAOiI,KAAP,IAAgBjB,KAAKhH,MAAL,EAAaiI,KAAb,CAAhB,GAAsC,EAApD;CAvDP;IA8DHC,oBAAoB,SAApBA,iBAAoB,GAAc;uCAAVD,KAAU;aAAA;;;QACxBE,cAAcnG,MAAMgG,OAAN,EAAeC,KAAf,CAApB;QACIG,WAAWC,KAAKC,GAAL,CAAStG,KAAT,CAAeqG,IAAf,EAAqBF,WAArB,CADf;WAEOnB,KAAK,UAACuB,IAAD,EAAOtB,GAAP;eAAekB,YAAYlB,GAAZ,IAAmBmB,QAAnB,GACvBT,QAAQS,QAAR,EAAkBG,IAAlB,CADuB,GACGV,KAAKU,IAAL,CADlB;KAAL,EACmCN,KADnC,CAAP;CAjED;IA6EHO,cAAc,SAAdA,WAAc,CAACC,IAAD,EAAOC,EAAP,EAAWhI,GAAX,EAAgBgH,GAAhB,EAAwB;QAC5BR,QAAQlH,OAAO0H,GAAP,CAAd;QACI,CAACR,KAAL,EAAY;eAASxG,GAAP;;QACVuG,MAAM,CAAV;QACI0B,SAASjI,GADb;WAEOuG,MAAMC,KAAb,EAAoBD,KAApB,EAA2B;YACnBwB,KAAKf,IAAIT,GAAJ,CAAL,EAAeA,GAAf,EAAoBS,GAApB,CAAJ,EAA8B;;;iBACrBgB,GAAGC,MAAH,EAAWjB,IAAIT,GAAJ,CAAX,EAAqBA,GAArB,EAA0BS,GAA1B,CAAT;;WAEGiB,MAAP;CAtFD;IAiGHC,mBAAmB,SAAnBA,gBAAmB,CAACH,IAAD,EAAOC,EAAP,EAAWhI,GAAX,EAAgBgH,GAAhB,EAAwB;QACjCR,QAAQlH,OAAO0H,GAAP,CAAd;QACI,CAACR,KAAL,EAAY;eAASxG,GAAP;;QACVuG,MAAMC,QAAQ,CAAlB;QACIyB,SAASjI,GADb;WAEOuG,OAAO,CAAd,EAAiBA,KAAjB,EAAwB;YAChBwB,KAAKf,IAAIT,GAAJ,CAAL,EAAeA,GAAf,EAAoBS,GAApB,CAAJ,EAA8B;;;iBACrBgB,GAAGC,MAAH,EAAWjB,IAAIT,GAAJ,CAAX,EAAqBA,GAArB,EAA0BS,GAA1B,CAAT;;WAEGiB,MAAP;CA1GD;IA6GHnI,WAAS,SAATA,MAAS,CAACqI,SAAD,EAAYnI,GAAZ,EAAiBgH,GAAjB;WACLc,YACI3B,WADJ;aAAA;OAAA;OAAA,CADK;CA7GN;IAoHH7F,gBAAc,SAAdA,WAAc,CAAC6H,SAAD,EAAYnI,GAAZ,EAAiBgH,GAAjB;WACVkB,iBACI/B,WADJ;aAAA;OAAA;OAAA,CADU;CApHX;IAiIHiC,YAAY,SAAZA,SAAY,IAAK;QAAQC,MAAM/I,OAAOC,CAAP,CAAZ,CAAuB,OAAO8I,MAAMA,MAAM,CAAZ,GAAgB,CAAvB;CAjIvC;IA0IHC,iBAAiB,SAAjBA,cAAiB,CAACP,IAAD,EAAOf,GAAP,EAAe;QACxBT,MAAM,CAAC,CAAX;QACIgC,qBAAqB,KADzB;QAEM/B,QAAQlH,OAAO0H,GAAP,CAAd;WACOT,MAAMC,KAAN,IAAe,CAAC+B,kBAAvB,EAA2C;6BAClBR,KAAKf,IAAI,EAAET,GAAN,CAAL,EAAiBA,GAAjB,EAAsBS,GAAtB,CAArB;;WAEGT,GAAP;CAjJD;IA2JHiC,sBAAsB,SAAtBA,mBAAsB,CAACT,IAAD,EAAOf,GAAP,EAAe;QAC3BR,QAAQlH,OAAO0H,GAAP,CAAd;QACIT,MAAMC,KAAV;QACI+B,qBAAqB,KADzB;WAEOhC,OAAO,CAAP,IAAY,CAACgC,kBAApB,EAAwC,EAAEhC,GAA1C,EAA+C;6BACtBwB,KAAKf,IAAIT,GAAJ,CAAL,EAAeA,GAAf,EAAoBS,GAApB,CAArB;;WAEGT,GAAP;CAlKD;IA0KHkC,mBAAmB,SAAnBA,gBAAmB,CAACV,IAAD,EAAO7G,EAAP,EAAc;QACzB,CAACA,EAAD,IAAO,CAACA,GAAG5B,MAAf,EAAuB;eAAS1B,SAAP;;QACnB4I,QAAQlH,OAAO4B,EAAP,CAAd;QACIqF,MAAM,CAAV;QACIE,MAAM,EADV;WAEOF,MAAMC,KAAb,EAAoBD,KAApB,EAA2B;YACnBwB,KAAK7G,GAAGqF,GAAH,CAAL,EAAcA,GAAd,EAAmBrF,EAAnB,CAAJ,EAA4B;gBAAMV,IAAJ,CAAS+F,GAAT;;;WAE3BE,IAAInH,MAAJ,GAAamH,GAAb,GAAmB7I,SAA1B;CAlLD;IA2LH8K,YAAY,SAAZA,SAAY,CAACX,IAAD,EAAO7G,EAAP,EAAc;QAClBqF,MAAM,CAAV;QACIC,QAAQlH,OAAO4B,EAAP,CADZ;QAEI,CAACsF,KAAL,EAAY;;;WACLD,MAAMC,KAAb,EAAoBD,KAApB,EAA2B;YACnBoC,MAAMzH,GAAGqF,GAAH,CAAV;YACIwB,KAAKY,GAAL,EAAUpC,GAAV,EAAerF,EAAf,CAAJ,EAAwB;mBAASyH,GAAP;;;CAjM/B;;ACbP;;;;;;AAMA,AAwBA;AACA,AAAO,IAeHC,SAASC,MAfN;IA0BHC,aAAa,SAAbA,UAAa,GAAa;sCAATjK,IAAS;YAAA;;;QAClBS,OAAOT,IAAP,CAAJ,EAAkB;eAASyC,MAAMuH,MAAN,EAAkBhK,IAAlB,CAAP;;UACd,IAAII,KAAJ,CAAU,yCAAV,CAAN;CA5BD;IAsCH8J,OAAO,SAAPA,IAAO;WAAKxJ,EAAE,CAAF,CAAL;CAtCJ;IA+CHyJ,OAAO,SAAPA,IAAO;WAAM9H,GAAGkH,UAAUlH,EAAV,CAAH,CAAN;CA/CJ;IAwDH+H,OAAO,SAAPA,IAAO;WAAMnC,UAAU,CAAV,EAAa5F,EAAb,CAAN;CAxDJ;IAiEHgI,OAAO,SAAPA,IAAO;WAAMjC,QAAQmB,UAAUlH,EAAV,CAAR,EAAuBA,EAAvB,CAAN;CAjEJ;IA0EHiI,SAAS,SAATA,MAAS;WACL,CAACjI,EAAD,IAAO5B,OAAO4B,EAAP,MAAe,CAAtB,GAA0BtD,SAA1B,GAAsC,CAACmL,KAAK7H,EAAL,CAAD,EAAW+H,KAAK/H,EAAL,CAAX,CADjC;CA1EN;IAoFHkI,UAAU,SAAVA,OAAU;WAAM,CAAClI,EAAD,IAAO5B,OAAO4B,EAAP,MAAe,CAAtB,GAA0BtD,SAA1B,GAAsC,CAACsL,KAAKhI,EAAL,CAAD,EAAW8H,KAAK9H,EAAL,CAAX,CAA5C;CApFP;IA6FHH,WAAS,SAATA,SAAS;WAAM,CAACzB,OAAO4B,EAAP,CAAD,GAAciG,KAAKjG,EAAL,CAAd,GAAyBI,MAAMwH,UAAN,EAAkB5H,EAAlB,CAA/B;CA7FN;IAuGHmI,YAAY,SAAZA,SAAY,CAAC9H,EAAD,EAAK+H,WAAL;WAAqBvI,SAAOuF,KAAK/E,EAAL,EAAS+H,WAAT,CAAP,CAArB;CAvGT;IAgHHjJ,YAAU,SAAVA,OAAU;WAAKkJ,MAAM,UAACvJ,GAAD,EAAMO,IAAN;eAAgBP,IAAIQ,IAAJ,CAASD,IAAT,GAAgBP,GAAhC;KAAN,EAA4C,EAA5C,EAAgDT,CAAhD,CAAL;CAhHP;IA2HHiK,cAAc,SAAdA,WAAc,CAACC,OAAD,EAAUzC,GAAV,EAAkB;QACtBR,QAAQlH,OAAO0H,GAAP,CAAd;QACI0C,UAAUlD,QAAQ,CADtB;QAEIC,MAAM,EAFV;QAGI,CAACD,KAAL,EAAY;eACDC,GAAP;;WAEGkD,MAAM,UAAC3J,GAAD,EAAMO,IAAN,EAAYgG,GAAZ;eACLA,QAAQmD,OAAR,GACI1J,IAAIQ,IAAJ,CAASD,IAAT,CADJ,GAEIP,IAAIQ,IAAJ,CAASD,IAAT,EAAekJ,OAAf,CAFJ,EAGAzJ,GAJK;KAAN,EAKAyG,GALA,EAKKO,GALL,CAAP;CAlID;IAkJH4C,cAAc,SAAdA,WAAc,CAAC1I,EAAD,EAAK2I,GAAL;WAAa9I,SAAOyI,YAAYtI,EAAZ,EAAgB2I,GAAhB,CAAP,CAAb;CAlJX;IAqKHC,YAAY,SAAZA,SAAY,MAAO;QACXC,WAAWzK,OAAOuK,GAAP,CAAf;QACItD,MAAM,CADV;QACayD,aADb;QAEI,CAACD,QAAL,EAAe;eACJ,EAAP;;QAEEtC,cAAcnG,MAAMgG,OAAN,EAAeuC,GAAf,CAApB;QACII,iBAAiBC,QAAQzC,WAAR,CADrB;QAEI0C,WAAW,EAFf;WAGO5D,MAAM0D,cAAb,EAA6B1D,OAAO,CAApC,EAAuC;YAC7B6D,UAAU,EAAhB;aACKJ,OAAO,CAAZ,EAAeA,OAAOD,QAAtB,EAAgCC,QAAQ,CAAxC,EAA2C;gBACnCvC,YAAYuC,IAAZ,IAAoBzD,MAAM,CAA9B,EAAiC;;;oBAGzB/F,IAAR,CAAaqJ,IAAIG,IAAJ,EAAUzD,GAAV,CAAb;;iBAEK/F,IAAT,CAAc4J,OAAd;;WAEG1J,SAAO;eAAKpB,OAAOC,CAAP,CAAL;KAAP,EAAuB4K,QAAvB,CAAP;CAxLD;IAuMHE,eAAe,SAAfA,YAAe,KAAM;QACXC,UAAUhL,OAAO4B,EAAP,CAAhB;QACImH,MAAMV,KAAK4C,GAAL,CAAS,CAAT,EAAYD,OAAZ,CADV;QAEI7D,MAAM,EAFV;SAGK,IAAI+D,IAAI,CAAb,EAAgBA,IAAInC,GAApB,EAAyBmC,KAAK,CAA9B,EAAiC;YACzBC,QAAQ,EAAZ;aACK,IAAIC,IAAI,CAAb,EAAgBA,IAAIJ,OAApB,EAA6BI,KAAK,CAAlC,EAAqC;gBAC7BF,IAAK,KAAKE,CAAd,EAAkB;sBACRlK,IAAN,CAAWU,GAAGwJ,CAAH,CAAX;;;YAGJlK,IAAJ,CAASiK,KAAT;;WAEGhE,GAAP;CApND;IAgPHkE,UAAU,SAAVA,OAAU,CAACC,IAAD,EAAOZ,IAAP,EAAanC,IAAb,EAAsB;QACtBpB,MAAMU,KAAKU,IAAL,CAAZ;QACIgD,MAAMpE,IAAImE,IAAJ,CADV;QAEIA,IAAJ,IAAYnE,IAAIuD,IAAJ,CAAZ;QACIA,IAAJ,IAAYa,GAAZ;WACOpE,GAAP;CArPD;IAgQHqE,eAAe,SAAfA,YAAe,KAAM;QACXtE,QAAQlH,OAAO4B,EAAP,CAAd;;QAEI,CAACsF,KAAD,IAAUA,UAAU,CAAxB,EAA2B;eAChB,CAACtF,EAAD,CAAP;;;QAGA2G,OAAOV,KAAKjG,EAAL,CAAX;QACIuE,IAAIsF,OAAOvE,KAAP,EAAc,CAAd,CADR;QAEIgE,IAAI,CAFR;;QAIM/D,MAAM,CAACoB,IAAD,CAAZ;;WAEO2C,IAAIhE,KAAX,EAAkBgE,GAAlB,EAAuB;YACf/E,EAAE+E,CAAF,IAAOA,CAAX,EAAc;mBACHG,QAAQH,IAAI,CAAJ,KAAU,CAAV,GAAc,CAAd,GAAkB/E,EAAE+E,CAAF,CAA1B,EAAgCA,CAAhC,EAAmC3C,IAAnC,CAAP;gBACIrH,IAAJ,CAASqH,IAAT;cACE2C,CAAF,KAAQ,CAAR;gBACI,CAAJ;;;UAGFA,CAAF,IAAO,CAAP;;;WAGG/D,GAAP;CAxRD;IAmSHkD,QAAQ7J,QAnSL;IA6SHyJ,QAAQjJ,aA7SL;IAuTH0K,SAAS,SAATA,MAAS,CAAChD,EAAD,EAAK9G,EAAL,EAAY;QACX+J,QAAQ9B,OAAOjI,EAAP,CAAd;WACO,CAAC+J,KAAD,GAAS,EAAT,GAAcnL,SAAOkI,EAAP,EAAWiD,MAAM,CAAN,CAAX,EAAqBA,MAAM,CAAN,CAArB,CAArB;CAzTD;IAoUHC,SAAS,SAATA,MAAS,CAAClD,EAAD,EAAK9G,EAAL,EAAY;QACX+J,QAAQ7B,QAAQlI,EAAR,CAAd;WACO,CAAC+J,KAAD,GAAS,EAAT,GAAc3K,cAAY0H,EAAZ,EAAgBiD,MAAM,CAAN,CAAhB,EAA0BA,MAAM,CAAN,CAA1B,CAArB;CAtUD;IAkVHE,YAAY,SAAZA,SAAY,CAACnD,EAAD,EAAKoD,IAAL,EAAWlK,EAAX,EAAkB;QACpB2G,OAAOV,KAAKjG,EAAL,CAAb;QACIsF,QAAQlH,OAAO4B,EAAP,CADZ;QAEI,CAACsF,KAAL,EAAY;eACD,CAAC4E,IAAD,EAAOvD,IAAP,CAAP;;QAEAtB,MAAM,CAAV;QACIvG,MAAMoL,IADV;QAEIC,SAAS,EAFb;QAGIC,cAHJ;WAIO/E,MAAMC,KAAb,EAAoBD,KAApB,EAA2B;gBACfyB,GAAGhI,GAAH,EAAQ6H,KAAKtB,GAAL,CAAR,EAAmBA,GAAnB,CAAR;cACM+E,MAAM,CAAN,CAAN;iBACSA,MAAM,CAAN,CAAT;;WAEG,CAACtL,GAAD,EAAMqL,MAAN,CAAP;CAjWD;IA6WHE,YAAY,SAAZA,SAAY,CAACvD,EAAD,EAAKoD,IAAL,EAAWlK,EAAX,EAAkB;QACpB2G,OAAOV,KAAKjG,EAAL,CAAb;QACIsF,QAAQlH,OAAO4B,EAAP,CADZ;QAEI,CAACsF,KAAL,EAAY;eACD,CAAC4E,IAAD,EAAOvD,IAAP,CAAP;;QAEAtB,MAAMC,QAAQ,CAAlB;QACIxG,MAAMoL,IADV;QAEIC,SAAS,EAFb;QAGIC,cAHJ;WAIO/E,OAAO,CAAd,EAAiBA,KAAjB,EAAwB;gBACZyB,GAAGhI,GAAH,EAAQ6H,KAAKtB,GAAL,CAAR,EAAmBA,GAAnB,CAAR;cACM+E,MAAM,CAAN,CAAN;iBACSA,MAAM,CAAN,CAAT;;WAEG,CAACtL,GAAD,EAAMqL,MAAN,CAAP;CA5XD;IAwYHG,UAAU,SAAVA,OAAU,CAAChF,KAAD,EAAQwB,EAAR,EAAYzI,CAAZ,EAAkB;QACpBgH,MAAM,CAAV;QACIE,MAAM,EADV;QAEIgF,QAAQlM,CAFZ;WAGOgH,MAAMC,KAAb,EAAoBD,OAAO,CAA3B,EAA8B;YACtB/F,IAAJ,CAASiL,KAAT;gBACQzD,GAAGyD,KAAH,CAAR;;WAEGhF,GAAP;CAhZD;IA0ZHsE,SAAS,SAATA,MAAS,CAACvE,KAAD,EAAQjH,CAAR;WAAciM,QAAQhF,KAAR,EAAe;eAAKlB,CAAL;KAAf,EAAuB/F,CAAvB,CAAd;CA1ZN;IAmaHmM,YAAYX,MAnaT;IA4aHY,QAAQ,SAARA,KAAQ,CAACnF,KAAD,EAAQtF,EAAR;WAAeH,SAAO2K,UAAUlF,KAAV,EAAiBtF,EAAjB,CAAP,CAAf;CA5aL;IAsbH0K,UAAU,SAAVA,OAAU,CAAC5D,EAAD,EAAKzI,CAAL,EAAW;QACbgH,MAAM,CAAV;QACIE,MAAM,EADV;QAEIoF,cAAc7D,GAAGzI,CAAH,EAAMgH,GAAN,EAAWE,GAAX,CAFlB;WAGOoF,WAAP,EAAoB;YACZrL,IAAJ,CAASqL,YAAY,CAAZ,CAAT;sBACc7D,GAAG6D,YAAY,CAAZ,CAAH,EAAmB,EAAEtF,GAArB,EAA0BE,GAA1B,CAAd;;WAEGA,GAAP;CA9bD;IAwcHqF,YAAYxD,cAxcT;IAgdHyD,cAActD,gBAhdX;IAwdHuD,YAAY,SAAZA,SAAY,CAACzM,CAAD,EAAI2B,EAAJ,EAAW;QACb+K,WAAW9K,QAAQ5B,CAAR,EAAW2B,EAAX,CAAjB;WACO+K,aAAa,CAAC,CAAd,GAAkBA,QAAlB,GAA6BrO,SAApC;CA1dD;IAmeHsO,cAAc,SAAdA,WAAc,CAACxO,KAAD,EAAQwD,EAAR;WAAe6K,YAAY;eAAKxM,MAAM7B,KAAX;KAAZ,EAA8BwD,EAA9B,CAAf;CAneX;IA4eHiL,OAAO,SAAPA,IAAO,CAAC3F,KAAD,EAAQqB,IAAR;WAAiBZ,QAAQT,KAAR,EAAeqB,IAAf,CAAjB;CA5eJ;IAqfHuE,OAAO,SAAPA,IAAO,CAACC,KAAD,EAAQxE,IAAR;WAAiBf,UAAUuF,KAAV,EAAiBxE,IAAjB,CAAjB;CArfJ;IA+fHyE,UAAU,SAAVA,OAAU,CAAC/F,GAAD,EAAMsB,IAAN;WAAe,CAAEZ,QAAQV,GAAR,EAAasB,IAAb,CAAF,EAAsBf,UAAUP,GAAV,EAAesB,IAAf,CAAtB,CAAf;CA/fP;IAwgBH0E,YAAY,SAAZA,SAAY,CAACxE,IAAD,EAAOF,IAAP;WACRC,YACIhC,QAAQiC,IAAR,CADJ;gBAAA;MAAA;QAAA,CADQ;CAxgBT;IAwhBHyE,YAAY,SAAZA,SAAY,CAACzE,IAAD,EAAOF,IAAP,EAAgB;QAClBrB,QAAQlH,OAAOuI,IAAP,CAAd;QACI4E,aACInE,eAAe,UAAC/H,IAAD,EAAOgG,GAAP,EAAYmG,KAAZ;eACX,CAAC3E,KAAKF,KAAKtB,GAAL,CAAL,EAAgBA,GAAhB,EAAqBmG,KAArB,CADU;KAAf,EACkC7E,IADlC,CAFR;;WAKO4E,eAAe,CAAC,CAAhB,GACHxF,QAAQT,KAAR,EAAeqB,IAAf,CADG,GAEH7G,MAAMyL,UAAN,EAAkBjG,KAAlB,EAAyBqB,IAAzB,CAFJ;CA9hBD;IA0iBH8E,eAAe,SAAfA,YAAe,CAAC5E,IAAD,EAAOF,IAAP,EAAgB;QACrBrB,QAAQlH,OAAOuI,IAAP,CAAd;QACI4E,aACIjE,oBAAoB,UAACjI,IAAD,EAAOgG,GAAP,EAAYmG,KAAZ;eAChB,CAAC3E,KAAKF,KAAKtB,GAAL,CAAL,EAAgBA,GAAhB,EAAqBmG,KAArB,CADe;KAApB,EACkC7E,IADlC,CAFR;;WAKO4E,eAAe,CAAC,CAAhB,GACHxF,QAAQT,KAAR,EAAeqB,IAAf,CADG,GAEHZ,QAAQwF,aAAa,CAArB,EAAwB5E,IAAxB,CAFJ;CAhjBD;IA8jBH+E,OAAO,SAAPA,IAAO,CAAC7E,IAAD,EAAOF,IAAP,EAAgB;QACb4E,aAAanE,eAAexC,QAAQiC,IAAR,CAAf,EAA8BF,IAA9B,CAAnB;WACO4E,eAAe,CAAC,CAAhB,GACHH,QAAQ,CAAR,EAAWzE,IAAX,CADG,GACgByE,QAAQG,UAAR,EAAoB5E,IAApB,CADvB;CAhkBD;IAokBHgF,cAAc,SAAdA,WAAc,CAAC9E,IAAD,EAAOF,IAAP,EAAgB;QACpB4E,aAAanE,eAAeP,IAAf,EAAqBF,IAArB,CAAnB;WACO4E,eAAe,CAAC,CAAhB,GACHH,QAAQ,CAAR,EAAWzE,IAAX,CADG,GACgByE,QAAQG,UAAR,EAAoB5E,IAApB,CADvB;CAtkBD;IAilBHiF,KAAKzK,MAjlBF;IA0lBH0K,OAAOrE,SA1lBJ;IAmmBHhI,WAAS,SAATA,MAAS,CAACqH,IAAD,EAAO7G,EAAP,EAAc;QACfqF,MAAM,CAAV;QACIC,QAAQlH,OAAO4B,EAAP,CADZ;QAEIuF,MAAM,EAFV;QAGI,CAACD,KAAL,EAAY;eACDC,GAAP;;WAEGF,MAAMC,KAAb,EAAoBD,KAApB,EAA2B;YACnBwB,KAAK7G,GAAGqF,GAAH,CAAL,EAAcA,GAAd,EAAmBrF,EAAnB,CAAJ,EAA4B;gBACpBV,IAAJ,CAASU,GAAGqF,GAAH,CAAT;;;WAGDE,GAAP;CA/mBD;IA2nBHuG,YAAY,SAAZA,SAAY,CAACjF,IAAD,EAAOF,IAAP;WACR,CAACvI,OAAOuI,IAAP,CAAD,GACI,CAAC,EAAD,EAAK,EAAL,CADJ,GAEQ,CAACnH,SAAOqH,IAAP,EAAaF,IAAb,CAAD,EAAqBnH,SAAOoF,QAAQiC,IAAR,CAAP,EAAsBF,IAAtB,CAArB,CAHA;CA3nBT;IAuoBHoF,OAAOhM,QAvoBJ;IAgpBHiM,UAAU7H,QAAQpE,QAAR,CAhpBP;IAkpBHkM,SAASL,EAlpBN;IAopBHM,aAAa,SAAbA,UAAa,CAACC,GAAD,EAAMC,GAAN,EAAc;QACjBC,SAASjO,OAAO+N,GAAP,CAAf;QACIG,SAASlO,OAAOgO,GAAP,CADb;QAEIE,SAASD,MAAT,IAAmB,CAACA,MAApB,IAA8B,CAACC,MAA/B,IAAyCrM,QAAQkM,IAAI,CAAJ,CAAR,EAAgBC,GAAhB,MAAyB,CAAC,CAAvE,EAA0E;eAC/D,KAAP;;QAEA/G,MAAM,CAAV;WACOA,MAAMgH,MAAb,EAAqBhH,KAArB,EAA4B;YACpB8G,IAAI9G,GAAJ,MAAa+G,IAAI/G,GAAJ,CAAjB,EAA2B;mBAChB,KAAP;;;WAGD,IAAP;CAhqBD;IAmqBHkH,aAAa,SAAbA,UAAa,CAACJ,GAAD,EAAMC,GAAN,EAAc;QACjBC,SAASjO,OAAO+N,GAAP,CAAf;QACIG,SAASlO,OAAOgO,GAAP,CADb;QAEIE,SAASD,MAAT,IAAmB,CAACA,MAApB,IAA8B,CAACC,MAA/B,IAAyCrM,QAAQkM,IAAI,CAAJ,CAAR,EAAgBC,GAAhB,MAAyB,CAAC,CAAvE,EAA0E;eAC/D,KAAP;;QAEA1C,OAAO2C,SAAS,CAApB;QACIvD,OAAOwD,SAAS,CADpB;WAEO5C,QAAQ,CAAf,EAAkBA,MAAlB,EAA0B;YAClByC,IAAIzC,IAAJ,MAAc0C,IAAItD,IAAJ,CAAlB,EAA6B;mBAClB,KAAP;;gBAEI,CAAR;;WAEG,IAAP;CAjrBD;IAorBH0D,YAAY,SAAZA,SAAY,CAACL,GAAD,EAAMC,GAAN,EAAc;QAChBC,SAASjO,OAAO+N,GAAP,CAAf;QACIG,SAASlO,OAAOgO,GAAP,CADb;QAEIE,SAASD,MAAT,IAAmB,CAACA,MAApB,IAA8B,CAACC,MAAnC,EAA2C;eAChC,KAAP;;QAEA5C,aAAJ;QACI+C,iBADJ;QAEIpH,MAAM,CAFV;WAGOA,MAAMiH,MAAb,EAAqBjH,OAAO,CAA5B,EAA+B;mBAChB,CAAX;aACKqE,OAAO,CAAZ,EAAeA,OAAO2C,MAAtB,EAA8B3C,QAAQ,CAAtC,EAAyC;gBACjC0C,IAAI1C,OAAOrE,GAAX,MAAoB8G,IAAIzC,IAAJ,CAAxB,EAAmC;4BACnB,CAAZ;;gBAEA+C,aAAaJ,MAAjB,EAAyB;uBACd,IAAP;;;;WAIL,KAAP;CAxsBD;IA2sBHK,kBAAkB,SAAlBA,eAAkB,CAACP,GAAD,EAAMC,GAAN,EAAc;QACtBjF,MAAMV,KAAK4C,GAAL,CAAS,CAAT,EAAYjL,OAAOgO,GAAP,CAAZ,CAAZ;QACIO,SAASvO,OAAO+N,GAAP,CADb;QAEIM,iBAAJ;QACInD,UADJ;SAEKA,IAAI,CAAT,EAAYA,IAAInC,GAAhB,EAAqBmC,KAAK,CAA1B,EAA6B;mBACd,CAAX;aACK,IAAIE,IAAI,CAAb,EAAgBA,IAAIrC,GAApB,EAAyBqC,KAAK,CAA9B,EAAiC;gBACzBF,IAAK,KAAKE,CAAV,IAAgBvJ,QAAQmM,IAAI5C,CAAJ,CAAR,EAAgB2C,GAAhB,IAAuB,CAAC,CAA5C,EAA+C;4BAC/B,CAAZ;;gBAEAM,aAAaE,MAAjB,EAAyB;uBACd,IAAP;;;;WAIL,KAAP;CA3tBD;IA0uBHC,QAAQ,SAARA,KAAQ;WAAMC,QAAQ,UAACzI,CAAD,EAAIC,CAAJ;eAAUD,MAAMC,CAAhB;KAAR,EAA2BrE,EAA3B,CAAN;CA1uBL;IAqvBH6M,UAAU,SAAVA,OAAU,CAACC,UAAD,EAAa9M,EAAb,EAAoB;QACpBsF,QAAQlH,OAAO4B,EAAP,CAAd;QACI,CAACsF,KAAL,EAAY;eACDW,KAAKjG,EAAL,CAAP;;QAEAqF,MAAM,CAAV;QACI0H,iBADJ;QAEI1N,aAFJ;QAGI2N,SAAS,SAATA,MAAS,IAAK;YACNF,WAAWzO,CAAX,EAAc0O,QAAd,CAAJ,EAA6B;;;YAGzBD,WAAWzO,CAAX,EAAcgB,IAAd,CAAJ,EAAyB;uBACVhB,CAAX;mBACO,IAAP;;eAEG,KAAP;KAXR;QAaIS,MAAM,EAbV;WAcOuG,MAAMC,KAAb,EAAoBD,OAAO,CAA3B,EAA8B;eACnBrF,GAAGqF,GAAH,CAAP;YACI/F,IAAJ,CAAS+L,UAAU2B,MAAV,EAAkBlN,MAAMuF,GAAN,EAAWC,KAAX,EAAkBtF,EAAlB,CAAlB,CAAT;;WAEGlB,GAAP;CA5wBD;IAyxBHmO,QAAQ,SAARA,KAAQ,KAAM;QACN3H,QAAQlH,OAAO4B,EAAP,CAAZ;QACIqF,MAAM,CADV;QAEIvG,MAAM,EAFV;QAGI,CAACwG,KAAL,EAAY;eACD,EAAP;;WAEGD,OAAOC,KAAd,EAAqBD,OAAO,CAA5B,EAA+B;YACvB/F,IAAJ,CAASyG,QAAQV,GAAR,EAAarF,EAAb,CAAT;;WAEGlB,GAAP;CAnyBD;IAgzBHoO,QAAQ,SAARA,KAAQ,KAAM;QACN5H,QAAQlH,OAAO4B,EAAP,CAAZ;QACIqF,MAAM,CADV;QAEIvG,MAAM,EAFV;QAGI,CAACwG,KAAL,EAAY;eACD,EAAP;;WAEGD,OAAOC,KAAd,EAAqBD,OAAO,CAA5B,EAA+B;YACvB/F,IAAJ,CAASQ,MAAMuF,GAAN,EAAWC,KAAX,EAAkBtF,EAAlB,CAAT;;WAEGlB,GAAP;CA1zBD;IA6zBHqO,cAAc,SAAdA,WAAc,CAACC,MAAD,EAASzG,IAAT;WACVuF,WAAWkB,MAAX,EAAmBzG,IAAnB,IACIyE,QAAQhN,OAAOgP,MAAP,CAAR,EAAwBzG,IAAxB,EAA8B,CAA9B,CADJ,GAEIV,KAAKU,IAAL,CAHM;CA7zBX;IA20BH0G,MAAM,SAANA,GAAM,CAACC,IAAD,EAAOC,IAAP,EAAgB;QACd,CAACnP,OAAOkP,IAAP,CAAD,IAAiB,CAAClP,OAAOmP,IAAP,CAAtB,EAAoC;eACzB,EAAP;;;6BAEajH,kBAAkBgH,IAAlB,EAAwBC,IAAxB,CAJC;;QAIXC,EAJW;QAIPC,EAJO;;WAKX7O,SAAO,UAACE,GAAD,EAAMO,IAAN,EAAYgG,GAAZ;eACNI,aAAa3G,GAAb,EAAkB,CAACO,IAAD,EAAOoO,GAAGpI,GAAH,CAAP,CAAlB,CADM;KAAP,EAEH,EAFG,EAECmI,EAFD,CAAP;CAh1BD;IA61BHE,OAAO,SAAPA,IAAO,GAAc;uCAAVrH,KAAU;aAAA;;;QACXsH,eAAevN,MAAMkG,iBAAN,EAAyB9G,SAAOpB,MAAP,EAAeiI,KAAf,CAAzB,CAArB;QACIuH,eAAexP,OAAOuP,YAAP,CADnB;QAEI,CAACC,YAAL,EAAmB;eACR,EAAP;KADJ,MAGK,IAAIA,iBAAiB,CAArB,EAAwB;eAClB7H,QAAQ3H,OAAOuP,aAAa,CAAb,CAAP,CAAR,EAAiCA,aAAa,CAAb,CAAjC,CAAP;;WAEG/O,SAAO,UAACE,GAAD,EAAMO,IAAN,EAAYgG,GAAZ;eACNI,aAAa3G,GAAb,EAAkBsG,KAAK;mBAAMpF,GAAGqF,GAAH,CAAN;SAAL,EAAoBsI,YAApB,CAAlB,CADM;KAAP,EAEH,EAFG,EAECA,aAAa,CAAb,CAFD,CAAP;CAt2BD;IAi6BHE,UAAU,SAAVA,OAAU,CAAC/G,EAAD,EAAKqF,GAAL,EAAUC,GAAV,EAAkB;QACpB,CAAChO,OAAO+N,GAAP,CAAD,IAAgB,CAAC/N,OAAOgO,GAAP,CAArB,EAAkC;eACvB,EAAP;;;8BAEa9F,kBAAkB6F,GAAlB,EAAuBC,GAAvB,CAJO;;QAIjBoB,EAJiB;QAIbC,EAJa;;WAKjB7O,SAAO,UAACE,GAAD,EAAMO,IAAN,EAAYgG,GAAZ;eACNI,aAAa3G,GAAb,EAAkBgI,GAAGzH,IAAH,EAASoO,GAAGpI,GAAH,CAAT,CAAlB,CADM;KAAP,EAEH,EAFG,EAECmI,EAFD,CAAP;CAt6BD;IAw7BHM,WAAW,SAAXA,QAAW,CAAChH,EAAD,EAAkB;uCAAVT,KAAU;aAAA;;;QACnBsH,eAAevN,MAAMkG,iBAAN,EAAyBD,KAAzB,CAArB;QACIuH,eAAexP,OAAOuP,YAAP,CADnB;QAEI,CAACC,YAAL,EAAmB;eACR,EAAP;KADJ,MAGK,IAAIA,iBAAiB,CAArB,EAAwB;eAClB7H,QAAQ3H,OAAOuP,aAAa,CAAb,CAAP,CAAR,EAAiCA,aAAa,CAAb,CAAjC,CAAP;;WAEG/O,SAAO,UAACE,GAAD,EAAMO,IAAN,EAAYgG,GAAZ;eACNI,aAAa3G,GAAb,EAAkBsB,MAAM0G,EAAN,EAAU1B,KAAK;mBAAMpF,GAAGqF,GAAH,CAAN;SAAL,EAAoBsI,YAApB,CAAV,CAAlB,CADM;KAAP,EAEH,EAFG,EAECA,aAAa,CAAb,CAFD,CAAP;CAj8BD;IA2/BHI,QAAQ,SAARA,KAAQ;WACJtF,MAAM,UAAC3J,GAAD,EAAMO,IAAN,EAAe;YACb,CAAJ,EAAOC,IAAP,CAAYD,KAAK,CAAL,CAAZ;YACI,CAAJ,EAAOC,IAAP,CAAYD,KAAK,CAAL,CAAZ;eACOP,GAAP;KAHJ,EAIG,CAAC,EAAD,EAAK,EAAL,CAJH,EAIagH,GAJb,CADI;CA3/BL;IA0gCHkI,SAAS,SAATA,MAAS,OAAQ;QACT,CAAC5P,OAAOuI,IAAP,CAAL,EAAmB;eACR,EAAP;;QAEEsH,WAAW7P,OAAOuI,KAAK,CAAL,CAAP,CAAjB;QACIuD,OAAO+D,WACPvD,QAAQ;eAAY7B,aAAa,CAAC,EAAD,EAAKA,QAAL,CAAb,GAA8BnM,SAA1C;KAAR,EAA6DuR,QAA7D,CADO,GAEP,EAFJ;WAGOxF,MAAM,UAAC3J,GAAD,EAAMO,IAAN,EAAe;YACpBI,OAAJ,CAAY,UAACyJ,OAAD,EAAU7D,GAAV;mBAAkB6D,QAAQ5J,IAAR,CAAaD,KAAKgG,GAAL,CAAb,CAAlB;SAAZ;eACOvG,GAAP;KAFG,EAGJoL,IAHI,EAGEvD,IAHF,CAAP;CAlhCD;IA+hCHuH,MAAM,SAANA,GAAM,CAACC,CAAD,EAAInO,EAAJ,EAAW;QACTqF,MAAM,CAAV;QACIC,QAAQlH,OAAO4B,EAAP,CADZ;QAEI,CAACsF,KAAL,EAAY;eACD,KAAP;;WAEGD,MAAMC,KAAb,EAAoBD,OAAO,CAA3B,EAA8B;YACtB8I,EAAEnO,GAAGqF,GAAH,CAAF,CAAJ,EAAgB;mBACL,IAAP;;;WAGD,KAAP;CA1iCD;IAojCH+I,MAAM,SAANA,GAAM,CAACD,CAAD,EAAInO,EAAJ,EAAW;QACPsF,QAAQlH,OAAO4B,EAAP,CAAd;QACIqF,MAAM,CAAV;QACIC,UAAU,CAAd,EAAiB;eACN,KAAP;;WAEGD,MAAMC,KAAb,EAAoBD,KAApB,EAA2B;YACnB,CAAC8I,EAAEnO,GAAGqF,GAAH,CAAF,EAAWA,GAAX,EAAgBrF,EAAhB,CAAL,EAA0B;mBACf,KAAP;;;WAGD,IAAP;CA/jCD;IAykCHqO,MAAM,SAANA,GAAM;WAAMD,IAAItJ,QAAJ,EAAc9E,EAAd,CAAN;CAzkCH;IAolCHsO,KAAK,SAALA,EAAK;WAAMJ,IAAIpJ,QAAJ,EAAc9E,EAAd,CAAN;CAplCF;IAwmCHuO,MAAM,SAANA,GAAM;WAAQ9F,MAAM,UAAC3J,GAAD,EAAMT,CAAN;eAAYS,MAAMT,CAAlB;KAAN,EAA2B,CAA3B,EAA8BsI,IAA9B,CAAR;CAxmCH;IAinCH6H,UAAU,SAAVA,OAAU;WAAQ/F,MAAM,UAAC3J,GAAD,EAAMT,CAAN;eAAYS,MAAMT,CAAlB;KAAN,EAA2B,CAA3B,EAA8BsI,IAA9B,CAAR;CAjnCP;IA0nCHqC,UAAU,SAAVA,OAAU;WAAQlB,KAAK2G,OAAOtI,kBAAP,EAA2BQ,IAA3B,CAAL,CAAR;CA1nCP;IAmoCH+H,UAAU,SAAVA,OAAU;WAAQ7G,KAAK4G,OAAOtI,kBAAP,EAA2BQ,IAA3B,CAAL,CAAR;CAnoCP;IA4oCHgI,QAAQ,SAARA,KAAQ,CAACtO,EAAD,EAAK6J,IAAL,EAAWlK,EAAX,EAAkB;QAClB,CAACA,EAAD,IAAO,CAAC5B,OAAO4B,EAAP,CAAZ,EAAwB;eACb,EAAP;;QAEEsF,QAAQlH,OAAO4B,EAAP,CAAd;QACIqF,MAAM,CAAV;QACI0B,SAASmD,IADb;QAEI3E,MAAM,EAFV;WAGOF,MAAMC,KAAb,EAAoB;iBACPjF,GAAG0G,MAAH,EAAW/G,GAAGqF,GAAH,CAAX,EAAoBA,GAApB,EAAyBrF,EAAzB,CAAT;YACIV,IAAJ,CAASyH,MAAT;;;WAGGxB,GAAP;CAzpCD;IA4pCHqJ,SAAS,SAATA,MAAS,CAACvO,EAAD,EAAKL,EAAL,EAAY;QACb,CAACA,EAAD,IAAO,CAACA,GAAG5B,MAAf,EAAuB;eAAS,EAAP;;WAClBuQ,MAAMtO,EAAN,EAAUwH,KAAK7H,EAAL,CAAV,EAAoB+H,KAAK/H,EAAL,CAApB,CAAP;CA9pCD;IAiqCH6O,QAAQ,SAARA,KAAQ,CAACxO,EAAD,EAAK6J,IAAL,EAAWlK,EAAX,EAAkB;QAClB,CAACA,EAAD,IAAO,CAAC5B,OAAO4B,EAAP,CAAZ,EAAwB;eACb,EAAP;;QAEEsF,QAAQlH,OAAO4B,EAAP,CAAd;QACIqF,MAAMC,QAAQ,CAAlB;QACIyB,SAAS/G,GAAG,CAAH,CADb;QAEIuF,MAAM,EAFV;WAGOF,MAAM,CAAC,CAAd,EAAiB;iBACJhF,GAAG0G,MAAH,EAAW/G,GAAGqF,GAAH,CAAX,EAAoBA,GAApB,EAAyBrF,EAAzB,CAAT;YACIV,IAAJ,CAASyH,MAAT;;;WAGGxB,GAAP;CA9qCD;IAirCHuJ,SAAS,SAATA,MAAS,CAACzO,EAAD,EAAKL,EAAL,EAAY;QACb,CAACA,EAAD,IAAO,CAACA,GAAG5B,MAAf,EAAuB;eAAS,EAAP;;WAClByQ,MAAMxO,EAAN,EAAUyH,KAAK9H,EAAL,CAAV,EAAoBgI,KAAKhI,EAAL,CAApB,CAAP;CAnrCD;IAsrCH+O,MAAM,SAANA,GAAM;WAAQC,MAAM,UAAC5K,CAAD,EAAIC,CAAJ;eAAUD,MAAMC,CAAhB;KAAN,EAAyBsC,IAAzB,CAAR;CAtrCH;IAwrCHsI,SAAS,SAATA,MAAS,CAAC5Q,CAAD,EAAIsI,IAAJ;WAAauI,SAAS,UAAC9K,CAAD,EAAIC,CAAJ;eAAUD,MAAMC,CAAhB;KAAT,EAA4BhG,CAA5B,EAA+BsI,IAA/B,CAAb;CAxrCN;IA0rCHwI,OAAO,SAAPA,IAAO;WAAMV,OAAOtI,kBAAP,EAA2BnG,EAA3B,CAAN;CA1rCJ;IA4rCHoP,SAAS,SAATA,MAAS,CAACC,OAAD,EAAUrP,EAAV;;;;aAGA;mBAAasP,UAAU,CAAV,CAAb;SAAL;;;;;;;gBAKUC,EAAF;;;gBAAQC,EAAR;;mBAAgBrJ,mBAAmBoJ,EAAnB,EAAuBC,EAAvB,CAAhB;SAFJ;;;aAKS;mBAAQ,CAACH,QAAQhQ,IAAR,CAAD,EAAgBA,IAAhB,CAAR;SAAL,EAAoCW,EAApC,CALJ,CAHJ;;CA/rCD;IA2sCHyO,SAAS,SAATA,MAAS,CAACgB,UAAD,EAAazP,EAAb;WAAoBiG,KAAKjG,EAAL,EAASmP,IAAT,CAAcM,cAActJ,kBAA5B,CAApB;CA3sCN;IA6sCHuJ,SAAS,SAATA,MAAS,CAACrR,CAAD,EAAI2B,EAAJ,EAAW;QACZ,CAAC5B,OAAO4B,EAAP,CAAL,EAAiB;eACN,CAAC3B,CAAD,CAAP;;QAEEsR,aAAa/E,UAAU;eAAQvM,KAAKgB,IAAb;KAAV,EAA6BW,EAA7B,CAAnB;WACO2P,eAAe,CAAC,CAAhB,GAAoB,CAACtR,CAAD,CAApB,GACHwB,SAAOyI,YAAY,CAACjK,CAAD,CAAZ,EAAiB+M,QAAQuE,UAAR,EAAoB3P,EAApB,CAAjB,CAAP,CADJ;CAltCD;IAmuCH4P,WAAW,SAAXA,QAAW,CAACH,UAAD,EAAapR,CAAb,EAAgB2B,EAAhB,EAAuB;QACxBsF,QAAQlH,OAAO4B,EAAP,CAAd;QACI,CAACsF,KAAL,EAAY;eACD,CAACjH,CAAD,CAAP;;QAEAgH,MAAM,CAAV;WACOA,MAAMC,KAAb,EAAoBD,OAAO,CAA3B,EAA8B;YACtBoK,WAAWpR,CAAX,EAAc2B,GAAGqF,GAAH,CAAd,KAA0B,CAA9B,EAAiC;gBACvB0E,QAAQqB,QAAQ/F,GAAR,EAAarF,EAAb,CAAd;mBACOH,SAAO,CAACkK,MAAM,CAAN,CAAD,EAAW,CAAC1L,CAAD,CAAX,EAAgB0L,MAAM,CAAN,CAAhB,CAAP,CAAP;;;WAGDtE,aAAaQ,KAAKjG,EAAL,CAAb,EAAuB3B,CAAvB,CAAP;CA/uCD;IAkvCH2Q,QAAQ,SAARA,KAAQ,CAACnI,IAAD,EAAOF,IAAP,EAAgB;QAChB,CAACvI,OAAOuI,IAAP,CAAL,EAAmB;eACR,EAAP;;QAEErB,QAAQlH,OAAOuI,IAAP,CAAd;QACItB,MAAM,CAAV;QACIwK,iBADJ;QAEItK,MAAM,EAFV;QAGIuK,QAAQ,SAARA,KAAQ;eAAcjJ,KAAKgJ,QAAL,EAAeE,UAAf,CAAd;KAHZ;WAIO1K,MAAMC,KAAb,EAAoBD,OAAO,CAA3B,EAA8B;mBACfsB,KAAKtB,GAAL,CAAX;YACI6I,IAAI4B,KAAJ,EAAWvK,GAAX,CAAJ,EAAqB;;;YAGjBjG,IAAJ,CAASuQ,QAAT;;WAEGtK,GAAP;CAlwCD;IAqwCH2J,WAAW,SAAXA,QAAW,CAACrI,IAAD,EAAOxI,CAAP,EAAUsI,IAAV,EAAmB;;QACpBgJ,aAAa/E,UAAU;eAAQ/D,KAAKxI,CAAL,EAAQgB,IAAR,CAAR;KAAV,EAAiCsH,IAAjC,CAAnB;QACIoD,QAAQqB,QAAQuE,aAAa,CAAC,CAAd,GAAkBA,UAAlB,GAA+B,CAAvC,EAA0ChJ,IAA1C,CADZ,CAD0B;WAGnBe,OAAOqC,MAAM,CAAN,CAAP,EAAiBhC,KAAKgC,MAAM,CAAN,CAAL,CAAjB,CAAP;CAxwCD;IA4wCHiG,iBAAiB,SAAjBA,cAAiB,CAACnJ,IAAD,EAAOsF,GAAP,EAAYC,GAAZ;WACb3D,MAAM,UAAC3J,GAAD,EAAMO,IAAN;eAAe6P,SAASrI,IAAT,EAAexH,IAAf,EAAqBP,GAArB,CAAf;KAAN,EAAgDqN,GAAhD,EAAqDC,GAArD,CADa;CA5wCd;IAuxCH6D,UAAU,SAAVA,OAAU,CAACpJ,IAAD,EAAOyG,IAAP,EAAaC,IAAb;WACN9E,MAAM,UAAC3J,GAAD,EAAMuF,CAAN,EAAY;YACJ6L,eAAehC,IAAI;mBAAKrH,KAAKzC,CAAL,EAAQC,CAAR,CAAL;SAAJ,EAAqBvF,GAArB,CAArB;eACO,CAACoR,YAAD,IAAiBpR,IAAIQ,IAAJ,CAAS+E,CAAT,GAAavF,GAA9B,IAAqCA,GAA5C;KAFR,EAGOmH,KAAKqH,IAAL,CAHP,EAGmBC,IAHnB,CADM;CAvxCP;IAqyCH4C,QAAQ,SAARA,KAAQ,CAAC7C,IAAD,EAAOC,IAAP;WACJ7F,OAAO4F,IAAP,EACI9N,SAAO;eAAO,CAACO,SAAS0H,GAAT,EAAc6F,IAAd,CAAR;KAAP,EAAoCC,IAApC,CADJ,CADI;CAryCL;IAgzCH6C,YAAY,SAAZA,SAAY,CAAC9C,IAAD,EAAOC,IAAP;WACR,CAACD,IAAD,IAAS,CAACC,IAAV,IAAmB,CAACD,IAAD,IAAS,CAACC,IAA7B,GAAqC,EAArC,GACI/N,SAAO;eAAOO,SAAS0H,GAAT,EAAc8F,IAAd,CAAP;KAAP,EAAmCD,IAAnC,CAFI;CAhzCT;IA4zCH+C,cAAc,SAAdA,WAAc,CAACxJ,IAAD,EAAOyJ,KAAP,EAAc9E,KAAd;WACV/C,MAAM,UAAC3J,GAAD,EAAMsF,CAAN;eACE8J,IAAI;mBAAKrH,KAAKzC,CAAL,EAAQC,CAAR,CAAL;SAAJ,EAAqBmH,KAArB,KAA+B1M,IAAIQ,IAAJ,CAAS8E,CAAT,GAAatF,GAA5C,IAAmDA,GADrD;KAAN,EAEM,EAFN,EAEUwR,KAFV,CADU;CA5zCX;IAy0CHC,aAAa,SAAbA,UAAa,CAACC,MAAD,EAASC,MAAT,EAAoB;;QACzBD,UAAU,CAACC,MAAf,EAAuB;eACZxK,KAAKuK,MAAL,CAAP;KADJ,MAGK,IAAI,CAACA,MAAD,IAAWC,MAAX,IAAsB,CAACD,MAAD,IAAW,CAACC,MAAtC,EAA+C;eACzC,EAAP;;WAEG7R,SAAO,UAACE,GAAD,EAAM2I,GAAN;eACN,CAAC1H,SAAS0H,GAAT,EAAcgJ,MAAd,CAAD,IAA0B3R,IAAIQ,IAAJ,CAASmI,GAAT,GAAe3I,GAAzC,IAAgDA,GAD1C;KAAP,EAED,EAFC,EAEG0R,MAFH,CAAP;CAh1CD;IA41CHE,aAAa,SAAbA,UAAa,CAACC,IAAD;uCAAUC,MAAV;cAAA;;;WACThS,SAAO,UAACE,GAAD,EAAMgH,GAAN;eAAc4B,OAAO5I,GAAP,EAAYyR,WAAWzK,GAAX,EAAgB6K,IAAhB,CAAZ,CAAd;KAAP,EAAyD,EAAzD,EAA6DC,MAA7D,CADS;CA51CV;;AC3BA,IAEHC,aAAW,SAAXA,QAAW,CAACC,IAAD,EAAOC,IAAP;WAAgBlN,aAAWiN,IAAX,EAAiBC,IAAjB,CAAhB;CAFR;IAIHC,iBAAe,SAAfA,YAAe,CAACF,IAAD,EAAOC,IAAP;WAAgBtI,MAAM,UAAC3J,GAAD,EAAMC,GAAN,EAAc;YAC3CZ,iBAAeY,GAAf,EAAoBgS,IAApB,CAAJ,EAA+B;gBACvBhS,GAAJ,IAAWgS,KAAKhS,GAAL,CAAX;;eAEGD,GAAP;KAJ2B,EAK5B,EAL4B,EAKxBR,KAAKwS,IAAL,CALwB,CAAhB;CAJZ;IAWHG,kBAAgB,SAAhBA,aAAgB,CAACH,IAAD,EAAOC,IAAP;WAAgBtI,MAAM,UAAC3J,GAAD,EAAMC,GAAN,EAAc;YAC5C,CAACZ,iBAAeY,GAAf,EAAoBgS,IAApB,CAAL,EAAgC;gBACxBhS,GAAJ,IAAW+R,KAAK/R,GAAL,CAAX;;eAEGD,GAAP;KAJ4B,EAK7B,EAL6B,EAKzBR,KAAKwS,IAAL,CALyB,CAAhB;CAXb;IAkBHI,kBAAgB,SAAhBA,aAAgB,CAACxS,IAAD;sCAAUC,IAAV;YAAA;;;WAAmB8J,MAAM,UAAC3J,GAAD,EAAMN,GAAN;eACrCqF,aAAW/E,GAAX,EAAgBmS,gBAAczS,GAAd,EAAmBE,IAAnB,CAAhB,CADqC;KAAN,EACY,EADZ,EACgBC,IADhB,CAAnB;CAlBb;;ACJP;;;AAGA,AA4BO,IAUHwC,UAAOX,MAAM2Q,MAAN,CAVJ;IAoBHnT,gBAAawC,MAAM4Q,YAAN,CApBV;IA8BHjT,oBAAiBqC,MAAM6Q,gBAAN,CA9Bd;IAuCH5S,YAASsC,OAAOuQ,QAAP,CAvCN;IAgDHzN,gBAAa9C,OAAOwQ,YAAP,CAhDV;IA0DHV,cAAWrQ,MAAMgR,UAAN,CA1DR;IAoEHR,kBAAexQ,MAAMiR,cAAN,CApEZ;IA8EHR,mBAAgBzQ,MAAMkR,eAAN,CA9Eb;IAwFHR,mBAAgBnQ,OAAO4Q,eAAP,CAxFb;IAiGH1P,YAASzB,MAAMoR,QAAN,CAjGN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/BA,IAUHC,UAAQ,SAARA,KAAQ,CAACC,SAAD,EAAY7K,SAAZ,EAAuB8K,YAAvB,EAAwC;QACxChL,SAASgL,YAAb;WACO,CAACD,UAAU/K,MAAV,CAAR,EAA2B;iBACdE,UAAUF,MAAV,CAAT;;WAEGA,MAAP;CAfD;;ACGA,IAQHiL,UAAQ,SAARA,KAAQ;SAAM;sCAAIrU,IAAJ;UAAA;;;WAAayC,MAAMC,EAAN,EAAUlB,QAAQxB,IAAR,CAAV,CAAb;GAAN;CARL;IAgBHsU,UAAQ,SAARA,KAAQ;SAAM,UAAC7N,CAAD,EAAIC,CAAJ,EAAOE,CAAP;WAAajE,KAAKD,EAAL,EAASkE,CAAT,EAAYF,CAAZ,EAAeD,CAAf,CAAb;GAAN;CAhBL;IAwBH8N,UAAQ,SAARA,KAAQ;SAAM,UAAC9N,CAAD,EAAIC,CAAJ,EAAOE,CAAP,EAAUE,CAAV;WAAgBnE,KAAKD,EAAL,EAASoE,CAAT,EAAYF,CAAZ,EAAeF,CAAf,EAAkBD,CAAlB,CAAhB;GAAN;CAxBL;IAgCH+N,UAAQ,SAARA,KAAQ;SAAM,UAAC/N,CAAD,EAAIC,CAAJ,EAAOE,CAAP,EAAUE,CAAV,EAAaE,CAAb;WAAmBrE,KAAKD,EAAL,EAASsE,CAAT,EAAYF,CAAZ,EAAeF,CAAf,EAAkBF,CAAlB,EAAqBD,CAArB,CAAnB;GAAN;CAhCL;IAwCHgO,SAAO,SAAPA,IAAO;SAAM,UAAC/N,CAAD,EAAID,CAAJ;WAAU9D,KAAKD,EAAL,EAAS+D,CAAT,EAAYC,CAAZ,CAAV;GAAN;CAxCJ;;ACHP;;;;;;;;AAQA,AAGA;;;;;AAKA,IAAMgO,cAAc,SAASA,WAAT,GAAuB,EAA3C;IAEI9R,mBAAiB,+BAFrB;IASI+R,sBAAsB,IAAID,WAAJ,EAT1B;;;;;;;;AAiBA,SAASE,aAAT,CAAwBrU,QAAxB,EAAkC;SACvBA,oBAAoBmU,WAA3B;;;;;;;;;;;AAWJ,SAASG,mBAAT,CAA8BC,KAA9B,EAAqC9U,IAArC,EAA2C;MACnC4H,MAAMhG,IAAI,mBAAW;QACb,CAACgT,cAAcG,OAAd,CAAL,EAA6B;aAASA,OAAP;KAA/B,MACK,IAAItU,OAAOT,IAAP,CAAJ,EAAkB;aAASA,KAAKgV,KAAL,EAAP;;WAClBD,OAAP;GAHE,EAIHD,KAJG,CAAV;SAKOrU,OAAOT,IAAP,IAAekC,OAAO0F,GAAP,EAAY5H,IAAZ,CAAf,GAAmC4H,GAA1C;;;;;;;;;;AAUJ,AAAO,SAASqN,MAAT,CAAiBvS,EAAjB,EAAqC;oCAAbI,WAAa;eAAA;;;SACjCoS,0BAAQjV,UAAU2C,gBAAV,EAA0BF,EAA1B,EAA8BjC,MAAtC,EAA8CiC,EAA9C,SAAqDI,WAArD,EAAP;;;;;;;;;;;AAWJ,AAAO,SAASoS,OAAT,CAAkBlS,YAAlB,EAAgCN,EAAhC,EAAoD;qCAAbO,WAAa;eAAA;;;SAChD,YAAa;uCAATjD,IAAS;UAAA;;;QACZkD,eAAe2R,oBAAoB5R,WAApB,EAAiCjD,IAAjC,CAAnB;QACImV,eAAetT,OAAO+S,aAAP,EAAsB1R,YAAtB,CADnB;QAEIC,cAAe1C,OAAOyC,YAAP,IAAuBzC,OAAO0U,YAAP,CAAvB,IAA+CnS,YAAhD,IAAiE,CAACA,YAFpF;WAGO,CAACG,WAAD,GACHV,MAAMyS,OAAN,EAAehT,OAAO,CAACc,YAAD,EAAe/C,UAAU2C,gBAAV,EAA0BF,EAA1B,CAAf,CAAP,EAAsDQ,YAAtD,CAAf,CADG,GAEHT,MAAMxC,UAAU2C,gBAAV,EAA0BF,EAA1B,CAAN,EAAqCQ,YAArC,CAFJ;GAJJ;;;;;;;;AAeJ,AAAO,IAAIkS,KAAKxU,OAAOyU,MAAP,GAAgBzU,OAAOyU,MAAP,CAAcV,mBAAd,CAAhB,GAAqDA,mBAA9D;IAQHW,UAAU,SAAVA,OAAU;SAAMJ,QAAQ,CAAR,EAAWxS,EAAX,CAAN;CARP;IAgBH6S,UAAU,SAAVA,OAAU;SAAML,QAAQ,CAAR,EAAWxS,EAAX,CAAN;CAhBP;IAwBH8S,UAAU,SAAVA,OAAU;SAAMN,QAAQ,CAAR,EAAWxS,EAAX,CAAN;CAxBP;IAgCH+S,UAAU,SAAVA,OAAU;SAAMP,QAAQ,CAAR,EAAWxS,EAAX,CAAN;CAhCP;;ACzFP;;;;;;;;;;;AAWA,AAAO,IAAMgT,KAAK,SAALA,EAAK;SAAKhV,CAAL;CAAX;;ACTP;;;;;;;;AAQA,AAAO,IAAMiV,UAAU,SAAVA,OAAU;oCAAI3V,IAAJ;QAAA;;;SACf;WAAQyB,YAAY,UAAC5C,KAAD,EAAQ6D,EAAR;aAAeA,GAAG7D,KAAH,CAAf;KAAZ,EAAsC+W,IAAtC,EAA4C5V,IAA5C,CAAR;GADe;CAAhB;;ACVP;;;;;AAKA,AA2BO,IAUHyC,UAAQI,MAAMgT,KAAN,CAVL;IAoBHlT,SAAOS,OAAO0S,IAAP,CApBJ;IA+BH5B,WAAQrR,MAAMkT,OAAN,CA/BL;IAwCH1B,WAAQ,SAARA,QAAQ;SAAMhR,OAAO;sCAAIrD,IAAJ;UAAA;;;WAAayC,QAAMC,EAAN,EAAUlB,QAAQxB,IAAR,CAAV,CAAb;GAAP,CAAN;CAxCL;IAiDHyU,UAAO,SAAPA,OAAO;SAAM5R,MAAMmT,OAAMtT,EAAN,CAAN,CAAN;CAjDJ;IA0DH4R,WAAQ,SAARA,QAAQ;SAAMzR,MAAMoT,QAAOvT,EAAP,CAAN,CAAN;CA1DL;IAmEH6R,WAAQ,SAARA,QAAQ;SAAM1R,MAAMqT,QAAOxT,EAAP,CAAN,CAAN;CAnEL;IA4EH8R,WAAQ,SAARA,QAAQ;SAAM3R,MAAMsT,QAAOzT,EAAP,CAAN,CAAN;CA5EL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChCP;;;;;ACAA;;;;;;AAMA,AAEO,IAEH0T,iBAAiB,SAAjBA,cAAiB;SAAQvT,MAAM,UAACzD,GAAD,EAAMC,CAAN;WAAYA,EAAEb,IAAF,EAAQY,GAAR,CAAZ;GAAN,CAAR;CAFd;IAIHiX,eAAe,SAAfA,YAAe;SAAQxT,MAAM,UAACtD,IAAD,EAAOC,IAAP,EAAaH,CAAb;WAAmBA,EAAEb,IAAF,EAAQe,IAAR,EAAcC,IAAd,CAAnB;GAAN,CAAR;CAJZ;IAMH8W,uBAAuB,SAAvBA,oBAAuB;SAAQlT,OAAO,UAAC/D,CAAD;sCAAOW,IAAP;UAAA;;;WAAgBX,EAAEb,IAAF,WAAWwB,IAAX,CAAhB;GAAP,CAAR;CANpB;;ACRP;;;;;;;AAOA,AASO,IASH4B,QAAMwU,eAAe,KAAf,CATH;IAkBHvU,WAASuU,eAAe,QAAf,CAlBN;IA2BHnV,WAASoV,aAAa,QAAb,CA3BN;IAoCH5U,gBAAc4U,aAAa,aAAb,CApCX;IA8CHvU,YAAUsU,eAAe,SAAf,CA9CP;IAyDHrU,SAAOqU,eAAe,MAAf,CAzDJ;IAmEHpU,UAAQoU,eAAe,OAAf,CAnEL;IA4EHnU,SAAOmU,eAAe,MAAf,CA5EJ;IAqFHzU,SAAO2U,qBAAqB,MAArB,CArFJ;;AChBP;;;;;;;AAOA,AASO,IAWHpU,WAASW,MAAM0T,MAAN,CAXN;IAoBHpU,UAAQU,MAAM2T,KAAN,CApBL;IAsBHpU,aAAWS,MAAM4T,QAAN,CAtBR;IAwBHnU,YAAUO,MAAM6T,OAAN,CAxBP;IA0BHnU,gBAAcM,MAAM8T,WAAN,CA1BX;;AChBP;;;;;;AAMA,AAIA;;;;;;;;AAQA,AAAO,IAAMnU,UAAQK,MAAM+T,KAAN,CAAd;;AClBP;;;;;ACAA;;;;;;;;AAQA,AAEA;AACA,AAyCA;AACA,AAAO,IAeH7M,WAASlH,MAAMgU,MAAN,CAfN;IA2BH5M,eAAa7G,OAAO0T,UAAP,CA3BV;IAqCHtM,cAAYpH,OAAO2T,SAAP,CArCT;IA6CHnV,QAAMiB,MAAM4E,IAAN,CA7CH;IAwDHkD,gBAAc9H,MAAMmU,WAAN,CAxDX;IAkEHjM,gBAAclI,MAAMoU,WAAN,CAlEX;IA4EHnM,UAAQjI,MAAMqU,KAAN,CA5EL;IAsFHxM,UAAQ7H,MAAMsU,KAAN,CAtFL;IA+FHhL,WAAStJ,MAAMuU,MAAN,CA/FN;IAwGH/K,WAASxJ,MAAMwU,MAAN,CAxGN;IAmHH/K,cAAYzJ,MAAMyU,SAAN,CAnHT;IA8HH5K,cAAY7J,MAAM0U,SAAN,CA9HT;IAwIH5K,YAAU9J,MAAM2U,OAAN,CAxIP;IA0IHtL,WAASrJ,MAAM4U,MAAN,CA1IN;IA4IH5K,cAAYX,QA5IT;IA8IHY,UAAQjK,MAAM6U,KAAN,CA9IL;IAwJH3K,YAAUlK,MAAM8U,OAAN,CAxJP;IAiKH1K,cAAYpK,MAAM+U,SAAN,CAjKT;IAyKH1K,gBAAcrK,MAAMgV,WAAN,CAzKX;IAiLH1K,cAAYtK,MAAMiV,SAAN,CAjLT;IAyLHzK,gBAAcxK,MAAMkV,WAAN,CAzLX;IAkMHzK,SAAOzK,MAAMmV,IAAN,CAlMJ;IA2MHzK,SAAO1K,MAAMoV,IAAN,CA3MJ;IAqNHxK,YAAU5K,MAAMqV,OAAN,CArNP;IA8NHxK,cAAY7K,MAAMsV,SAAN,CA9NT;IAwOHxK,cAAY9K,MAAMuV,SAAN,CAxOT;IAiPHtK,iBAAejL,MAAMwV,YAAN,CAjPZ;IA4PHtK,SAAOlL,MAAMyV,IAAN,CA5PJ;IA8PHtK,gBAAcnL,MAAM0V,WAAN,CA9PX;IAsQHtK,OAAKpL,MAAM2V,EAAN,CAtQF;IA8QHtK,SAAOrL,MAAM4V,IAAN,CA9QJ;IAgRH5W,WAASgB,MAAM6V,QAAN,CAhRN;IA2RHvK,cAAYtL,MAAM8V,SAAN,CA3RT;IA6RHvK,SAAOvL,MAAM+V,IAAN,CA7RJ;IA+RHvK,YAAUjL,OAAOyV,OAAP,CA/RP;IAiSHvK,WAASL,IAjSN;IAmSHM,eAAa1L,MAAMiW,UAAN,CAnSV;IAqSHlK,eAAa/L,MAAMkW,UAAN,CArSV;IAuSHlK,cAAYhM,MAAMmW,SAAN,CAvST;IAySHjK,oBAAkBlM,MAAMoW,eAAN,CAzSf;IAoTH/J,YAAUrM,MAAMqW,OAAN,CApTP;IAsTH1J,gBAAc3M,MAAMsW,WAAN,CAtTX;IAiUHzJ,QAAM7M,MAAMuW,GAAN,CAjUH;IAwVHlJ,YAAUrN,MAAMwW,OAAN,CAxVP;IAuWHlJ,aAAW9M,OAAOiW,QAAP,CAvWR;IAqXHC,aAAWjW,OAAO6M,UAAP,CArXR;IAoYHqJ,aAAWjW,OAAO4M,UAAP,CApYR;IAoZHsJ,aAAW1W,OAAO,CAAP,EAAUoN,UAAV,CApZR;IAsZHI,QAAM1N,MAAM6W,GAAN,CAtZH;IAwZHjJ,QAAM5N,MAAM8W,GAAN,CAxZH;IA0ZH3I,UAAQnO,MAAM+W,KAAN,CA1ZL;IA4ZH3I,WAASpO,MAAMgX,MAAN,CA5ZN;IA8ZH3I,UAAQrO,MAAMiX,KAAN,CA9ZL;IAgaH3I,WAAStO,MAAMkX,MAAN,CAhaN;IAkaHzI,WAASzO,MAAMmX,MAAN,CAlaN;IAoaHvI,WAAS5O,MAAMoX,MAAN,CApaN;IAsaHnJ,WAASjO,MAAMqX,MAAN,CAtaN;IAwaHnI,WAASlP,MAAMsX,MAAN,CAxaN;IAubHlI,aAAWpP,MAAMuX,QAAN,CAvbR;IAybH/I,UAAQxO,MAAMwX,KAAN,CAzbL;IA2bH9I,aAAW1O,MAAMyX,QAAN,CA3bR;IA6bHjI,mBAAiBxP,MAAM0X,cAAN,CA7bd;IAucHjI,YAAUzP,MAAM2X,OAAN,CAvcP;IAgdHhI,UAAQ3P,MAAM4X,KAAN,CAhdL;IAydHhI,cAAY5P,MAAM6X,SAAN,CAzdT;IAmeHhI,gBAAc7P,MAAM8X,WAAN,CAneX;IA6eH/H,eAAa/P,MAAM+X,UAAN,CA7eV;IAsfH7H,eAAa3P,OAAOyX,UAAP,CAtfV;;ACrDP;;;;;;AAMA,AAIO,IAQHC,QAAQtY,QAAM,UAAN,CARL;IAgBHuY,QAAQvY,QAAM,UAAN,CAhBL;IAwBHwY,UAAUjQ,cAAY,GAAZ,CAxBP;IAgCHkQ,UAAUlQ,cAAY,IAAZ,CAhCP;IAwCHmQ,aAAa,SAAbA,UAAa;SAAM7Y,GAAG,CAAH,EAAM8Y,WAAN,KAAsB9Y,GAAG+Y,SAAH,CAAa,CAAb,CAA5B;CAxCV;IAgDHC,aAAa,SAAbA,UAAa;SAAMhZ,GAAG,CAAH,EAAMiZ,WAAN,KAAsBjZ,GAAG+Y,SAAH,CAAa,CAAb,CAA5B;CAhDV;IAyDHG,YAAY,SAAZA,SAAY,CAAClZ,EAAD,EAAKmZ,OAAL;SAAiB/T,KAAK4T,UAAL,EAAiBnD,QAASsD,WAAW,WAApB,EAAiCnZ,EAAjC,CAAjB,CAAjB;CAzDT;;ACVP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}