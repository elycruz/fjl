{"version":3,"file":"fjl.js","sources":["../../src/uncurried/_object/_typeOf.js","../../src/uncurried/_object/_utils.js","../../src/uncurried/_jsPlatform/_object.js","../../src/uncurried/_jsPlatform/_array.js","../../src/uncurried/_jsPlatform/_list.js","../../src/uncurried/_jsPlatform/_string.js","../../src/uncurried/_jsPlatform/_function.js","../../src/uncurried/_jsPlatform/_jsPlatform.js","../../src/uncurried/_function/_curry.js","../../src/uncurried/_object/_is.js","../../src/uncurried/_object/_fromNamespace.js","../../src/uncurried/_object/_prop.js","../../src/uncurried/_object/_of.js","../../src/uncurried/_object/_assignDeep.js","../../src/uncurried/_function/_negate.js","../../src/boolean.js","../../src/uncurried/_list/_map.js","../../src/uncurried/_list/_aggregation.js","../../src/uncurried/_list/_utils.js","../../src/uncurried/_list/_list.js","../../src/uncurried/_object/_setTheory.js","../../src/uncurried/_object/_console.js","../../src/uncurried/_object/_errorThrowing.js","../../src/uncurried/_object/_jsonClone.js","../../src/uncurried/_object/_assocList.js","../../src/uncurried/_object/_toArray.js","../../src/uncurried/_object/_object.js","../../src/object.js","../../src/uncurried/_function/_until.js","../../src/uncurried/_function/_flip.js","../../src/uncurried/_function/__curry.js","../../src/uncurried/_function/_id.js","../../src/uncurried/_function/_compose.js","../../src/function.js","../../src/uncurried/_function/_function.js","../../src/utils.js","../../src/jsPlatform/array.js","../../src/jsPlatform/list.js","../../src/jsPlatform/string.js","../../src/jsPlatform.js","../../src/list.js","../../src/string.js","../../src/fjl.js"],"sourcesContent":["/**\r\n * Created by elyde on 12/18/2016.\r\n * @memberOf _object\r\n */\r\nconst _Number = Number.name,\r\n    _NaN = 'NaN',\r\n    _Null = 'Null',\r\n    _Undefined = 'Undefined';\r\n\r\n/**\r\n * Returns the constructor/class/type name of a value.\r\n * @note Returns 'NaN' if value is of type `Number` and value is `isNaN`.\r\n * @note Returns 'Undefined' if value is `undefined`\r\n * @note Returns 'Null' if value is `null`\r\n * For values that have no concrete constructors and/or casters\r\n * (null, NaN, and undefined) we returned normalized names for them ('Null', 'NaN', 'Number')\r\n * @function module:object.typeOf\r\n * @param value {*}\r\n * @returns {string} - Constructor's name or derived name (in the case of `null`, `undefined`, or `NaN` (whose\r\n *  normalized names are 'Null', 'Undefined', 'NaN' respectively).\r\n */\r\nexport function typeOf (value) {\r\n    let retVal;\r\n    if (value === undefined) {\r\n        retVal = _Undefined;\r\n    }\r\n    else if (value === null) {\r\n        retVal = _Null;\r\n    }\r\n    else {\r\n        let constructorName = (value).constructor.name;\r\n        retVal = constructorName === _Number && isNaN(value) ?\r\n            _NaN : constructorName;\r\n    }\r\n    return retVal;\r\n}\r\n","import {typeOf} from './_typeOf';\r\n\r\nexport const\r\n\r\n    fPureTakesOne = name => (arg, f) => f[name](arg),\r\n\r\n    fPureTakes2 = name => (arg1, arg2, f) => f[name](arg1, arg2),\r\n\r\n    fPureTakes3 = name => (arg1, arg2, arg3, f) => f[name](arg1, arg2, arg3),\r\n\r\n    fPureTakes4 = name => (arg1, arg2, arg3, arg4, f) => f[name](arg1, arg2, arg3, arg4),\r\n\r\n    fPureTakes5 = name => (arg1, arg2, arg3, arg4, arg5, f) => f[name](arg1, arg2, arg3, arg4, arg5),\r\n\r\n    fPureTakesOneOrMore = name => (f, ...args) => f[name](...args),\r\n\r\n    fnOrError = (symbolName, f) => {\r\n        if (!f || typeof f !== 'function') {\r\n            throw new Error (`${symbolName} should be a function. ` +\r\n                `Type received: ${typeOf(f)};  Value received: ${f}.`);\r\n        }\r\n        return f;\r\n    };\r\n","/**\r\n * Created by elydelacruz on 9/6/2017.\r\n * Defines some of the platform methods for objects (the ones used within `fjl`) uncurried for use\r\n * throughout the library.  @note Doesn't include all methods for objects just the ones used in\r\n *  the library.\r\n * @todo change all files named '*UnCurried' to '*_'.\r\n */\r\n\r\nimport {fPureTakesOne} from '../_object/_utils';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns whether constructor has derived _object.\r\n     * @function module:_jsPlatform_object._instanceOf\r\n     * @param instanceConstructor {Function} - Constructor.\r\n     * @param instance {*}\r\n     * @instance {*}\r\n     * @returns {Boolean}\r\n     */\r\n    _instanceOf = (instanceConstructor, instance) =>\r\n        instance instanceof instanceConstructor,\r\n\r\n    /**\r\n     * @function module:_jsPlatform_object.hasOwnProperty\r\n     * @param propName {*}\r\n     * @param typeInstance {*}\r\n     * @returns {Boolean}\r\n     */\r\n    _hasOwnProperty = fPureTakesOne('hasOwnProperty'),\r\n\r\n    /**\r\n     * @function module:_jsPlatform_object.length\r\n     * @param x {*}\r\n     * @returns {Number}\r\n     * @throws {Error} - Throws an error if value doesn't have a `length` property (\r\n     *  `null`, `undefined`, {Boolean}, Symbol, et. al.).\r\n     */\r\n    length = x => x.length,\r\n\r\n    /**\r\n     * Gets own enumerable keys of passed in object (`Object.keys`).\r\n     * @function module:_jsPlatform_object.keys\r\n     * @param obj {*}\r\n     * @returns {Array<String>}\r\n     */\r\n    keys = obj => Object.keys(obj),\r\n\r\n    /**\r\n     * Defined as `Object.assign` else is the same thing but shimmed.\r\n     * @function module:_jsPlatform_object._assign\r\n     * @param obj0 {Object}\r\n     * @param objs {...{Object}}\r\n     * @returns {Object}\r\n     */\r\n    _assign = (() => Object.assign ?\r\n            (obj0, ...objs) => Object.assign(obj0, ...objs) :\r\n            (obj0, ...objs) => objs.reduce((topAgg, obj) => {\r\n                return keys(obj).reduce((agg, key) => {\r\n                    agg[key] = obj[key];\r\n                    return agg;\r\n                }, topAgg);\r\n            }, obj0)\r\n        )();\r\n","/**\r\n * Created by elyde on 7/20/2017.\r\n * Functional versions of common array methods (`map`, `filter`, etc.) (un-curried);\r\n * @module _jsPlatform_arrayOps\r\n * @private\r\n * @todo updated doc blocks to list correct/updated module name.\r\n */\r\n\r\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from '../_object/_utils';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Array.prototype.reverse generator (generates a _function that calls the prototype version or a\r\n     * shimmed version if it doesn't exist).\r\n     * @returns {Function}\r\n     */\r\n    defineReverse = () =>\r\n        Array.prototype.reverse ? x => x.reverse() :\r\n            x => x.reduceRight((agg, item) => {\r\n                agg.push(item);\r\n                return agg;\r\n            }, []),\r\n\r\n    /**\r\n     * Maps a _function to functor (_list etc.).\r\n     * @function module:_jsPlatform_array.map\r\n     * @param fn {Function}\r\n     * @param functor {Array|{map: {Function}}}\r\n     * @returns {Array|{map: {Function}}}\r\n     */\r\n    map = fPureTakesOne('map'),\r\n\r\n    /**\r\n     * Filters a functor (_list etc.) with passed in _function.\r\n     * @function module:_jsPlatform_array.filter\r\n     * @param fn {Function}\r\n     * @param functor {Array|{filter: {Function}}}\r\n     * @returns {Array|{filter: {Function}}}\r\n     */\r\n    filter = fPureTakesOne('filter'),\r\n\r\n    /**\r\n     * Reduces a foldable (_list etc.) with passed in _function.\r\n     * @function module:_jsPlatform_array.reduce\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduce: {Function}}}\r\n     * @returns {Array|{reduce: {Function}}}\r\n     */\r\n    reduce = fPureTakes2('reduce'),\r\n\r\n    /**\r\n     * Reduces a foldable (_list etc.) from the right with passed in _function.\r\n     * @function module:_jsPlatform_array.reduceRight\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduceRight: {Function}}}\r\n     * @returns {Array|{reduceRight: {Function}}}\r\n     */\r\n    reduceRight = fPureTakes2('reduceRight'),\r\n\r\n    /**\r\n     * For each on functor (Array|Object|etc.).\r\n     * @param fn {Function}\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type of object you pass in unless it doesn't have a `forEach` method.\r\n     * @throws {Error} - When passed in functor doesn't have a `forEach` method.\r\n     */\r\n    forEach = fPureTakesOne('forEach'),\r\n\r\n    /**\r\n     * Returns `true` if `fn` (predicate) returns true for at least one item\r\n     * in functor else returns `false`.\r\n     * @param fn {Function} - Predicate.\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have a `some` method.\r\n     */\r\n    some = fPureTakesOne('some'),\r\n\r\n    /**\r\n     * Returns `true` if `fn` (predicate) returns true for all items in functor else returns `false`.\r\n     * @param fn {Function} - Predicate.\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have an `every` method.\r\n     */\r\n    every = fPureTakesOne('every'),\r\n\r\n    /**\r\n     * Array.prototype.join\r\n     * @function module:listPrelude.join\r\n     * @param separator {String|RegExp}\r\n     * @param arr {Array}\r\n     * @returns {String}\r\n     */\r\n    join = fPureTakesOne('join'),\r\n\r\n    /**\r\n     * Same as Array.prototype.push\r\n     * @param item {*}\r\n     * @param arr {Array}\r\n     * @returns {Number}\r\n     */\r\n    push = fPureTakesOneOrMore('push'),\r\n\r\n    /**\r\n     * Reverses an _list (shimmed if not exists).\r\n     * @function module:listPrelude.reverse\r\n     * @return {Array}\r\n     */\r\n    reverse = defineReverse();\r\n","/**\r\n *  List operations that overlap (apart from globally overlapping props and functions like `length`)\r\n *      on both strings and arrays.\r\n */\r\n\r\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from '../_object/_utils';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Concats/appends all functors onto the end of first functor.\r\n     * Note:  functors passed in after the first one must be of the same type.\r\n     * @function module:_jsPlatform_list.concat\r\n     * @param functor {Array|Object|*}\r\n     * @param ...functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have an `every` method.\r\n     */\r\n    concat = fPureTakesOneOrMore('concat'),\r\n\r\n    /**\r\n     * Same as Array.prototype.slice\r\n     * @function module:_jsPlatform_list.slice\r\n     * @param separator {String|RegExp}\r\n     * @param arr{Array}\r\n     * @returns {Array}\r\n     */\r\n    slice = fPureTakes2('slice'),\r\n\r\n    /**\r\n     * `Array.prototype.includes` or shim.\r\n     * @function module:_jsPlatform_list.includes\r\n     * @param value {*}\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    includes = (() => 'includes' in Array.prototype ?\r\n            fPureTakesOne('includes') :\r\n            (value, xs) => xs.indexOf(value) > -1)(),\r\n\r\n    /**\r\n     * Searches list/list-like for given element `x`.\r\n     * @function module:_jsPlatform_list.indexOf\r\n     * @param x {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like to look in.\r\n     * @returns {Number} - `-1` if element not found else index at which it is found.\r\n     */\r\n    indexOf = fPureTakesOne('indexOf'),\r\n\r\n    /**\r\n     * Last index of (`Array.prototype.lastIndexOf`).\r\n     * @function module:_jsPlatform_list.lastIndexOf\r\n     * @param x {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like to look in.\r\n     * @returns {Number} - `-1` if element not found else index at which it is found.\r\n     */\r\n    lastIndexOf = fPureTakesOne('lastIndexOf')\r\n\r\n;\r\n","/**\r\n * Created by elydelacruz on 9/6/2017.\r\n */\r\n\r\nimport {fPureTakesOne} from '../_object/_utils';\r\n\r\n/**\r\n * Functional version of `String.prototype.split`.\r\n * @function module:_string.split\r\n * @param separator {String|RegExp}\r\n * @param str {String}\r\n * @returns {Array}\r\n */\r\nexport const split = fPureTakesOne('split');\r\n","/**\r\n * Created by elydelacruz on 9/7/2017.\r\n * @module _jsPlatform_function\r\n * @private\r\n */\r\nexport const\r\n\r\n    /**\r\n     * Functional `apply` function (takes no context).\r\n     * @function module:_jsPlatform_function.apply\r\n     * @param fn {Function}\r\n     * @param args {Array|*}\r\n     * @returns {*}\r\n     */\r\n    apply = (fn, args) => fn.apply(null, args),\r\n\r\n    /**\r\n     * Functional `call` function (takes no context).\r\n     * @function module:_jsPlatform_function.call\r\n     * @param fn {Function}\r\n     * @param args {...*}\r\n     * @returns {*}\r\n     */\r\n    call = (fn, ...args) => apply(fn, args);\r\n","/**\r\n * @module jsPlatform_\r\n * @private\r\n */\r\nexport * from './_object';\r\nexport * from './_array';\r\nexport * from './_list';\r\nexport * from './_string';\r\nexport * from './_function';\r\n","/**\r\n * @author elydelacruz\r\n * @created 12/6/2016.\r\n * @memberOf _function\r\n * @description \"Curry strict\" and \"curry arbitrarily\" functions (`curry`, `curryN`).\r\n */\r\nimport {apply, length, concat} from '../_jsPlatform/_jsPlatform';\r\nimport {fnOrError} from '../_object/_utils';\r\n\r\nconst notFnErrPrefix = '`fn` in `curry(fn, ...args)`';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Curries a function based on it's defined arity (argument's arrayOps expected length).\r\n     * @function module:_function.curry\r\n     * @param fn {Function}\r\n     * @param argsToCurry {...*}\r\n     * @returns {Function}\r\n     */\r\n    curry = (fn, ...argsToCurry) => curryN(fnOrError(notFnErrPrefix, fn).length, fn, ...argsToCurry),\r\n\r\n    /**\r\n     * Curries a function up to a given arity.\r\n     * @function module:_function.curryN\r\n     * @param executeArity {Number}\r\n     * @param fn {Function}\r\n     * @param curriedArgs {...*}\r\n     * @returns {Function}\r\n     */\r\n    curryN = (executeArity, fn, ...curriedArgs) => {\r\n        return (...args) => {\r\n            let concatedArgs = concat(curriedArgs, args),\r\n                canBeCalled = (length(concatedArgs) >= executeArity) || !executeArity;\r\n            return !canBeCalled ? apply(curryN, concat([executeArity, fnOrError(notFnErrPrefix, fn)], concatedArgs)) :\r\n                apply(fnOrError(notFnErrPrefix, fn), concatedArgs);\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Curries a _function up to an arity of 2 (won't call _function until 2 or more args).\r\n     * @function module:_function.curry2\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry2 = fn => curryN(2, fn),\r\n\r\n    /**\r\n     * Curries a _function up to an arity of 3 (won't call _function until 3 or more args).\r\n     * @function module:_function.curry3\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry3 = fn => curryN(3, fn),\r\n\r\n    /**\r\n     * Curries a _function up to an arity of 4 (won't call _function until 4 or more args).\r\n     * @function module:_function.curry4\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry4 = fn => curryN(4, fn),\r\n\r\n    /**\r\n     * Curries a _function up to an arity of 5 (won't call _function until 5 or more args).\r\n     * @function module:_function.curry5\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry5 = fn => curryN(5, fn);\r\n","/**\r\n * Created by elyde on 12/18/2016.\r\n * @memberOf _object\r\n */\r\n\r\nimport {typeOf} from './_typeOf';\r\nimport {_instanceOf, length, keys, _hasOwnProperty} from '../_jsPlatform/_object';\r\n\r\nlet _String = String.name,\r\n    _Number = Number.name,\r\n    _Object = Object.name,\r\n    _Boolean = Boolean.name,\r\n    _Function = Function.name,\r\n    _Array = Array.name,\r\n    _Symbol = 'Symbol',\r\n    _Map = 'Map',\r\n    _Set = 'Set',\r\n    _WeakMap = 'WeakMap',\r\n    _WeakSet = 'WeakSet',\r\n    _Null = 'Null',\r\n    _Undefined = 'Undefined';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns whether a value is a _function or not.\r\n     * @function module:object.isFunction\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isFunction = value => _instanceOf(Function, value),\r\n\r\n    /**\r\n     * Type checker.  Note** The `Type` passed in, if a constructor, should\r\n     * be a named constructor/_function-instance;  E.g.,\r\n     * ```\r\n     *  _function SomeName () {} // or\r\n     *  var SomeName = _function SomeName () {} // or\r\n     *  class SomeName {}\r\n     * ```\r\n     * @function module:object._isType\r\n     * @param type {Function|ObjectConstructor|String} - Constructor or constructor name\r\n     * @param obj {*}\r\n     * @return {Boolean}\r\n     */\r\n    _isType = (type, obj) => typeOf(obj) === (isFunction(type) ? type.name : type),\r\n\r\n    /**\r\n     * Checks if `value` is an es2015 `class`.\r\n     * @function module:object.isClass\r\n     * @param x {*}\r\n     * @returns {boolean}\r\n     */\r\n    isClass = x => x && /^\\s{0,3}class\\s{1,3}/.test((x + '').substr(0, 10)),\r\n\r\n    /**\r\n     * Returns a boolean depicting whether a value is callable or not.\r\n     * @function module:object.isCallable\r\n     * @tentative\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isCallable = x => isFunction(x) && !isClass(x),\r\n\r\n    /**\r\n     * Checks if value is an array (same as `Array.isArray`).\r\n     * @function module:object.isArray\r\n     * @param value {*}\r\n     * @returns {boolean}\r\n     */\r\n    {isArray} = Array,\r\n\r\n    /**\r\n     * Checks whether value is an object or not.\r\n     * @function module:object.isObject\r\n     * @param value\r\n     * @returns {Boolean}\r\n     */\r\n    isObject = value => _isType(_Object, value),\r\n\r\n    /**\r\n     * Checks if value is a boolean.\r\n     * @function module:object.isBoolean\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isBoolean = value => _isType(_Boolean, value),\r\n\r\n    /**\r\n     * Checks if value is a valid number (also checks if isNaN so that you don't have to).\r\n     * @function module:object.isNumber\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isNumber = value => _isType(_Number, value),\r\n\r\n    /**\r\n     * Checks whether value is a string or not.\r\n     * @function module:object.isString\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isString = value => _isType(_String, value),\r\n\r\n    /**\r\n     * Checks whether value is of `Map` or not.\r\n     * @function module:object.isMap\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isMap = value => _isType(_Map, value),\r\n\r\n    /**\r\n     * Checks whether value is of `Set` or not.\r\n     * @function module:object.isSet\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isSet = value => _isType(_Set, value),\r\n\r\n    /**\r\n     * Checks whether value is of `WeakMap` or not.\r\n     * @function module:object.isWeakMap\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isWeakMap = value => _isType(_WeakMap, value),\r\n\r\n    /**\r\n     * Checks whether value is of `WeakSet` or not.\r\n     * @function module:object.isWeakSet\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isWeakSet = value => _isType(_WeakSet, value),\r\n\r\n    /**\r\n     * Checks if value is undefined.\r\n     * @function module:object.isUndefined\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isUndefined = value => _isType(_Undefined, value),\r\n\r\n    /**\r\n     * Checks if value is null.\r\n     * @function module:object.isNull\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isNull = value => _isType(_Null, value),\r\n\r\n    /**\r\n     * Checks if value is a `Symbol`.\r\n     * @function module:object.isSymbol\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isSymbol = value => _isType(_Symbol, value),\r\n\r\n    /**\r\n     * Checks if given `x` is set and of one of\r\n     *  [String, Boolean, Number, Symbol] (null and undefined are immutable\r\n     *  but are not \"usable\" (usually not what we want to operate on).\r\n     * @function module:object.isUsableImmutablePrimitive\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isUsableImmutablePrimitive = x => {\r\n        const typeOfX = typeOf(x);\r\n        return isset(x) &&\r\n            [_String, _Number, _Boolean, _Symbol]\r\n                .some(Type => Type === typeOfX);\r\n    },\r\n\r\n    /**\r\n     * Checks if !length.\r\n     * @function module:object.isEmptyList\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyList = x => !length(x),\r\n\r\n    /**\r\n     * Checks if object has own properties/enumerable-props or not.\r\n     * @function module:object.isEmptyObject\r\n     * @param obj {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyObject = obj => isEmptyList(keys(obj)),\r\n\r\n    /**\r\n     * Checks if collection is empty or not (Map, WeakMap, WeakSet, Set etc.).\r\n     * @function module:object.isEmptyCollection\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyCollection = x => x.size === 0,\r\n\r\n    /**\r\n     * Checks to see if passed in value is empty;  I.e.,\r\n     *  check for one of '', 0, `null`, `undefined`, `false`, empty array, empty object, empty function (zero arity),\r\n     *  or empty collection (es6 Map, Set, WeakMap, or WeakSet etc. (`!value.size`);\r\n     * @function module:object.isEmpty\r\n     * @param value {*} - Value to check.\r\n     * @returns {Boolean}\r\n     */\r\n    isEmpty = value => {\r\n        let retVal;\r\n        if (!value) { // if '', 0, `null`, `undefined`, or `false` then is empty\r\n            retVal = true;\r\n        }\r\n\r\n        const typeOfValue = typeOf(value);\r\n        if (typeOfValue === _Array || typeOfValue === _Function) {\r\n            retVal = isEmptyList(value);\r\n        }\r\n        else if (typeOfValue === _Number) {\r\n            retVal = false;\r\n        }\r\n        else if (typeOfValue === _Object) {\r\n            retVal = isEmptyObject(value);\r\n        }\r\n        else if (_hasOwnProperty('size', value) && isNumber(value.size)) {\r\n            retVal = isEmptyCollection(value);\r\n        }\r\n        else {\r\n            retVal = !value;\r\n        }\r\n        return retVal;\r\n    },\r\n\r\n    /**\r\n     * Returns whether passed in values is defined and not null or not.\r\n     * @function module:object.isset\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isset = x => x !== null && x !== undefined;\r\n","import {isset} from './_is';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Gives you value at key/namespace-key;  E.g.,\r\n     * ```\r\n     *   _fromNamespace('all.your.base', {all: {your: {base: 99}}}) === 99\r\n     * ```\r\n     * @function module:object._fromNamespace\r\n     * @param nsString {String}\r\n     * @param obj {*}\r\n     * @returns {*}\r\n     */\r\n    _fromNamespace = (nsString, obj) => {\r\n        if (!obj) { return obj; }\r\n        if (nsString.indexOf('.') === -1) {\r\n            return obj[nsString];\r\n        }\r\n        const parts = nsString.split('.'),\r\n            limit = parts.length;\r\n        let ind = 0,\r\n            parent = obj;\r\n        for (; ind < limit; ind += 1) {\r\n            const node = parent[parts[ind]];\r\n            if (!isset(node)) {\r\n                return node;\r\n            }\r\n            parent = node;\r\n        }\r\n        return parent;\r\n    }\r\n;\r\n","/**\r\n * @memberOf _object\r\n */\r\n\r\nimport {isset} from './_is';\r\n\r\n/**\r\n * Returns property value if found; Else `undefined`.\r\n * @note This method is null/undefined safe (will not throw on `null` or `undefined`).\r\n * @function module:object._prop\r\n * @param name {String} - Key to search on `obj`\r\n * @param obj {Object} - Object to search `name` on.\r\n * @returns {*}\r\n */\r\nexport const _prop = (name, obj) => isset(obj) ? obj[name] : undefined;\r\n","import {isFunction, isset} from './_is';\r\nimport {_hasOwnProperty} from '../_jsPlatform/_object';\r\nimport {apply} from '../_jsPlatform/_function';\r\nimport {typeOf} from './_typeOf';\r\n\r\n/**\r\n * Checks if given `x` is set and of one of\r\n *  [String, Boolean, Number, or Symbol] (null and undefined are immutable\r\n *   but are not \"usable\" or 'not what we usually want to operate on'.\r\n * @private\r\n * @param x {*}\r\n * @returns {Boolean}\r\n */\r\nfunction isUsableImmutablePrimitive (x) {\r\n    const typeOfX = typeOf(x);\r\n    return isset(x) &&\r\n        [String.name, Number.name, Boolean.name, Symbol.name]\r\n            .some(Type => Type === typeOfX);\r\n}\r\n\r\n/**\r\n * Creates a value `of` given type;  Checks for one of the following construction strategies (in order listed):\r\n * ```\r\n * // - If exists `(value).constructor.of` uses this.\r\n * // - If value is of one String, Boolean, Symbol, or Number types calls it's\r\n * //      constructor as a function (in cast form;  E.g., `constructor(...args)` )\r\n * // - Else if constructor is a function, thus far, then calls constructor using\r\n * //      the `new` keyword (with any passed in args).\r\n * ```\r\n * @function module:object.of\r\n * @param x {*} - Value to derive returned value's type from.\r\n * @param [args] {...*} - Any args to pass in to matched construction strategy.\r\n * @returns {*|undefined} - New value of given value's type else `undefined`.\r\n */\r\nexport const of = (x, ...args) => {\r\n    if (!isset(x)) { return undefined; }\r\n    const constructor = x.constructor;\r\n    if (_hasOwnProperty('of', constructor)) {\r\n        return apply(constructor.of, args);\r\n    }\r\n    else if (isUsableImmutablePrimitive(x)) {\r\n        return apply(constructor, args);\r\n    }\r\n    else if (isFunction(constructor)) {\r\n        return new constructor(...args);\r\n    }\r\n    return undefined;\r\n};\r\n","\r\nimport {isObject} from './_is';\r\n\r\nimport {keys, _hasOwnProperty} from '../_jsPlatform/_object';\r\n\r\nexport const\r\n    /**\r\n     * Merges all objects down into one.\r\n     * @function module:object.assignDeep\r\n     * @param obj0 {Object}\r\n     * @param objs {...{Object}}\r\n     * @returns {Object}\r\n     */\r\n    _assignDeep = (obj0, ...objs) =>\r\n        objs.reduce((topAgg, obj) =>\r\n            !obj ? topAgg : keys(obj).reduce((agg, key) => {\r\n                let propDescription = Object.getOwnPropertyDescriptor(agg, key);\r\n                // If property is not writable move to next item in collection\r\n                if (_hasOwnProperty(key, agg) && propDescription &&\r\n                    !(propDescription.get && propDescription.set) &&\r\n                    !propDescription.writable) {\r\n                    return agg;\r\n                }\r\n                if (isObject(agg[key]) && isObject(obj[key])) {\r\n                    _assignDeep(agg[key], obj[key]);\r\n                }\r\n                else { agg[key] = obj[key]; }\r\n                return agg;\r\n            }, topAgg)\r\n        , obj0);\r\n","/**\r\n * @memberOf _function\r\n */\r\n\r\nimport {apply} from '../_jsPlatform/_function';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Takes a function that takes two parameters and returns a negated version of given\r\n     * function.\r\n     * @function module:_negate.negateF\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateF = fn => (a, b) => !fn(a, b),\r\n\r\n    /**\r\n     * Takes a function that takes three parameters and returns a\r\n     * negated version of given function.\r\n     * @function module:_negate.negateF3\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateF3 = fn => (a, b, c) => !fn(a, b, c),\r\n\r\n    /**\r\n     * Takes a function that takes four parameters and returns a\r\n     * negated version of given function.\r\n     * @function module:_negate.negateF4\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateF4 = fn => (a, b, c, d) => !fn(a, b, c, d),\r\n\r\n    /**\r\n     * Takes a function that takes four parameters and returns a\r\n     * negated version of given function.\r\n     * @function module:_negate.negateF5\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateF5 = fn => (a, b, c, d, e) => !fn(a, b, c, d, e),\r\n\r\n    /**\r\n     * Negates a javascript-'generic' predicate; `Function<element, index, list>`.\r\n     * @function module:_function.negateP\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateP = negateF3,\r\n\r\n    /**\r\n     * Returns a new function which is the dual of `fn` (or the negated version of `fn`).\r\n     * @function module:_function.negateFMany\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateFMany = fn => (...args) => !apply(fn, args);\r\n","/**\r\n * Created by elyde on 7/15/2017.\r\n * @module boolean\r\n */\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns whether `value` is 'truthy' or not\r\n     * @function module:boolean.isTruthy\r\n     * @param value\r\n     * @returns {Boolean}\r\n     */\r\n    isTruthy = value => !!value,\r\n\r\n    /**\r\n     * Returns whether `value` is 'falsy' or not\r\n     * @function module:boolean.isFalsy\r\n     * @param value\r\n     * @returns {Boolean}\r\n     */\r\n    isFalsy = value => !value,\r\n\r\n    /**\r\n     * Returns `true`.\r\n     * @function module:boolean.alwaysTrue\r\n     * @returns {Boolean}\r\n     */\r\n    alwaysTrue = () => true,\r\n\r\n    /**\r\n     * Returns `false`.\r\n     * @function module:boolean.alwaysFalse\r\n     * @returns {Boolean}\r\n     */\r\n    alwaysFalse = () => false;\r\n","import {length} from '../_jsPlatform/_object';\r\n\r\n/**\r\n * @function module:_list.map\r\n * @param fn {Function} - Function to map on array.\r\n * @param xs {Array}\r\n * @returns {Array}\r\n */\r\nexport default function _map (fn, xs) {\r\n    let ind = 0,\r\n        limit = length(xs),\r\n        out = [];\r\n    if (!limit) { return out; }\r\n    while (ind < limit) {\r\n        out.push(fn(xs[ind], ind, xs));\r\n        ind += 1;\r\n    }\r\n    return out;\r\n}\r\n","import {typeOf} from '../_object/_object';\r\n\r\nexport const\r\n\r\n    aggregateStr = (agg, item) => agg + item,\r\n\r\n    aggregateArr = (agg, item) => {\r\n        agg.push(item);\r\n        return agg;\r\n    },\r\n\r\n    aggregateObj = (agg, item, ind) => {\r\n        agg[ind] = item;\r\n        return agg;\r\n    },\r\n\r\n    aggregatorByType = x => {\r\n        switch (typeOf(x)) {\r\n            case 'String': return aggregateStr;\r\n            case 'Array': return aggregateArr;\r\n            case 'Object':\r\n            default: return aggregateObj;\r\n        }\r\n    };\r\n","/**\r\n * List operator utils module.\r\n * @module _listOpUtils\r\n * @private\r\n */\r\nimport {apply}              from '../_jsPlatform/_function';  // un-curried version\r\nimport {slice}              from '../_jsPlatform/_list';      // un-curried version good for both strings and arrays\r\nimport {length}             from '../_jsPlatform/_object';\r\nimport {alwaysFalse}        from '../../boolean';\r\nimport _map                 from './_map';\r\n\r\nexport * from './_aggregation';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns a slice of the given list from `startInd` to the end of the list.\r\n     * @function module:_listUtils.sliceFrom\r\n     * @param startInd {Number}\r\n     * @param arr {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    sliceFrom = (startInd, arr) => slice(startInd, undefined, arr),\r\n\r\n    /**\r\n     * Slices from index `0` to given index.\r\n     * @function module:_listUtils.sliceTo\r\n     * @param toInd {Number}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    sliceTo = (toInd, xs) => slice(0, toInd, xs),\r\n\r\n    /**\r\n     * Slices a copy of list.\r\n     * @function _listOpUtils.sliceFrom\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    copy = xs => sliceFrom(0, xs),\r\n\r\n    /**\r\n     * Slices a copy of list.\r\n     * @function _listOpUtils.sliceCopy\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    sliceCopy = copy,\r\n\r\n    /**\r\n     * Generic 'ascending order' ordering function (use by the likes of `list.sort` etc.)\r\n     * @function module:_listUtils.genericAscOrdering\r\n     * @param a {*}\r\n     * @param b {*}\r\n     * @returns {number}\r\n     */\r\n    genericAscOrdering = (a, b) => {\r\n        if (a > b) { return 1; }\r\n        else if (a < b) { return -1; }\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * Returns length of all passed lists in list.\r\n     * @function module:_listUtils.lengths\r\n     * @param lists ...{Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    lengths = (...lists) => length(lists) ? _map(length, lists) : [],\r\n\r\n    /**\r\n     * @function module:_listUtils.lengthsToSmallest\r\n     * @param lists {...(Array|String|*)}\r\n     * @returns {Array|String|*}\r\n     */\r\n    lengthsToSmallest = (...lists) => {\r\n        const listLengths = apply(lengths, lists),\r\n            smallLen = Math.min.apply(Math, listLengths);\r\n        return _map((list, ind) => listLengths[ind] > smallLen ?\r\n            sliceTo(smallLen, list) : copy(list), lists);\r\n    },\r\n\r\n    /**\r\n     * Reduces until predicate.\r\n     * @param pred\r\n     * @param op\r\n     * @param agg\r\n     * @param arr\r\n     * @returns {*}\r\n     */\r\n    reduceUntil = (pred, op, agg, arr) => {\r\n        const limit = length(arr);\r\n        if (!limit) { return agg; }\r\n        let ind = 0,\r\n            result = agg;\r\n        for (; ind < limit; ind++) {\r\n            if (pred(arr[ind], ind, arr)) { break; }\r\n            result = op(result, arr[ind], ind, arr);\r\n        }\r\n        return result;\r\n    },\r\n\r\n    /**\r\n     * Reduces until predicate (from the right).\r\n     * @param pred\r\n     * @param op\r\n     * @param agg\r\n     * @param arr\r\n     * @returns {*}\r\n     */\r\n    reduceRightUntil = (pred, op, agg, arr) => {\r\n        const limit = length(arr);\r\n        if (!limit) { return agg; }\r\n        let ind = limit - 1,\r\n            result = agg;\r\n        for (; ind >= 0; ind--) {\r\n            if (pred(arr[ind], ind, arr)) { break; }\r\n            result = op(result, arr[ind], ind, arr);\r\n        }\r\n        return result;\r\n    },\r\n\r\n    reduce = (operation, agg, arr) =>\r\n        reduceUntil(\r\n            alwaysFalse,            // until-predicate\r\n            operation,              // operation\r\n            agg,                    // aggregator\r\n            arr),                   // list\r\n\r\n    reduceRight = (operation, agg, arr) =>\r\n        reduceRightUntil(\r\n            alwaysFalse,            // until-predicate\r\n            operation,              // operation\r\n            agg,                    // aggregator\r\n            arr),                   // list\r\n\r\n    /**\r\n     * Gets last index of a list/list-like (Array|String|Function etc.).\r\n     * @function module:_listOpUtilslastIndex\r\n     * @param x {Array|String|*} - list like or list.\r\n     * @returns {Number} - `-1` if no element found.\r\n     */\r\n    lastIndex = x => { const len = length(x); return len ? len - 1 : 0; },\r\n\r\n    /**\r\n     * Finds index in string or list.\r\n     * @function module:_listOpUtilsfindIndexWhere\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    findIndexWhere = (pred, arr) => {\r\n        let ind = -1,\r\n            predicateFulfilled = false;\r\n        const limit = length(arr);\r\n        while (ind < limit && !predicateFulfilled) {\r\n            predicateFulfilled = pred(arr[++ind], ind, arr);\r\n        }\r\n        return ind;\r\n    },\r\n\r\n    /**\r\n     * Finds index in list from right to left.\r\n     * @function module:_listOpUtilsfindIndexWhereRight\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    findIndexWhereRight = (pred, arr) => {\r\n        const limit = length(arr);\r\n        let ind = limit,\r\n            predicateFulfilled = false;\r\n        for (; ind >= 0 && !predicateFulfilled; --ind) {\r\n            predicateFulfilled = pred(arr[ind], ind, arr);\r\n        }\r\n        return ind;\r\n    },\r\n\r\n    /**\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {Array|undefined}\r\n     */\r\n    findIndicesWhere = (pred, xs) => {\r\n        if (!xs || !xs.length) { return undefined; }\r\n        const limit = length(xs);\r\n        let ind = 0,\r\n            out = [];\r\n        for (; ind < limit; ind++) {\r\n            if (pred(xs[ind], ind, xs)) { out.push(ind); }\r\n        }\r\n        return out.length ? out : undefined;\r\n    },\r\n\r\n    /**\r\n     * @function module:_listOpUtilsfind\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    findWhere = (pred, xs) => {\r\n        let ind = 0,\r\n            limit = length(xs);\r\n        if (!limit) { return; }\r\n        for (; ind < limit; ind++) {\r\n            let elm = xs[ind];\r\n            if (pred(elm, ind, xs)) { return elm; }\r\n        }\r\n    }\r\n\r\n;\r\n","/**\r\n * List operations module (un-curried version).\r\n * @module _list\r\n * @private\r\n */\r\nimport {\r\n    concat as listAppend,\r\n    indexOf, slice, includes\r\n}\r\n                            from '../_jsPlatform/_list';\r\n\r\nimport {apply}              from '../_jsPlatform/_function';\r\nimport {negateP, negateF}   from '../_function/_negate';\r\nimport {isTruthy, isFalsy}  from '../../boolean';\r\nimport {_prop, length}       from '../_object/_object';\r\nimport _map                 from './_map';\r\n\r\nimport {\r\n    sliceFrom, sliceTo, lengths,\r\n    lengthsToSmallest, aggregateArr,\r\n    reduceUntil, reduce, reduceRight, lastIndex,\r\n    findIndexWhere, findIndexWhereRight, findIndicesWhere,\r\n    findWhere, copy, genericAscOrdering\r\n}\r\n    from './_utils';\r\n\r\nexport {_map};\r\n\r\nexport const\r\n\r\n    /**\r\n     * Append two lists, i.e.,\r\n     * ```\r\n     * append([x1, ..., xm], [y1, ..., yn]) // outputs: [x1, ..., xm, y1, ..., yn]\r\n     * append([x1, ..., xm], [y1, ...]) // outputs: [x1, ..., xm, y1, ...]\r\n     * ```\r\n     * If the first list is not finite, the result is the first list.\r\n     * @haskellType `append :: List a => a -> a -> a`\r\n     * @function module:_list._append\r\n     * @param xs1 {Array} - list or list like.\r\n     * @param xs2 {Array} - list or list like.\r\n     * @returns {Array} - Same type as list like passed in.\r\n     */\r\n    _append = listAppend,\r\n\r\n    /**\r\n     * Append two or more lists, i.e., same as `_append` but for two ore more lists.\r\n     * @haskellType `appendMany :: List a => a -> [a] -> a\r\n     * @note In `@haskellType` we wrote `[a]` only to keep the haskell type valid though note in javascript\r\n     *  this is actually different since the function converts the zero ore more parameters into an array containing such for us.\r\n     * @function module:_list._appendMany\r\n     * @param args ...{Array} - Lists or lists likes.\r\n     * @returns {Array} - Same type as first list or list like passed in.\r\n     */\r\n    _appendMany = (...args) => {\r\n        if (length(args)) { return apply(listAppend, args); }\r\n        throw new Error('`_appendMany` requires at least one arg.');\r\n    },\r\n\r\n    /**\r\n     * Returns head of list (first item of list).\r\n     * @haskellType `head :: [a] -> a`\r\n     * @function module:_list._head\r\n     * @param x {Array|String}\r\n     * @returns {*} - First item from list\r\n     */\r\n    _head = x => x[0],\r\n\r\n    /**\r\n     * Returns last item of list.\r\n     * @haskellType `last :: [a] -> a`\r\n     * @function module:_list._last\r\n     * @param xs {Array|String}\r\n     * @returns {*}\r\n     */\r\n    _last = xs => xs[lastIndex(xs)],\r\n\r\n    /**\r\n     * Returns tail part of list (everything after the first item as new list).\r\n     * @haskelType `tail :: [a] -> [a]`\r\n     * @function module:_list._tail\r\n     * @param xs {Array}\r\n     * @returns {Array}\r\n     */\r\n    _tail = xs => sliceFrom(1, xs),\r\n\r\n    /**\r\n     * Returns everything except last item of list as new list.\r\n     * @haskellType `init :: [a] -> [a]`\r\n     * @function module:_list._init\r\n     * @param xs {Array|String}\r\n     * @returns {Array|String}\r\n     */\r\n    _init = xs => sliceTo(lastIndex(xs), xs),\r\n\r\n    /**\r\n     * Returns `head` and `tail` of passed in list/string in a tuple.\r\n     * @haskellType `uncons :: [a] -> Maybe (a, [a])`\r\n     * @function module:_list._uncons\r\n     * @param xs {Array|String}\r\n     * @returns {Array|undefined}\r\n     */\r\n    _uncons = xs =>\r\n        !xs || length(xs) === 0 ? undefined : [_head(xs), _tail(xs)],\r\n\r\n    /**\r\n     * Returns `tail` and `head` of passed in list/string in a tuple.\r\n     * @haskellType `unconsr :: [a] -> Maybe ([a], a)`\r\n     * @function module:_list._unconsr\r\n     * @param xs {Array|String}\r\n     * @returns {Array|String|*|undefined}\r\n     */\r\n    _unconsr = xs => !xs || length(xs) === 0 ? undefined : [_init(xs), _last(xs)],\r\n    \r\n    /**\r\n     * Concatenates all the elements of a container of lists.\r\n     * @haskellType `concat :: Foldable t => t [a] -> [a]`\r\n     * @function module:_list._concat\r\n     * @param xs {Array}\r\n     * @returns {Array}\r\n     */\r\n    _concat = xs => !length(xs) ? copy(xs) : apply(_appendMany, xs),\r\n\r\n    /**\r\n     * Map a function over all the elements of a container and concatenate the resulting lists.\r\n     * @haskellType `concatMap :: Foldable t => (a -> [b]) -> t a -> [b]`\r\n     * @function module:_list._concatMap\r\n     * @param fn {Function}\r\n     * @param foldableOfA {Array}\r\n     * @returns {Array}\r\n     */\r\n    _concatMap = (fn, foldableOfA) => _concat(_map(fn, foldableOfA)),\r\n\r\n    /**\r\n     * Returns a copy of the passed in list reverses.\r\n     * @haskellType `reverse :: [a] -> [a]`\r\n     * @function module:_list._reverse\r\n     * @param x {Array}\r\n     * @returns {Array}\r\n     */\r\n    _reverse = x => _foldr((agg, item) => (agg.push(item), agg), [], x),\r\n\r\n    /**\r\n     * Takes an element and a list and `intersperses' that element between the elements of the list. For example\r\n     * @function module:_list._intersperse\r\n     * @note In our version of the function javascript is loosely typed so, so is our function (to much overhead to make\r\n     *  it typed) so `between` can be any value.\r\n     * @param between {*} - Should be of the same type of elements contained in list.\r\n     * @param arr {Array} - List.\r\n     * @returns {Array}\r\n     */\r\n    _intersperse = (between, arr) => {\r\n        const limit = length(arr),\r\n            lastInd = limit - 1,\r\n            out = [];\r\n        if (!limit) {\r\n            return out;\r\n        }\r\n        return _foldl((agg, item, ind) => (\r\n                ind === lastInd ?\r\n                    agg.push(item) :\r\n                    agg.push(item, between),\r\n                agg\r\n            ), out, arr);\r\n    },\r\n\r\n    /**\r\n     * `intercalate xs xss` is equivalent to (concat (intersperse xs xss)). It inserts the list xs in between the lists in xss and concatenates the result.\r\n     * @haskellType `intercalate :: [a] -> [[a]] -> [a]`\r\n     * @function module:_list._intercalate\r\n     * @param xs {Array}\r\n     * @param xss {Array}\r\n     * @returns {Array}\r\n     */\r\n    _intercalate = (xs, xss) => _concat(_intersperse(xs, xss)),\r\n\r\n    /**\r\n     * Transposes rows and columns into lists by index;  E.g.,\r\n     * Haskell example:\r\n     * ```\r\n     *  transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]\r\n     *\r\n     *  -- Notice the shorter arrays are ignored after their last index is copied over:\r\n     *  transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]\r\n     * ```\r\n     * @note from columns to rows.\r\n     * @note Empty lists are ignored.\r\n     * @todo upgrade this function to support lists of strings.\r\n     * @haskellType `transpose :: [[a]] -> [[a]]`\r\n     * @function module:_list._transpose\r\n     * @param xss {Array}\r\n     * @returns {Array}\r\n     */\r\n    _transpose = xss => {\r\n        let numLists = length(xss),\r\n            ind = 0, ind2;\r\n        if (!numLists) {\r\n            return [];\r\n        }\r\n        const listLengths = apply(lengths, xss),\r\n            longestListLen = _maximum(listLengths),\r\n            outLists = [];\r\n        for (; ind < longestListLen; ind += 1) {\r\n            const outList = [];\r\n            for (ind2 = 0; ind2 < numLists; ind2 += 1) {\r\n                if (listLengths[ind2] < ind + 1) {\r\n                    continue;\r\n                }\r\n                outList.push(xss[ind2][ind]);\r\n            }\r\n            outLists.push(outList);\r\n        }\r\n        return _filter(x => length(x), outLists);\r\n    },\r\n\r\n    /**\r\n     * Generates 2^n sub-sequences for passed in sequence (string/list) (`n` is\r\n     * the length of the passed in sequence so: 2^length(xs)).\r\n     * Note: The return value doubles per index/character passed in so use with caution!\r\n     *  Also note that for 2^16 (or for a sequence of 16 characters) this algorithm\r\n     *  will generate 65536 sub-sequences!  So caution should be taken to not\r\n     *  use this with sequences above a certain length on certain platform (the browser thread in specific).\r\n     * @function module:_list._subsequences\r\n     * @jsperftest https://jsperf.com/subsequences\r\n     * @param xs {Array|String}\r\n     * @returns {Array.<Array>}\r\n     */\r\n    _subsequences = xs => {\r\n        const listLen = length(xs),\r\n            len = Math.pow(2, listLen),\r\n            out = [];\r\n        for (let i = 0; i < len; i += 1) {\r\n            let entry = [];\r\n            for (let j = 0; j < listLen; j += 1) {\r\n                if (i & (1 << j)) {\r\n                    entry.push(xs[j]);\r\n                }\r\n            }\r\n            out.push(entry);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Returns an array with the given indices swapped.\r\n     * @function module:_list._swapped\r\n     * @param ind1 {Number}\r\n     * @param ind2 {Number}\r\n     * @param list {Array}\r\n     * @returns {Array} - Copy of incoming with swapped values at indices.\r\n     */\r\n    _swapped = (ind1, ind2, list) => {\r\n        const out = copy(list),\r\n            tmp = out[ind1];\r\n        out[ind1] = out[ind2];\r\n        out[ind2] = tmp;\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Returns a list of permutations for passed in list.\r\n     *  Use caution with lists above a length of 15 (will take long due to nature of\r\n     *  algorithm).\r\n     * @function module:_list._permutations\r\n     * @param xs {Array} - List.\r\n     * @returns {Array<Array|String|*>} - Array of permutations.\r\n     */\r\n    _permutations = xs => {\r\n        const limit = length(xs);\r\n\r\n        if (!limit || limit === 1) {\r\n            return [xs];\r\n        }\r\n\r\n        let list = copy(xs),\r\n            c = _repeat(limit, 0),\r\n            i = 0;\r\n\r\n        const out = [list];\r\n\r\n        for (; i < limit; i++) {\r\n            if (c[i] < i) {\r\n                list = _swapped(i % 2 === 0 ? 0 : c[i], i, list);\r\n                out.push(list);\r\n                c[i] += 1;\r\n                i = 0;\r\n                continue;\r\n            }\r\n            c[i] = 0;\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Left associative fold.  Reduces a container of elements down by the given operation (same as [].reduce).\r\n     * @function module:_list._foldl\r\n     * @param fn {Function}\r\n     * @param zero {*} - Aggregator.\r\n     * @param functor {Array}\r\n     * @returns {*} - Whatever type is lastly returned from `fn`.\r\n     */\r\n    _foldl = reduce,\r\n\r\n    /**\r\n     * Right associative fold.  Reduces a container of elements down by the given operation (same as [].reduceRight).\r\n     * @function module:_list._foldr\r\n     * @param fn {Function}\r\n     * @param zero {*} - Aggregator.\r\n     * @param functor {Array}\r\n     * @returns {*} - Whatever type is lastly returned from `fn`.\r\n     */\r\n    _foldr = reduceRight,\r\n\r\n    /**\r\n     * A variant of `foldl` except that this one doesn't require the starting point.  The starting point/value will be pulled\r\n     * out from a copy of the container.\r\n     * @function module:_list._foldl1\r\n     * @param op {Function}\r\n     * @param xs {Array}\r\n     * @returns {*} - Whatever type is lastly returned from `op`.\r\n     */\r\n    _foldl1 = (op, xs) => {\r\n        const parts = _uncons(xs);\r\n        return !parts ? [] : reduce(op, parts[0], parts[1]);\r\n    },\r\n\r\n    /**\r\n     * A variant of `foldr` except that this one doesn't require the starting point/value.  The starting point/value will be pulled\r\n     * out from a copy of the container.\r\n     * @function module:_list._foldr1\r\n     * @param op {Function}\r\n     * @param xs {Array}\r\n     * @returns {*} - Whatever type is lastly returned from `op`.\r\n     */\r\n    _foldr1 = (op, xs) => {\r\n        const parts = _unconsr(xs);\r\n        return !parts ? [] : reduceRight(op, parts[1], parts[0]);\r\n    },\r\n\r\n    /**\r\n     * Performs a map then a reduce all in one (from left-to-right). Returns a tuple\r\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\r\n     * @function module:_list._mapAccumL\r\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\r\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\r\n     * @param xs {Array} - list type.\r\n     * @return {Array} - [aggregated, list]\r\n     */\r\n    _mapAccumL = (op, zero, xs) => {\r\n        const list = copy(xs),\r\n            limit = length(xs);\r\n        if (!limit) {\r\n            return [zero, list];\r\n        }\r\n        let ind = 0,\r\n            agg = zero,\r\n            mapped = [],\r\n            tuple;\r\n        for (; ind < limit; ind++) {\r\n            tuple = op(agg, list[ind], ind);\r\n            agg = tuple[0];\r\n            mapped = tuple[1];\r\n        }\r\n        return [agg, mapped];\r\n    },\r\n\r\n    /**\r\n     * Performs a map and a reduce all in one (from right-to-left). Returns a tuple\r\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\r\n     * @function module:_list._mapAccumR\r\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\r\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\r\n     * @param xs {Array} - list type.\r\n     * @return {Array} - [aggregated, list]\r\n     */\r\n    _mapAccumR = (op, zero, xs) => {\r\n        const list = copy(xs),\r\n            limit = length(xs);\r\n        if (!limit) {\r\n            return [zero, list];\r\n        }\r\n        let ind = limit - 1,\r\n            agg = zero,\r\n            mapped = [],\r\n            tuple;\r\n        for (; ind >= 0; ind--) {\r\n            tuple = op(agg, list[ind], ind);\r\n            agg = tuple[0];\r\n            mapped = tuple[1];\r\n        }\r\n        return [agg, mapped];\r\n    },\r\n\r\n    /**\r\n     * iterate f x returns an infinite list of repeated applications of f to x.\r\n     * @function module:_list._iterate\r\n     * @example `iterate(5, f, x) == [x, f(x), f(f(x)), ...]`\r\n     * @param limit {Number}\r\n     * @param op {Function} - Operation.\r\n     * @param x {*} - Starting point.\r\n     * @returns {*}\r\n     */\r\n    _iterate = (limit, op, x) => {\r\n        let ind = 0,\r\n            out = [],\r\n            lastX = x;\r\n        for (; ind < limit; ind += 1) {\r\n            out.push(lastX);\r\n            lastX = op(lastX, ind);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Repeats `x` `limit` number of times.\r\n     * @function module:_list._repeat\r\n     * @param limit {Number}\r\n     * @param x {*}\r\n     * @return {Array}\r\n     */\r\n    _repeat = (limit, x) => _iterate(limit, a => a, x),\r\n\r\n    /**\r\n     * Same as `repeat` due to the nature of javascript (see haskell version for usage).\r\n     * @function module:_list._replicate\r\n     * @param limit {Number}\r\n     * @param x {*}\r\n     * @return {Array}\r\n     */\r\n    _replicate = _repeat,\r\n\r\n    /**\r\n     * Replicates a list `limit` number of times and appends the results (concat)\r\n     * @function module:_list._cycle\r\n     * @param limit {Number}\r\n     * @param xs {Array}\r\n     * @returns {Array}\r\n     */\r\n    _cycle = (limit, xs) => _concat(_replicate(limit, xs)),\r\n\r\n    /**\r\n     * Unfolds a value into a list of somethings.\r\n     * @haskellType `unfoldr :: (b -> Maybe (a, b)) -> b -> [a]`\r\n     * @function module:_list._unfoldr\r\n     * @param op {Function} - Operation to perform (should return a two component tuple (item to aggregate and item to unfold in next iteration).\r\n     * @param x {*} - Starting parameter to unfold from.\r\n     * @returns {Array} - An array of whatever you return from `op` yielded.\r\n     */\r\n    _unfoldr = (op, x) => {\r\n        let ind = 0,\r\n            out = [],\r\n            resultTuple = op(x, ind, out);\r\n        while (resultTuple) {\r\n            out.push(resultTuple[0]);\r\n            resultTuple = op(resultTuple[1], ++ind, out);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Finds index in string or list (alias for `findIndex`).\r\n     * @function module:_list._findIndex\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    _findIndex = findIndexWhere,\r\n\r\n    /**\r\n     * @function module:_list._findIndices\r\n     * @param pred {Function}\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {Array|undefined}\r\n     */\r\n    _findIndices = findIndicesWhere,\r\n\r\n    /**\r\n     * @function module:_list._elemIndex\r\n     * @param x {*} - Element to search for.\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    _elemIndex = (x, xs) => {\r\n        const foundInd = indexOf(x, xs);\r\n        return foundInd !== -1 ? foundInd : undefined;\r\n    },\r\n\r\n    /**\r\n     * @function module:_list._elemIndices\r\n     * @param value {*} - Element to search for.\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    _elemIndices = (value, xs) => _findIndices(x => x === value, xs),\r\n\r\n    /**\r\n     * Takes `n` items from start of list to `limit` (exclusive).\r\n     * @function module:_list._take\r\n     * @param list {Array|String}\r\n     * @param limit {Number}\r\n     * @returns {String|Array} - Passed in type's type\r\n     */\r\n    _take = (limit, list) => sliceTo(limit, list),\r\n\r\n    /**\r\n     * Drops `n` items from start of list to `count` (exclusive).\r\n     * @function module:_list._take\r\n     * @param list {Array|String}\r\n     * @param count {Number}\r\n     * @returns {String|Array} - Passed in type's type\r\n     */\r\n    _drop = (count, list) => sliceFrom(count, list),\r\n\r\n    /**\r\n     * Splits `x` in two at given `index` (exclusive (includes element/character at\r\n     * given index in second part of returned list)).\r\n     * @function module:_list._splitAt\r\n     * @param ind {Number} - Index to split at.\r\n     * @param list {Array} - functor (list or string) to split.\r\n     * @returns {Array} - Array of whatever type `x` was when passed in\r\n     */\r\n    _splitAt = (ind, list) => [ sliceTo(ind, list), sliceFrom(ind, list) ],\r\n\r\n    /**\r\n     * Gives an list with passed elements while predicate was true.\r\n     * @function module:_list._takeWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @returns {Array}\r\n     */\r\n    _takeWhile = (pred, list) =>\r\n        reduceUntil(\r\n            negateP(pred),  // predicate\r\n            aggregateArr,   // operation\r\n            [],             // aggregator\r\n            list\r\n        ),\r\n\r\n    /**\r\n     * Returns an list without elements that match predicate.\r\n     * @function module:_list._dropWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @refactor\r\n     * @returns {Array|String}\r\n     */\r\n    _dropWhile = (pred, list) => {\r\n        const limit = length(list),\r\n            splitPoint =\r\n                findIndexWhere((item, ind, list2) =>\r\n                    !pred(list[ind], ind, list2), list);\r\n\r\n        return splitPoint === -1 ?\r\n            sliceTo(limit, list) :\r\n            slice(splitPoint, limit, list);\r\n    },\r\n\r\n    /**\r\n     * @function module:_list._dropWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @refactor\r\n     * @returns {Array|String}\r\n     */\r\n    _dropWhileEnd = (pred, list) => {\r\n        const limit = length(list),\r\n            splitPoint =\r\n                findIndexWhereRight((item, ind, list2) =>\r\n                    !pred(list[ind], ind, list2), list);\r\n\r\n        return splitPoint === -1 ?\r\n            sliceTo(limit, list) :\r\n            sliceTo(splitPoint + 1, list);\r\n    },\r\n\r\n    /**\r\n     * Gives a span such that the first list (in returned tuple) is the span of items matching upto `not predicate` and\r\n     * the second list in the tuple is a list of the remaining elements in the given list.\r\n     * **@Note: Not the same as `partition`.  Read descriptions closely!!!\r\n     * @function module:_list._span\r\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\r\n     * @param list {Array} - Predicate<item, index, originalArrayOrString>\r\n     * @returns {Array} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\r\n     */\r\n    _span = (pred, list) => {\r\n        const splitPoint = findIndexWhere(negateP(pred), list);\r\n        return splitPoint === -1 ?\r\n            _splitAt(0, list) : _splitAt(splitPoint, list);\r\n    },\r\n\r\n    /**\r\n     * breakOnList, applied to a predicate p and a list xs, returns a tuple\r\n     * where first element is longest prefix (possibly empty) of xs of elements\r\n     * that do not satisfy p and second element is the remainder of the list:\r\n     * @haskellExample\r\n     * Replace `break` with `breakOnList` for our version.\r\n     * ```\r\n     * break (> 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])\r\n     * break (< 9) [1,2,3] == ([],[1,2,3])\r\n     * break (> 9) [1,2,3] == ([1,2,3],[])\r\n     * ```\r\n     * @function module:_list._breakOnList\r\n     * @param pred {Function}\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    _breakOnList = (pred, list) => {\r\n        const splitPoint = findIndexWhere(pred, list);\r\n        return splitPoint === -1 ?\r\n            _splitAt(0, list) : _splitAt(splitPoint, list);\r\n    },\r\n\r\n    /**\r\n     * Gets item at index.\r\n     * @function module:_list._at\r\n     * @param ind {Number} - Index.\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {*|undefined} - Item or `undefined`.\r\n     */\r\n    _at = _prop,\r\n\r\n    /**\r\n     * Find an item in structure of elements based on given predicate (`pred`).\r\n     * @function module:_list._find\r\n     * @param pred {Function}\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {*} - Found item.\r\n     */\r\n    _find = findWhere,\r\n\r\n    /**\r\n     * Filters a structure of elements using given predicate (`pred`) (same as `[].filter`).\r\n     * @function module:_list._filter\r\n     * @param pred {Function}\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {Array} - Structure of filtered elements.\r\n     */\r\n    _filter = (pred, xs) => {\r\n        let ind = 0,\r\n            limit = length(xs),\r\n            out = [];\r\n        if (!limit) {\r\n            return out;\r\n        }\r\n        for (; ind < limit; ind++) {\r\n            if (pred(xs[ind], ind, xs)) {\r\n                out.push(xs[ind]);\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Partitions a list on a predicate;  Items that match predicate are in first list in tuple;  Items that\r\n     * do not match the tuple are in second list in the returned tuple.\r\n     *  Essentially `[filter(p, xs), filter(negateP(p), xs)]`.\r\n     * @function module:_list._partition\r\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\r\n     * @param list {Array}\r\n     * @returns {Array|String} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\r\n     */\r\n    _partition = (pred, list) =>\r\n        !length(list) ?\r\n            [[], []] :\r\n                [_filter(pred, list), _filter(negateP(pred), list)],\r\n\r\n    /**\r\n     * Returns a boolean indicating whether an element exists in given structure of elements.\r\n     * @function module:_list._elem\r\n     * @param element {*}\r\n     * @param xs {Array}\r\n     * @returns {Boolean}\r\n     */\r\n    _elem = includes,\r\n\r\n    /**\r\n     * The opposite of `elem` - Returns a boolean indicating whether an element exists in given list.\r\n     * @function module:_list._notElem\r\n     * @param element {*}\r\n     * @param xs {Array}\r\n     * @returns {Boolean}\r\n     */\r\n    _notElem = negateF(includes),\r\n\r\n    /**\r\n     * Same as _list._at - Returns property value at key/indice.\r\n     * @function module:object._lookup\r\n     * @type {module:object.prop}\r\n     */\r\n    _lookup = _at,\r\n\r\n    /**\r\n     * Checks if list `xs1` is a prefix of list `xs2`\r\n     * @function module:_list._isPrefixOf\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {boolean}\r\n     */\r\n    _isPrefixOf = (xs1, xs2) => {\r\n        const limit1 = length(xs1),\r\n            limit2 = length(xs2);\r\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\r\n            return false;\r\n        }\r\n        let ind = 0;\r\n        for (; ind < limit1; ind++) {\r\n            if (xs1[ind] !== xs2[ind]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Checks if list `xs1` is a suffix of list `xs2`\r\n     * @function module:_list._isSuffixOf\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {boolean}\r\n     */\r\n    _isSuffixOf = (xs1, xs2) => {\r\n        const limit1 = length(xs1),\r\n            limit2 = length(xs2);\r\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\r\n            return false;\r\n        }\r\n        let ind1 = limit1 - 1,\r\n            ind2 = limit2 - 1;\r\n        for (; ind1 >= 0; ind1--) {\r\n            if (xs1[ind1] !== xs2[ind2]) {\r\n                return false;\r\n            }\r\n            ind2 -= 1;\r\n        }\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Checks if list `xs1` is an infix of list `xs2`\r\n     * @function module:_list._isInfixOf\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {boolean}\r\n     */\r\n    _isInfixOf = (xs1, xs2) => {\r\n        const limit1 = length(xs1),\r\n            limit2 = length(xs2);\r\n        if (limit2 < limit1 || !limit1 || !limit2) {\r\n            return false;\r\n        }\r\n        let ind1,\r\n            foundLen,\r\n            ind = 0;\r\n        for (; ind < limit2; ind += 1) {\r\n            foundLen = 0;\r\n            for (ind1 = 0; ind1 < limit1; ind1 += 1) {\r\n                if (xs2[ind1 + ind] === xs1[ind1]) {\r\n                    foundLen += 1;\r\n                }\r\n                if (foundLen === limit1) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Checks if list `xs1` is a sub-sequence of list `xs2`\r\n     * @function module:_list._isPrefixOf\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {boolean}\r\n     */\r\n    _isSubsequenceOf = (xs1, xs2) => {\r\n        const len = Math.pow(2, length(xs2)),\r\n            lenXs1 = length(xs1);\r\n        let foundLen,\r\n            i;\r\n        for (i = 0; i < len; i += 1) {\r\n            foundLen = 0;\r\n            for (let j = 0; j < len; j += 1) {\r\n                if (i & (1 << j) && indexOf(xs2[j], xs1) > -1) {\r\n                    foundLen += 1;\r\n                }\r\n                if (foundLen === lenXs1) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * The group function takes a list and returns a list of lists such that\r\n     *  the concatenation of the result is equal to the argument. Moreover, each\r\n     *  sublist in the result contains only equal elements. For example,\r\n     * `group \"Mississippi\" = [\"M\",\"i\",\"ss\",\"i\",\"ss\",\"i\",\"pp\",\"i\"]`\r\n     * It is a special case of groupBy, which allows the programmer to supply\r\n     *  their own equality test.\r\n     * @haskellType `group :: Eq a => [a] -> [[a]]`\r\n     * @function module:_list._group\r\n     * @param xs {Array}\r\n     * @returns {Array<Array|String|*>|*}\r\n     */\r\n    _group = xs => _groupBy((a, b) => a === b, xs),\r\n\r\n    /**\r\n     * Allows you to group items in a list based on your supplied equality check.\r\n     * @note Sames `group` but allows you to specify equality operation.\r\n     * @haskellType `groupBy :: (a -> a -> Bool) -> [a] -> [[a]]`\r\n     * @function module:_list._groupBy\r\n     * @param equalityOp {Function}\r\n     * @param xs {Array}\r\n     * @returns {*}\r\n     */\r\n    _groupBy = (equalityOp, xs) => {\r\n        const limit = length(xs);\r\n        if (!limit) {\r\n            return copy(xs);\r\n        }\r\n        let ind = 0,\r\n            prevItem,\r\n            item,\r\n            predOp = x => {\r\n                if (equalityOp(x, prevItem)) {\r\n                    ind++;\r\n                }\r\n                if (equalityOp(x, item)) {\r\n                    prevItem = x;\r\n                    return true;\r\n                }\r\n                return false;\r\n            },\r\n            agg = [];\r\n        for (; ind < limit; ind += 1) {\r\n            item = xs[ind];\r\n            agg.push(_takeWhile(predOp, slice(ind, limit, xs)));\r\n        }\r\n        return agg;\r\n    },\r\n\r\n    /**\r\n     * The inits function returns all initial segments of the argument, shortest first. For example,\r\n     * ```\r\n     * shallowEquals(inits('abc'), ['','a','ab','abc'])\r\n     * ```\r\n     * @function module:_list._inits\r\n     * @haskellType `inits :: [a] -> [[a]]`\r\n     * @param xs {Array}\r\n     * @returns {Array}\r\n     */\r\n    _inits = xs => {\r\n        let limit = length(xs),\r\n            ind = 0,\r\n            agg = [];\r\n        if (!limit) {\r\n            return [];\r\n        }\r\n        for (; ind <= limit; ind += 1) {\r\n            agg.push(sliceTo(ind, xs));\r\n        }\r\n        return agg;\r\n    }, //_map(list => _init(list), xs),\r\n\r\n    /**\r\n     * The inits function returns all initial segments of the argument, shortest first. For example,\r\n     * ```\r\n     * shallowEquals(tails('abc'), ['abc', 'bc', 'c',''])\r\n     * ```\r\n     * @function module:_list._tails\r\n     * @haskellType `tails :: [a] -> [[a]]`\r\n     * @param xs {Array}\r\n     * @returns {Array}\r\n     */\r\n    _tails = xs => {\r\n        let limit = length(xs),\r\n            ind = 0,\r\n            agg = [];\r\n        if (!limit) {\r\n            return [];\r\n        }\r\n        for (; ind <= limit; ind += 1) {\r\n            agg.push(slice(ind, limit, xs));\r\n        }\r\n        return agg;\r\n    }, //_map(list => tail(list), xs),\r\n\r\n    /**\r\n     * Strips prefix list from given list\r\n     * @function module:_list._stripPrefix\r\n     * @param prefix {Array|String|*}\r\n     * @param list {Array|string|*}\r\n     * @returns {Array|*}\r\n     */\r\n    _stripPrefix = (prefix, list) =>\r\n        _isPrefixOf(prefix, list) ?\r\n            _splitAt(length(prefix), list)[1] :\r\n            copy(list),\r\n\r\n    /**\r\n     * zip takes two lists and returns a list of corresponding pairs.\r\n     * If one input list is short, excess elements of the longer list are discarded.\r\n     * @haskellType `zip :: [a] -> [b] -> [(a, b)]`\r\n     * @function module:_list._zip\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    _zip = (arr1, arr2) => {\r\n        if (!length(arr1) || !length(arr2)) {\r\n            return [];\r\n        }\r\n        const [a1, a2] = lengthsToSmallest(arr1, arr2);\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArr(agg, [item, a2[ind]]),\r\n            [], a1);\r\n    },\r\n\r\n    /**\r\n     * zipN takes one or more lists and returns a list containing lists of all indices\r\n     * at a given index, index by index.\r\n     * If one input list is short, excess elements of the longer list are discarded.\r\n     * @function module:_list._zipN\r\n     * @param lists {Array|String} - One ore more lists of the same type.\r\n     * @returns {Array}\r\n     */\r\n    _zipN = (...lists) => {\r\n        const trimmedLists = apply(lengthsToSmallest, _filter(length, lists)),\r\n            lenOfTrimmed = length(trimmedLists);\r\n        if (!lenOfTrimmed) {\r\n            return [];\r\n        }\r\n        else if (lenOfTrimmed === 1) {\r\n            return sliceTo(length(trimmedLists[0]), trimmedLists[0]);\r\n        }\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArr(agg, _map(xs => xs[ind], trimmedLists)),\r\n            [], trimmedLists[0]);\r\n    },\r\n\r\n    /**\r\n     * @haskellType `zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]`\r\n     * @function module:_list._zip3\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    _zip3 = (arr1, arr2, arr3) => _zipN(arr1, arr2, arr3),\r\n\r\n    /**\r\n     * @haskellType `zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]`\r\n     * @function module:_list._zip4\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @param arr4 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    _zip4 = (arr1, arr2, arr3, arr4) => _zipN(arr1, arr2, arr3, arr4),\r\n\r\n    /**\r\n     * @haskellType `zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]`\r\n     * @function module:_list._zip5\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @param arr4 {Array}\r\n     * @param arr5 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    _zip5 = (arr1, arr2, arr3, arr4, arr5) => _zipN(arr1, arr2, arr3, arr4, arr5),\r\n\r\n    /**\r\n     * zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\r\n     * zipWith generalises zip by zipping with the function given as the\r\n     * first argument, instead of a function tupling function (function that returns a tuple). For example,\r\n     * zipWith (+) is applied to two lists to produce the list of corresponding sums.\r\n     * @note `_|_` means bottom or perpetual (@see\r\n     *  - https://wiki.haskell.org/Bottom\r\n     *  - https://stackoverflow.com/questions/19794681/what-does-this-syntax-mean-in-haskell-or\r\n     *  )\r\n     * @example\r\n     * ```\r\n     * zipWith f [] _|_ = []\r\n     * ```\r\n     * @haskellType `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`\r\n     * @function module:_list._zipWith\r\n     * @param op {Function} - Takes two parts of a tuple and returns a tuple.\r\n     *  E.g., ` op :: a -> b -> (a, b)`\r\n     * @param xs1 {Array}\r\n     * @param xs2 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    _zipWith = (op, xs1, xs2) => {\r\n        if (!length(xs1) || !length(xs2)) {\r\n            return [];\r\n        }\r\n        const [a1, a2] = lengthsToSmallest(xs1, xs2);\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArr(agg, op(item, a2[ind])),\r\n            [], a1);\r\n    },\r\n\r\n    /**\r\n     * Zips all given lists with tupling function. Note: Haskell types do not have\r\n     *  a way (that I know of) to show one or more for params in a function so `@haskellType` below\r\n     *  is left there for general purpose not for exactness as is told by aforementioned.\r\n     * @haskellType `zipWithN :: (a -> b -> c) -> [a] -> [b] -> [c]` - Where `N` is the number\r\n     *  of lists to zip.\r\n     * @function module:_list._zipWithN\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\r\n     * @param lists ...{Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    _zipWithN = (op, ...lists) => {\r\n        const trimmedLists = apply(lengthsToSmallest, lists),\r\n            lenOfTrimmed = length(trimmedLists);\r\n        if (!lenOfTrimmed) {\r\n            return [];\r\n        }\r\n        else if (lenOfTrimmed === 1) {\r\n            return sliceTo(length(trimmedLists[0]), trimmedLists[0]);\r\n        }\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArr(agg, apply(op, _map(xs => xs[ind], trimmedLists))),\r\n            [], trimmedLists[0]);\r\n    },\r\n\r\n    /**\r\n     * Zips 3 lists with tupling function.\r\n     * @haskellType `zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]`\r\n     * @function module:_list._zipWith3\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\r\n     * @param xs1 {Array}\r\n     * @param xs2 {Array}\r\n     * @param xs3 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    _zipWith3 = (op, xs1, xs2, xs3) => _zipWithN(op, xs1, xs2, xs3),\r\n\r\n    /**\r\n     * Zips 4 lists with tupling function.\r\n     * @haskellType `zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c]  -> [d] -> [e]`\r\n     * @function module:_list._zipWith4\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> d -> (a, b, c, d)`\r\n     * @param xs1 {Array}\r\n     * @param xs2 {Array}\r\n     * @param xs3 {Array}\r\n     * @param xs4 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    _zipWith4 = (op, xs1, xs2, xs3, xs4) => _zipWithN(op, xs1, xs2, xs3, xs4),\r\n\r\n    /**\r\n     * Zips 5 lists.\r\n     * @haskellType `zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c]  -> [d] -> [e] -> [f]`\r\n     * @function module:_list._zipWith5\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> d -> e -> (a, b, c, d, e)`\r\n     * @param xs1 {Array}\r\n     * @param xs2 {Array}\r\n     * @param xs3 {Array}\r\n     * @param xs4 {Array}\r\n     * @param xs5 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    _zipWith5 = (op, xs1, xs2, xs3, xs4, xs5) => _zipWithN(op, xs1, xs2, xs3, xs4, xs5),\r\n\r\n    /**\r\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\r\n     * @haskellType `unzip :: [(a, b)] -> ([a], [b])`\r\n     * @todo Should support other list types (should not have `push` hard coded instead should use `mappend` (if available)).\r\n     * @function module:_list._unzip\r\n     * @param arr {Array|*}\r\n     * @returns {Array|*}\r\n     */\r\n    _unzip = arr =>\r\n        _foldl((agg, item) => {\r\n            agg[0].push(item[0]);\r\n            agg[1].push(item[1]);\r\n            return agg;\r\n        }, [[], []], arr),\r\n\r\n    /**\r\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\r\n     * @sudoHaskellType `unzipN :: [(a, b, ...x)] -> ([a], [b], ...[x])`\r\n     * @todo Should support other list types (should not have `push` hard coded instead should use `mappend` (if available)).\r\n     * @function module:_list._unzip\r\n     * @param list {Array|*} - List of tuples (lists).\r\n     * @returns {Array|*}\r\n     */\r\n    _unzipN = list => {\r\n        if (!length(list)) {\r\n            return [];\r\n        }\r\n        const lenItem0 = length(list[0]);\r\n        let zero = lenItem0 ?\r\n            _unfoldr(numLists => numLists-- ? [[], numLists] : undefined, lenItem0) :\r\n            [];\r\n        return _foldl((agg, item) => {\r\n            agg.forEach((outList, ind) => outList.push(item[ind]));\r\n            return agg;\r\n        }, zero, list);\r\n    },\r\n\r\n    /**\r\n     * Returns true if any item in container passes predicate `p`.\r\n     * @function module:_list._any\r\n     * @param p {Function} - Predicate.\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    _any = (p, xs) => {\r\n        let ind = 0,\r\n            limit = length(xs);\r\n        if (!limit) {\r\n            return false;\r\n        }\r\n        for (; ind < limit; ind += 1) {\r\n            if (p(xs[ind])) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Returns true if all items in container pass predicate `p`.\r\n     * @function module:_list._all\r\n     * @param p {Function} - Predicate.\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    _all = (p, xs) => {\r\n        const limit = length(xs);\r\n        let ind = 0;\r\n        if (limit === 0) {\r\n            return false;\r\n        }\r\n        for (; ind < limit; ind++) {\r\n            if (!p(xs[ind], ind, xs)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Conjuction of container of bools (or truthy and/or falsy values);  Returns\r\n     * `true` if all in container are 'truthy' else returns `false`\r\n     * @function module:_list._and\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    _and = xs => _all(isTruthy, xs),\r\n\r\n    /**\r\n     * Returns a boolean indicating whether any item in container is 'truthy' or not.\r\n     * **Note** The haskell type for this function only takes two items, but here\r\n     * we allow the passing of more than one item (may change later to adhere to the haskell type).\r\n     * @function module:_list._or\r\n     * @haskellType `or :: Bool -> Bool -> Bool`\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    _or = xs => _any(isTruthy, xs),\r\n\r\n    /**\r\n     * Returns a boolean indicating whether all items in container are 'falsy' or not.\r\n     * **Note** The haskell type for this function only takes two items, but here\r\n     * we allow the passing of more than one item (may change later to adhere to the haskell type).\r\n     * @function module:_list._not\r\n     * @haskellType `not :: Bool -> Bool`\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    _not = xs => _all(isFalsy, xs),\r\n\r\n    /**\r\n     * Computes the sum of the numbers of a structure.\r\n     * @function module:_list._sum\r\n     * @haskellType `sum :: (List t, Num a) => t a -> a`\r\n     * @param list {Array|String}\r\n     * @returns {Number}\r\n     */\r\n    _sum = list => _foldl((agg, x) => agg + x, 0, list),\r\n\r\n    /**\r\n     * Computes the product of the numbers of a structure.\r\n     * @function module:_list._product\r\n     * @haskellType `product :: (List t, Num a) => t a -> a`\r\n     * @param list {Array|String}\r\n     * @returns {Number}\r\n     */\r\n    _product = list => _foldl((agg, x) => agg * x, 1, list),\r\n\r\n    /**\r\n     * Returns the largest element in a non-empty structure of elements.\r\n     * @function module:_list._maximum\r\n     * @haskellType `maximum :: forall a . Ord a => t a -> a`\r\n     * @param list {Array|String}\r\n     * @returns {*} - Whatever type the array is made of (if any).\r\n     */\r\n    _maximum = list => _last(_sortBy(genericAscOrdering, list)),\r\n\r\n    /**\r\n     * Returns the smallest element in a non-empty structure of elements.\r\n     * @function module:_list._minimum\r\n     * @haskellType `minimum :: forall a . Ord a => t a -> a`\r\n     * @param list {Array|String}\r\n     * @returns {*} - Whatever type the array is made of (if any).\r\n     */\r\n    _minimum = list => _head(_sortBy(genericAscOrdering, list)),\r\n\r\n    /**\r\n     * scanl is similar to foldl, but returns a list of successive reduced values from the left:\r\n     * ```\r\n     * scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]\r\n     * ```\r\n     * Also note that:\r\n     * ```\r\n     * last (scanl f z xs) == foldl f z xs.\r\n     * ```\r\n     * @function module:_list._scanl\r\n     * @param fn {Function}\r\n     * @param zero {*}\r\n     * @param xs {Array}\r\n     * @returns {Array|*}\r\n     */\r\n    _scanl = (fn, zero, xs) => {\r\n        if (!xs || !length(xs)) {\r\n            return [];\r\n        }\r\n        const limit = length(xs);\r\n        let ind = 0,\r\n            result = zero,\r\n            out = [];\r\n        while (ind < limit) {\r\n            result = fn(result, xs[ind], ind, xs);\r\n            out.push(result);\r\n            ind++;\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * `scanl1` is a variant of `scanl` that has no starting value argument:\r\n     * `shallowCompare(scanl1(fn, [x1, x2, ...]), [x1, fn(x1, x2), ...]) // true`\r\n     * @function module:_list._scanl1\r\n     * @param fn {Function}\r\n     * @param xs {Array}\r\n     * @returns {Array|*}\r\n     */\r\n    _scanl1 = (fn, xs) => {\r\n        if (!xs || !xs.length) { return []; }\r\n        return _scanl(fn, _head(xs), _tail(xs));\r\n    },\r\n\r\n    /**\r\n     * Same as `scanl` but from the right (similiar to `foldr`'s relationship to `foldl`).\r\n     * Note also `scanr`'s relationship ot `foldr`:\r\n     * `head (scanr(fn, z, xs)) === foldr(fn, z, xs).\r\n     * @function module:_list._scanr\r\n     * @param fn {Function}\r\n     * @param zero {*}\r\n     * @param xs {Array}\r\n     * @returns {Array|*}\r\n     */\r\n    _scanr = (fn, zero, xs) => {\r\n        if (!xs || !length(xs)) {\r\n            return [];\r\n        }\r\n        const limit = length(xs);\r\n        let ind = limit - 1,\r\n            result = xs[0],\r\n            out = [];\r\n        while (ind > -1) {\r\n            result = fn(result, xs[ind], ind, xs);\r\n            out.push(result);\r\n            ind--;\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Same as `scanr` but takes no zero/accumulator value.\r\n     * @function module:_list._scanr1\r\n     * @param fn {Function}\r\n     * @param xs {Array}\r\n     * @returns {Array|*}\r\n     */\r\n    _scanr1 = (fn, xs) => {\r\n        if (!xs || !xs.length) { return []; }\r\n        return _scanr(fn, _last(xs), _init(xs));\r\n    },\r\n\r\n    /**\r\n     * The nub function removes duplicate elements from a list.\r\n     * In particular, it keeps only the first occurrence of each element.\r\n     * (The name nub means `essence'.) It is a special case of nubBy, which\r\n     * allows the programmer to supply their own equality test.\r\n     * ```shallowCompare( nub ([1,2,3,4,3,2,1,2,4,3,5]), [1,2,3,4,5] )```\r\n     * @function module:_list._nub\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    _nub = list => _nubBy((a, b) => a === b, list),\r\n\r\n    /**\r\n     * `remove(x, xs)` removes the first occurrence of `x` from `xs`.\r\n     * For example, `remove('a', 'banana') === 'bnana';`\r\n     * @function module:_list._remove\r\n     * @param x {*}\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    _remove = (x, list) => _removeBy((a, b) => a === b, x, list),\r\n\r\n    /**\r\n     * The sort function implements a stable sorting algorithm.\r\n     * It is a special case of sortBy, which allows the programmer\r\n     * to supply their own comparison function.\r\n     * ```shallowCompare(sort ([1,6,4,3,2,5]), [1,2,3,4,5,6]) // true```\r\n     * @function module:_list._sort\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    _sort = xs => _sortBy(genericAscOrdering, xs),\r\n\r\n    /**\r\n     * Sort a list by comparing the results of a key function applied to each\r\n     * element. sortOn f is equivalent to sortBy (comparing f), but has the\r\n     * performance advantage of only evaluating f once for each element in the\r\n     * input list. This is called the decorate-sort-undecorate paradigm, or\r\n     * Schwartzian transform.\r\n     *\r\n     * Elements are arranged from from lowest to highest, keeping duplicates\r\n     * in the order they appeared in the input.\r\n     *\r\n     * Ex:\r\n     * ```\r\n     * shallowEquals(\r\n     *  sortOn (head, [[2, \"world\"], [4, \"!\"], [1, \"Hello\"]]),\r\n     *  [[1,\"Hello\"],[2,\"world\"],[4,\"!\"]]\r\n     * ) // true\r\n     * ```\r\n     * @function module:_list._sortOn\r\n     * @param valueFn {Function}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    _sortOn = (valueFn, xs) =>\r\n\r\n        // Un-decorate\r\n        _map(decorated => decorated[1],\r\n\r\n            // Decorate and sort\r\n            _sortBy(\r\n                // Ordering\r\n                ([a0], [b0]) => genericAscOrdering(a0, b0),\r\n\r\n                // Decorate\r\n                _map(item => [valueFn(item), item], xs)\r\n            )\r\n        ),\r\n\r\n    /**\r\n     * The sortBy function is the non-overloaded (in haskell terms) version of sort.\r\n     * @haskellExample ```\r\n     *  >>> sortBy (\\(a,_) (b,_) -> compare a b) [(2, \"world\"), (4, \"!\"), (1, \"Hello\")]\r\n     *  [(1,\"Hello\"),(2,\"world\"),(4,\"!\")]\r\n     * ```\r\n     * @function module:_list._sortBy\r\n     * @param orderingFn {Function}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    _sortBy = (orderingFn, xs) => copy(xs).sort(orderingFn || genericAscOrdering),\r\n\r\n    /**\r\n     * The insert function takes an element and a list and inserts the element\r\n     * into the list at the first position where it is less than or equal to the\r\n     * next element. In particular, if the list is sorted before the call, the\r\n     * result will also be sorted. It is a special case of insertBy, which allows\r\n     * the programmer to supply their own comparison function.\r\n     * @function module:_list._insert\r\n     * @param x {*}\r\n     * @param xs {Array|*}\r\n     * @returns {Array}\r\n     */\r\n    _insert = (x, xs) => {\r\n        if (!length(xs)) {\r\n            return [x];\r\n        }\r\n        const foundIndex = _findIndex(item => x <= item, xs);\r\n        return foundIndex === -1 ? [x] :\r\n            _concat(_intersperse([x], _splitAt(foundIndex, xs)));\r\n    },\r\n\r\n    /**\r\n     * A version of `insert` that allows you to specify the ordering of the inserted\r\n     * item;  Before/at, or after\r\n     * @function module:_list._insertBy\r\n     * @haskellType `insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]`\r\n     * @note `Ordering` === // something that is order-able\r\n     * @todo Optimize and work the logic of this function;  Think about the types that will be\r\n     *  operated on by this functions logic.\r\n     * @param orderingFn {Function} - A function that returns `-1`, `0`, or 1`.\r\n     * @param x {*} - Value to insert.\r\n     * @param xs {Array} - List to insert into (note new list is returned)\r\n     * @returns {Array} - New list.\r\n     */\r\n    _insertBy = (orderingFn, x, xs) => {\r\n        const limit = length(xs);\r\n        if (!limit) {\r\n            return [x];\r\n        }\r\n        let ind = 0;\r\n        for (; ind < limit; ind += 1) {\r\n            if (orderingFn(x, xs[ind]) <= 0) {\r\n                const parts = _splitAt(ind, xs);\r\n                return _concat([parts[0], [x], parts[1]]);\r\n            }\r\n        }\r\n        return aggregateArr(copy(xs), x);\r\n    },\r\n\r\n    /**\r\n     * The nubBy function behaves just like nub, except it uses a user-supplied equality predicate.\r\n     * @function module:_list._nubBy\r\n     * @param pred {Function}\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    _nubBy = (pred, list) => {\r\n        if (!length(list)) {\r\n            return [];\r\n        }\r\n        const limit = length(list);\r\n        let ind = 0,\r\n            currItem,\r\n            out = [],\r\n            anyOp = storedItem => pred(currItem, storedItem);\r\n        for (; ind < limit; ind += 1) {\r\n            currItem = list[ind];\r\n            if (_any(anyOp, out)) {\r\n                continue;\r\n            }\r\n            out.push(currItem);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Behaves the same as `remove`, but takes a user-supplied equality predicate.\r\n     * @function module:_list._removeBy\r\n     * @param pred {Function}\r\n     * @param x {*}\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    _removeBy = (pred, x, list) => { // @todo optimize this implementation\r\n        const foundIndex = _findIndex(item => pred(x, item), list),\r\n            parts = _splitAt(foundIndex > -1 ? foundIndex : 0, list); // @todo correct this implementation\r\n        return _append(parts[0], _tail(parts[1]));\r\n    },\r\n\r\n    /**\r\n     * The `removeFirstsBy` function takes a predicate and two lists and returns the first list with the first\r\n     * occurrence of each element of the second list removed.\r\n     * @param pred {Function}\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    _removeFirstsBy = (pred, xs1, xs2) =>\r\n        _foldl((agg, x2) => _removeBy(pred, x2, agg), xs1, xs2),\r\n\r\n    /**\r\n     * Returns the union on elements matching boolean check passed in.\r\n     * @function module:_list._unionBy\r\n     * @param pred {Function} - `pred :: a -> a -> Bool`\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @returns {Array}\r\n     */\r\n    _unionBy = (pred, arr1, arr2) =>\r\n        _foldl((agg, b) => {\r\n                const alreadyAdded = _any(a => pred(a, b), agg);\r\n                return !alreadyAdded ? (agg.push(b), agg) : agg;\r\n            }, copy(arr1), arr2\r\n        ),\r\n\r\n    /**\r\n     * Creates a union on matching elements from array1.\r\n     * @function module:_list._union\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @returns {Array}\r\n     */\r\n    _union = (arr1, arr2) =>\r\n        _append(arr1,\r\n            _filter(elm => !includes(elm, arr1), arr2)),\r\n\r\n    /**\r\n     * Performs an intersection on list 1 with  elements from list 2.\r\n     * @function module:_list._intersect\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @returns {Array}\r\n     */\r\n    _intersect = (arr1, arr2) =>\r\n        !arr1 || !arr2 || (!arr1 && !arr2) ? [] :\r\n            _filter(elm => includes(elm, arr2), arr1),\r\n\r\n    /**\r\n     * Returns an intersection by predicate.\r\n     * @function module:_list._intersectBy\r\n     * @param pred {Function} - `pred :: a -> b -> Bool`\r\n     * @param list1 {Array}\r\n     * @param list2 {Array}\r\n     * @return {Array}\r\n     */\r\n    _intersectBy = (pred, list1, list2) =>\r\n        _foldl((agg, a) =>\r\n                _any(b => pred(a, b), list2) ? (agg.push(a), agg) : agg\r\n            , [], list1),\r\n\r\n    /**\r\n     * Returns the difference of list 1 from list 2.\r\n     * @note The `difference` operation here is non-associative;  E.g., `a - b` is not equal to `b - a`;\r\n     * @function module:_list._difference\r\n     * @param array1 {Array}\r\n     * @param array2 {Array}\r\n     * @returns {Array}\r\n     */\r\n    _difference = (array1, array2) => { // augment this with max length and min length ordering on op\r\n        if (array1 && !array2) {\r\n            return copy(array1);\r\n        }\r\n        else if (!array1 && array2 || (!array1 && !array2)) {\r\n            return [];\r\n        }\r\n        return reduce((agg, elm) =>\r\n                !includes(elm, array2) ? (agg.push(elm), agg) : agg\r\n            , [], array1);\r\n    },\r\n\r\n    /**\r\n     * Returns the complement of list 0 and the reset of the passed in arrays.\r\n     * @function module:_list._complement\r\n     * @param arr0 {Array}\r\n     * @param arrays {...Array}\r\n     * @returns {Array}\r\n     */\r\n    _complement = (arr0, ...arrays) =>\r\n        reduce((agg, arr) => _append(agg, _difference(arr, arr0)), [], arrays);\r\n","import {_assignDeep} from './_assignDeep';\r\nimport {_hasOwnProperty, keys} from '../_jsPlatform/_object';\r\nimport {_foldl} from '../_list/_list';\r\n\r\nexport const\r\n\r\n    _objUnion = (obj1, obj2) => _assignDeep(obj1, obj2),\r\n\r\n    _objIntersect = (obj1, obj2) => _foldl((agg, key) => {\r\n        if (_hasOwnProperty(key, obj2)) {\r\n            agg[key] = obj2[key];\r\n        }\r\n        return agg;\r\n    }, {}, keys(obj1)),\r\n\r\n    _objDifference = (obj1, obj2) => _foldl((agg, key) => {\r\n        if (!_hasOwnProperty(key, obj2)) {\r\n            agg[key] = obj1[key];\r\n        }\r\n        return agg;\r\n    }, {}, keys(obj1)),\r\n\r\n    _objComplement = (obj0, ...objs) => _foldl((agg, obj) =>\r\n        _assignDeep(agg, _objDifference(obj, obj0)), {}, objs);\r\n","export const\r\n\r\n    /**\r\n     * `Console.log` method.\r\n     * @function module:object.log\r\n     * @params args {...*}\r\n     * @returns {void}\r\n     */\r\n    log = console.log.bind(console),\r\n\r\n    /**\r\n     * `Console.error` method.\r\n     * @function module:object.error\r\n     * @params args {...*}\r\n     * @returns {void}\r\n     */\r\n    error = console.error.bind(console),\r\n\r\n    /**\r\n     * Peeks at incoming value(s) and returns the last value.\r\n     * @function module:object.peek\r\n     * @param args {...*}\r\n     * @returns {*} - Last given value (if one or more values) else first value.\r\n     */\r\n    peek = (...args) => (log(...args), args.pop())\r\n\r\n;\r\n","/**\r\n * @module object\r\n * @description Contains error throwing facilities for when a value doesn't match a type.\r\n *  In addition gives you curried and uncurried versions of the multi arity functions.\r\n */\r\nimport {typeOf} from './_typeOf';\r\nimport {isset, _isType, isString, isArray, isFunction} from './_is';\r\nimport {curry, curry4} from '../_function/_curry';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Checks if `type` is a string or a function (constructor or constructor name)\r\n     * @function module:object.isCheckableType\r\n     * @param type {TypeRef}\r\n     * @returns {Boolean}\r\n     */\r\n    isCheckableType = type => isString(type) || isFunction(type),\r\n\r\n    /**\r\n     * Throws an error if `type` is not a checkable type (can't be checked by the `TypeChecker` type)\r\n     * @function module:object._errorIfNotCheckableType\r\n     * @param contextName {String}\r\n     * @param type {TypeRef}\r\n     * @returns {TypeRef} - Type passed in if `type` is checkable\r\n     */\r\n    _errorIfNotCheckableType = (contextName, type) => {\r\n        if (!isCheckableType(type)) {\r\n            throw new Error (`${contextName} expects \\`type\\` to be of type \\`String\\` or \\`Function\\`.` +\r\n                `  Type received \\`${typeOf(type)}\\`.  Value \\`${type}\\`.`);\r\n        }\r\n        return type;\r\n    },\r\n\r\n    /**\r\n     * Resolves/normalizes a type name from either a string or a constructor.\r\n     * @function module:object.getTypeName\r\n     * @param type {Function|String} - String or function representing a type.\r\n     * @returns {String}\r\n     * @private\r\n     */\r\n    getTypeName = type => {\r\n        _errorIfNotCheckableType('getTypeName', type);\r\n        return type.name || type;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean indicating whether given value matches given type.\r\n     * @function module:object.defaultTypeChecker$\r\n     * @param Type {String|Function} - Type name, constructor and/or class.\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    _defaultTypeChecker = (Type, value) => _isType(getTypeName(Type), value) || (\r\n        isFunction(Type) && isset(value) && value instanceof Type),\r\n\r\n    /**\r\n     * Pretty prints an array of types/type-strings for use by error messages;\r\n     * Outputs \"`SomeTypeName`, ...\" from [SomeType, 'SomeTypeName', etc...]\r\n     * @function module:object.multiTypesToString\r\n     * @param types {Array|TypesArray}\r\n     * @return {String}\r\n     * @private\r\n     */\r\n    multiTypesToString = types => types.length ?\r\n             types.map(type => `\\`${getTypeName(type)}\\``).join(', ') : '',\r\n\r\n    /**\r\n     * Prints a message from an object.  Object signature:\r\n     * {contextName, valueName, value, expectedTypeName, foundTypeName, messageSuffix}\r\n     * @function module:object.defaultErrorMessageCall\r\n     * @param tmplContext {Object|TemplateContext} - Object to use in error template.\r\n     * @returns {string}\r\n     * @private\r\n     */\r\n    defaultErrorMessageCall = tmplContext => {\r\n        const {\r\n            contextName, valueName, value, expectedTypeName,\r\n            foundTypeName, messageSuffix\r\n        } = tmplContext,\r\n            isMultiTypeNames = isArray(expectedTypeName),\r\n            typesCopy = isMultiTypeNames ? 'of type' : 'of one of the types',\r\n            typesToMatchCopy = isMultiTypeNames ? multiTypesToString(expectedTypeName) : expectedTypeName;\r\n        return (contextName ? `\\`${contextName}.` : '`') +\r\n            `${valueName}\\` is not ${typesCopy}: ${typesToMatchCopy}.  ` +\r\n            `Type received: ${foundTypeName}.  Value: ${value};` +\r\n            `${messageSuffix ?  '  ' + messageSuffix + ';' : ''}`;\r\n    },\r\n\r\n    /**\r\n     * Gets the error message thrower seeded with passed in errorMessage template call.\r\n     * @function module:object.getErrorIfNotTypeThrower$\r\n     * @param errorMessageCall {Function|ErrorMessageCall}\r\n     * @param typeChecker {Function|TypeChecker} - Function<Type, value>:Boolean\r\n     * @returns {Function|ErrorIfNotType}\r\n     */\r\n    _getErrorIfNotTypeThrower = (errorMessageCall, typeChecker = _defaultTypeChecker) =>\r\n      (ValueType, contextName, valueName, value, messageSuffix = null) => {\r\n        const expectedTypeName = getTypeName(ValueType),\r\n            foundTypeName = typeOf(value);\r\n        if (typeChecker(ValueType, value)) { return value; } // Value matches type\r\n        throw new Error(errorMessageCall(\r\n            {contextName, valueName, value, expectedTypeName, foundTypeName, messageSuffix}\r\n        ));\r\n    },\r\n\r\n    /**\r\n     * Gets the error message thrower seeded with passed in errorMessage template call.\r\n     * @function module:object.getErrorIfNotTypesThrower$\r\n     * @param errorMessageCall {Function|ErrorMessageCall}\r\n     * @param typeChecker {Function|TypeChecker} - Function<Type, value>:Boolean\r\n     * @returns {Function|ErrorIfNotTypes}\r\n     */\r\n    _getErrorIfNotTypesThrower = (errorMessageCall, typeChecker = _defaultTypeChecker) =>\r\n      (valueTypes, contextName, valueName, value) => {\r\n            const expectedTypeNames = valueTypes.map(getTypeName),\r\n                matchFound = valueTypes.some(ValueType => typeChecker(ValueType, value)),\r\n                foundTypeName = typeOf(value);\r\n            if (matchFound) { return value; }\r\n            throw new Error(\r\n                errorMessageCall({\r\n                    contextName, valueName, value,\r\n                    expectedTypeName: expectedTypeNames, foundTypeName\r\n                })\r\n            );\r\n        },\r\n\r\n    /**\r\n     * Checks that passed in `value` is of given `type`.  Throws an error if value\r\n     * is not of given `type`.  This is the un-curried version.  For the curried version\r\n     * see `module:object.errorIfNotType`.\r\n     * @function module:object.errorIfNotType$\r\n     * @param type {String|Function} - Type's name or type itself.\r\n     * @param contextName {String} - Name of context to attribute errors if thrown.\r\n     * @param valueName {String} - String rep of value.\r\n     * @param value {*}\r\n     * @param [messageSuffix=null] {String} - Optional.\r\n     * @returns {undefined}\r\n     * @uncurried\r\n     */\r\n    _errorIfNotType = _getErrorIfNotTypeThrower(defaultErrorMessageCall),\r\n\r\n    /**\r\n     * Checks that passed in `value` is of one of the given `types`.  Throws an error if value\r\n     *  is not of one of the given `types`.  This is the un-curried version.  For the curried version\r\n     * see `module:object.errorIfNotTypes`.\r\n     * @type {Function|module:object.errorIfNotTypes}\r\n     * @function module:object.errorIfNotTypes$\r\n     * @param types {Array} - Array of one or more types or type names themselves.\r\n     * @param contextName {String} - Name of context to attribute errors if thrown.\r\n     * @param valueName {String} - String rep of value.\r\n     * @param value {*}\r\n     * @returns {undefined}\r\n     * @uncurried\r\n     */\r\n    _errorIfNotTypes = _getErrorIfNotTypesThrower(defaultErrorMessageCall),\r\n\r\n    /**\r\n     * Same as `defaultTypeChecker$` except curried:\r\n     *  \"Returns a boolean indicating whether given value matches given type\".\r\n     * @curried\r\n     * @function module:object.defaultTypeChecker\r\n     * @param Type {String|Function} - Type name, constructor and/or class.\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    defaultTypeChecker = curry(_defaultTypeChecker),\r\n\r\n    /**\r\n     * Checks that passed in `value` is of given `type`.  Throws an error if value\r\n     * is not of given `type`.  Curried.\r\n     * @function module:object.errorIfNotType\r\n     * @param type {String|Function} - Type's name or type itself.\r\n     * @param contextName {String} - Name of context to attribute errors if thrown.\r\n     * @param valueName {String} - String rep of value.\r\n     * @param value {*}\r\n     * @param [messageSuffix=null] {String} - Optional.\r\n     * @returns {undefined}\r\n     * @curried\r\n     */\r\n    errorIfNotType = curry(_errorIfNotType),\r\n\r\n    /**\r\n     * Checks that passed in `value` is of one of the given `types`.  Throws an error if value\r\n     *  is not of one of the given `types`.  Curried.\r\n     * @function module:object.errorIfNotTypes\r\n     * @param types {Array} - Array of one or more types or type names themselves.\r\n     * @param contextName {String} - Name of context to attribute errors if thrown.\r\n     * @param valueName {String} - String rep of value.\r\n     * @param value {*}\r\n     * @returns {undefined}\r\n     * @curried\r\n     */\r\n    errorIfNotTypes = curry4(_errorIfNotTypes),\r\n\r\n    /**\r\n     * Returns a function that can be used to ensure that values are of a given type.\r\n     *   Also throws informative error messages containing the value types, names, expected type names,\r\n     *   etc.\r\n     * @function module:object.getErrorIfNotTypeThrower\r\n     * @param errorMessageCall {Function|ErrorMessageCall} - Template function (takes an info-object and returns a printed string).\r\n     * @returns {Function|ErrorIfNotType} - Returns a function with the same signature as `errorIfNotType` though curried.\r\n     */\r\n    getErrorIfNotTypeThrower = errorMessageCall => curry(_getErrorIfNotTypeThrower(errorMessageCall)),\r\n\r\n    /**\r\n     * Returns a function that can be used to ensure that a value is of one or more given types.\r\n     *   The returned function is used in cases where informative error messages\r\n     *   containing the value types, names, expected type names, are-required/should-be-used etc.\r\n     * @function module:object.getErrorIfNotTypesThrower\r\n     * @param errorMessageCall {Function|ErrorMessageCall} - Template function (takes an info-object and returns a printed string).\r\n     * @returns {Function|ErrorIfNotTypes} - Returns a function with the same signature as `errorIfNotTypes` though curried.\r\n     */\r\n    getErrorIfNotTypesThrower = errorMessageCall => curry4(_getErrorIfNotTypesThrower(errorMessageCall))\r\n;\r\n\r\n/**\r\n * @typedef {*} Any - Synonym for 'any value'.\r\n */\r\n\r\n/**\r\n * @typedef {String|Function} TypeRef\r\n * @description Type reference.  Type itself or Type's name;  E.g., `Type.name`;\r\n */\r\n\r\n/**\r\n * @typedef {Object<value, valueName, expectedTypeName, foundTypeName, messageSuffix>} TemplateContext\r\n * @description Template context used for error message renderers (functions that take a context obj and return a string).\r\n * @property value {*}\r\n * @property valueName {String}\r\n * @property expectedTypeName {String} - Expected name of constructor of `value`;  E.g., usually `SomeConstructor.name`;\r\n * @property foundTypeName {String} - Found types name;  E.g., `FoundConstructor.name`;\r\n * @property [messageSuffix=null] {*} - Message suffix (sometimes an extra hint or instructions for\r\n *  directing user to fix where his/her error has occurred).  Optional.\r\n */\r\n\r\n/**\r\n * @typedef {Array<(String|Function)>} TypesArray\r\n */\r\n\r\n/**\r\n * @typedef {Function} TypeChecker\r\n * @description Checks whether a value is of given type.\r\n * @param Type {TypeRef} - a Type or it's name;  E.g., `Type.name`.\r\n * @param value {*}\r\n * @returns {Boolean}\r\n */\r\n\r\n/**\r\n * @typedef {Function} ErrorMessageCall\r\n * @description Error message template function.\r\n * @param tmplContext {TemplateContext}\r\n * @returns {String}\r\n */\r\n\r\n/**\r\n * @typedef {Function} ErrorIfNotType\r\n * @description Used to ensure value matches passed in type.\r\n * @param type {TypeRef} - Constructor name or constructor.\r\n * @param contextName {String}\r\n * @param valueName {String}\r\n * @param value {*}\r\n * @throws {Error} - If value doesn't match type.\r\n * @returns {*} - What ever value is.\r\n */\r\n\r\n/**\r\n * @typedef {Function} ErrorIfNotTypes\r\n * @description Used to ensure a value matches one of one or more types passed in.\r\n * @param valueTypes {TypesArray} - Array of constructor names or constructors.\r\n * @param contextName {String}\r\n * @param valueName {String}\r\n * @param value {*}\r\n * @throws {Error} - If value doesn't match type.\r\n * @returns {*} - Whatever value is.\r\n */\r\n","export const\r\n\r\n    /**\r\n     * Clones and object or array using `JSON.parse(JSON.stringify(...))` pattern.\r\n     * @function module:object.jsonClone\r\n     * @param x {*}\r\n     * @returns {*}\r\n     */\r\n    jsonClone = x => JSON.parse(JSON.stringify(x))\r\n\r\n;\r\n","import {isArray, _isType} from './_is';\r\nimport {keys} from '../_jsPlatform/_object';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns an associated list from given object.\r\n     * @note Useful for working with plain javascript objects.\r\n     * @function module:object._toAssocList\r\n     * @param obj {(Object|Array|*)}\r\n     * @returns {Array.<*, *>}\r\n     */\r\n    toAssocList = obj => keys(obj).map(key => [key, obj[key]]),\r\n\r\n    /**\r\n     * Returns an associated list from given object (deeply (on incoming object's type)).\r\n     * @note Does deep conversion on all values of passed in type's type.\r\n     * @function module:object.toAssocListDeep\r\n     * @param obj {*}\r\n     * @param [TypeConstraint = Object] {(Constructor|Function)} - Type constraint to convert on.\r\n     * @returns {*}\r\n     */\r\n    toAssocListDeep = (obj, TypeConstraint = Object) => keys(obj).map(key =>\r\n        TypeConstraint && _isType(TypeConstraint, obj[key]) ?\r\n            [key, toAssocListDeep(obj[key], TypeConstraint)] :\r\n            [key, obj[key]]\r\n    ),\r\n\r\n    /**\r\n     * From associated list to object.\r\n     * @function module:object.fromAssocList\r\n     * @param xs {Array.<Array>} - Associated list.\r\n     * @param [OutType = Object] {Constructor|Function} - Output type.  Default `Object`.\r\n     * @returns {*} - Default is `Object`\r\n     */\r\n    fromAssocList = (xs, OutType = Object) => xs.reduce((agg, [key, value]) => {\r\n        agg[key] = value;\r\n        return agg;\r\n    }, new OutType()),\r\n\r\n    /**\r\n     * From associated list to object.\r\n     * @note Considers array of arrays associated lists.\r\n     * @function module:object.fromAssocList\r\n     * @param xs {Array.<Array>} - Associated list.\r\n     * @param [OutType = Object] {Constructor|Function} - Output type.  Default `Object`.\r\n     * @returns {*} - Default is `Object`\r\n     */\r\n    fromAssocListDeep = (xs, OutType = Object) => xs.reduce((agg, [key, value]) => {\r\n        if (isArray(value) && isArray(value[0])) {\r\n            agg[key] = fromAssocListDeep(value, OutType);\r\n            return agg;\r\n        }\r\n        agg[key] = value;\r\n        return agg;\r\n    }, new OutType()),\r\n\r\n    /**\r\n     * Returns an array map (associated list) representing incoming value (object, array, etc.).\r\n     * @alias `toAssocList`\r\n     * @function module:object.toArrayMap\r\n     * @param obj {(Object|Array|*)}\r\n     * @deprecated\r\n     * @returns {*}\r\n     */\r\n    toArrayMap = toAssocList,\r\n\r\n    /**\r\n     * Converts an array-map into an object (one level).\r\n     * @alias `fromAssocList`\r\n     * @function module:object.fromArrayMap\r\n     * @param xs {Array|*} - Array-map (associated list).\r\n     * @deprecated\r\n     * @returns {*}\r\n     */\r\n    fromArrayMap = fromAssocList\r\n\r\n;\r\n","import {typeOf} from './_typeOf';\r\nimport {toAssocList} from './_assocList';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Converts incoming value to an array.\r\n     * @note For `WeakMap`, `WeakSet`, `Map` and `Set` result is the same as calling `Array.from` on such.\r\n     * @note For `null`, `undefined`, `NaN`, `Number{}`, `Symbol{}`, `Boolean{}` returns an empty array.\r\n     * @note Method does a shallow conversion;\r\n     * @function module:object.toArray\r\n     * @param x {*} - Thing to convert from.\r\n     * @returns {Array}\r\n     */\r\n    toArray = x => {\r\n        switch (typeOf(x)) {\r\n            case 'Null':\r\n            case 'Undefined':\r\n                return [];\r\n            case String.name:\r\n            case Array.name:\r\n            case 'WeakMap':\r\n            case 'WeakSet':\r\n            case 'Map':\r\n            case 'Set':\r\n                return Array.from(x);\r\n            case Object.name:\r\n            default:\r\n                return toAssocList(x);\r\n        }\r\n    }\r\n\r\n;\r\n","/**\r\n * @module _object\r\n * @description Object operations (un-curried).\r\n * @private\r\n */\r\nexport * from '../_jsPlatform/_object';\r\nexport * from './_prop';\r\nexport * from './_typeOf';\r\nexport * from './_is';\r\nexport * from './_of';\r\nexport * from './_fromNamespace';\r\nexport * from './_assignDeep';\r\nexport * from './_setTheory';\r\nexport * from './_console';\r\nexport * from './_errorThrowing';\r\nexport * from './_jsonClone';\r\nexport * from './_toArray';\r\nexport * from './_assocList';\r\n","/**\r\n * @module object\r\n */\r\nimport {curry, curry2} from './uncurried/_function/_curry';\r\nimport {_fromNamespace} from './uncurried/_object/_fromNamespace';\r\nimport {_instanceOf, _hasOwnProperty, _assign} from './uncurried/_jsPlatform/_object';\r\nimport {_prop, _isType} from './uncurried/_object/_object';\r\nimport {_assignDeep} from './uncurried/_object/_assignDeep';\r\nimport {\r\n    _objUnion, _objComplement, _objIntersect, _objDifference}\r\n    from './uncurried/_object/_setTheory';\r\n\r\nexport * from './uncurried/_object/_object';\r\n\r\nexport {length, keys} from './uncurried/_jsPlatform/_object';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Gives `undefined` or prop value if it is available.\r\n     * @function module:object.prop\r\n     * @param propName {String}\r\n     * @param obj {*} - Object to search.\r\n     * @returns {*|undefined}\r\n     * @curried\r\n     */\r\n    prop = curry(_prop),\r\n\r\n    /**\r\n     * `instanceof` in function form.\r\n     * @function module:object.instanceOf\r\n     * @param instance {*}\r\n     * @param Type {Function}\r\n     * @returns {Boolean}\r\n     * @curried\r\n     */\r\n    instanceOf = curry(_instanceOf),\r\n\r\n    /**\r\n     * `hasOwnProperty` as a method (takes object last).\r\n     * @function module:object.hasOwnProperty\r\n     * @param propName {String}\r\n     * @param obj {*} - Object to search.\r\n     * @returns {Boolean}\r\n     * @curried\r\n     */\r\n    hasOwnProperty = curry(_hasOwnProperty),\r\n\r\n    /**\r\n     * `Object.assign` if it is available else a shim.\r\n     * @function module:object.assign\r\n     * @param [...obj]{Object} - One or more objects to merge onto first object.\r\n     * @returns {Object}\r\n     * @curried - Called after having two or more args\r\n     */\r\n    assign = curry2(_assign),\r\n\r\n    /**\r\n     * Same as `Object.assign` except does a deep merge.\r\n     * @function module:object.assignDeep\r\n     * @param [...obj]{Object} - One or more objects to deep merge onto first object.\r\n     * @returns {Object}\r\n     * @curried - Called after having two or more args\r\n     */\r\n    assignDeep = curry2(_assignDeep),\r\n\r\n    /**\r\n     * Cartesian union for objects (operates on two objects).\r\n     * @function module:object.objUnion\r\n     * @param obj1 {Object}\r\n     * @param obj2 {Object}\r\n     * @returns {Object} - Unified obj.\r\n     * @curried\r\n     */\r\n    objUnion = curry(_objUnion),\r\n\r\n    /**\r\n     * Returns the cartesian intersection of two objects.\r\n     * @function module:object.objIntersect\r\n     * @param obj1 {Object}\r\n     * @param obj2 {Object}\r\n     * @returns {Object} - Intersection of given objects.\r\n     * @curried\r\n     */\r\n    objIntersect = curry(_objIntersect),\r\n\r\n    /**\r\n     * Returns the cartesian difference of two objects.\r\n     * @function module:object.objDifference\r\n     * @param obj1 {Object}\r\n     * @param obj2 {Object}\r\n     * @returns {Object} - Difference of given objects.\r\n     * @curried\r\n     */\r\n    objDifference = curry(_objDifference),\r\n\r\n    /**\r\n     * Returns the cartesian complement of one or more objects on given object.\r\n     * @function module:object.objDifference\r\n     * @param obj {Object}\r\n     * @param [...obj]{Object} - One or more objects to calculate complement from.\r\n     * @returns {Object} - Complement of given objects.\r\n     * @curried\r\n     */\r\n    objComplement = curry2(_objComplement),\r\n\r\n    /**\r\n     * Returns a boolean indicating whether a value is of given type or not.\r\n     * @function module:object.isType\r\n     * @param Type {Function|String} - Constructor or constructor name\r\n     * @param value {*}\r\n     * @return {Boolean}\r\n     */\r\n    isType = curry(_isType),\r\n\r\n    /**\r\n     * Gives you value at key/namespace-key;  E.g.,\r\n     * ```\r\n     *   fromNamespace('all.your.base', {all: {your: {base: 99}}}) === 99\r\n     * ```\r\n     * @note same as `_fromNamespace` except, is curried\r\n     * @function module:object.fromNamespace\r\n     * @param nsString {String}\r\n     * @param obj {*}\r\n     * @returns {*}\r\n     * @curried\r\n     */\r\n    fromNamespace = curry(_fromNamespace)\r\n\r\n;\r\n","export const\r\n\r\n    /**\r\n     * Run `operation` until predicate returns `true`.\r\n     * @function module:_function._until\r\n     * @param predicate {Function} :: a -> Boolean\r\n     * @param operation {Function} :: a -> a\r\n     * @param typeInstance {*} :: * - A monoidal zero or some starting point.\r\n     * @returns {*} - What ever type `typeInstance` is\r\n     */\r\n    until = (predicate, operation, typeInstance) => {\r\n        let result = typeInstance;\r\n        while (!predicate(result)) {\r\n            result = operation(result);\r\n        }\r\n        return result;\r\n    };\r\n","import {reverse} from '../_jsPlatform/_array';\r\nimport {apply, call} from '../_jsPlatform/_function';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Flips a functions arguments order and returns a new function requiring such (arguments in reverse order).\r\n     * @function module:_function.flipN\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    flipN = fn => (...args) => apply(fn, reverse(args)),\r\n\r\n    /**\r\n     * Returns a function that receives 3 args in reverse (3, 2, 1 etc.).\r\n     * @function module:_function.flip3\r\n     * @param fn {Function} - Function<a, b, c>\r\n     * @returns {Function} - Function<c, b, a>\r\n     */\r\n    flip3 = fn => (a, b, c) => call(fn, c, b, a),\r\n\r\n    /**\r\n     * Returns a function that receives 4 args in reverse (4, 3, 2, 1 etc.).\r\n     * @function module:_function.flip4\r\n     * @param fn {Function} - Function<a, b, c, d>\r\n     * @returns {Function} - Function<d, c, b, a>\r\n     */\r\n    flip4 = fn => (a, b, c, d) => call(fn, d, c, b, a),\r\n\r\n    /**\r\n     * Returns a function that receives 5 args in reverse (5, 4, 3, 2, 1 etc.).\r\n     * @function module:_function.flip5\r\n     * @param fn {Function} - Function<a, b, c, d, e>\r\n     * @returns {Function} - Function<e, d, c, b, a>\r\n     */\r\n    flip5 = fn => (a, b, c, d, e) => call(fn, e, d, c, b, a),\r\n\r\n    /**\r\n     * Flips a _function's first and second arguments and and returns a new _function requiring said arguments in reverse.\r\n     * @function module:_function.flip\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    flip = fn => (b, a) => call(fn, a, b);\r\n","/**\r\n * @memberOf _function\r\n * @author elydelacruz\r\n * @created 12/6/2016.\r\n * @description Curry implementation with place holder concept (`__`).\r\n * @todo Make code here more minimal (reuse small parts here).\r\n */\r\n\r\nimport {apply, concat, map, filter, length} from '../_jsPlatform/_jsPlatform';\r\nimport {fnOrError} from '../_object/_utils';\r\n\r\n/**\r\n * PlaceHolder (__) constructor.\r\n * @constructor PlaceHolder\r\n * @private\r\n */\r\nconst PlaceHolder = function PlaceHolder() {},\r\n\r\n    notFnErrPrefix = '`fn` in `curry_(fn, ...args)`',\r\n\r\n    /**\r\n     * Placeholder instance.\r\n     * @type {PlaceHolder}\r\n     * @private\r\n     */\r\n    placeHolderInstance = new PlaceHolder();\r\n\r\n/**\r\n * Checks to see if value is a `PlaceHolder`.\r\n * @param instance {*}\r\n * @returns {boolean}\r\n * @private\r\n */\r\nfunction isPlaceHolder (instance) {\r\n    return instance instanceof PlaceHolder;\r\n}\r\n\r\n/**\r\n * Replaces `placeholder` values in `_list`.\r\n * @function replacePlaceHolder\r\n * @private\r\n * @param array {Array} - Array to replace placeholders in.\r\n * @param args {Array} - Args from to choose from to replace placeholders.\r\n * @returns {Array|*} - Returns passed in `_list` with placeholders replaced by values in `args`.\r\n */\r\nfunction replacePlaceHolders (array, args) {\r\n    let out = map(element => {\r\n            if (!isPlaceHolder(element)) { return element; }\r\n            else if (length(args)) { return args.shift(); }\r\n            return element;\r\n        }, array);\r\n    return length(args) ? concat(out, args) : out;\r\n}\r\n\r\n/**\r\n * Curries passed in function up to given arguments length (can enforce arity via placeholder values (`__`)).\r\n * @function module:_function.curry_\r\n * @param fn {Function}\r\n * @param argsToCurry {...*}\r\n * @returns {Function}\r\n */\r\nexport function curry_ (fn, ...argsToCurry) {\r\n    return curryN_(fnOrError(notFnErrPrefix, fn).length, fn, ...argsToCurry);\r\n}\r\n\r\n/**\r\n * Curries a _function up to given arity also enforces arity via placeholder values (`__`).\r\n * @function module:_function.curryN_\r\n * @param executeArity {Number}\r\n * @param fn {Function}\r\n * @param curriedArgs {...*} - Allows `Placeholder` (`__`) values.\r\n * @returns {Function} - Passed in _function wrapped in a _function for currying.\r\n */\r\nexport function curryN_ (executeArity, fn, ...curriedArgs) {\r\n    return (...args) => {\r\n        let concatedArgs = replacePlaceHolders(curriedArgs, args),\r\n            placeHolders = filter(isPlaceHolder, concatedArgs),\r\n            canBeCalled = (length(concatedArgs) - length(placeHolders) >= executeArity) || !executeArity;\r\n        return !canBeCalled ?\r\n            apply(curryN_, concat([executeArity, fnOrError(notFnErrPrefix, fn)], concatedArgs)) :\r\n            apply(fnOrError(notFnErrPrefix, fn), concatedArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * Place holder object (frozen) used by curry.\r\n * @memberOf _function\r\n * @type {PlaceHolder}\r\n */\r\nexport let __ = Object.freeze ? Object.freeze(placeHolderInstance) : placeHolderInstance,\r\n\r\n    /**\r\n     * Curries a _function up to an arity of 2 (takes into account placeholders `__` (arity enforcers)) (won't call _function until 2 or more args).\r\n     * @function module:_function.curry2_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry2_ = fn => curryN_(2, fn),\r\n\r\n    /**\r\n     * Curries a _function up to an arity of 3 (takes into account placeholders `__` (arity enforcers)) (won't call _function until 3 or more args).\r\n     * @function module:_function.curry3_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry3_ = fn => curryN_(3, fn),\r\n\r\n    /**\r\n     * Curries a _function up to an arity of 4 (takes into account placeholders `__` (arity enforcers))  (won't call _function until 4 or more args).\r\n     * @function module:_function.curry4_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry4_ = fn => curryN_(4, fn),\r\n\r\n    /**\r\n     * Curries a _function up to an arity of 5  (takes into account placeholders `__` (arity enforcers))  (won't call _function until 5 or more args).\r\n     * @function module:_function.curry5_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry5_ = fn => curryN_(5, fn)\r\n\r\n;\r\n","/**\r\n * @memberOf _function\r\n */\r\n\r\n/**\r\n * Returns passed in parameter.\r\n * @haskellType `id :: a -> a`\r\n * @function module:function.id\r\n * @param x {*}\r\n * @returns {*}\r\n */\r\nexport const id = x => x;\r\n","import {reduceRight} from '../_jsPlatform/_array';\r\n\r\n/**\r\n * Composes all functions passed in from right to left passing each functions return value to\r\n * the function on the left of itself.\r\n * @function module:_function.compose\r\n * @type {Function}\r\n * @param args {...{Function}}\r\n * @returns {Function}\r\n */\r\nexport const compose = (...args) =>\r\n        arg0 => reduceRight((value, fn) => fn(value), arg0, args);\r\n","/**\r\n * Function operations: `\r\n * @module function\r\n */\r\n\r\nimport {curry, curry2, curry3} from './uncurried/_function/_curry';\r\n\r\nimport {\r\n    apply as _apply,\r\n    call as _call, reverse\r\n} from './uncurried/_jsPlatform/_jsPlatform';\r\n\r\nimport {\r\n    until as _until\r\n} from './uncurried/_function/_until';\r\n\r\nimport {\r\n    flip as _flip,\r\n    flipN as _flipN,\r\n    flip3 as _flip3,\r\n    flip4 as _flip4,\r\n    flip5 as _flip5\r\n} from './uncurried/_function/_flip';\r\n\r\nexport * from './uncurried/_function/_curry';\r\nexport * from './uncurried/_function/__curry';\r\nexport * from './uncurried/_function/_negate';\r\nexport * from './uncurried/_function/_id';\r\nexport * from './uncurried/_function/_compose';\r\n\r\nexport {_apply, _call, _until, _flip, _flip3, _flip4, _flip5,  _flipN};\r\n\r\nexport const\r\n\r\n    /**\r\n     * Functional `apply` function (takes no context).\r\n     * @function module:function.apply\r\n     * @param fn {Function}\r\n     * @param [args] {Array<*>}\r\n     * @returns {*}\r\n     * @curried - Triggered at 2 or more args.\r\n     */\r\n    apply = curry(_apply),\r\n\r\n    /**\r\n     * Functional `call` function (takes no context).\r\n     * @function module:function.call\r\n     * @param fn {Function}\r\n     * @param [args] {...*}\r\n     * @returns {*}\r\n     * @curried\r\n     */\r\n    call = curry2(_call),\r\n\r\n    /**\r\n     * Run `operation` `until` predicate returns `true`.\r\n     * @function module:function.until\r\n     * @param predicate {Function} :: a -> Boolean\r\n     * @param operation {Function} :: a -> a\r\n     * @param typeInstance {*} :: * - A monoidal zero or some starting point.\r\n     * @returns {*} - What ever type `typeInstance` is\r\n     * @curried\r\n     */\r\n    until = curry(_until),\r\n\r\n    /**\r\n     * Flips a functions arguments order and returns a new function requiring such (arguments in reverse order).\r\n     * @function module:function.flipN\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     * @curried - Triggered at 3 or more (args).\r\n     */\r\n    flipN = fn => curry3((...args) => apply(fn, reverse(args))),\r\n\r\n    /**\r\n     * Flips a function's first and second arguments and and returns a new function requiring said arguments in reverse.\r\n     * @function module:function.flip\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     * @curried\r\n     */\r\n    flip = fn => curry(_flip(fn)),\r\n\r\n    /**\r\n     * Returns a function that receives 3 args in reverse (3, 2, 1 etc.).\r\n     * @function module:function.flip3\r\n     * @param fn {Function} - Function<a, b, c>\r\n     * @returns {Function} - Function<c, b, a>\r\n     * @curried\r\n     */\r\n    flip3 = fn => curry(_flip3(fn)),\r\n\r\n    /**\r\n     * Returns a function that receives 4 args in reverse (4, 3, 2, 1 etc.).\r\n     * @function module:function.flip4\r\n     * @param fn {Function} - Function<a, b, c, d>\r\n     * @returns {Function} - Function<d, c, b, a>\r\n     * @curried\r\n     */\r\n    flip4 = fn => curry(_flip4(fn)),\r\n\r\n    /**\r\n     * Returns a function that receives 5 args in reverse (5, 4, 3, 2, 1 etc.).\r\n     * @function module:function.flip5\r\n     * @param fn {Function} - Function<a, b, c, d, e>\r\n     * @returns {Function} - Function<e, d, c, b, a>\r\n     * @curried\r\n     */\r\n    flip5 = fn => curry(_flip5(fn));\r\n\r\n    /**\r\n     * Curries a function based on it's defined arity (argument's arrayOps expected length).\r\n     * @function module:function.curry\r\n     * @param fn {Function}\r\n     * @param argsToCurry {...*}\r\n     * @returns {Function}\r\n     * @curried\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to a given arity.\r\n     * @function module:function.curryN\r\n     * @param executeArity {Number}\r\n     * @param fn {Function}\r\n     * @param curriedArgs {...*}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to an arity of 2 (won't call function until 2 or more args).\r\n     * @function module:function.curry2\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to an arity of 3 (won't call function until 3 or more args).\r\n     * @function module:function.curry3\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to an arity of 4 (won't call function until 4 or more args).\r\n     * @function module:function.curry4\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to an arity of 5 (won't call function until 5 or more args).\r\n     * @function module:function.curry5\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries passed in function up to given arguments length (can enforce arity via placeholder values (`__`)).\r\n     * @function module:function.curry_\r\n     * @param fn {Function}\r\n     * @param argsToCurry {...*}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to given arity also enforces arity via placeholder values (`__`).\r\n     * @function module:function.curryN_\r\n     * @param executeArity {Number}\r\n     * @param fn {Function}\r\n     * @param curriedArgs {...*} - Allows `Placeholder` (`__`) values.\r\n     * @returns {Function} - Passed in function wrapped in a function for currying.\r\n     */\r\n\r\n    /**\r\n     * Place holder object (frozen) used by curry.\r\n     * @memberOf function\r\n     * @type {PlaceHolder}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to an arity of 2 (takes into account placeholders `__` (arity enforcers))\r\n     * (won't call function until 2 or more args (not counting placeholder (`__`) value).\r\n     * @function module:function.curry2_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to an arity of 3 (takes into account placeholders `__` (arity enforcers))\r\n     * (won't call function until 3 or more args (not counting placeholder (`__`) value).\r\n     * @function module:function.curry3_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to an arity of 4 (takes into account placeholders `__` (arity enforcers))\r\n     * (won't call function until 4 or more args (not counting placeholder (`__`) value).\r\n     * @function module:function.curry4_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Curries a function up to an arity of 5  (takes into account placeholders `__` (arity enforcers))\r\n     * (won't call function until 5 or more args (not counting placeholder (`__`) value).\r\n     * @function module:function.curry5_\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Takes a function that takes two parameters and returns a negated version of given\r\n     * function.\r\n     * @function module:function.negateF\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Takes a function that takes three parameters and returns a\r\n     * negated version of given function.\r\n     * @function module:function.negateF3\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Takes a function that takes four parameters and returns a\r\n     * negated version of given function.\r\n     * @function module:function.negateF4\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Takes a function that takes four parameters and returns a\r\n     * negated version of given function.\r\n     * @function module:function.negateF5\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Negates a javascript-'generic' predicate; `Function<element, index, list>`.\r\n     * @function module:function.negateP\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Returns a new function which is the dual of `fn` (or the negated version of `fn`).\r\n     * @function module:function.negateFMany\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n\r\n    /**\r\n     * Composes all functions passed in from right to left passing each functions return value to\r\n     * the function on the left of itself.\r\n     * @function module:function.compose\r\n     * @param args {...Function}\r\n     * @returns {Function}\r\n     */\r\n","/**\r\n * @module _function\r\n * @private\r\n */\r\nexport * from '../_jsPlatform/_function';\r\nexport * from './_compose';\r\nexport * from './_curry';\r\nexport * from './__curry';\r\nexport * from './_flip';\r\nexport * from './_id';\r\nexport * from './_negate';\r\nexport * from './_until';\r\n","/**\r\n * Created by elydelacruz on 7/22/2017.\r\n * @module utils\r\n * @private\r\n */\r\n\r\nimport {curry, curry2} from './uncurried/_function/_curry';\r\nexport * from './uncurried/_object/_utils';\r\nexport const\r\n\r\n    fPureTakesOne_ = name => curry((arg, f) => f[name](arg)),\r\n\r\n    fPureTakes2_ = name => curry((arg1, arg2, f) => f[name](arg1, arg2)),\r\n\r\n    fPureTakesOneOrMore_ = name => curry2((f, ...args) => f[name](...args))\r\n;\r\n","/**\r\n * Created by elyde on 7/20/2017.\r\n * Curried functional versions of common array methods (`filter`, `map`, etc.).\r\n * @module jsPlatform_array\r\n * @private\r\n */\r\n\r\nimport {fPureTakesOne_, fPureTakes2_, fPureTakesOneOrMore_} from '../utils';\r\n\r\n/**\r\n * Reverses a list (shimmed if not exists).\r\n * @function module:jsPlatform_array.reverse\r\n * @return {Array}\r\n */\r\nexport {reverse} from '../uncurried/_jsPlatform/_array';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Maps a function to functor (lists etc.).\r\n     * @function module:jsPlatform_array.map\r\n     * @param fn {Function}\r\n     * @param functor {Array|{map: {Function}}}\r\n     * @returns {Array|{map: {Function}}}\r\n     */\r\n    map = fPureTakesOne_('map'),\r\n\r\n    /**\r\n     * Filters a functor (lists etc.) with passed in function.\r\n     * @function module:jsPlatform_array.filter\r\n     * @param fn {Function}\r\n     * @param functor {Array|{filter: {Function}}}\r\n     * @returns {Array|{filter: {Function}}}\r\n     */\r\n    filter = fPureTakesOne_('filter'),\r\n\r\n    /**\r\n     * Reduces a foldable (lists etc.) with passed in function.\r\n     * @function module:jsPlatform_array.reduce\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduce: {Function}}}\r\n     * @returns {Array|{reduce: {Function}}}\r\n     */\r\n    reduce = fPureTakes2_('reduce'),\r\n\r\n    /**\r\n     * Reduces a foldable (lists etc.) from the right with passed in function.\r\n     * @function module:jsPlatform_array.reduceRight\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduceRight: {Function}}}\r\n     * @returns {Array|{reduceRight: {Function}}}\r\n     */\r\n    reduceRight = fPureTakes2_('reduceRight'),\r\n\r\n    /**\r\n     * For each on functor (Array|Object|etc.).\r\n     * @function module:jsPlatform_array.forEach\r\n     * @param fn {Function}\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type of object you pass in unless it doesn't have a `forEach` method.\r\n     * @throws {Error} - When passed in functor doesn't have a `forEach` method.\r\n     */\r\n    forEach = fPureTakesOne_('forEach'),\r\n\r\n    /**\r\n     * Returns `true` if `fn` (predicate) returns true for at least one item\r\n     * in functor else returns `false`.\r\n     * @function module:jsPlatform_array.some\r\n     * @param fn {Function} - Predicate.\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have a `some` method.\r\n     */\r\n    some = fPureTakesOne_('some'),\r\n\r\n    /**\r\n     * Returns `true` if `fn` (predicate) returns true for all items in functor else returns `false`.\r\n     * @function module:jsPlatform_array.every\r\n     * @param fn {Function} - Predicate.\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have an `every` method.\r\n     */\r\n    every = fPureTakesOne_('every'),\r\n\r\n    /**\r\n     * Array.prototype.join\r\n     * @function module:jsPlatform_array.join\r\n     * @param separator {String|RegExp}\r\n     * @param arr {Array}\r\n     * @returns {String}\r\n     */\r\n    join = fPureTakesOne_('join'),\r\n\r\n    /**\r\n     * Same as Array.prototype.push\r\n     * @function module:jsPlatform_array.push\r\n     * @param item {*}\r\n     * @param arr {Array}\r\n     * @returns {Number}\r\n     */\r\n    push = fPureTakesOneOrMore_('push');\r\n","/**\r\n * List operations that overlap (apart from globally overlapping props and functions like `length`)\r\n * on both strings and arrays.\r\n * @module jsPlatform_list\r\n * @private\r\n */\r\n\r\nimport {curry} from '../uncurried/_function/_curry';\r\n\r\nimport {\r\n    concat as concat_,\r\n    slice as slice_,\r\n    includes as includes_,\r\n    indexOf as indexOf_,\r\n    lastIndexOf as lastIndexOf_ } from '../uncurried/_jsPlatform/_list';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Concats/appends all functors onto the end of first functor.\r\n     * Note:  functors passed in after the first one must be of the same type.\r\n     * @function module:jsPlatform_array.concat\r\n     * @param functor {Array|Object|*}\r\n     * @param ...functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have an `every` method.\r\n     */\r\n    concat = curry(concat_),\r\n\r\n    /**\r\n     * Same as Array.prototype.slice\r\n     * @function module:jsPlatform_array.slice\r\n     * @param separator {String|RegExp}\r\n     * @param arr{Array}\r\n     * @returns {Array}\r\n     */\r\n    slice = curry(slice_),\r\n\r\n    includes = curry(includes_),\r\n\r\n    indexOf = curry(indexOf_),\r\n\r\n    lastIndexOf = curry(lastIndexOf_)\r\n\r\n;\r\n","/**\r\n * Created by elydelacruz on 9/6/2017.\r\n * @module jsPlatform_string\r\n * @private\r\n */\r\n\r\nimport {curry} from '../uncurried/_function/_curry';\r\n\r\nimport {split as _split} from '../uncurried/_jsPlatform/_string';\r\n\r\n/**\r\n * Functional version of `String.prototype.split`.\r\n * @curried\r\n * @function module:jsPlatform_string.split\r\n * @param separator {String|RegExp}\r\n * @param str {String}\r\n * @returns {Array}\r\n */\r\nexport const split = curry(_split);\r\n","/**\r\n * @module jsPlatform\r\n * @private\r\n */\r\n\r\nexport * from './jsPlatform/array';\r\nexport * from './jsPlatform/list';\r\nexport * from './jsPlatform/string';\r\n","/**\r\n * List operators.\r\n * @module list\r\n */\r\nimport {curry, curry2} from './uncurried/_function/_function';\r\n\r\nimport {\r\n    _append, _appendMany, _head, _last, _tail, _init, _uncons, _unconsr,\r\n    _map, _concat, _concatMap, _reverse, _intersperse, _intercalate, _transpose,\r\n    _subsequences, _swapped, _permutations, _foldl, _foldl1,\r\n    _foldr, _foldr1, _unfoldr, _mapAccumL, _mapAccumR, _iterate, _repeat,\r\n    _replicate, _cycle, _findIndex, _findIndices, _elemIndex, _elemIndices,\r\n    _take, _drop, _splitAt, _takeWhile, _dropWhile, _dropWhileEnd, _span,\r\n    _breakOnList, _at, _find, _filter, _partition, _elem, _notElem, _lookup,\r\n    _isPrefixOf, _isSuffixOf, _isInfixOf, _isSubsequenceOf, _group, _groupBy,\r\n    _inits, _tails, _stripPrefix, _zip, _zipN, _zip3, _zip4, _zip5, _zipWith,\r\n    _zipWithN, _zipWith3, _zipWith4, _zipWith5, _unzip, _unzipN, _any, _all,\r\n    _and, _or, _not, _sum, _product, _maximum, _minimum, _scanl, _scanl1, _scanr, _scanr1,\r\n    _nub, _remove, _sort, _sortOn, _sortBy, _insert, _insertBy, _nubBy, _removeBy,\r\n    _removeFirstsBy, _unionBy, _union, _intersect, _intersectBy, _difference,\r\n    _complement\r\n} from './uncurried/_list/_list';\r\n\r\n// Export single arity methods\r\nexport {\r\n    _and as and, _or as or, _not as not, _zipN as zipN, _unzip as unzip, _unzipN as unzipN,\r\n    _concat as concat, _reverse as reverse, _transpose as transpose,\r\n    _subsequences as subsequences, _permutations as permutations,\r\n    _group as group, _tails as tails, _sum as sum, _product as product,\r\n    _maximum as maximum, _minimum as minimum, _sort as sort, _nub as nub,\r\n    _head as head, _last as last, _tail as tail, _init as init, _inits as inits,\r\n    _uncons as uncons, _unconsr as unconsr,\r\n    _swapped as swapped\r\n};\r\n\r\nexport {slice, includes, indexOf, lastIndexOf, split, push} from './jsPlatform';\r\n\r\nexport * from './uncurried/_list/_list';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Append two lists, i.e.,\r\n     * @example\r\n     * append([x1, ..., xm], [y1, ..., yn]) // outputs: [x1, ..., xm, y1, ..., yn]\r\n     * append([x1, ..., xm], [y1, ...]) // outputs: [x1, ..., xm, y1, ...]\r\n     * @function module:list.append\r\n     * @param xs1 {Array|String|*} - list or list like.\r\n     * @param xs2 {Array|String|*} - list or list like.\r\n     * @returns {Array|String|*} - Same type as list like passed in.\r\n     */\r\n    append = curry(_append),\r\n\r\n    /**\r\n     * Append two or more lists, i.e., same as `append` but for two ore more lists.\r\n     * @haskellType `appendMany :: List a => a -> [a] -> a\r\n     * @note In `@haskellType` we wrote `[a]` only to keep the haskell type valid though note in javascript\r\n     *  this is actually different since the function converts the zero ore more parameters into an array containing such for us.\r\n     * @function module:list.appendMany\r\n     * @param x {Array|String|*}\r\n     * @param args ...{Array|String|*} - Lists or lists likes.\r\n     * @returns {Array|String|*} - Same type as first list or list like passed in.\r\n     */\r\n    appendMany = curry2(_appendMany),\r\n\r\n    /**\r\n     * Map a function over all the elements of a container and concatenate the resulting lists.\r\n     * @haskellType `concatMap :: Foldable t => (a -> [b]) -> t a -> [b]`\r\n     * @function module:list.concatMap\r\n     * @param fn {Function}\r\n     * @param foldableOfA {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    concatMap = curry2(_concatMap),\r\n\r\n    /**\r\n     * @function module:list.map\r\n     * @param fn {Function} - Function to map on functor item(s).\r\n     * @param xs {Array|String|*} - Functor.\r\n     * @returns {Array|String|*} - Functor type that is passed in.\r\n     */\r\n    map = curry(_map),\r\n\r\n    /**\r\n     * Takes an element and a list and `intersperses' that element between the elements of the list. For example\r\n     * @function module:list.intersperse\r\n     * @note In our version of the function javascript is loosely typed so, so is our function (to much overhead to make\r\n     *  it typed) so `between` can be any value.\r\n     * @param between {*} - Should be of the same type of elements contained in list.\r\n     * @param arr {Array|String|*} - List.\r\n     * @returns {Array|String|*}\r\n     */\r\n    intersperse = curry(_intersperse),\r\n\r\n    /**\r\n     * `intercalate xs xss` is equivalent to (concat (intersperse xs xss)). It inserts the list xs in between the lists in xss and concatenates the result.\r\n     * @haskellType `intercalate :: [a] -> [[a]] -> [a]`\r\n     * @function module:list.intercalate\r\n     * @param xs {Array|String|*}\r\n     * @param xss {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    intercalate = curry(_intercalate),\r\n\r\n    /**\r\n     * Reduces a foldable (list etc.) with passed in function.\r\n     * @function module:list.foldl\r\n     * @param fn {Function}\r\n     * @param zero {*} - Aggregator.\r\n     * @param functor {Array|String|*}\r\n     * @returns {*} - Usually same type as aggregate (`zero`) (depends on `fn`).\r\n     */\r\n    foldl = curry(_foldl),\r\n\r\n    /**\r\n     * Reduces a foldable (list etc.) from right to left with passed in function.\r\n     * @function module:list.foldr\r\n     * @param fn {Function}\r\n     * @param zero {*} - Aggregator.\r\n     * @param functor {Array|{reduce: {Function}}}\r\n     * @returns {*} - Usually same type as aggregate (`zero`) (depends on `fn`).\r\n     */\r\n    foldr = curry(_foldr),\r\n\r\n    /**\r\n     * Reduces a foldable (list etc.) with passed in function.\r\n     * @function module:list.foldl1\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduce: {Function}}}\r\n     * @returns {*}\r\n     */\r\n    foldl1 = curry(_foldl1),\r\n\r\n    /**\r\n     * Reduces a foldable (list etc.) from right to left with passed in function.\r\n     * @function module:list.foldr1\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduce: {Function}}}\r\n     * @returns {*}\r\n     */\r\n    foldr1 = curry(_foldr1),\r\n\r\n    /**\r\n     * Performs a map then a reduce all in one (from left-to-right). Returns a tuple\r\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\r\n     * @function module:list.mapAccumL\r\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\r\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\r\n     * @param xs {Array|String|*} - list type.\r\n     * @return {Array} - [aggregated, list]\r\n     */\r\n    mapAccumL = curry(_mapAccumL),\r\n\r\n    /**\r\n     * Performs a map and a reduce all in one (from right-to-left). Returns a tuple\r\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\r\n     * @function module:list.mapAccumR\r\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\r\n     * @param zero {*} - An instance of the passed in list type used to aggregate on.\r\n     * @param xs {Array|String|*} - list type.\r\n     * @return {Array} - [aggregated, list]\r\n     */\r\n    mapAccumR = curry(_mapAccumR),\r\n\r\n    /**\r\n     * Iterate on value (`x`) with `op` up to `limit`.\r\n     * @function module:list.iterate\r\n     * @param limit {Number}\r\n     * @param op {Function} - Operation\r\n     * @param x {*} - Starting point.\r\n     * @returns {*}\r\n     */\r\n    iterate = curry(_iterate),\r\n\r\n    /**\r\n     * Repeats `x` `limit` number of times.\r\n     * @function module:list.repeat\r\n     * @param limit {Number}\r\n     * @param x {*}\r\n     * @return {Array}\r\n     */\r\n    repeat = curry(_repeat),\r\n\r\n    /**\r\n     * Same as `repeat` due to the nature of javascript (see haskell version for usage).\r\n     * @function module:list.replicate\r\n     * @param limit {Number}\r\n     * @param x {*}\r\n     * @return {Array}\r\n     */\r\n    replicate = curry(_replicate),\r\n\r\n    /**\r\n     * Replicates a list `limit` number of times and appends the results (concat)\r\n     * @function module:list.cycle\r\n     * @param limit {Number}\r\n     * @param xs {Array}\r\n     * @returns {Array}\r\n     */\r\n    cycle = curry(_cycle),\r\n\r\n    /**\r\n     * Unfolds a value into a list of somethings.\r\n     * @haskellType `unfoldr :: (b -> Maybe (a, b)) -> b -> [a]`\r\n     * @function module:list.unfoldr\r\n     * @param op {Function} - Operation to perform (should return a two component tuple (item to aggregate and item to unfold in next iteration).\r\n     * @param x {*} - Starting parameter to unfold from.\r\n     * @returns {Array} - An array of whatever you return from `op` yielded.\r\n     */\r\n    unfoldr = curry(_unfoldr),\r\n\r\n    /**\r\n     * Finds index in string or list (alias for `findIndex`).\r\n     * @function module:list.findIndex\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    findIndex = curry(_findIndex),\r\n\r\n    /**\r\n     * @function module:list.findIndices\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {Array|undefined}\r\n     */\r\n    findIndices = curry(_findIndices),\r\n\r\n    /**\r\n     * @function module:list.elemIndex\r\n     * @param x {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    elemIndex = curry(_elemIndex),\r\n\r\n    /**\r\n     * @function module:list.elemIndices\r\n     * @param value {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    elemIndices = curry(_elemIndices),\r\n\r\n    /**\r\n     * Takes `n` items from start of list to `limit` (exclusive).\r\n     * @function module:list.take\r\n     * @param list {Array|String}\r\n     * @param limit {Number}\r\n     * @returns {String|Array} - Passed in type's type\r\n     */\r\n    take = curry(_take),\r\n\r\n    /**\r\n     * Drops `n` items from start of list to `count` (exclusive).\r\n     * @function module:list.drop\r\n     * @param list {Array|String}\r\n     * @param count {Number}\r\n     * @returns {String|Array} - Passed in type's type\r\n     */\r\n    drop = curry(_drop),\r\n\r\n    /**\r\n     * Splits `x` in two at given `index` (exclusive (includes element/character at\r\n     * given index in second part of returned list)).\r\n     * @function module:list.splitAt\r\n     * @param ind {Number} - Index to split at.\r\n     * @param list {Array|String|*} - functor (list or string) to split.\r\n     * @returns {Array} - Array of whatever type `x` was when passed in\r\n     */\r\n    splitAt = curry(_splitAt),\r\n\r\n    /**\r\n     * Gives an list with passed elements while predicate was true.\r\n     * @function module:list.takeWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @returns {Array}\r\n     */\r\n    takeWhile = curry(_takeWhile),\r\n\r\n    /**\r\n     * Returns an list without elements that match predicate.\r\n     * @function module:list.dropWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @refactor\r\n     * @returns {Array|String}\r\n     */\r\n    dropWhile = curry(_dropWhile),\r\n\r\n    /**\r\n     * @function module:list.dropWhileEnd\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @refactor\r\n     * @returns {Array|String}\r\n     */\r\n    dropWhileEnd = curry(_dropWhileEnd),\r\n\r\n    /**\r\n     * Gives a span such that the first list (in returned tuple) is the span of items matching upto `not predicate` and\r\n     * the second list in the tuple is a list of the remaining elements in the given list.\r\n     * **@Note: Not the same as `partition`.  Read descriptions closely!!!\r\n     * @function module:list.partition\r\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\r\n     * @param list {Array|String|*} - Predicate<item, index, originalArrayOrString>\r\n     * @returns {Array|String|*} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\r\n     */\r\n    span = curry(_span),\r\n\r\n    /**\r\n     * breakOnList, applied to a predicate p and a list xs, returns a tuple\r\n     * where first element is longest prefix (possibly empty) of xs of elements\r\n     * that do not satisfy p and second element is the remainder of the list:\r\n     * @haskellExample\r\n     * Replace `break` with `breakOnList` for our version.\r\n     * ```\r\n     * break (> 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])\r\n     * break (< 9) [1,2,3] == ([],[1,2,3])\r\n     * break (> 9) [1,2,3] == ([1,2,3],[])\r\n     * ```\r\n     * @function module:list.breakOnList\r\n     * @param pred {Function}\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    breakOnList = curry(_breakOnList),\r\n\r\n    /**\r\n     * @function module:list.at\r\n     * @param ind {Number} - Index.\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    at = curry(_at),\r\n\r\n    /**\r\n     * @function module:list.find\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    find = curry(_find),\r\n\r\n    filter = curry(_filter),\r\n\r\n    /**\r\n     * Partitions a list on a predicate;  Items that match predicate are in first list in tuple;  Items that\r\n     * do not match the tuple are in second list in the returned tuple.\r\n     *  Essentially `[filter(p, xs), filter(negateP(p), xs)]`.\r\n     * @function module:list.partition\r\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\r\n     * @param list {Array|String|*}\r\n     * @returns {Array|String} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\r\n     */\r\n    partition = curry(_partition),\r\n\r\n    /**\r\n     * Returns a boolean indicating whether an element exists in given structure of elements.\r\n     * @function module:list.elem\r\n     * @param element {*}\r\n     * @param xs {Array}\r\n     * @returns {Boolean}\r\n     */\r\n    elem = curry(_elem),\r\n\r\n    /**\r\n     * The opposite of `elem` - Returns a boolean indicating whether an element exists in given list.\r\n     * @function module:list.notElem\r\n     * @param element {*}\r\n     * @param xs {Array}\r\n     * @returns {Boolean}\r\n     */\r\n    notElem = curry2(_notElem),\r\n\r\n    /**\r\n     * Same as _list._at - Returns property value at key/indice.\r\n     * @function module:object._lookup\r\n     * @type {module:object.prop}\r\n     */\r\n    lookup = curry(_lookup),\r\n\r\n    /**\r\n     * Checks if list `xs1` is a prefix of list `xs2`\r\n     * @function module:list.isPrefixOf\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {boolean}\r\n     */\r\n    isPrefixOf = curry(_isPrefixOf),\r\n\r\n    /**\r\n     * Checks if list `xs1` is a suffix of list `xs2`\r\n     * @function module:list.isSuffixOf\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {boolean}\r\n     */\r\n    isSuffixOf = curry(_isSuffixOf),\r\n\r\n    /**\r\n     * Checks if list `xs1` is an infix of list `xs2`\r\n     * @function module:list.isInfixOf\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {boolean}\r\n     */\r\n    isInfixOf = curry(_isInfixOf),\r\n\r\n    /**\r\n     * Checks if list `xs1` is a sub-sequence of list `xs2`\r\n     * @function module:list.isSubsequenceOf\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {boolean}\r\n     */\r\n    isSubsequenceOf = curry(_isSubsequenceOf),\r\n\r\n    /**\r\n     * Allows you to group items in a list based on your supplied equality check.\r\n     * @note Sames `group` but allows you to specify equality operation.\r\n     * @haskellType `groupBy :: (a -> a -> Bool) -> [a] -> [[a]]`\r\n     * @function module:list.groupBy\r\n     * @param equalityOp {Function}\r\n     * @param xs {Array|String|*}\r\n     * @returns {*}\r\n     */\r\n    groupBy = curry(_groupBy),\r\n\r\n    /**\r\n     * Strips prefix list from given list\r\n     * @function module:list.stripPrefix\r\n     * @param prefix {Array|String|*}\r\n     * @param list {Array|string|*}\r\n     * @returns {Array|*}\r\n     */\r\n    stripPrefix = curry(_stripPrefix),\r\n\r\n    /**\r\n     * zip takes two lists and returns a list of corresponding pairs.\r\n     * If one input list is short, excess elements of the longer list are discarded.\r\n     * @haskellType `zip :: [a] -> [b] -> [(a, b)]`\r\n     * @function module:list.zip\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip = curry(_zip),\r\n\r\n    /**\r\n     * @haskellType `zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]`\r\n     * @function module:list.zip3\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip3 = curry(_zip3),\r\n\r\n    /**\r\n     * @haskellType `zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]`\r\n     * @function module:list.zip4\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @param arr4 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip4 = curry(_zip4),\r\n\r\n    /**\r\n     * @haskellType `zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]`\r\n     * @function module:list.zip5\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @param arr4 {Array}\r\n     * @param arr5 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip5 = curry(_zip5),\r\n\r\n    /**\r\n     * zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\r\n     * zipWith generalises zip by zipping with the function given as the\r\n     * first argument, instead of a function tupling function (function that returns a tuple). For example,\r\n     * zipWith (+) is applied to two lists to produce the list of corresponding sums.\r\n     * @note `_|_` means bottom or perpetual (@see\r\n     *  - https://wiki.haskell.org/Bottom\r\n     *  - https://stackoverflow.com/questions/19794681/what-does-this-syntax-mean-in-haskell-or\r\n     *  )\r\n     * @example\r\n     * ```\r\n     * zipWith f [] _|_ = []\r\n     * ```\r\n     * @haskellType `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`\r\n     * @function module:list.zipWith\r\n     * @param op {Function} - Takes two parts of a tuple and returns a tuple.\r\n     *  E.g., ` op :: a -> b -> (a, b)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith = curry(_zipWith),\r\n\r\n    /**\r\n     * Zips all given lists with tupling function. Note: Haskell types do not have\r\n     *  a way (that I know of) to show one or more for params in a function so `@haskellType` below\r\n     *  is left there for general purpose not for exactness as is told by aforementioned.\r\n     * @haskellType `zipWithN :: (a -> b -> c) -> [a] -> [b] -> [c]` - Where `N` is the number\r\n     *  of lists to zip.\r\n     * @function module:list.zipWithN\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\r\n     * @param lists ...{Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWithN = curry(_zipWithN),\r\n\r\n    /**\r\n     * Zips 3 lists with tupling function.\r\n     * @haskellType `zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]`\r\n     * @function module:list.zipWith3\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @param xs3 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith3 = curry(_zipWith3),\r\n\r\n    /**\r\n     * Zips 4 lists with tupling function.\r\n     * @haskellType `zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c]  -> [d] -> [e]`\r\n     * @function module:list.zipWith4\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> d -> (a, b, c, d)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @param xs3 {Array|String|*}\r\n     * @param xs4 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith4 = curry(_zipWith4),\r\n\r\n    /**\r\n     * Zips 5 lists.\r\n     * @haskellType `zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c]  -> [d] -> [e] -> [f]`\r\n     * @function module:list.zipWith5\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> d -> e -> (a, b, c, d, e)`\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @param xs3 {Array|String|*}\r\n     * @param xs4 {Array|String|*}\r\n     * @param xs5 {Array|String|*}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith5 = curry(_zipWith5),\r\n\r\n    /**\r\n     * Returns true if any item in container passes predicate `p`.\r\n     * @function module:list.any\r\n     * @param p {Function} - Predicate.\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    any = curry(_any),\r\n\r\n    /**\r\n     * Returns true if all items in container pass predicate `p`.\r\n     * @function module:list.all\r\n     * @param p {Function} - Predicate.\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    all = curry(_all),\r\n\r\n    /**\r\n     * scanl is similar to foldl, but returns a list of successive reduced values from the left:\r\n     * ```\r\n     * scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]\r\n     * ```\r\n     * Also note that:\r\n     * ```\r\n     * last (scanl f z xs) == foldl f z xs.\r\n     * ```\r\n     * @function module:list.scanl\r\n     * @param fn {Function}\r\n     * @param zero {*}\r\n     * @param xs {Array}\r\n     * @returns {Array|*}\r\n     */\r\n    scanl = curry(_scanl),\r\n\r\n    /**\r\n     * `scanl1` is a variant of `scanl` that has no starting value argument:\r\n     * `shallowCompare(scanl1(fn, [x1, x2, ...]), [x1, fn(x1, x2), ...]) // true`\r\n     * @function module:list.scanl1\r\n     * @param fn {Function}\r\n     * @param xs {Array}\r\n     * @returns {Array|*}\r\n     */\r\n    scanl1 = curry(_scanl1),\r\n\r\n    /**\r\n     * Same as `scanl` but from the right (similiar to `foldr`'s relationship to `foldl`).\r\n     * Note also `scanr`'s relationship ot `foldr`:\r\n     * `head (scanr(fn, z, xs)) === foldr(fn, z, xs).\r\n     * @function module:list.scanr\r\n     * @param fn {Function}\r\n     * @param zero {*}\r\n     * @param xs {Array}\r\n     * @returns {Array|*}\r\n     */\r\n    scanr = curry(_scanr),\r\n\r\n    /**\r\n     * Same as `scanr` but takes no zero/accumulator value.\r\n     * @function module:list.scanr1\r\n     * @param fn {Function}\r\n     * @param xs {Array}\r\n     * @returns {Array|*}\r\n     */\r\n    scanr1 = curry(_scanr1),\r\n\r\n    /**\r\n     * `remove(x, xs)` removes the first occurrence of `x` from `xs`.\r\n     * For example, `remove('a', 'banana') === 'bnana';`\r\n     * @function module:list.remove\r\n     * @param x {*}\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    remove = curry(_remove),\r\n\r\n    /**\r\n     * Sort a list by comparing the results of a key function applied to each\r\n     * element. sortOn f is equivalent to sortBy (comparing f), but has the\r\n     * performance advantage of only evaluating f once for each element in the\r\n     * input list. This is called the decorate-sort-undecorate paradigm, or\r\n     * Schwartzian transform.\r\n     *\r\n     * Elements are arranged from from lowest to highest, keeping duplicates\r\n     * in the order they appeared in the input.\r\n     *\r\n     * Ex:\r\n     * ```\r\n     * shallowEquals(\r\n     *  sortOn (head, [[2, \"world\"], [4, \"!\"], [1, \"Hello\"]]),\r\n     *  [[1,\"Hello\"],[2,\"world\"],[4,\"!\"]]\r\n     * ) // true\r\n     * ```\r\n     * @function module:list.sortOn\r\n     * @param valueFn {Function}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    sortOn = curry(_sortOn),\r\n\r\n    /**\r\n     * The sortBy function is the non-overloaded (in haskell terms) version of sort.\r\n     * @haskellExample ```\r\n     *  >>> sortBy (\\(a,_) (b,_) -> compare a b) [(2, \"world\"), (4, \"!\"), (1, \"Hello\")]\r\n     *  [(1,\"Hello\"),(2,\"world\"),(4,\"!\")]\r\n     * ```\r\n     * @function module:list.sortBy\r\n     * @param orderingFn {Function}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    sortBy = curry(_sortBy),\r\n\r\n    /**\r\n     * The insert function takes an element and a list and inserts the element\r\n     * into the list at the first position where it is less than or equal to the\r\n     * next element. In particular, if the list is sorted before the call, the\r\n     * result will also be sorted. It is a special case of insertBy, which allows\r\n     * the programmer to supply their own comparison function.\r\n     * @function module:list.insert\r\n     * @param x {*}\r\n     * @param xs {Array|*}\r\n     * @returns {Array}\r\n     */\r\n    insert = curry(_insert),\r\n\r\n    /**\r\n     * A version of `insert` that allows you to specify the ordering of the inserted\r\n     * item;  Before/at, or after\r\n     * @function module:list.insertBy\r\n     * @haskellType `insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]`\r\n     * @note `Ordering` === // something that is order-able\r\n     * @todo Optimize and work the logic of this function;  Think about the types that will be\r\n     *  operated on by this functions logic.\r\n     * @param orderingFn {Function} - A function that returns `-1`, `0`, or 1`.\r\n     * @param x {*} - Value to insert.\r\n     * @param xs {Array|String|*} - List to insert into (note new list is returned)\r\n     * @returns {Array|String|*} - New list.\r\n     */\r\n    insertBy = curry(_insertBy),\r\n\r\n    /**\r\n     * The nubBy function behaves just like nub, except it uses a user-supplied equality predicate.\r\n     * @function module:list.nubBy\r\n     * @param pred {Function}\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    nubBy = curry(_nubBy),\r\n\r\n    /**\r\n     * Behaves the same as `remove`, but takes a user-supplied equality predicate.\r\n     * @function module:list.removeBy\r\n     * @param pred {Function}\r\n     * @param x {*}\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    removeBy = curry(_removeBy),\r\n\r\n    /**\r\n     * The `removeFirstsBy` function takes a predicate and two lists and returns the first list with the first\r\n     * occurrence of each element of the second list removed.\r\n     * @function module:list.removeFirstBy\r\n     * @param pred {Function}\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    removeFirstsBy = curry(_removeFirstsBy),\r\n\r\n    /**\r\n     * Returns the union on elements matching boolean check passed in.\r\n     * @function module:list.unionBy\r\n     * @param pred {Function} - `pred :: a -> a -> Bool`\r\n     * @param arr1 {Array|String|*}\r\n     * @param arr2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    unionBy = curry(_unionBy),\r\n\r\n    /**\r\n     * Creates a union on matching elements from array1.\r\n     * @function module:list.union\r\n     * @param arr1 {Array|String|*}\r\n     * @param arr2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    union = curry(_union),\r\n\r\n    /**\r\n     * Performs an intersection on list 1 with  elements from list 2.\r\n     * @function module:list.intersect\r\n     * @param arr1 {Array|String|*}\r\n     * @param arr2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    intersect = curry(_intersect),\r\n\r\n    /**\r\n     * Returns an intersection by predicate.\r\n     * @function module:list.intersectBy\r\n     * @param pred {Function} - `pred :: a -> b -> Bool`\r\n     * @param list1 {Array|String|*}\r\n     * @param list2 {Array|String|*}\r\n     * @return {Array|String|*}\r\n     */\r\n    intersectBy = curry(_intersectBy),\r\n\r\n    /**\r\n     * Returns the difference of list 1 from list 2.\r\n     * @note The `difference` operation here is non-associative;  E.g., `a - b` is not equal to `b - a`;\r\n     * @function module:list.difference\r\n     * @param array1 {Array|String|*}\r\n     * @param array2 {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    difference = curry(_difference),\r\n\r\n    /**\r\n     * Returns the complement of list 0 and the reset of the passed in arrays.\r\n     * @function module:list.complement\r\n     * @param arr0 {Array}\r\n     * @param arrays {...Array}\r\n     * @returns {Array}\r\n     */\r\n    complement = curry2(_complement)\r\n\r\n;\r\n","/**\r\n * Contains functions for operating strings.\r\n * @author elyde\r\n * @created 7/9/2017.\r\n * @module string\r\n */\r\nimport {intercalate, map, filter} from './list';\r\nimport {split} from './jsPlatform/string';\r\nimport {compose} from './uncurried/_function/_compose';\r\nimport {join} from './jsPlatform/array';\r\nimport {_errorIfNotType} from './uncurried/_object/_errorThrowing';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Splits a string on all '\\n', '\\r', '\\n\\r', or '\\r\\n' characters.\r\n     * @function module:string.lines\r\n     * @param str {String}\r\n     * @returns {Array}\r\n     */\r\n    lines = split(/[\\n\\r]/gm),\r\n\r\n    /**\r\n     * Splits a string on all '\\s' and/or all '\\t' characters.\r\n     * @function module:string.words\r\n     * @param str{String}\r\n     * @returns {Array}\r\n     */\r\n    words = split(/[\\s\\t]/gm),\r\n\r\n    /**\r\n     * Intersperse an array of strings with '\\s' and then concats them.\r\n     * @function module:string.unwords\r\n     * @param arr {String}\r\n     * @returns {Array}\r\n     */\r\n    unwords = intercalate(' '),\r\n\r\n    /**\r\n     * Intersperses a '\\n' character into a list of strings and then concats it.\r\n     * @function module:string.unlines\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    unlines = intercalate('\\n'),\r\n\r\n    /**\r\n     * Lower cases first character of a non-empty string.\r\n     * @function module:string.lcaseFirst\r\n     * @param xs {String}\r\n     * @returns {string}\r\n     * @throws {Error} - Throws error if receiving anything that is not a string.\r\n     */\r\n    lcaseFirst = xs => {\r\n        _errorIfNotType(String, 'lcaseFirst', 'xs', xs);\r\n        return xs[0].toLowerCase() + xs.substring(1);\r\n    },\r\n\r\n    /**\r\n     * Upper cases first character of a non-empty string.\r\n     * @function module:string.ucaseFirst\r\n     * @param xs {String}\r\n     * @returns {string}\r\n     * @throws {Error} - Throws error if receiving anything that is not a string.\r\n     */\r\n    ucaseFirst = xs => {\r\n        _errorIfNotType(String, 'ucaseFirst', 'xs', xs);\r\n        return xs[0].toUpperCase() + xs.substring(1);\r\n    },\r\n\r\n    /**\r\n     * Camel cases (class case) a string.\r\n     * @function module:string.camelCase\r\n     * @param xs {String}\r\n     * @param [pattern=/[^a-z\\d/i]/] {RegExp} - Pattern to split on.  Optional.\r\n     * @throws {Error} - Throws error if param `xs` is not a string.\r\n     * @returns {string}\r\n     * @curried\r\n     */\r\n    camelCase = (xs, pattern = /[^a-z\\d]/i) => compose(\r\n            join(''),\r\n            map(str => ucaseFirst(str.toLowerCase())),\r\n            filter(x => !!x),\r\n            split(pattern)\r\n        )(_errorIfNotType(String, 'camelCase', 'xs', xs)),\r\n\r\n    /**\r\n     * Class cases a string.  Uses pattern /[^a-z\\d/i]/ to split on.\r\n     * If you require a different pattern use `string.camelCase(str, pattern)`\r\n     * and then upper case first character (`ucaseFirst`).\r\n     * @function module:string.classCase\r\n     * @param xs {String}\r\n     * @returns {string}\r\n     * @throws {Error} - Throws error if `xs` is not a string (via `camelCase` call).\r\n     */\r\n    classCase = compose(ucaseFirst, camelCase)\r\n\r\n;\r\n","/**\r\n * @module fjl\r\n * @description Includes operations from haskell's Prelude.\r\n * @goal to include everything from haskell's Prelude where it makes sense in order to create\r\n *  a subset of functions which can make the javascript developer more efficient and make his/her\r\n *  code more concise (and functional).\r\n * @motivation preludejs, lodash/fp, RamdaJs, Haskell.\r\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html\r\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-List.html\r\n */\r\nexport * from './object';\r\nexport * from './boolean';\r\nexport * from './function';\r\nexport * from './list';\r\nexport * from './string';\r\nexport * from './utils';\r\nexport * from './uncurried/_list/_utils';\r\n"],"names":["_Number","Number","name","_NaN","_Null","_Undefined","typeOf","value","retVal","undefined","constructorName","constructor","isNaN","fPureTakesOne","arg","f","fPureTakes2","arg1","arg2","fPureTakes3","arg3","fPureTakes4","arg4","fPureTakes5","arg5","fPureTakesOneOrMore","args","fnOrError","symbolName","Error","_instanceOf","instanceConstructor","instance","_hasOwnProperty","length","x","keys","Object","obj","_assign","assign","obj0","objs","reduce","topAgg","agg","key","defineReverse","Array","prototype","reverse","reduceRight","item","push","map","filter","forEach","some","every","join","concat","slice","includes","xs","indexOf","lastIndexOf","split","apply","fn","call","notFnErrPrefix","curry","argsToCurry","curryN","executeArity","curriedArgs","concatedArgs","canBeCalled","curry2","curry3","curry4","curry5","_String","String","_Object","_Boolean","Boolean","_Function","Function","_Array","_Symbol","_Map","_Set","_WeakMap","_WeakSet","isFunction","_isType","type","isClass","test","substr","isCallable","isArray","isObject","isBoolean","isNumber","isString","isMap","isSet","isWeakMap","isWeakSet","isUndefined","isNull","isSymbol","isUsableImmutablePrimitive","typeOfX","isset","Type","isEmptyList","isEmptyObject","isEmptyCollection","size","isEmpty","typeOfValue","_fromNamespace","nsString","parts","limit","ind","parent","node","_prop","Symbol","of","_assignDeep","propDescription","getOwnPropertyDescriptor","get","set","writable","negateF","a","b","negateF3","c","negateF4","d","negateF5","e","negateP","negateFMany","isTruthy","isFalsy","alwaysTrue","alwaysFalse","_map","out","aggregateStr","aggregateArr","aggregateObj","aggregatorByType","sliceFrom","startInd","arr","sliceTo","toInd","copy","sliceCopy","genericAscOrdering","lengths","lists","lengthsToSmallest","listLengths","smallLen","Math","min","list","reduceUntil","pred","op","result","reduceRightUntil","operation","lastIndex","len","findIndexWhere","predicateFulfilled","findIndexWhereRight","findIndicesWhere","findWhere","elm","_append","listAppend","_appendMany","_head","_last","_tail","_init","_uncons","_unconsr","_concat","_concatMap","foldableOfA","_reverse","_foldr","_intersperse","between","lastInd","_foldl","_intercalate","xss","_transpose","numLists","ind2","longestListLen","_maximum","outLists","outList","_filter","_subsequences","listLen","pow","i","entry","j","_swapped","ind1","tmp","_permutations","_repeat","_foldl1","_foldr1","_mapAccumL","zero","mapped","tuple","_mapAccumR","_iterate","lastX","_replicate","_cycle","_unfoldr","resultTuple","_findIndex","_findIndices","_elemIndex","foundInd","_elemIndices","_take","_drop","count","_splitAt","_takeWhile","_dropWhile","splitPoint","list2","_dropWhileEnd","_span","_breakOnList","_at","_find","_partition","_elem","_notElem","_lookup","_isPrefixOf","xs1","xs2","limit1","limit2","_isSuffixOf","_isInfixOf","foundLen","_isSubsequenceOf","lenXs1","_group","_groupBy","equalityOp","prevItem","predOp","_inits","_tails","_stripPrefix","prefix","_zip","arr1","arr2","a1","a2","_zipN","trimmedLists","lenOfTrimmed","_zip3","arr3","_zip4","arr4","_zip5","arr5","_zipWith","_zipWithN","_zipWith3","xs3","_zipWith4","xs4","_zipWith5","xs5","_unzip","_unzipN","lenItem0","_any","p","_all","_and","_or","_not","_sum","_product","_sortBy","_minimum","_scanl","_scanl1","_scanr","_scanr1","_nub","_nubBy","_remove","_removeBy","_sort","_sortOn","valueFn","decorated","a0","b0","orderingFn","sort","_insert","foundIndex","_insertBy","currItem","anyOp","storedItem","_removeFirstsBy","x2","_unionBy","alreadyAdded","_union","_intersect","_intersectBy","list1","_difference","array1","array2","_complement","arr0","arrays","_objUnion","obj1","obj2","_objIntersect","_objDifference","_objComplement","log","console","bind","error","peek","pop","isCheckableType","_errorIfNotCheckableType","contextName","getTypeName","_defaultTypeChecker","multiTypesToString","types","defaultErrorMessageCall","tmplContext","valueName","expectedTypeName","foundTypeName","messageSuffix","isMultiTypeNames","typesCopy","typesToMatchCopy","_getErrorIfNotTypeThrower","errorMessageCall","typeChecker","ValueType","_getErrorIfNotTypesThrower","valueTypes","expectedTypeNames","matchFound","_errorIfNotType","_errorIfNotTypes","defaultTypeChecker","errorIfNotType","errorIfNotTypes","getErrorIfNotTypeThrower","getErrorIfNotTypesThrower","jsonClone","JSON","parse","stringify","toAssocList","toAssocListDeep","TypeConstraint","fromAssocList","OutType","fromAssocListDeep","toArrayMap","fromArrayMap","toArray","from","prop","instanceOf","hasOwnProperty","assignDeep","objUnion","objIntersect","objDifference","objComplement","isType","fromNamespace","until","predicate","typeInstance","flipN","flip3","flip4","flip5","flip","PlaceHolder","placeHolderInstance","isPlaceHolder","replacePlaceHolders","array","element","shift","curry_","curryN_","placeHolders","__","freeze","curry2_","curry3_","curry4_","curry5_","id","compose","arg0","_apply","_call","_until","_flip","_flip3","_flip4","_flip5","fPureTakesOne_","fPureTakes2_","fPureTakesOneOrMore_","concat_","slice_","includes_","indexOf_","lastIndexOf_","_split","append","appendMany","concatMap","intersperse","intercalate","foldl","foldr","foldl1","foldr1","mapAccumL","mapAccumR","iterate","repeat","replicate","cycle","unfoldr","findIndex","findIndices","elemIndex","elemIndices","take","drop","splitAt","takeWhile","dropWhile","dropWhileEnd","span","breakOnList","at","find","partition","elem","notElem","lookup","isPrefixOf","isSuffixOf","isInfixOf","isSubsequenceOf","groupBy","stripPrefix","zip","zip3","zip4","zip5","zipWith","zipWithN","zipWith3","zipWith4","zipWith5","any","all","scanl","scanl1","scanr","scanr1","remove","sortOn","sortBy","insert","insertBy","nubBy","removeBy","removeFirstsBy","unionBy","union","intersect","intersectBy","difference","complement","lines","words","unwords","unlines","lcaseFirst","toLowerCase","substring","ucaseFirst","toUpperCase","camelCase","pattern","str","classCase"],"mappings":"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"}