{"version":3,"file":"fjl.js","sources":["../../src/function/curry.js","../../src/utils.js","../../src/jsPlatform/array.js","../../src/jsPlatform/function.js","../../src/function/flip.js","../../src/jsPlatform/object.js","../../src/object/typeOf.js","../../src/object/is.js","../../src/object/lookup.js","../../src/object/of.js","../../src/object/copy.js","../../src/object/searchObj.js","../../src/object/assignDeep.js","../../src/jsPlatform/slice.js","../../src/boolean.js","../../src/list/map.js","../../src/list/aggregation.js","../../src/list/utils.js","../../src/object/setTheory.js","../../src/object/console.js","../../src/object/jsonClone.js","../../src/object/assocList.js","../../src/object/toArray.js","../../src/object.js","../../src/function/compose.js","../../src/function/id.js","../../src/function/negate.js","../../src/function/until.js","../../src/function/fnOrError.js","../../src/function/noop.js","../../src/function/trampoline.js","../../src/function/toFunction.js","../../src/function.js","../../src/list/range.js","../../src/jsPlatform/string.js","../../src/jsPlatform.js","../../src/list.js","../../src/errorThrowing.js","../../src/string.js","../../src/fjl.js"],"sourcesContent":["/**\r\n * @author elydelacruz\r\n * @created 12/6/2016.\r\n * @memberOf function\r\n * @description \"Curry strict\" and \"curry arbitrarily\" functions (`curry`, `curryN`).\r\n */\r\n\r\n/**\r\n * @private\r\n * @type {string}\r\n */\r\nconst\r\n\r\n    /**\r\n     * Returns curried function.\r\n     * @private\r\n     * @param executeArity {Number}\r\n     * @param unmetArityNum {Number}\r\n     * @param fn {Function}\r\n     * @param argsToCurry {...*}\r\n     * @returns {Function} - Curried function.\r\n     */\r\n    returnCurried = (executeArity, unmetArityNum, fn, argsToCurry) => {\r\n        switch (unmetArityNum) {\r\n            case 1:\r\n                /* eslint-disable */\r\n                return function func(x) {\r\n                /* eslint-enable */\r\n                    return executeAsCurriedFunc(fn, executeArity, unmetArityNum, Array.from(arguments), argsToCurry);\r\n                };\r\n            case 2:\r\n                /* eslint-disable */\r\n                return function func(a, b) {\r\n                /* eslint-enable */\r\n                    return executeAsCurriedFunc(fn, executeArity, unmetArityNum, Array.from(arguments), argsToCurry);\r\n                };\r\n            case 3:\r\n                /* eslint-disable */\r\n                return function func(a, b, c) {\r\n                /* eslint-enable */\r\n                    return executeAsCurriedFunc(fn, executeArity, unmetArityNum, Array.from(arguments), argsToCurry);\r\n                };\r\n            case 4:\r\n                /* eslint-disable */\r\n                return function func(a, b, c, d) {\r\n                /* eslint-enable */\r\n                    return executeAsCurriedFunc(fn, executeArity, unmetArityNum, Array.from(arguments), argsToCurry);\r\n                };\r\n            case 5:\r\n                /* eslint-disable */\r\n                return function func(a, b, c, d, e) {\r\n                /* eslint-enable */\r\n                    return executeAsCurriedFunc(fn, executeArity, unmetArityNum, Array.from(arguments), argsToCurry);\r\n                };\r\n            default:\r\n                return (...args) => executeAsCurriedFunc(fn, executeArity, unmetArityNum, args, argsToCurry);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns curried function if unmetArity is not met else returns result of executing\r\n     * final function.\r\n     * @private\r\n     * @param fn {Function}\r\n     * @param executeArity {Number}\r\n     * @param unmetArity {Number}\r\n     * @param args {Array<*>}\r\n     * @param argsToCurry {Array<*>}\r\n     * @returns {Function|*} - Curried function or result of 'finally' executed function.\r\n     */\r\n    executeAsCurriedFunc = (fn, executeArity, unmetArity, args, argsToCurry) => {\r\n        let concatedArgs = argsToCurry.concat(args),\r\n            canBeCalled = (concatedArgs.length >= executeArity) || !executeArity,\r\n            newExpectedArity = executeArity - concatedArgs.length;\r\n        return !canBeCalled ?\r\n            returnCurried(executeArity, newExpectedArity, fn, concatedArgs) :\r\n            fn(...concatedArgs);\r\n    }\r\n;\r\n\r\nexport const\r\n\r\n    /**\r\n     * Curries a function up to a given arity.\r\n     * @function module:function.curryN\r\n     * @param executeArity {Number}\r\n     * @param fn {Function}\r\n     * @param argsToCurry {...*}\r\n     * @returns {Function}\r\n     * @throws {Error} - When `fn` is not a function.\r\n     */\r\n    curryN = (executeArity, fn, ...argsToCurry) => {\r\n        if (!fn || !(fn instanceof Function)) {\r\n            throw new Error(`\\`curry*\\` functions expect first parameter to be of type \\`Function\\` though received ${fn}?`);\r\n        }\r\n        return returnCurried(executeArity, executeArity - argsToCurry.length, fn, argsToCurry);\r\n    },\r\n\r\n    /**\r\n     * Curries a function based on it's defined arity (note: rest args param (`...rest`) are not counted in arity).\r\n     * @function module:function.curry\r\n     * @param fn {Function}\r\n     * @param argsToCurry {...*}\r\n     * @returns {Function}\r\n     */\r\n    curry = (fn, ...argsToCurry) => curryN((fn || {}).length, fn, ...argsToCurry),\r\n\r\n    /**\r\n     * Curries a function up to an arity of 2 (won't call function until 2 or more args).\r\n     * @function module:function.curry2\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry2 = fn => curryN(2, fn),\r\n\r\n    /**\r\n     * Curries a function up to an arity of 3 (won't call function until 3 or more args).\r\n     * @function module:function.curry3\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry3 = fn => curryN(3, fn),\r\n\r\n    /**\r\n     * Curries a function up to an arity of 4 (won't call function until 4 or more args).\r\n     * @function module:function.curry4\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry4 = fn => curryN(4, fn),\r\n\r\n    /**\r\n     * Curries a function up to an arity of 5 (won't call function until 5 or more args).\r\n     * @function module:function.curry5\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    curry5 = fn => curryN(5, fn);\r\n","/**\r\n * @module utils\r\n */\r\nimport {curry, curry2} from './function/curry';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns a function that takes an argument and an object on which to execute 'method name'\r\n     * with said parameters.\r\n     * @function module:utils.fPureTakesOne\r\n     * @param name {String}\r\n     * @returns {Function}\r\n     */\r\n    fPureTakesOne = name => curry((arg, f) => f[name](arg)),\r\n\r\n    /**\r\n     * Returns a function that takes 2 arguments and an object on which to execute 'method name'\r\n     * with said parameters.\r\n     * @function module:utils.fPureTakes2\r\n     * @param name {String}\r\n     * @returns {Function}\r\n     */\r\n    fPureTakes2 = name => curry((arg1, arg2, f) => f[name](arg1, arg2)),\r\n\r\n    /**\r\n     * Returns a function that takes 3 arguments and an object on which to execute 'method name'\r\n     * with said parameters.\r\n     * @function module:utils.fPureTakes3\r\n     * @param name {String}\r\n     * @returns {Function}\r\n     */\r\n    fPureTakes3 = name => curry((arg1, arg2, arg3, f) => f[name](arg1, arg2, arg3)),\r\n\r\n    /**\r\n     * Returns a function that takes 4 arguments and an object on which to execute 'method name'\r\n     * with said parameters.\r\n     * @function module:utils.fPureTakes4\r\n     * @param name {String}\r\n     * @returns {Function}\r\n     */\r\n    fPureTakes4 = name => curry((arg1, arg2, arg3, arg4, f) => f[name](arg1, arg2, arg3, arg4)),\r\n\r\n    /**\r\n     * Returns a function that takes 5 arguments and an object on which to execute 'method name'\r\n     * with said parameters.\r\n     * @function module:utils.fPureTakes5\r\n     * @param name {String}\r\n     * @returns {Function}\r\n     */\r\n    fPureTakes5 = name => curry((arg1, arg2, arg3, arg4, arg5, f) => f[name](arg1, arg2, arg3, arg4, arg5)),\r\n\r\n    /**\r\n     * Returns a function that takes an object and one or more arguments on which to execute 'method name'\r\n     * with said parameters.\r\n     * @function module:utils.fPureTakesOneOrMore\r\n     * @param name {String}\r\n     * @returns {Function}\r\n     */\r\n    fPureTakesOneOrMore = name => curry2((f, ...args) => f[name](...args))\r\n\r\n;\r\n","/**\r\n * Created by elyde on 7/20/2017.\r\n * Functional versions of common array methods (`map`, `filter`, etc.) (un-curried);\r\n */\r\n\r\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from '../utils';\r\n\r\nconst\r\n    /**\r\n     * Array.prototype.reverse generator (generates a function that calls the prototype version or a\r\n     * shimmed version if it doesn't exist).\r\n     * @returns {Function}\r\n     */\r\n    defineReverse = () =>\r\n        Array.prototype.reverse ? x => x.reverse() :\r\n            x => x.reduceRight((agg, item) => {\r\n                agg.push(item);\r\n                return agg;\r\n            }, [])\r\n;\r\n\r\nexport const\r\n\r\n    /**\r\n     * Maps a function to functor (list etc.).\r\n     * @function module:jsPlatform.map\r\n     * @param fn {Function}\r\n     * @param functor {Array|{map: {Function}}}\r\n     * @returns {Array|{map: {Function}}}\r\n     */\r\n    map = fPureTakesOne('map'),\r\n\r\n    /**\r\n     * Filters a functor (list etc.) with passed in function.\r\n     * @function module:jsPlatform.filter\r\n     * @param fn {Function}\r\n     * @param functor {Array|{filter: {Function}}}\r\n     * @returns {Array|{filter: {Function}}}\r\n     */\r\n    filter = fPureTakesOne('filter'),\r\n\r\n    /**\r\n     * Reduces a foldable (list etc.) with passed in function.\r\n     * @function module:jsPlatform.reduce\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduce: {Function}}}\r\n     * @returns {Array|{reduce: {Function}}}\r\n     */\r\n    reduce = fPureTakes2('reduce'),\r\n\r\n    /**\r\n     * Reduces a foldable (list etc.) from the right with passed in function.\r\n     * @function module:jsPlatform.reduceRight\r\n     * @param fn {Function}\r\n     * @param functor {Array|{reduceRight: {Function}}}\r\n     * @returns {Array|{reduceRight: {Function}}}\r\n     */\r\n    reduceRight = fPureTakes2('reduceRight'),\r\n\r\n    /**\r\n     * For each on functor (Array|Object|etc.).\r\n     * @function module:jsPlatform.forEach\r\n     * @param fn {Function}\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type of object you pass in unless it doesn't have a `forEach` method.\r\n     * @throws {Error} - When passed in functor doesn't have a `forEach` method.\r\n     */\r\n    forEach = fPureTakesOne('forEach'),\r\n\r\n    /**\r\n     * Returns `true` if `fn` (predicate) returns true for at least one item\r\n     * in functor else returns `false`.\r\n     * @param fn {Function} - Predicate.\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have a `some` method.\r\n     */\r\n    some = fPureTakesOne('some'),\r\n\r\n    /**\r\n     * Returns `true` if `fn` (predicate) returns true for all items in functor else returns `false`.\r\n     * @function module:jsPlatform.every\r\n     * @param fn {Function} - Predicate.\r\n     * @param functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have an `every` method.\r\n     */\r\n    every = fPureTakesOne('every'),\r\n\r\n    /**\r\n     * Array.prototype.join\r\n     * @function module:jsPlatform.join\r\n     * @param separator {String|RegExp}\r\n     * @param arr {Array}\r\n     * @returns {String}\r\n     */\r\n    join = fPureTakesOne('join'),\r\n\r\n    /**\r\n     * Same as Array.prototype.push\r\n     * @function module:jsPlatform.push\r\n     * @param item {*}\r\n     * @param arr {Array}\r\n     * @returns {Number}\r\n     */\r\n    push = fPureTakesOneOrMore('push'),\r\n\r\n    /**\r\n     * Reverses an list (shimmed if not exists).\r\n     * @function module:jsPlatform.reverse\r\n     * @param x {Array<any>}\r\n     * @return {Array}\r\n     */\r\n    reverse = defineReverse();\r\n","import {curry, curry2} from '../function/curry';\r\n\r\n/**\r\n * Created by elydelacruz on 9/7/2017.\r\n */\r\nexport const\r\n\r\n    /**\r\n     * Functional `apply` function (takes no context).\r\n     * @function module:function.apply\r\n     * @param fn {Function}\r\n     * @param args {Array|*}\r\n     * @returns {*}\r\n     */\r\n    apply = curry((fn, args) => fn.apply(null, args)),\r\n\r\n    /**\r\n     * Functional `call` function (takes no context).\r\n     * @function module:function.call\r\n     * @param fn {Function}\r\n     * @param args {...*}\r\n     * @returns {*}\r\n     */\r\n    call = curry2((fn, ...args) => fn.call(null, ...args));\r\n","import {reverse} from '../jsPlatform/array';\r\nimport {apply, call} from '../jsPlatform/function';\r\nimport {curry, curry2} from './curry';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns a curried function requiring given functions arguments in reverse\r\n     * (returned function expects 2 or more variables (curried at 2 or more args)).\r\n     * @function module:function.flipN\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     * @curried\r\n     */\r\n    flipN = fn => curry2((...args) => apply(fn, reverse(args))),\r\n\r\n    /**\r\n     * Flips a function's first and second arguments and and returns a new function requiring said arguments in reverse.\r\n     * @function module:function.flip\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    flip = fn => curry((b, a) => call(fn, a, b)),\r\n\r\n    /**\r\n     * Same as `flip` except returns a flipped function of arity 3.\r\n     * @function module:function.flip3\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    flip3 = fn => curry((c, b, a) => call(fn, a, b, c)),\r\n\r\n    /**\r\n     * Same as `flip` except returns a flipped function of arity 4.\r\n     * @function module:function.flip4\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    flip4 = fn => curry((d, c, b, a) => call(fn, a, b, c, d)),\r\n\r\n    /**\r\n     * Same as `flip` except returns a flipped function of arity 5.\r\n     * @function module:function.flip5\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    flip5 = fn => curry((e, d, c, b, a) => call(fn, a, b, c, d, e));\r\n","/**\r\n * @description Defines some of the platform methods for objects (the ones used within `fjl`).\r\n */\r\n\r\nimport {fPureTakesOne} from '../utils';\r\nimport {curry, curry2} from '../function/curry';\r\nimport {flip, flip3, flip4, flip5} from '../function/flip';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns whether constructor has derived object.\r\n     * @function module:object.instanceOf\r\n     * @param instanceConstructor {Function} - Constructor.\r\n     * @param instance {*}\r\n     * @instance {*}\r\n     * @returns {Boolean}\r\n     */\r\n    instanceOf = curry((instanceConstructor, instance) =>\r\n        instance instanceof instanceConstructor),\r\n\r\n    /**\r\n     * @function module:object.hasOwnProperty\r\n     * @param propName {*}\r\n     * @param typeInstance {*}\r\n     * @returns {Boolean}\r\n     * @deprecated - Use property directly instead.\r\n     */\r\n    hasOwnProperty = fPureTakesOne('hasOwnProperty'),\r\n\r\n    /**\r\n     * @function module:object.length\r\n     * @param x {*}\r\n     * @returns {Number}\r\n     * @throws {Error} - Throws an error if value doesn't have a `length` property (\r\n     *  `null`, `undefined`, {Boolean}, Symbol, et. al.).\r\n     */\r\n    length = x => x.length,\r\n\r\n    /**\r\n     * Contains all the static functions from `Object` but curried and flipped;\r\n     * @example\r\n     * // E.g., `Object.defineProperties(obj, descriptor)` can now be used like\r\n     * import {defineProperties} from 'fjl'\r\n     * defineProperties(descriptor, someObj),\r\n     * // Et. al.\r\n     * @memberOf module:object\r\n     * @type {{...Object}}\r\n     */\r\n    native = Object.getOwnPropertyNames(Object).reduce((agg, key) => {\r\n        if (typeof Object[key] !== 'function') {\r\n            return agg;\r\n        }\r\n        const operation = Object[key];\r\n        switch (operation.length) {\r\n            case 2:\r\n                agg[key] = flip(operation);\r\n                break;\r\n            case 3:\r\n                agg[key] = flip3(operation);\r\n                break;\r\n            case 4:\r\n                agg[key] = flip4(operation);\r\n                break;\r\n            case 5:\r\n                agg[key] = flip5(operation);\r\n                break;\r\n            default:\r\n                agg[key] = Object[key];\r\n                break;\r\n        }\r\n        return agg;\r\n    }, {}),\r\n\r\n    /**\r\n     * Gets passed in object's own enumerable keys (same as `Object.keys`).\r\n     * @function module:object.keys\r\n     * @param obj {*}\r\n     * @returns {Array<String>}\r\n     */\r\n    {keys} = native,\r\n\r\n    /**\r\n     * Defined as `Object.assign` else is the same thing but shimmed.\r\n     * @function module:object.assign\r\n     * @param obj0 {Object}\r\n     * @param objs {...{Object}}\r\n     * @returns {Object}\r\n     */\r\n    assign = (() => Object.assign ?\r\n            (obj0, ...objs) => Object.assign(obj0, ...objs) :\r\n            curry2((obj0, ...objs) => objs.reduce((topAgg, obj) => {\r\n                return Object.keys(obj).reduce((agg, key) => {\r\n                    agg[key] = obj[key];\r\n                    return agg;\r\n                }, topAgg);\r\n            }, obj0))\r\n        )();\r\n","/**\r\n * Created by elyde on 12/18/2016.\r\n * @memberOf object\r\n */\r\nconst _Number = Number.name,\r\n    _NaN = 'NaN',\r\n    _Null = 'Null',\r\n    _Undefined = 'Undefined';\r\n\r\n/**\r\n * Returns the constructor/class/type name of a value.\r\n * @note Returns 'NaN' if value is of type `Number` and value is `isNaN`.\r\n * @note Returns 'Undefined' if value is `undefined`\r\n * @note Returns 'Null' if value is `null`\r\n * For values that have no concrete constructors and/or casters\r\n * (null, NaN, and undefined) we returned normalized names for them ('Null', 'NaN', 'Number')\r\n * @function module:object.typeOf\r\n * @param value {*}\r\n * @returns {string} - Constructor's name or derived name (in the case of `null`, `undefined`, or `NaN` (whose\r\n *  normalized names are 'Null', 'Undefined', 'NaN' respectively).\r\n */\r\nexport function typeOf (value) {\r\n    let retVal;\r\n    if (value === undefined) {\r\n        retVal = _Undefined;\r\n    }\r\n    else if (value === null) {\r\n        retVal = _Null;\r\n    }\r\n    else {\r\n        let constructorName = (value).constructor.name;\r\n        retVal = constructorName === _Number && isNaN(value) ?\r\n            _NaN : constructorName;\r\n    }\r\n    return retVal;\r\n}\r\n","/**\r\n * Created by elyde on 12/18/2016.\r\n * @memberOf object\r\n */\r\n\r\nimport {typeOf} from './typeOf';\r\nimport {instanceOf, length, keys} from '../jsPlatform/object';\r\nimport {curry} from '../function/curry';\r\n\r\nlet _String = String.name,\r\n    _Number = Number.name,\r\n    _Object = Object.name,\r\n    _Boolean = Boolean.name,\r\n    _Symbol = 'Symbol',\r\n    _Map = 'Map',\r\n    _Set = 'Set',\r\n    _WeakMap = 'WeakMap',\r\n    _WeakSet = 'WeakSet',\r\n    _Null = 'Null',\r\n    _Undefined = 'Undefined';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Resolves/normalizes a type name from either a string or a constructor.\r\n     * @function module:object.toTypeRef\r\n     * @param type {Function|String} - String or function representing a type.\r\n     * @returns {String}\r\n     * @todo write tests for this function.\r\n     */\r\n    toTypeRef = type => {\r\n        if (!type) {\r\n            return typeOf(type);\r\n        }\r\n        else if (type.constructor === String || (type instanceof Function)) {\r\n            return type;\r\n        }\r\n        return typeOf(type);\r\n    },\r\n\r\n    /**\r\n     * Returns an array of type refs from possible type refs (converts null, undefined, NaN, and other values into\r\n     * type refs (either constructor name or constructor name based on whether value(s) is a string, a constructor, or not).\r\n     * @function module:object.toTypeRefs\r\n     * @param types {...(TypeRef|*)}\r\n     * @returns {Array<TypeRef>}\r\n     * @todo Ensure tests are written for this function.\r\n     */\r\n    toTypeRefs = (...types) => types.map(toTypeRef),\r\n\r\n    /**\r\n     * Returns possible Type's TypeRef name.\r\n     * @function module:object.toTypeRefName\r\n     * @param Type {(TypeRef|*)}\r\n     * @returns {String}\r\n     * @todo Ensure tests are written for this function.\r\n     */\r\n    toTypeRefName = Type => {\r\n        const ref = toTypeRef(Type);\r\n        return ref instanceof Function ? ref.name : ref;\r\n    },\r\n\r\n    /**\r\n     * Returns possible Types' TypeRef names.\r\n     * @function module:object.toTypeRefNames\r\n     * @param types {...(TypeRef|*)}\r\n     * @returns {String[]}\r\n     * @todo Ensure tests are written for this function.\r\n     */\r\n    toTypeRefNames = (...types) => types.map(toTypeRefName),\r\n\r\n    /**\r\n     * Returns whether a value is a function or not.\r\n     * @function module:object.isFunction\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isFunction = instanceOf(Function),\r\n\r\n    /**\r\n     * Strict type checker.  Checks if given value is a direct instance of given type;  E.g.,\r\n     * @example\r\n     *   isType(String, 'abcdefg')  === true // true\r\n     *   isType(String.name, 'abcdefg') === true\r\n     *   isType(Number, NaN) === false\r\n     *   isType(Number, 99) === true\r\n     *   isType('Null', 99) === false // though, for `null` and `undefined` checks\r\n     *                                // @see `isset`, in this module, instead\r\n     *   isType('Undefined', undefined) === true // true\r\n     *\r\n     * @note Useful where absolute types, or some semblance thereof, are required.\r\n     * @function module:object.isType\r\n     * @param type {Function|ObjectConstructor|String} - Constructor or constructor name\r\n     * @param obj {*}\r\n     * @return {Boolean}\r\n     */\r\n    isType = curry((type, obj) => typeOf(obj) === toTypeRefName(type)),\r\n\r\n    /**\r\n     * Synonym for `isType` (or just a more accurate name for `isType`).\r\n     * @function module:object.isStrictly\r\n     * @param type {Function|ObjectConstructor|String} - Constructor or constructor name\r\n     * @param obj {*}\r\n     * @return {Boolean}\r\n     */\r\n    isStrictly = isType,\r\n\r\n    /**\r\n     * Loose type checker;  E.g., If `type` is not a constructor, but a constructor name, does a type check on\r\n     * constructor names, else if first check fails and `type` is a constructor, performs an `instanceof` check\r\n     * on value with constructor.\r\n     * @note Use care when checking for `Array` since it is an `instanceof` Object.\r\n     * @note For `null` and `undefined` their class cased names can be used for type checks\r\n     * `isOfType('Null', null) === true (passes strict type check)` (or better yet @link `module:object.isset` can be used).\r\n     * @throwsafe - Doesn't throw on `null` or `undefined` `obj` values.\r\n     * @example\r\n     * isOfType(Number, 99) === true        // true  (passes strict type check (numbers are not instances of `Number`\r\n     *                                      //        constructor)\r\n     * isOfType('Number', 99) === true      // true  (passes strict type check)\r\n     * isOfType(Number, NaN) === true       // true. (passes instance of check)\r\n     *                                      //        If you want \"true\" strict type checking use `isType`\r\n     * isOfType(Object, []) === true        // true  (passes instance of check)\r\n     * isOfType(Array, []) === true         // true  (passes instance of check)\r\n     * isOfType(Object, {}) === true        // true  (passes instance of check)\r\n     * isOfType(Object.name, {}) === true   // true  (Passes strict type check)\r\n     * class Abc extends String {}\r\n     * isOfType(String, new Abc('abcd')) // true (passes instanceof check)\r\n     *\r\n     * @function module:object.isOfType\r\n     * @param type {Function|String} - Type reference (constructor or `constructor.name`).\r\n     * @param x {*} - Value to check.\r\n     * @returns {Boolean}\r\n     */\r\n    isOfType = curry((type, x) => isType(type, x) || instanceOf(type, x)),\r\n\r\n    /**\r\n     * Synonym for `isOfType` (or just a more accurate name).\r\n     * @function module:object.isLoosely\r\n     * @param type {Function|String} - Type reference (constructor or `constructor.name`).\r\n     * @param x {*} - Value to check.\r\n     * @returns {Boolean}\r\n     */\r\n    isLoosely = isOfType,\r\n\r\n    /**\r\n     * Checks if `value` is an es2015 `class`.\r\n     * @function module:object.isClass\r\n     * @param x {*}\r\n     * @returns {boolean}\r\n     */\r\n    isClass = x => x && /^\\s{0,3}class\\s{1,3}/.test((x + '').substr(0, 10)),\r\n\r\n    /**\r\n     * Returns a boolean depicting whether a value is callable or not.\r\n     * @function module:object.isCallable\r\n     * @tentative\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isCallable = x => isFunction(x) && !isClass(x),\r\n\r\n    /**\r\n     * Checks if value is an array (same as `Array.isArray`).\r\n     * @function module:object.isArray\r\n     * @param value {*}\r\n     * @returns {boolean}\r\n     */\r\n    {isArray} = Array,\r\n\r\n    /**\r\n     * Checks whether value is an object or not.\r\n     * @function module:object.isObject\r\n     * @param value\r\n     * @returns {Boolean}\r\n     */\r\n    isObject = isType(_Object),\r\n\r\n    /**\r\n     * Checks if value is a boolean.\r\n     * @function module:object.isBoolean\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isBoolean = isType(_Boolean),\r\n\r\n    /**\r\n     * Checks if value is a valid number (also checks if isNaN so that you don't have to).\r\n     * @function module:object.isNumber\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isNumber = isType(_Number),\r\n\r\n    /**\r\n     * Checks whether value is a string or not.\r\n     * @function module:object.isString\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isString = isType(_String),\r\n\r\n    /**\r\n     * Checks whether value is of `Map` or not.\r\n     * @function module:object.isMap\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isMap = isType(_Map),\r\n\r\n    /**\r\n     * Checks whether value is of `Set` or not.\r\n     * @function module:object.isSet\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isSet = isType(_Set),\r\n\r\n    /**\r\n     * Checks whether value is of `WeakMap` or not.\r\n     * @function module:object.isWeakMap\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isWeakMap =isType(_WeakMap),\r\n\r\n    /**\r\n     * Checks whether value is of `WeakSet` or not.\r\n     * @function module:object.isWeakSet\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isWeakSet = isType(_WeakSet),\r\n\r\n    /**\r\n     * Checks if value is undefined.\r\n     * @function module:object.isUndefined\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isUndefined = isType(_Undefined),\r\n\r\n    /**\r\n     * Checks if value is null.\r\n     * @function module:object.isNull\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isNull = isType(_Null),\r\n\r\n    /**\r\n     * Checks if value is a `Symbol`.\r\n     * @function module:object.isSymbol\r\n     * @param value {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isSymbol = isType(_Symbol),\r\n\r\n    /**\r\n     * Checks if given `x` is set and of one of\r\n     *  [String, Boolean, Number, Symbol] (null and undefined are immutable\r\n     *  but are not \"usable\" (usually not what we want to operate on).\r\n     * @function module:object.isUsableImmutablePrimitive\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isUsableImmutablePrimitive = x => {\r\n        const typeOfX = typeOf(x);\r\n        return isset(x) &&\r\n            [_String, _Number, _Boolean, _Symbol]\r\n                .some(Type => Type === typeOfX);\r\n    },\r\n\r\n    /**\r\n     * Checks if !length.\r\n     * @function module:object.isEmptyList\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyList = x => !length(x),\r\n\r\n    /**\r\n     * Checks if object has own properties/enumerable-props or not.\r\n     * @function module:object.isEmptyObject\r\n     * @param obj {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyObject = obj => isEmptyList(keys(obj)),\r\n\r\n    /**\r\n     * Checks if collection is empty or not (Map, WeakMap, WeakSet, Set etc.).\r\n     * @function module:object.isEmptyCollection\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyCollection = x => x.size === 0,\r\n\r\n    /**\r\n     * Checks to see if passed in value is empty;  I.e.,\r\n     *  check for one of '', 0, `null`, `undefined`, `NaN`, `false`, empty array, empty object, ~~empty function (zero arity)~~,\r\n     *  or empty collection (es6 collection: Map, Set, WeakMap, or WeakSet etc.) (`!value.size`).\r\n     * @function module:object.isEmpty\r\n     * @param x {*} - Value to check.\r\n     * @returns {Boolean}\r\n     */\r\n    isEmpty = x => {\r\n        if (!x) { // if '', 0, `null`, `undefined`, `NaN`, or `false` then is empty\r\n            return true;\r\n        }\r\n        if (isNumber(x) || isFunction(x)) {\r\n            return false;\r\n        }\r\n        if (isArray(x)) { // takes care of 'instances of Array'\r\n            return !x.length;\r\n        }\r\n        if (x.size !== undefined && !instanceOf(Function, x.size)) {\r\n            return !x.size;\r\n        }\r\n        if (isObject(x)) {\r\n            return !keys(x).length;\r\n        }\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Returns whether passed in values is defined and not null or not.\r\n     * @function module:object.isset\r\n     * @param x {*}\r\n     * @returns {Boolean}\r\n     */\r\n    isset = x => x !== null && x !== undefined,\r\n\r\n    /**\r\n     * Checks to see if `x` is of one of the given type refs;  Strict type check (not-instanceof check).\r\n     * @function object.isOneOf\r\n     * @param x {*}\r\n     * @param types {...(TypeRef|*)}\r\n     * @returns {boolean}\r\n     * @deprecated - Instead use @link module:isStrictlyOneOf\r\n     * @todo write tests for this function.\r\n     */\r\n    isOneOf = (x, ...types) => {\r\n        const typeName = typeOf(x);\r\n        return toTypeRefNames(types).some(name => typeName === name);\r\n    },\r\n\r\n    /**\r\n     * Checks if given value is strictly one of given types.\r\n     * @function module:object.isStrictlyOneOf\r\n     * @param x {*}\r\n     * @param types {...TypeRef}\r\n     * @returns {boolean}\r\n     */\r\n    isStrictlyOneOf = isOneOf,\r\n\r\n    /**\r\n     * Checks if given value is either strictly one of given types or is\r\n     * an `instanceof` one of given types.\r\n     * @function module:object.isLooselyOneOf\r\n     * @param x {*}\r\n     * @param types {...TypeRef}\r\n     * @returns {boolean}\r\n     */\r\n    isLooselyOneOf = (x, ...types) =>\r\n        types.some(type => isType(type, x) || instanceOf(x, type)),\r\n\r\n    /**\r\n     * Checks if given value is instance of one of the types given.\r\n     * @function module:object.instanceOfOne\r\n     * @param x {*}\r\n     * @param types {...TypeRef}\r\n     * @returns {boolean}\r\n     */\r\n    instanceOfOne = (x, ...types) => types.some(instanceOf(x)),\r\n\r\n    /**\r\n     * Checks if value qualifies (has `map` method) as a functor.\r\n     * @function module:object.isFunctor\r\n     * @param x {*}\r\n     * @returns {bool}\r\n     */\r\n    isFunctor = x => x && x.map && instanceOf(Function, x.map)\r\n\r\n;\r\n","/**\r\n * @memberOf object\r\n */\r\n\r\nimport {isset} from './is';\r\nimport {curry} from '../function/curry';\r\n\r\n/**\r\n * Looks up property and returns it's value; Else `undefined`.\r\n * Method is null safe (will not throw on `null` or `undefined`).\r\n * @function module:object.lookup\r\n * @param key {String} - Key to search on `obj`\r\n * @param obj {Object} - Object to search `name` on.\r\n * @returns {*}\r\n */\r\nexport const lookup = curry((key, obj) => isset(obj) ? obj[key] : undefined);\r\n","import {isFunction, isset, isUsableImmutablePrimitive} from './is';\r\nimport {apply} from '../jsPlatform/function';\r\n\r\n/**\r\n * Creates a value `of` given type;  Checks for one of the following construction strategies (in order listed):\r\n * @example\r\n * // - If exists `(value).constructor.of` uses this.\r\n * // - If value is of one String, Boolean, Symbol, or Number types calls it's\r\n * //      constructor as a function (in cast form;  E.g., `constructor(...args)` )\r\n * // - Else if constructor is a function, thus far, then calls constructor using\r\n * //      the `new` keyword (with any passed in args).\r\n\r\n * @function module:object.of\r\n * @param x {*} - Value to derive returned value's type from.\r\n * @param [args] {...*} - Any args to pass in to matched construction strategy.\r\n * @returns {*|undefined} - New value of given value's type else `undefined`.\r\n */\r\nexport const of = (x, ...args) => {\r\n    if (!isset(x)) { return undefined; }\r\n    const constructor = x.constructor;\r\n    if (constructor.hasOwnProperty('of')) {\r\n        return apply(constructor.of, args);\r\n    }\r\n    else if (isUsableImmutablePrimitive(x)) {\r\n        return apply(constructor, args);\r\n    }\r\n    else if (isFunction(constructor)) {\r\n        return new constructor(...args);\r\n    }\r\n    return undefined;\r\n};\r\n","import {typeOf} from './typeOf';\r\nimport {of} from './of';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Make a copy of a value or optionally copy incoming value onto an outgoing value (second parameter).\r\n     * @note If incoming thing is an immmutable primitive (string, number, symbol, null, undefined, boolean)\r\n     *  it is returned as is.\r\n     * @function module:object.copy\r\n     * @param x {*} - Thing to copy.\r\n     * @param [out = undefined] {*} - Optional value to copy on to.  Not required.\r\n     * @returns {*} - Copied thing or optionally outgoing value copied onto.\r\n     */\r\n    copy = (x, out) => {\r\n        // if `null`, `undefined`, `''`, `0`, `false` return\r\n        if (!x) { return x; }\r\n        switch (typeOf(x)) {\r\n            case Array.name:\r\n                return !out ? x.slice(0) : Object.assign(out, x);\r\n\r\n            // If immutable primitive, return it\r\n            case Symbol.name:\r\n            case Boolean.name:\r\n            case String.name:\r\n            case Number.name:\r\n            case Promise.name:\r\n            case Function.name:\r\n            case 'NaN':\r\n            case 'Null':\r\n            case 'Undefined':\r\n                return x;\r\n\r\n            case 'Map':\r\n            case 'Set':\r\n            case 'WeakMap':\r\n            case 'WeakSet':\r\n                return new x.constructor(Array.from(x));\r\n\r\n            // Else make copy\r\n            default:\r\n                return Object.assign(!out ? of(x) : out, x);\r\n        }\r\n    }\r\n;\r\n\r\nexport default copy;\r\n","import {isset} from './is';\r\nimport {curry} from '../function/curry';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Gives you value at key/namespace-key within `obj`;  E.g.,\r\n     * searchObj('all.your.base', {all: {your: {base: 99}}}) === 99 // `true`\r\n     * @note If key is unreachable (undefined) returns `undefined`.\r\n     *  Useful in cases where we do not want to check each key along the way before getting/checking value;  E.g.,\r\n     * @example\r\n     * ```\r\n     * if (obj && obj.all && obj.all.your && obj.all.your.base) {\r\n     *   // Thing we want to do\r\n     * }\r\n     *\r\n     * // So with our function becomes\r\n     * if (searchObj('all.your.base', obj)) {\r\n     *   // Thing we want to do\r\n     * }\r\n     * ```\r\n     * @function module:object.searchObj\r\n     * @param nsString {String}\r\n     * @param obj {*}\r\n     * @returns {*}\r\n     */\r\n    searchObj = curry((nsString, obj) => {\r\n        if (!obj) { return obj; }\r\n        if (nsString.indexOf('.') === -1) {\r\n            return obj[nsString];\r\n        }\r\n        const parts = nsString.split('.'),\r\n            limit = parts.length;\r\n        let ind = 0,\r\n            parent = obj;\r\n        for (; ind < limit; ind += 1) {\r\n            const node = parent[parts[ind]];\r\n            if (!isset(node)) {\r\n                return node;\r\n            }\r\n            parent = node;\r\n        }\r\n        return parent;\r\n    })\r\n;\r\n","\r\nimport {isObject} from './is';\r\nimport {keys} from '../jsPlatform/object';\r\nimport {curry2} from '../function/curry';\r\n\r\nexport const\r\n    /**\r\n     * Merges all objects down into one (takes two or more args).\r\n     * @function module:object.assignDeep\r\n     * @param obj0 {Object}\r\n     * @param [objs] {...{Object}} - One or more objects to merge onto `obj0`.\r\n     * @returns {Object}\r\n     */\r\n    assignDeep = curry2((obj0, ...objs) =>\r\n        !obj0 ? obj0 : objs.reduce((topAgg, obj) =>\r\n            !obj ? topAgg : keys(obj).reduce((agg, key) => {\r\n                let propDescription = Object.getOwnPropertyDescriptor(agg, key);\r\n                // If property is not writable move to next item in collection\r\n                if (agg.hasOwnProperty(key) && propDescription &&\r\n                    !(propDescription.get && propDescription.set) &&\r\n                    !propDescription.writable) {\r\n                    return agg;\r\n                }\r\n                if (isObject(agg[key]) && isObject(obj[key])) {\r\n                    assignDeep(agg[key], obj[key]);\r\n                }\r\n                else { agg[key] = obj[key]; }\r\n                return agg;\r\n            }, topAgg)\r\n        , obj0));\r\n","/**\r\n *  List operations that overlap (apart from globally overlapping props and functions like `length`)\r\n *      on both strings and arrays.\r\n */\r\n\r\nimport {fPureTakesOne, fPureTakes2, fPureTakesOneOrMore} from '../utils';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Concats/appends all functors onto the end of first functor.\r\n     * Note:  functors passed in after the first one must be of the same type.\r\n     * @function module:jsPlatform.concat\r\n     * @param functor {Array|Object|*}\r\n     * @param ...functor {Array|Object|*}\r\n     * @return {*|Array|Object} - The type passed.\r\n     * @throws {Error} - When passed in object doesn't have an `every` method.\r\n     */\r\n    concat = fPureTakesOneOrMore('concat'),\r\n\r\n    /**\r\n     * Same as Array.prototype.slice\r\n     * @function module:list.slice\r\n     * @param separator {String|RegExp}\r\n     * @param arr{Array}\r\n     * @returns {Array}\r\n     */\r\n    slice = fPureTakes2('slice'),\r\n\r\n    /**\r\n     * `Array.prototype.includes` or shim.\r\n     * @function module:list.includes\r\n     * @param value {*}\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    includes = (() => 'includes' in Array.prototype ?\r\n            fPureTakesOne('includes') :\r\n            (value, xs) => xs.indexOf(value) > -1)(),\r\n\r\n    /**\r\n     * Searches list/list-like for given element `x`.\r\n     * @function module:list.indexOf\r\n     * @param x {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like to look in.\r\n     * @returns {Number} - `-1` if element not found else index at which it is found.\r\n     */\r\n    indexOf = fPureTakesOne('indexOf'),\r\n\r\n    /**\r\n     * Last index of (`Array.prototype.lastIndexOf`).\r\n     * @function module:list.lastIndexOf\r\n     * @param x {*} - Element to search for.\r\n     * @param xs {Array|String|*} - list or list like to look in.\r\n     * @returns {Number} - `-1` if element not found else index at which it is found.\r\n     */\r\n    lastIndexOf = fPureTakesOne('lastIndexOf')\r\n\r\n;\r\n","/**\r\n * @module boolean\r\n * @description Contains functional version of 'always-true', 'always-false', 'is-truthy', and 'is-falsy'.\r\n */\r\nimport {curry, curry2} from './function/curry';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns whether `value` is 'truthy' or not\r\n     * @function module:boolean.isTruthy\r\n     * @param value\r\n     * @returns {Boolean}\r\n     */\r\n    isTruthy = value => !!value,\r\n\r\n    /**\r\n     * Returns whether `value` is 'falsy' or not\r\n     * @function module:boolean.isFalsy\r\n     * @param value\r\n     * @returns {Boolean}\r\n     */\r\n    isFalsy = value => !value,\r\n\r\n    /**\r\n     * Returns `true`.\r\n     * @function module:boolean.alwaysTrue\r\n     * @returns {Boolean}\r\n     */\r\n    alwaysTrue = () => true,\r\n\r\n    /**\r\n     * Returns `false`.\r\n     * @function module:boolean.alwaysFalse\r\n     * @returns {Boolean}\r\n     */\r\n    alwaysFalse = () => false,\r\n\r\n    /**\r\n     * Equality operator.\r\n     * @function module:boolean.equal\r\n     * @param a {*}\r\n     * @param b {*}\r\n     * @returns {boolean}\r\n     */\r\n    equal = curry((a, b) => a === b),\r\n\r\n    /**\r\n     * Equality operator for all.\r\n     * @function module:boolean.equalAll\r\n     * @param a {*} - Item `0`.\r\n     * @param args {...*} - Others\r\n     * @returns {boolean}\r\n     */\r\n    equalAll = curry2((a, ...args) => args.every(b => equal(a, b)))\r\n\r\n;\r\n","import {length} from '../jsPlatform/object';\r\nimport {curry} from '../function/curry';\r\nimport {typeOf} from '../object/typeOf';\r\nimport {of} from '../object/of';\r\nimport {isFunctor, isset} from '../object/is';\r\n\r\n/**\r\n * Maps a function onto a List (string or array) or a functor (value containing a map method).\r\n * @function module:list.map\r\n * @param fn {Function} - Function to map on given value.\r\n * @param xs {Array|String|*}\r\n * @returns {Array|String|*}\r\n */\r\nconst map = curry((fn, xs) =>  {\r\n    if (!isset(xs)) { return xs; }\r\n    let out = of(xs),\r\n        limit,\r\n        i = 0;\r\n    switch (typeOf(xs)) {\r\n        case 'Array':\r\n            limit = length(xs);\r\n            if (!limit) { return out; }\r\n            for (; i < limit; i += 1) {\r\n                out.push(fn(xs[i], i, xs));\r\n            }\r\n            return out;\r\n        case 'String':\r\n            limit = length(xs);\r\n            if (!xs) { return out; }\r\n            for (; i < limit; i += 1) {\r\n                out += fn(xs[i], i, xs);\r\n            }\r\n            return out;\r\n        default:\r\n            if (isFunctor(xs)) { return xs.map(fn); }\r\n\r\n            // Other objects\r\n            return Object.keys(xs).reduce((agg, key) => {\r\n                out[key] = fn(xs[key], key, xs);\r\n                return out;\r\n            }, out);\r\n    }\r\n});\r\n\r\nexport default map;\r\n","\r\nexport const\r\n\r\n    /**\r\n     * Pushes incoming `item` onto given array and returns said array.\r\n     * @private\r\n     * @param agg {Array}\r\n     * @param item {*}\r\n     * @returns {Array}\r\n     */\r\n    aggregateArray = (agg, item) => {\r\n        agg.push(item);\r\n        return agg;\r\n    }\r\n\r\n;\r\n","/**\r\n * List operator utils module.\r\n * @module listUtils\r\n */\r\nimport {apply}          from '../jsPlatform/function';  // un-curried version\r\nimport {slice}          from '../jsPlatform/slice';      // un-curried version good for both strings and arrays\r\nimport {length}         from '../jsPlatform/object';\r\nimport {alwaysFalse}    from '../boolean';\r\nimport map              from './map';\r\nimport {curry, curry2}  from '../function/curry';\r\n\r\nexport * from './aggregation';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns a slice of the given list from `startInd` to the end of the list.\r\n     * @function module:listUtils.sliceFrom\r\n     * @param startInd {Number}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    sliceFrom = curry((startInd, xs) => slice(startInd, undefined, xs)),\r\n\r\n    /**\r\n     * Slices from index `0` to given index.\r\n     * @function module:listUtils.sliceTo\r\n     * @param toInd {Number}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    sliceTo = curry((toInd, xs) => slice(0, toInd, xs)),\r\n\r\n    /**\r\n     * Slices a copy of list.\r\n     * @function listUtils.sliceCopy\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    sliceCopy = sliceFrom(0),\r\n\r\n    /**\r\n     * Generic 'ascending order' ordering function (use by the likes of `list.sort` etc.)\r\n     * @function module:listUtils.genericAscOrdering\r\n     * @param a {*}\r\n     * @param b {*}\r\n     * @returns {number}\r\n     */\r\n    genericAscOrdering = curry((a, b) => {\r\n        if (a > b) { return 1; }\r\n        else if (a < b) { return -1; }\r\n        return 0;\r\n    }),\r\n\r\n    /**\r\n     * Returns length of all passed lists in list.\r\n     * @function module:listUtils.lengths\r\n     * @param lists ...{Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    lengths = curry2((...lists) => map(length, lists)),\r\n\r\n    /**\r\n     * Returns a list of lists trimmed to the shortest length in given list of lists.   @background This method is used by the `zip*` functions to achieve their\r\n     *  'slice to smallest' functionality.\r\n     * @function module:listUtils.toShortest\r\n     * @param lists {...(Array|String|*)}\r\n     * @returns {Array|String|*}\r\n     */\r\n    toShortest = curry2((...lists) => {\r\n        const listLengths = apply(lengths, lists),\r\n            smallLen = Math.min.apply(Math, listLengths);\r\n        return map((list, ind) => listLengths[ind] > smallLen ?\r\n            sliceTo(smallLen, list) : sliceCopy(list), lists);\r\n    }),\r\n\r\n    /**\r\n     * Reduces until predicate.\r\n     * @function module:listUtils.reduceUntil\r\n     * @param pred {Function} - `(item, index, list) => Boolean(...)`\r\n     * @param op {Function} - Operation - `(agg, item, index, list) => agg`\r\n     * @param agg {*} - Zero value.\r\n     * @param xs {Array|String|*} - List.\r\n     * @returns {*}\r\n     */\r\n    reduceUntil = curry((pred, op, agg, xs) => {\r\n        const limit = length(xs);\r\n        if (!limit) { return agg; }\r\n        let ind = 0,\r\n            result = agg;\r\n        for (; ind < limit; ind++) {\r\n            if (pred(xs[ind], ind, xs)) { break; }\r\n            result = op(result, xs[ind], ind, xs);\r\n        }\r\n        return result;\r\n    }),\r\n\r\n    /**\r\n     * Reduces until predicate (from right to left).\r\n     * @function module:listUtils.reduceUntilRight\r\n     * @param pred {Function} - `(item, index, list) => Boolean(...)`\r\n     * @param op {Function} - Operation - `(agg, item, index, list) => agg`\r\n     * @param agg {*} - Zero value.\r\n     * @param xs {Array|String|*} - List.\r\n     * @returns {*}\r\n     */\r\n    reduceUntilRight = curry((pred, op, agg, arr) => {\r\n        const limit = length(arr);\r\n        if (!limit) { return agg; }\r\n        let ind = limit - 1,\r\n            result = agg;\r\n        for (; ind >= 0; ind--) {\r\n            if (pred(arr[ind], ind, arr)) { break; }\r\n            result = op(result, arr[ind], ind, arr);\r\n        }\r\n        return result;\r\n    }),\r\n\r\n    /**\r\n     * Reduces a list with given operation (`op`) function.\r\n     * @function module:listUtils.reduce\r\n     * @param op {Function} - Operation - `(agg, item, index, list) => agg`\r\n     * @param agg {*} - Zero value.\r\n     * @param xs {Array|String|*} - List.\r\n     * @returns {*}\r\n     */\r\n    reduce = reduceUntil(alwaysFalse),\r\n\r\n    /**\r\n     * Reduces a list with given operation (`op`) function (from right-to-left).\r\n     * @function module:listUtils.reduceRight\r\n     * @param op {Function} - Operation - `(agg, item, index, list) => agg`\r\n     * @param agg {*} - Zero value.\r\n     * @param xs {Array|String|*} - List.\r\n     * @returns {*}\r\n     */\r\n    reduceRight = reduceUntilRight(alwaysFalse),\r\n\r\n    /**\r\n     * Gets last index of a list/list-like (Array|String|Function etc.).\r\n     * @function module:listUtils.lastIndex\r\n     * @param x {Array|String|*} - list like or list.\r\n     * @returns {Number} - `-1` if no element found.\r\n     */\r\n    lastIndex = x => { const len = length(x); return len ? len - 1 : 0; },\r\n\r\n    /**\r\n     * Finds index in string or list.\r\n     * @function module:listUtils.findIndexWhere\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    findIndexWhere = curry((pred, arr) => {\r\n        let ind = 0;\r\n        const limit = length(arr);\r\n        for (; ind < limit; ind += 1) {\r\n            const predicateFulfilled = !!pred(arr[ind], ind, arr);\r\n            if (predicateFulfilled) {\r\n                return ind;\r\n            }\r\n        }\r\n        return -1;\r\n    }),\r\n\r\n    /**\r\n     * Finds index in list from right to left.\r\n     * @function module:listUtils.findIndexWhereRight\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    findIndexWhereRight = curry((pred, arr) => {\r\n        let ind = length(arr) - 1;\r\n        for (; ind >= 0; ind -= 1) {\r\n            const predicateFulfilled = !!pred(arr[ind], ind, arr);\r\n            if (predicateFulfilled) {\r\n                return ind;\r\n            }\r\n        }\r\n        return -1;\r\n    }),\r\n\r\n    /**\r\n     * @function module:listUtils.findIndicesWhere\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {Array|undefined}\r\n     */\r\n    findIndicesWhere = curry((pred, xs) => {\r\n        const limit = length(xs);\r\n        let ind = 0,\r\n            out = [];\r\n        for (; ind < limit; ind++) {\r\n            if (pred(xs[ind], ind, xs)) { out.push(ind); }\r\n        }\r\n        return out.length ? out : undefined;\r\n    }),\r\n\r\n    /**\r\n     * @function module:listUtils.findWhere\r\n     * @param pred {Function}\r\n     * @param xs {Array|String|*} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    findWhere = curry((pred, xs) => {\r\n        let ind = 0,\r\n            limit = length(xs);\r\n        if (!limit) { return; }\r\n        for (; ind < limit; ind++) {\r\n            let elm = xs[ind];\r\n            if (pred(elm, ind, xs)) { return elm; }\r\n        }\r\n        return undefined;\r\n    })\r\n\r\n;\r\n","import {assignDeep} from './assignDeep';\r\nimport {keys} from '../jsPlatform/object';\r\nimport {reduce} from '../list/utils';\r\nimport {curry, curry2} from '../function/curry';\r\n\r\nexport const\r\n\r\n    objUnion = curry((obj1, obj2) => assignDeep(obj1, obj2)),\r\n\r\n    objIntersect = curry((obj1, obj2) => reduce((agg, key) => {\r\n        if (obj2.hasOwnProperty(key)) {\r\n            agg[key] = obj2[key];\r\n        }\r\n        return agg;\r\n    }, {}, keys(obj1))),\r\n\r\n    objDifference = curry((obj1, obj2) => reduce((agg, key) => {\r\n        if (!obj2.hasOwnProperty(key)) {\r\n            agg[key] = obj1[key];\r\n        }\r\n        return agg;\r\n    }, {}, keys(obj1))),\r\n\r\n    objComplement = curry2((obj0, ...objs) => reduce((agg, obj) =>\r\n        assignDeep(agg, objDifference(obj, obj0)), {}, objs));\r\n","/**\r\n * @module console\r\n * @description Console exports.\r\n */\r\nexport const\r\n\r\n    /**\r\n     * `Console.log` method.\r\n     * @function module:console.log\r\n     * @params args {...*}\r\n     * @returns {void}\r\n     */\r\n    log = console.log.bind(console),\r\n\r\n    /**\r\n     * `Console.error` method.\r\n     * @function module:console.error\r\n     * @params args {...*}\r\n     * @returns {void}\r\n     */\r\n    error = console.error.bind(console),\r\n\r\n    /**\r\n     * Peeks (console.log) at incoming value(s) and returns the last value.\r\n     * @function module:console.peek\r\n     * @param args {...*}\r\n     * @returns {*} Last given value (if one or more values) else first value.\r\n     */\r\n    peek = (...args) => (log(...args), args.pop()),\r\n\r\n    /**\r\n     * `Console.warn`.\r\n     * @function module:console.warn\r\n     * @param args {...*}\r\n     * @returns {void}\r\n     */\r\n    warn = console.warn.bind(console)\r\n\r\n;\r\n","export const\r\n\r\n    /**\r\n     * Clones and object or array using `JSON.parse(JSON.stringify(...))` pattern.\r\n     * @function module:object.jsonClone\r\n     * @param x {*}\r\n     * @returns {*}\r\n     */\r\n    jsonClone = x => JSON.parse(JSON.stringify(x))\r\n\r\n;\r\n","import {isArray, isType} from './is';\r\nimport {keys} from '../jsPlatform/object';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns an associated list from given object.\r\n     * @note Useful for working with plain javascript objects.\r\n     * @function module:object.toAssocList\r\n     * @param obj {(Object|Array|*)}\r\n     * @returns {Array.<*, *>}\r\n     */\r\n    toAssocList = obj => keys(obj).map(key => [key, obj[key]]),\r\n\r\n    /**\r\n     * Returns an associated list from given object (deeply (on incoming object's type)).\r\n     * @note Does deep conversion on all values of passed in type's type.\r\n     * @function module:object.toAssocListDeep\r\n     * @param obj {*}\r\n     * @param [TypeConstraint = Object] {(Constructor|Function)} - Type constraint to convert on.\r\n     * @returns {*}\r\n     */\r\n    toAssocListDeep = (obj, TypeConstraint = Object) => keys(obj).map(key =>\r\n        TypeConstraint && isType(TypeConstraint, obj[key]) ?\r\n            [key, toAssocListDeep(obj[key], TypeConstraint)] :\r\n            [key, obj[key]]\r\n    ),\r\n\r\n    /**\r\n     * From associated list to object.\r\n     * @function module:object.fromAssocList\r\n     * @param xs {Array.<Array>} - Associated list.\r\n     * @param [OutType = Object] {Constructor|Function} - Output type.  Default `Object`.\r\n     * @returns {*} - Default is `Object`\r\n     */\r\n    fromAssocList = (xs, OutType = Object) => xs.reduce((agg, [key, value]) => {\r\n        agg[key] = value;\r\n        return agg;\r\n    }, new OutType()),\r\n\r\n    /**\r\n     * From associated list to object (deep conversion on associative lists (array of 2 value arrays)).\r\n     * @note Considers array of arrays associated lists.\r\n     * @function module:object.fromAssocListDeep\r\n     * @param xs {Array.<Array>} - Associated list.\r\n     * @param [OutType = Object] {Constructor|Function} - Output type.  Default `Object`.\r\n     * @returns {*} - Default is `Object`\r\n     */\r\n    fromAssocListDeep = (xs, OutType = Object) => xs.reduce((agg, [key, value]) => {\r\n        if (isArray(value) && isArray(value[0]) && value[0].length === 2) {\r\n            agg[key] = fromAssocListDeep(value, OutType);\r\n            return agg;\r\n        }\r\n        agg[key] = value;\r\n        return agg;\r\n    }, new OutType())\r\n;\r\n","import {typeOf} from './typeOf';\r\nimport {toAssocList} from './assocList';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Converts incoming value to an array.\r\n     * @note For `WeakMap`, `WeakSet`, `Map` and `Set` result is the same as calling `Array.from` on such.\r\n     * @note For `null`, `undefined`, `NaN`, `Number{}`, `Symbol{}`, `Boolean{}` returns an empty array.\r\n     * @note Method does a shallow conversion;\r\n     * @function module:object.toArray\r\n     * @param x {*} - Thing to convert from.\r\n     * @returns {Array}\r\n     */\r\n    toArray = x => {\r\n        switch (typeOf(x)) {\r\n            case 'Null':\r\n            case 'Undefined':\r\n                return [];\r\n            case String.name:\r\n            case Array.name:\r\n            case 'WeakMap':\r\n            case 'WeakSet':\r\n            case 'Map':\r\n            case 'Set':\r\n                return Array.from(x);\r\n            case Object.name:\r\n            default:\r\n                return toAssocList(x);\r\n        }\r\n    }\r\n\r\n;\r\n","/**\r\n * @module object\r\n * @description Object operations/combinators.\r\n */\r\n\r\nexport * from './jsPlatform/object';\r\nexport * from './object/lookup';\r\nexport * from './object/typeOf';\r\nexport * from './object/copy';\r\nexport * from './object/is';\r\nexport * from './object/of';\r\nexport * from './object/searchObj';\r\nexport * from './object/assignDeep';\r\nexport * from './object/setTheory';\r\nexport * from './object/console';\r\nexport * from './object/jsonClone';\r\nexport * from './object/toArray';\r\nexport * from './object/assocList';\r\n","import {reduceRight} from '../jsPlatform/array';\r\n\r\n/**\r\n * Composes all functions passed in from right to left passing each functions return value to\r\n * the function on the left of itself.\r\n * @function module:function.compose\r\n * @type {Function}\r\n * @param args {...{Function}}\r\n * @returns {Function}\r\n */\r\nexport const compose = (...args) =>\r\n        arg0 => reduceRight((value, fn) => fn(value), arg0, args);\r\n","/**\r\n * @memberOf function\r\n */\r\n\r\n/**\r\n * Returns passed in parameter.\r\n * @haskellType `id :: a -> a`\r\n * @function module:function.id\r\n * @param x {*}\r\n * @returns {*}\r\n */\r\nexport const id = x => x;\r\n","/**\r\n * @memberOf function\r\n */\r\n\r\nimport {apply} from '../jsPlatform/function';\r\nimport {curry, curry2} from './curry';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Negates a function that takes one/no argument.\r\n     * @function module:function.negateF\r\n     * @param fn {Function}\r\n     * @returns {function(*=): boolean}\r\n     */\r\n    negateF = fn => x => !fn(x),\r\n\r\n    /**\r\n     * Takes a function that takes two parameters and returns a negated version of given\r\n     * function.\r\n     * @function module:_negate.negateF2\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateF2 = fn => curry((a, b) => !fn(a, b)),\r\n\r\n    /**\r\n     * Takes a function that takes three parameters and returns a\r\n     * negated version of given function.\r\n     * @function module:_negate.negateF3\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateF3 = fn => curry((a, b, c) => !fn(a, b, c)),\r\n\r\n    /**\r\n     * Returns a negated version of given function.\r\n     * Returned function is variadiac (takes one or more arguments).\r\n     * @note function returned is uncurried.\r\n     * @uncurried\r\n     * @function module:function.negateFN\r\n     * @param fn {Function}\r\n     * @returns {Function}\r\n     */\r\n    negateFN = fn => curry2((...args) => !apply(fn, args));\r\n","import {curry} from './curry';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Run `operation` until predicate returns `true` (like a functional\r\n     *  version of a while loop).\r\n     * @function module:function.until\r\n     * @param predicate {Function} :: a -> Boolean\r\n     * @param operation {Function} :: a -> a\r\n     * @param typeInstance {*} :: * - A monoidal zero or some starting point.\r\n     * @returns {*} - What ever type `typeInstance` is\r\n     */\r\n    until = curry((predicate, operation, typeInstance) => {\r\n        let result = typeInstance;\r\n        while (!predicate(result)) {\r\n            result = operation(result);\r\n        }\r\n        return result;\r\n    });\r\n","import {typeOf} from '../object/typeOf';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns a function or throws an error if given `f` is not a function.\r\n     * @function module:function.fnOrError\r\n     * @param symbolName {String} - Error message prefix.\r\n     * @param f {Function|*} - Expected function.\r\n     * @returns {Function}\r\n     * @throws {Error} - Error if `f` is not of `function`\r\n     */\r\n    fnOrError = (symbolName, f) => {\r\n        if (!f || !(f instanceof Function)) {\r\n            throw new Error(`${symbolName} should be a function. ` +\r\n                `Type received: ${typeOf(f)};  Value received: ${f}.`);\r\n        }\r\n        return f;\r\n    }\r\n\r\n;\r\n","/**\r\n * No-op ('op' as in 'operation') - Performs no operation 'always' (good for places where\r\n * a value should always be a function etc.).\r\n * @function module:function.noop\r\n * @returns {undefined}\r\n */\r\nexport const noop = () => undefined;\r\n","/**\r\n * Trampolines function calls in order to avoid stack overflow errors\r\n * on recursive function calls; Tail recursion replacement.\r\n * @example\r\n * // Instead of ... (which is prone to stack-overflow in\r\n * //   non-tail-call optimized environments (es5-es3))\r\n * const factorial = n => n > 1 ? n * factorial(n - 1) : 1;\r\n *\r\n * // We do\r\n * const\r\n *\r\n *  factorialProcess = (n, agg = 1) => {\r\n *      n > 1 ? () => factorialProcess(n - 1, agg * n) : agg,\r\n *  },\r\n *\r\n *  factorial = trampoline(factorialProcess)\r\n *  // will not overflow as we are performing tail call elimination\r\n *  // by returning thunks from factorial process which run in `while` loop\r\n *  // within `trampoline`.\r\n *\r\n *  ;\r\n *\r\n * @note function returned by trampoline is not curried (for convenience)!\r\n * @function module:function.trampoline\r\n * @param fn {Function} - Function to trampoline.\r\n * @param [fnName=undefined] {String} - Optionally restrict trampolining only to function with specific name.\r\n * @returns {*} - Finally returned value.\r\n */\r\nexport const trampoline = (fn, fnName) => {\r\n    return (...args) => {\r\n        let result = fn.apply(null, args);\r\n        while (typeof result === 'function' &&\r\n            (!fnName || (result.name === fnName))) {\r\n            result = result();\r\n        }\r\n        return result;\r\n    };\r\n};\r\n","import {isFunction} from '../object/is';\r\n\r\nexport const\r\n\r\n    /**\r\n     * If given value is not a function, wraps it an 'identity' function (function that returns given value untouched) else returns given value. (useful in\r\n     * functional composition).\r\n     * @function module:function.toFunction\r\n     * @param x {Function|any}\r\n     * @returns {function(): any}\r\n     */\r\n    toFunction = x => isFunction(x) ? x : () => x;\r\n","/**\r\n * @module function\r\n */\r\nexport * from './jsPlatform/function';\r\nexport * from './function/compose';\r\nexport * from './function/curry';\r\nexport * from './function/flip';\r\nexport * from './function/id';\r\nexport * from './function/negate';\r\nexport * from './function/until';\r\nexport * from './function/fnOrError';\r\nexport * from './function/noop';\r\nexport * from './function/trampoline';\r\nexport * from './function/toFunction';\r\n","/**\r\n * @module object\r\n */\r\nimport {curry} from '../function/curry';\r\n\r\n/**\r\n * Normalizes step for `from` and `to` combination.\r\n * @function module:list.normalizeStep\r\n * @param from {Number}\r\n * @param to {Number}\r\n * @param [step = 1] {Number}\r\n * @returns {Number}\r\n * @private\r\n */\r\nconst normalizeStep = (from, to, step) => {\r\n    if (from > to) {\r\n        return step > 0 ? -step : step; // make step negative\r\n    }\r\n    return step < 0 ? -1 * step : step; // make step positive\r\n};\r\n\r\nexport const\r\n\r\n    /**\r\n     * Range function - gives you an array contain numbers in given range.\r\n     * @note normalizes `step` to be valid if range numbers given are invalid\r\n     *  (forces `step` to be negative if range required is in the negative direction\r\n     *  and forces `step` to be positive if range required is in the other direction).\r\n     * @function module:list.range\r\n     * @param from {Number}\r\n     * @param to {Number}\r\n     * @param [step = 1] {Number}\r\n     * @returns {Array.<Number>}\r\n     */\r\n    range = curry((from, to, step = 1) => {\r\n        let i = from;\r\n        const out = [];\r\n        step = normalizeStep(from, to, step);\r\n        if (step === 0 || from === to) { return [from]; }\r\n        for (; (to - i) * step >= 0; i += step) { out.push(i); }\r\n        return out;\r\n    })\r\n;\r\n","/**\r\n * Created by elydelacruz on 9/6/2017.\r\n */\r\n\r\nimport {fPureTakesOne} from '../utils';\r\n\r\n/**\r\n * Functional version of `String.prototype.split`.\r\n * @function module:jsPlatform.split\r\n * @param separator {String|RegExp}\r\n * @param str {String}\r\n * @returns {Array}\r\n */\r\nexport const split = fPureTakesOne('split');\r\n","/**\r\n * @module jsPlatform\r\n */\r\nexport * from './jsPlatform/object';\r\nexport * from './jsPlatform/array';\r\nexport * from './jsPlatform/slice';\r\nexport * from './jsPlatform/string';\r\nexport * from './jsPlatform/function';\r\n","/**\r\n * List operations module.\r\n * @module list\r\n */\r\nimport {concat as listAppend, indexOf, slice, includes} from './jsPlatform/slice';\r\nimport {apply} from './jsPlatform/function';\r\nimport {length} from './jsPlatform/object';\r\nimport {negateF3, negateF2} from './function/negate';\r\nimport {curry, curry2, curry3} from './function/curry';\r\nimport {isTruthy, isFalsy} from './boolean';\r\nimport {lookup} from './object/lookup';\r\nimport {of} from './object/of';\r\nimport {isset, isString} from './object/is';\r\nimport {typeOf} from './object/typeOf';\r\nimport map from './list/map';\r\n\r\nimport {\r\n    sliceFrom, sliceTo, lengths,\r\n    toShortest, aggregateArray,\r\n    reduceUntil, reduce, reduceRight, lastIndex,\r\n    findIndexWhere, findIndexWhereRight, findIndicesWhere,\r\n    findWhere, sliceCopy, genericAscOrdering\r\n}\r\n    from './list/utils';\r\n\r\nexport * from './list/range';\r\n\r\nexport * from './list/utils';\r\n\r\nexport {map};\r\n\r\nexport {slice, includes, indexOf, lastIndexOf, push} from './jsPlatform';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Append two, or more, lists, i.e.,\r\n     * @example\r\n     * expectEqual(append(take(13, alphabetString), drop(13, alphabetString)), alphabetString); // true\r\n     *\r\n     * // Another example\r\n     * const result = append(\r\n     *   alphabetStr.split(''),\r\n     *   alphabetStr.split('')\r\n     * ),\r\n     * expected = repeat(2, alphabetStr).split('');\r\n     *\r\n     * shallowEquals(result, expected) === true // `true`\r\n     *\r\n     * @function module:list.append\r\n     * @param [args] {...(Array|String|*)} - One or more lists or list likes (strings etc.).\r\n     * @returns {(Array|String|*)} - Same type as list like passed in.\r\n     */\r\n    append = curry2((...args) => apply(listAppend, args)),\r\n\r\n    /**\r\n     * Returns head of list (first item of list).\r\n     * @haskellType `head :: [a] -> a`\r\n     * @function module:list.head\r\n     * @param x {Array|String}\r\n     * @returns {*} - First item from list\r\n     */\r\n    head = x => x[0],\r\n\r\n    /**\r\n     * Returns last item of list.\r\n     * @haskellType `last :: [a] -> a`\r\n     * @function module:list.last\r\n     * @param xs {Array|String}\r\n     * @returns {*}\r\n     */\r\n    last = xs => xs[lastIndex(xs)],\r\n\r\n    /**\r\n     * Returns tail part of list (everything after the first item as new list).\r\n     * @haskelType `tail :: [a] -> [a]`\r\n     * @function module:list.tail\r\n     * @param xs {Array|String}\r\n     * @returns {Array|String}\r\n     */\r\n    tail = xs => sliceFrom(1, xs),\r\n\r\n    /**\r\n     * Returns everything except last item of list as new list.\r\n     * @haskellType `init :: [a] -> [a]`\r\n     * @function module:list.init\r\n     * @param xs {Array|String}\r\n     * @returns {Array|String}\r\n     */\r\n    init = xs => sliceTo(lastIndex(xs), xs),\r\n\r\n    /**\r\n     * Returns `head` and `tail` of passed in list/string in a tuple.\r\n     * @haskellType `uncons :: [a] -> Maybe (a, [a])`\r\n     * @function module:list.uncons\r\n     * @param xs {Array|String}\r\n     * @returns {Array|undefined}\r\n     */\r\n    uncons = xs => !xs || length(xs) === 0 ? undefined : [head(xs), tail(xs)],\r\n\r\n    /**\r\n     * Returns `tail` and `head` of passed in list/string in a tuple.\r\n     * @haskellType `unconsr :: [a] -> Maybe ([a], a)`\r\n     * @function module:list.unconsr\r\n     * @param xs {Array|String}\r\n     * @returns {Array|String|*|undefined}\r\n     */\r\n    unconsr = xs => !xs || length(xs) === 0 ? undefined : [init(xs), last(xs)],\r\n\r\n    /**\r\n     * Concatenates all the elements of a container of lists.\r\n     * @haskellType `concat :: Foldable t => t [a] -> [a]`\r\n     * @function module:list.concat\r\n     * @param xs {Array}\r\n     * @returns {Array}\r\n     */\r\n    concat = xs => {\r\n        switch (length(xs)) {\r\n            case undefined:\r\n            case 0:\r\n                return [];\r\n            case 1:\r\n                const item0 = xs[0];\r\n                return item0 && item0.slice ? sliceCopy(item0) : item0;\r\n            case 2:\r\n            default:\r\n                return apply(append, xs);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Map a function over all the elements of a container and concatenate the resulting lists.\r\n     * @haskellType `concatMap :: Foldable t => (a -> [b]) -> t a -> [b]`\r\n     * @function module:list.concatMap\r\n     * @param fn {Function}\r\n     * @param foldableOfA {Array}\r\n     * @returns {Array}\r\n     */\r\n    concatMap = curry((fn, foldableOfA) => concat(map(fn, foldableOfA))),\r\n\r\n    /**\r\n     * Returns a copy of the passed in list reverses.\r\n     * @haskellType `reverse :: [a] -> [a]`\r\n     * @function module:list.reverse\r\n     * @param xs {Array|String}\r\n     * @returns {Array|String}\r\n     */\r\n    reverse = xs => {\r\n        if (!isset(xs) || !xs.length) {\r\n            return xs;\r\n        }\r\n        let out = of(xs),\r\n            i = xs.length - 1;\r\n        switch (typeOf(xs)) {\r\n            case 'String':\r\n                for (; i >= 0; i -= 1) {\r\n                    out += xs[i];\r\n                }\r\n                return out;\r\n            default:\r\n                for (; i >= 0; i -= 1) {\r\n                    out.push(xs[i]);\r\n                }\r\n                return out;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Takes an element and a list and `intersperses' that element between the\r\n     *  elements of the list.\r\n     * @function module:list.intersperse\r\n     * @note In our version of the function javascript is loosely typed so,\r\n     *  so is our function (to much overhead to make it typed) so `between` can be any value.\r\n     * @param between {*} - Should be of the same type of elements contained in list.\r\n     * @param arr {Array|String} - List.\r\n     * @returns {Array|String}\r\n     */\r\n    intersperse = curry((between, xs) => {\r\n        if (!xs || !xs.length) {\r\n            return xs;\r\n        }\r\n        const limit = xs.length,\r\n            lastInd = limit - 1;\r\n        let out = of(xs),\r\n            i = 0;\r\n        if (isString(xs)) {\r\n            for (; i < limit; i += 1) {\r\n                out += i === lastInd ?\r\n                    xs[i] : xs[i] + between;\r\n            }\r\n            return out;\r\n        }\r\n        for (; i < limit; i += 1) {\r\n            if (i === lastInd) {\r\n                out.push(xs[i]);\r\n            } else {\r\n                out.push(xs[i], between);\r\n            }\r\n        }\r\n        return out;\r\n    }),\r\n\r\n    /**\r\n     * `intercalate xs xss` is equivalent to (concat (intersperse xs xss)). It inserts the list xs in between the lists in xss and concatenates the result.\r\n     * @haskellType `intercalate :: [a] -> [[a]] -> [a]`\r\n     * @function module:list.intercalate\r\n     * @param xs {Array|String}\r\n     * @param xss {Array|String}\r\n     * @returns {Array|String}\r\n     */\r\n    intercalate = curry((xs, xss) => {\r\n        if (isString(xss)) {\r\n            return intersperse(xs, xss);\r\n        }\r\n        return concat(intersperse(xs, xss));\r\n    }),\r\n\r\n    /**\r\n     * Transposes rows and columns into lists by index;  E.g.,\r\n     * Haskell example:\r\n     * ```\r\n     *  transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]\r\n     *\r\n     *  -- Notice the shorter arrays are ignored after their last index is copied over:\r\n     *  transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]\r\n     * ```\r\n     * @note from columns to rows.\r\n     * @note Empty lists are ignored.\r\n     * @haskellType `transpose :: [[a]] -> [[a]]`\r\n     * @function module:list.transpose\r\n     * @param xss {Array}\r\n     * @returns {Array}\r\n     */\r\n    transpose = xss => {\r\n        let numLists = length(xss),\r\n            ind = 0, ind2;\r\n        if (!numLists) {\r\n            return [];\r\n        }\r\n        const listLengths = apply(lengths, xss),\r\n            longestListLen = maximum(listLengths),\r\n            outLists = [];\r\n        for (; ind < longestListLen; ind += 1) {\r\n            const outList = [];\r\n            for (ind2 = 0; ind2 < numLists; ind2 += 1) {\r\n                if (listLengths[ind2] < ind + 1) {\r\n                    continue;\r\n                }\r\n                outList.push(xss[ind2][ind]);\r\n            }\r\n            outLists.push(outList);\r\n        }\r\n        return filter(x => length(x) > 0, outLists);\r\n    },\r\n\r\n    /**\r\n     * Generates 2^n sub-sequences for passed in sequence (string/list) (`n` is\r\n     * the length of the passed in sequence so: 2^length(xs)).\r\n     * Note: The return value doubles per index/character passed in so use with caution!\r\n     *  Also note that for 2^16 (or for a sequence of 16 characters) this algorithm\r\n     *  will generate 65536 sub-sequences!  So caution should be taken to not\r\n     *  use this with sequences above a certain length on certain platform (the browser thread in specific).\r\n     * @function module:list.subsequences\r\n     * @jsperftest https://jsperf.com/subsequences\r\n     * @param xs {Array|String}\r\n     * @returns {Array.<Array>}\r\n     */\r\n    subsequences = xs => {\r\n        const listLen = length(xs),\r\n            len = Math.pow(2, listLen),\r\n            out = [];\r\n        for (let i = 0; i < len; i += 1) {\r\n            let entry = [];\r\n            for (let j = 0; j < listLen; j += 1) {\r\n                if (i & (1 << j)) {\r\n                    entry.push(xs[j]);\r\n                }\r\n            }\r\n            out.push(entry);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Returns an array with the given indices swapped.\r\n     * @function module:list.swapped\r\n     * @param ind1 {Number}\r\n     * @param ind2 {Number}\r\n     * @param list {Array}\r\n     * @returns {Array} - Copy of incoming with swapped values at indices.\r\n     */\r\n    swapped = curry((ind1, ind2, list) => {\r\n        const out = sliceCopy(list),\r\n            tmp = out[ind1];\r\n        out[ind1] = out[ind2];\r\n        out[ind2] = tmp;\r\n        return out;\r\n    }),\r\n\r\n    /**\r\n     * Returns a list of permutations for passed in list.\r\n     *  Use caution with lists above a length of 15 (will take long due to nature of\r\n     *  algorithm).\r\n     * @function module:list.permutations\r\n     * @param xs {Array} - List.\r\n     * @returns {Array<Array|String|*>} - Array of permutations.\r\n     */\r\n    permutations = xs => {\r\n        const limit = length(xs);\r\n\r\n        if (!limit || limit === 1) {\r\n            return [xs];\r\n        }\r\n\r\n        let list = sliceCopy(xs),\r\n            c = repeat(limit, 0),\r\n            i = 0;\r\n\r\n        const out = [list];\r\n\r\n        for (; i < limit; i++) {\r\n            if (c[i] < i) {\r\n                list = swapped(i % 2 === 0 ? 0 : c[i], i, list);\r\n                out.push(list);\r\n                c[i] += 1;\r\n                i = 0;\r\n                continue;\r\n            }\r\n            c[i] = 0;\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Left associative fold.  Reduces a container of elements down by the given operation (same as [].reduce).\r\n     * @function module:list.foldl\r\n     * @param fn {Function}\r\n     * @param zero {*} - Aggregator.\r\n     * @param functor {Array}\r\n     * @returns {*} - Whatever type is lastly returned from `fn`.\r\n     */\r\n    foldl = reduce,\r\n\r\n    /**\r\n     * Right associative fold.  Reduces a container of elements down by the given operation (same as [].reduceRight).\r\n     * @function module:list.foldr\r\n     * @param fn {Function}\r\n     * @param zero {*} - Aggregator.\r\n     * @param functor {Array}\r\n     * @returns {*} - Whatever type is lastly returned from `fn`.\r\n     */\r\n    foldr = reduceRight,\r\n\r\n    /**\r\n     * A variant of `foldl` except that this one doesn't require the starting point.  The starting point/value will be pulled\r\n     * out from a copy of the container.\r\n     * @function module:list.foldl1\r\n     * @param op {Function}\r\n     * @param xs {Array}\r\n     * @returns {*} - Whatever type is lastly returned from `op`.\r\n     */\r\n    foldl1 = curry((op, xs) => {\r\n        const parts = uncons(xs);\r\n        return !parts ? [] : reduce(op, parts[0], parts[1]);\r\n    }),\r\n\r\n    /**\r\n     * A variant of `foldr` except that this one doesn't require the starting point/value.  The starting point/value will be pulled\r\n     * out from a copy of the container.\r\n     * @function module:list.foldr1\r\n     * @param op {Function}\r\n     * @param xs {Array}\r\n     * @returns {*} - Whatever type is lastly returned from `op`.\r\n     */\r\n    foldr1 = curry((op, xs) => {\r\n        const parts = unconsr(xs);\r\n        return !parts ? [] : reduceRight(op, parts[1], parts[0]);\r\n    }),\r\n\r\n    /**\r\n     * Performs a map then a reduce all in one (from left-to-right). Returns a tuple\r\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\r\n     * @function module:list.mapAccumL\r\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\r\n     * @param zero {*} - An instance of the passed in list type used to aggregateArray on.\r\n     * @param xs {Array} - list type.\r\n     * @return {Array} - [aggregated, list]\r\n     */\r\n    mapAccumL = curry((op, zero, xs) => {\r\n        const list = sliceCopy(xs),\r\n            limit = length(xs);\r\n        if (!limit) {\r\n            return [zero, list];\r\n        }\r\n        let ind = 0,\r\n            agg = zero,\r\n            mapped = [],\r\n            tuple;\r\n        for (; ind < limit; ind++) {\r\n            tuple = op(agg, list[ind], ind);\r\n            agg = tuple[0];\r\n            mapped = tuple[1];\r\n        }\r\n        return [agg, mapped];\r\n    }),\r\n\r\n    /**\r\n     * Performs a map and a reduce all in one (from right-to-left). Returns a tuple\r\n     * containing the aggregated value and the result of mapping the passed in function on passed in list.\r\n     * @function module:list.mapAccumR\r\n     * @param op {Function} - Function<aggregator, item, index> : [aggregated, mapResult]\r\n     * @param zero {*} - An instance of the passed in list type used to aggregateArray on.\r\n     * @param xs {Array} - list type.\r\n     * @return {Array} - [aggregated, list]\r\n     */\r\n    mapAccumR = curry((op, zero, xs) => {\r\n        const list = sliceCopy(xs),\r\n            limit = length(xs);\r\n        if (!limit) {\r\n            return [zero, list];\r\n        }\r\n        let ind = limit - 1,\r\n            agg = zero,\r\n            mapped = [],\r\n            tuple;\r\n        for (; ind >= 0; ind--) {\r\n            tuple = op(agg, list[ind], ind);\r\n            agg = tuple[0];\r\n            mapped = tuple[1];\r\n        }\r\n        return [agg, mapped];\r\n    }),\r\n\r\n    /**\r\n     * iterate f x returns an infinite list of repeated applications of f to x.\r\n     * @function module:list.iterate\r\n     * @example `iterate(5, f, x) == [x, f(x), f(f(x)), ...]`\r\n     * @param limit {Number}\r\n     * @param op {Function} - Operation.\r\n     * @param x {*} - Starting point.\r\n     * @returns {*}\r\n     */\r\n    iterate = curry((limit, op, x) => {\r\n        let ind = 0,\r\n            out = [],\r\n            lastX = x;\r\n        for (; ind < limit; ind += 1) {\r\n            out.push(lastX);\r\n            lastX = op(lastX, ind);\r\n        }\r\n        return out;\r\n    }),\r\n\r\n    /**\r\n     * Repeats `x` `limit` number of times.\r\n     * @function module:list.repeat\r\n     * @param limit {Number}\r\n     * @param x {*}\r\n     * @return {Array}\r\n     */\r\n    repeat = curry((limit, x) => iterate(limit, a => a, x)),\r\n\r\n    /**\r\n     * Same as `repeat` due to the nature of javascript (see haskell version for usage).\r\n     * @function module:list.replicate\r\n     * @param limit {Number}\r\n     * @param x {*}\r\n     * @return {Array}\r\n     */\r\n    replicate = repeat,\r\n\r\n    /**\r\n     * Replicates a list `limit` number of times and appends the results (concat)\r\n     * @function module:list.cycle\r\n     * @param limit {Number}\r\n     * @param xs {Array}\r\n     * @returns {Array}\r\n     */\r\n    cycle = curry((limit, xs) => concat(replicate(limit, xs))),\r\n\r\n    /**\r\n     * Unfolds a value into a list of somethings.\r\n     * @haskellType `unfoldr :: (b -> Maybe (a, b)) -> b -> [a]`\r\n     * @function module:list.unfoldr\r\n     * @param op {Function} - Operation to perform (should return a two component tuple (item to aggregateArray and item to unfold in next iteration).\r\n     * @param x {*} - Starting parameter to unfold from.\r\n     * @returns {Array} - An array of whatever you return from `op` yielded.\r\n     */\r\n    unfoldr = curry((op, x) => {\r\n        let ind = 0,\r\n            out = [],\r\n            resultTuple = op(x, ind, out);\r\n        while (resultTuple) {\r\n            out.push(resultTuple[0]);\r\n            resultTuple = op(resultTuple[1], ++ind, out);\r\n        }\r\n        return out;\r\n    }),\r\n\r\n    /**\r\n     * Finds index in string or list (alias for `findIndex`).\r\n     * @function module:list.findIndex\r\n     * @param pred {Function} - Predicate<element, index, arr>.\r\n     * @param arr {Array|String}\r\n     * @returns {Number} - `-1` if predicate not matched else `index` found\r\n     */\r\n    findIndex = findIndexWhere,\r\n\r\n    /**\r\n     * @function module:list.findIndices\r\n     * @param pred {Function}\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {Array|undefined}\r\n     */\r\n    findIndices = findIndicesWhere,\r\n\r\n    /**\r\n     * @function module:list.elemIndex\r\n     * @param x {*} - Element to search for.\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    elemIndex = curry((x, xs) => {\r\n        const foundInd = indexOf(x, xs);\r\n        return foundInd !== -1 ? foundInd : undefined;\r\n    }),\r\n\r\n    /**\r\n     * @function module:list.elemIndices\r\n     * @param value {*} - Element to search for.\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {*}\r\n     */\r\n    elemIndices = curry((value, xs) => findIndices(x => x === value, xs)),\r\n\r\n    /**\r\n     * Takes `n` items from start of list to `limit` (exclusive).\r\n     * @function module:list.take\r\n     * @param list {Array|String}\r\n     * @param limit {Number}\r\n     * @returns {String|Array} - Passed in type's type\r\n     */\r\n    take = sliceTo,\r\n\r\n    /**\r\n     * Drops `n` items from start of list to `count` (exclusive).\r\n     * @function module:list.drop\r\n     * @param list {Array|String}\r\n     * @param count {Number}\r\n     * @returns {String|Array} - Passed in type's type\r\n     */\r\n    drop = sliceFrom,\r\n\r\n    /**\r\n     * Splits `x` in two at given `index` (exclusive (includes element/character at\r\n     * given index in second part of returned list)).\r\n     * @function module:list.splitAt\r\n     * @param ind {Number} - Index to split at.\r\n     * @param list {Array|String} - functor (list or string) to split.\r\n     * @returns {Array|String} - List like type passed\r\n     */\r\n    splitAt = (ind, list) => [sliceTo(ind, list), sliceFrom(ind, list)],\r\n\r\n    /**\r\n     * Gives an list with passed elements while predicate was true.\r\n     * @function module:list.takeWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @returns {Array}\r\n     */\r\n    takeWhile = curry((pred, list) =>\r\n        reduceUntil(\r\n            negateF3(pred),     // predicate\r\n            isString(list) ?\r\n                (agg, x) => agg + x :\r\n                aggregateArray, // operation\r\n            of(list),           // aggregate\r\n            list\r\n        )),\r\n\r\n    /**\r\n     * Returns an list without elements that match predicate.\r\n     * @function module:list.dropWhile\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @refactor\r\n     * @returns {Array|String}\r\n     */\r\n    dropWhile = curry((pred, list) => {\r\n        const limit = length(list),\r\n            splitPoint =\r\n                findIndexWhere(\r\n                    (x, i, xs) => !pred(x, i, xs),\r\n                    list\r\n                );\r\n\r\n        return splitPoint === -1 ?\r\n            sliceFrom(limit, list) :\r\n            slice(splitPoint, limit, list);\r\n    }),\r\n\r\n    /**\r\n     * @function module:list.dropWhileEnd\r\n     * @param pred {Function} - Predicate<*, index, list|string>\r\n     * @param list {Array|String}\r\n     * @refactor\r\n     * @returns {Array|String}\r\n     */\r\n    dropWhileEnd = curry((pred, list) => {\r\n        const splitPoint =\r\n            findIndexWhereRight(\r\n                (x, i, xs) => !pred(x, i, xs),\r\n                list\r\n            );\r\n        if (splitPoint === -1) {\r\n            return of(list);\r\n        }\r\n        return sliceTo(splitPoint + 1, list);\r\n    }),\r\n\r\n    /**\r\n     * Gives you the `span` of items matching predicate\r\n     * and items not matching predicate;  E.g., Gives an\r\n     * array of arrays;  E.g., [[matching-items], [non-matching-items]]\r\n     * @function list.span\r\n     * @param pred {Function} - List predicate (`(x, i, list) => bool`)\r\n     * @param list {Array|String}\r\n     * @returns {(Array<Array<*>>|Array<String>)}\r\n     * @type {Function}\r\n     */\r\n    span = curry((pred, list) => {\r\n        const splitPoint = findIndexWhere(negateF3(pred), list);\r\n        return splitPoint === -1 ?\r\n            [sliceFrom(0, list), of(list)] :\r\n            splitAt(splitPoint, list);\r\n    }),\r\n\r\n    /**\r\n     * breakOnList, applied to a predicate p and a list xs, returns a tuple\r\n     * where first element is longest prefix (possibly empty) of xs of elements\r\n     * that do not satisfy p and second element is the remainder of the list:\r\n     * @haskellExample\r\n     * Replace `break` with `breakOnList` for our version.\r\n     * ```\r\n     * breakOnList (> 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])\r\n     * breakOnList (< 9) [1,2,3] == ([],[1,2,3])\r\n     * breakOnList (> 9) [1,2,3] == ([1,2,3],[])\r\n     * ```\r\n     * @function module:list.breakOnList\r\n     * @param pred {Function}\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    breakOnList = curry((pred, list) => {\r\n        const splitPoint = findIndexWhere(negateF3(pred), list);\r\n        return splitPoint === -1 ?\r\n            [of(list), sliceFrom(0, list)] : reverse(splitAt(splitPoint, list));\r\n    }),\r\n\r\n    /**\r\n     * Gets item at index.\r\n     * @function module:list.at\r\n     * @param ind {Number} - Index.\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {*|undefined} - Item or `undefined`.\r\n     */\r\n    at = lookup,\r\n\r\n    /**\r\n     * Find an item in structure of elements based on given predicate (`pred`).\r\n     * @function module:list.find\r\n     * @param pred {Function}\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {*} - Found item.\r\n     */\r\n    find = findWhere,\r\n\r\n    /**\r\n     * For each function (same as `[].forEach` except in functional format).\r\n     * @function module:list.forEach\r\n     * @param fn {Function} - Operation (`(element, index, list) => {...}`, etc.)\r\n     * @param xs {(Array|String)}\r\n     * @returns {void}\r\n     */\r\n    forEach = curry((fn, list) => {\r\n        const limit = length(list);\r\n        if (!limit) {\r\n            return;\r\n        }\r\n        let ind = 0;\r\n        for (; ind < limit; ind += 1) {\r\n            fn(list[ind], ind, list);\r\n        }\r\n    }),\r\n\r\n    /**\r\n     * Filters a structure of elements using given predicate (`pred`) (same as `[].filter`).\r\n     * @function module:list.filter\r\n     * @param pred {Function}\r\n     * @param xs {Array} - list or list like.\r\n     * @returns {Array} - Structure of filtered elements.\r\n     */\r\n    filter = curry((pred, xs) => {\r\n        let ind = 0,\r\n            limit = length(xs),\r\n            out = [];\r\n        if (!limit) {\r\n            return out;\r\n        }\r\n        for (; ind < limit; ind++) {\r\n            if (pred(xs[ind], ind, xs)) {\r\n                out.push(xs[ind]);\r\n            }\r\n        }\r\n        return out;\r\n    }),\r\n\r\n    /**\r\n     * Partitions a list on a predicate;  Items that match predicate are in first list in tuple;  Items that\r\n     * do not match the tuple are in second list in the returned tuple.\r\n     *  Essentially `[filter(p, xs), filter(negateF3(p), xs)]`.\r\n     * @function module:list.partition\r\n     * @param pred {Function} - Predicate<item, index, originalArrayOrString>\r\n     * @param list {Array}\r\n     * @returns {Array|String} - Tuple of arrays or strings (depends on incoming list (of type list or string)).\r\n     */\r\n    partition = curry((pred, list) =>\r\n        !length(list) ?\r\n            [[], []] :\r\n            [filter(pred, list), filter(negateF3(pred), list)]),\r\n\r\n    /**\r\n     * Returns a boolean indicating whether an element exists in given structure of elements.\r\n     * @function module:list.elem\r\n     * @param element {*}\r\n     * @param xs {Array}\r\n     * @returns {Boolean}\r\n     */\r\n    elem = includes,\r\n\r\n    /**\r\n     * The opposite of `elem` - Returns a boolean indicating whether an element exists in given list.\r\n     * @function module:list.notElem\r\n     * @param element {*}\r\n     * @param xs {Array}\r\n     * @returns {Boolean}\r\n     */\r\n    notElem = negateF2(includes),\r\n\r\n    /**\r\n     * Checks if list `xs1` is a prefix of list `xs2`\r\n     * @function module:list.isPrefixOf\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {boolean}\r\n     */\r\n    isPrefixOf = curry((xs1, xs2) => {\r\n        const limit1 = length(xs1),\r\n            limit2 = length(xs2);\r\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\r\n            return false;\r\n        }\r\n        let ind = 0;\r\n        for (; ind < limit1; ind++) {\r\n            if (xs1[ind] !== xs2[ind]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }),\r\n\r\n    /**\r\n     * Checks if list `xs1` is a suffix of list `xs2`\r\n     * @function module:list.isSuffixOf\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {boolean}\r\n     */\r\n    isSuffixOf = curry((xs1, xs2) => {\r\n        const limit1 = length(xs1),\r\n            limit2 = length(xs2);\r\n        if (limit2 < limit1 || !limit1 || !limit2 || indexOf(xs1[0], xs2) === -1) {\r\n            return false;\r\n        }\r\n        let ind1 = limit1 - 1,\r\n            ind2 = limit2 - 1;\r\n        for (; ind1 >= 0; ind1--) {\r\n            if (xs1[ind1] !== xs2[ind2]) {\r\n                return false;\r\n            }\r\n            ind2 -= 1;\r\n        }\r\n        return true;\r\n    }),\r\n\r\n    /**\r\n     * Checks if list `xs1` is an infix of list `xs2`\r\n     * @function module:list.isInfixOf\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {boolean}\r\n     */\r\n    isInfixOf = curry((xs1, xs2) => {\r\n        const limit1 = length(xs1),\r\n            limit2 = length(xs2);\r\n        if (limit2 < limit1 || !limit1 || !limit2) {\r\n            return false;\r\n        }\r\n        let ind1,\r\n            foundLen,\r\n            ind = 0;\r\n        for (; ind < limit2; ind += 1) {\r\n            foundLen = 0;\r\n            for (ind1 = 0; ind1 < limit1; ind1 += 1) {\r\n                if (xs2[ind1 + ind] === xs1[ind1]) {\r\n                    foundLen += 1;\r\n                }\r\n                if (foundLen === limit1) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }),\r\n\r\n    /**\r\n     * Checks if list `xs1` is a sub-sequence of list `xs2`\r\n     * @function module:list.isSubsequenceOf\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {boolean}\r\n     */\r\n    isSubsequenceOf = curry((xs1, xs2) => {\r\n        const len = Math.pow(2, length(xs2)),\r\n            lenXs1 = length(xs1);\r\n        let foundLen,\r\n            i;\r\n        for (i = 0; i < len; i += 1) {\r\n            foundLen = 0;\r\n            for (let j = 0; j < len; j += 1) {\r\n                if (i & (1 << j) && indexOf(xs2[j], xs1) > -1) {\r\n                    foundLen += 1;\r\n                }\r\n                if (foundLen === lenXs1) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }),\r\n\r\n    /**\r\n     * The group function takes a list and returns a list of lists such that\r\n     *  the concatenation of the result is equal to the argument. Moreover, each\r\n     *  sublist in the result contains only equal elements. For example,\r\n     * `group \"Mississippi\" = [\"M\",\"i\",\"ss\",\"i\",\"ss\",\"i\",\"pp\",\"i\"]`\r\n     * It is a special case of groupBy, which allows the programmer to supply\r\n     *  their own equality test.\r\n     * @haskellType `group :: Eq a => [a] -> [[a]]`\r\n     * @function module:list.group\r\n     * @param xs {Array|String}\r\n     * @returns {Array<Array|String|*>|*}\r\n     */\r\n    group = xs => groupBy((a, b) => a === b, xs),\r\n\r\n    /**\r\n     * Allows you to group items in a list based on your supplied equality check.\r\n     * @note Sames `group` but allows you to specify equality operation.\r\n     * @haskellType `groupBy :: (a -> a -> Bool) -> [a] -> [[a]]`\r\n     * @function module:list.groupBy\r\n     * @param equalityOp {Function}\r\n     * @param xs {Array}\r\n     * @returns {*}\r\n     */\r\n    groupBy = curry((equalityOp, xs) => {\r\n        const limit = length(xs);\r\n        if (!limit) {\r\n            return sliceCopy(xs);\r\n        }\r\n        let ind = 0,\r\n            prevItem,\r\n            item,\r\n            predOp = x => {\r\n                if (equalityOp(x, prevItem)) {\r\n                    ind++;\r\n                }\r\n                if (equalityOp(x, item)) {\r\n                    prevItem = x;\r\n                    return true;\r\n                }\r\n                return false;\r\n            },\r\n            agg = [];\r\n        for (; ind < limit; ind += 1) {\r\n            item = xs[ind];\r\n            agg.push(takeWhile(predOp, slice(ind, limit, xs)));\r\n        }\r\n        return agg;\r\n    }),\r\n\r\n    /**\r\n     * The inits function returns all initial segments of the argument, shortest first. For example,\r\n     * ```\r\n     * shallowEquals(inits('abc'), ['','a','ab','abc'])\r\n     * ```\r\n     * @function module:list.inits\r\n     * @haskellType `inits :: [a] -> [[a]]`\r\n     * @param xs {Array}\r\n     * @returns {Array}\r\n     */\r\n    inits = xs => {\r\n        let limit = length(xs),\r\n            ind = 0,\r\n            agg = [];\r\n        if (!limit) {\r\n            return [];\r\n        }\r\n        for (; ind <= limit; ind += 1) {\r\n            agg.push(sliceTo(ind, xs));\r\n        }\r\n        return agg;\r\n    }, //map(list => init(list), xs),\r\n\r\n    /**\r\n     * The inits function returns all initial segments of the argument, shortest first. For example,\r\n     * ```\r\n     * shallowEquals(tails('abc'), ['abc', 'bc', 'c',''])\r\n     * ```\r\n     * @function module:list.tails\r\n     * @haskellType `tails :: [a] -> [[a]]`\r\n     * @param xs {Array}\r\n     * @returns {Array}\r\n     */\r\n    tails = xs => {\r\n        let limit = length(xs),\r\n            ind = 0,\r\n            agg = [];\r\n        if (!limit) {\r\n            return [];\r\n        }\r\n        for (; ind <= limit; ind += 1) {\r\n            agg.push(slice(ind, limit, xs));\r\n        }\r\n        return agg;\r\n    }, //map(list => tail(list), xs),\r\n\r\n    /**\r\n     * Strips prefix list from given list\r\n     * @function module:list.stripPrefix\r\n     * @param prefix {Array|String|*}\r\n     * @param list {Array|string|*}\r\n     * @returns {Array|*}\r\n     */\r\n    stripPrefix = curry((prefix, list) =>\r\n        isPrefixOf(prefix, list) ?\r\n            splitAt(length(prefix), list)[1] :\r\n            sliceCopy(list)),\r\n\r\n    /**\r\n     * zip takes two lists and returns a list of corresponding pairs.\r\n     * If one input list is short, excess elements of the longer list are discarded.\r\n     * @haskellType `zip :: [a] -> [b] -> [(a, b)]`\r\n     * @function module:list.zip\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip = curry((arr1, arr2) => {\r\n        if (!length(arr1) || !length(arr2)) {\r\n            return [];\r\n        }\r\n        const [a1, a2] = toShortest(arr1, arr2);\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArray(agg, [item, a2[ind]]),\r\n            [], a1);\r\n    }),\r\n\r\n    /**\r\n     * zipN takes one or more lists and returns a list containing lists of all indices\r\n     * at a given index, index by index.\r\n     * If one input list is short, excess elements of the longer list are discarded.\r\n     * @function module:list.zipN\r\n     * @param lists {Array|String} - One ore more lists of the same type.\r\n     * @returns {Array}\r\n     */\r\n    zipN = curry2((...lists) => {\r\n        const trimmedLists = apply(toShortest, lists);\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArray(agg, map(xs => xs[ind], trimmedLists)),\r\n            [], trimmedLists[0]);\r\n    }),\r\n\r\n    /**\r\n     * @haskellType `zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]`\r\n     * @function module:list.zip3\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip3 = curry((arr1, arr2, arr3) => zipN(arr1, arr2, arr3)),\r\n\r\n    /**\r\n     * @haskellType `zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]`\r\n     * @function module:list.zip4\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @param arr4 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip4 = curry((arr1, arr2, arr3, arr4) => zipN(arr1, arr2, arr3, arr4)),\r\n\r\n    /**\r\n     * @haskellType `zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]`\r\n     * @function module:list.zip5\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @param arr3 {Array}\r\n     * @param arr4 {Array}\r\n     * @param arr5 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zip5 = curry((arr1, arr2, arr3, arr4, arr5) => zipN(arr1, arr2, arr3, arr4, arr5)),\r\n\r\n    /**\r\n     * zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\r\n     * zipWith generalises zip by zipping with the function given as the\r\n     * first argument, instead of a function tupling function (function that returns a tuple). For example,\r\n     * zipWith (+) is applied to two lists to produce the list of corresponding sums.\r\n     * @note `_|_` means bottom or perpetual (@see\r\n     *  - https://wiki.haskell.org/Bottom\r\n     *  - https://stackoverflow.com/questions/19794681/what-does-this-syntax-mean-in-haskell-or\r\n     *  )\r\n     * @example\r\n     * ```\r\n     * zipWith f [] _|_ = []\r\n     * ```\r\n     * @haskellType `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`\r\n     * @function module:list.zipWith\r\n     * @param op {Function} - Takes two parts of a tuple and returns a tuple.\r\n     *  E.g., ` op :: a -> b -> (a, b)`\r\n     * @param xs1 {Array}\r\n     * @param xs2 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith = curry((op, xs1, xs2) => {\r\n        if (!length(xs1) || !length(xs2)) {\r\n            return [];\r\n        }\r\n        const [a1, a2] = toShortest(xs1, xs2);\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArray(agg, op(item, a2[ind])),\r\n            [], a1);\r\n    }),\r\n\r\n    /**\r\n     * Zips all given lists with tupling function. Note: Haskell types do not have\r\n     *  a way (that I know of) to show one or more for params in a function so `@haskellType` below\r\n     *  is left there for general purpose not for exactness as is told by aforementioned.\r\n     * @haskellType `zipWithN :: (a -> b -> c) -> [a] -> [b] -> [c]` - Where `N` is the number\r\n     *  of lists to zip.\r\n     * @function module:list.zipWithN\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\r\n     * @param lists ...{Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWithN = curry3((op, ...lists) => {\r\n        const trimmedLists = apply(toShortest, lists),\r\n            lenOfTrimmed = length(trimmedLists);\r\n        if (!lenOfTrimmed) {\r\n            return [];\r\n        }\r\n        else if (lenOfTrimmed === 1) {\r\n            return sliceTo(length(trimmedLists[0]), trimmedLists[0]);\r\n        }\r\n        return reduce((agg, item, ind) =>\r\n                aggregateArray(agg, apply(op, map(xs => xs[ind], trimmedLists))),\r\n            [], trimmedLists[0]);\r\n    }),\r\n\r\n    /**\r\n     * Zips 3 lists with tupling function.\r\n     * @haskellType `zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]`\r\n     * @function module:list.zipWith3\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> (a, b, c)`\r\n     * @param xs1 {Array}\r\n     * @param xs2 {Array}\r\n     * @param xs3 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith3 = curry((op, xs1, xs2, xs3) => zipWithN(op, xs1, xs2, xs3)),\r\n\r\n    /**\r\n     * Zips 4 lists with tupling function.\r\n     * @haskellType `zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c]  -> [d] -> [e]`\r\n     * @function module:list.zipWith4\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> d -> (a, b, c, d)`\r\n     * @param xs1 {Array}\r\n     * @param xs2 {Array}\r\n     * @param xs3 {Array}\r\n     * @param xs4 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith4 = curry((op, xs1, xs2, xs3, xs4) => zipWithN(op, xs1, xs2, xs3, xs4)),\r\n\r\n    /**\r\n     * Zips 5 lists.\r\n     * @haskellType `zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c]  -> [d] -> [e] -> [f]`\r\n     * @function module:list.zipWith5\r\n     * @param op {Function} - Takes expected number of parts for tuple and returns a tuple\r\n     *  of said parts:\r\n     *  E.g., ` op :: a -> b -> c -> d -> e -> (a, b, c, d, e)`\r\n     * @param xs1 {Array}\r\n     * @param xs2 {Array}\r\n     * @param xs3 {Array}\r\n     * @param xs4 {Array}\r\n     * @param xs5 {Array}\r\n     * @returns {Array<Array<*,*>>}\r\n     */\r\n    zipWith5 = curry((op, xs1, xs2, xs3, xs4, xs5) => zipWithN(op, xs1, xs2, xs3, xs4, xs5)),\r\n\r\n    /**\r\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\r\n     * @haskellType `unzip :: [(a, b)] -> ([a], [b])`\r\n     * @function module:list.unzip\r\n     * @param arr {Array|*}\r\n     * @returns {Array|*}\r\n     */\r\n    unzip = foldl((agg, item) => {\r\n        agg[0].push(item[0]);\r\n        agg[1].push(item[1]);\r\n        return agg;\r\n    }, [[], []]),\r\n\r\n    /**\r\n     * unzip transforms a list of pairs into a list of first components and a list of second components.\r\n     * @sudoHaskellType `unzipN :: [(a, b, ...x)] -> ([a], [b], ...[x])`\r\n     * @function module:list.unzipN\r\n     * @param list {Array|*} - List of tuples (lists).\r\n     * @returns {Array|*}\r\n     */\r\n    unzipN = list => {\r\n        if (!length(list)) {\r\n            return [];\r\n        }\r\n        const lenItem0 = length(list[0]);\r\n        let zero = lenItem0 ?\r\n            unfoldr(numLists => numLists-- ? [[], numLists] : undefined, lenItem0) :\r\n            [];\r\n        return foldl((agg, item) => {\r\n            agg.forEach((outList, ind) => outList.push(item[ind]));\r\n            return agg;\r\n        }, zero, list);\r\n    },\r\n\r\n    /**\r\n     * Returns true if any item in container passes predicate `p`.\r\n     * @function module:list.any\r\n     * @param p {Function} - Predicate.\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    any = curry((p, xs) => {\r\n        let ind = 0,\r\n            limit = length(xs);\r\n        if (!limit) {\r\n            return false;\r\n        }\r\n        for (; ind < limit; ind += 1) {\r\n            if (p(xs[ind])) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }),\r\n\r\n    /**\r\n     * Returns true if all items in container pass predicate `p`.\r\n     * @function module:list.all\r\n     * @param p {Function} - Predicate.\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    all = curry((p, xs) => {\r\n        const limit = length(xs);\r\n        let ind = 0;\r\n        if (!limit) {\r\n            return false;\r\n        }\r\n        for (; ind < limit; ind++) {\r\n            if (!p(xs[ind], ind, xs)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }),\r\n\r\n    /**\r\n     * Conjuction of container of bools (or truthy and/or falsy values);  Returns\r\n     * `true` if all in container are 'truthy' else returns `false`\r\n     * @function module:list.and\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    and = xs => all(isTruthy, xs),\r\n\r\n    /**\r\n     * Returns a boolean indicating whether any item in container is 'truthy' or not.\r\n     * **Note** The haskell type for this function only takes two items, but here\r\n     * we allow the passing of more than one item (may change later to adhere to the haskell type).\r\n     * @function module:list.or\r\n     * @haskellType `or :: Bool -> Bool -> Bool`\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    or = xs => any(isTruthy, xs),\r\n\r\n    /**\r\n     * Returns a boolean indicating whether all items in container are 'falsy' or not.\r\n     * **Note** The haskell type for this function only takes two items, but here\r\n     * we allow the passing of more than one item (may change later to adhere to the haskell type).\r\n     * @function module:list.not\r\n     * @haskellType `not :: Bool -> Bool`\r\n     * @param xs {Array|String}\r\n     * @returns {Boolean}\r\n     */\r\n    not = xs => all(isFalsy, xs),\r\n\r\n    /**\r\n     * Computes the sum of the numbers of a structure.\r\n     * @function module:list.sum\r\n     * @haskellType `sum :: (List t, Num a) => t a -> a`\r\n     * @param list {Array|String}\r\n     * @returns {Number}\r\n     */\r\n    sum = list => foldl((agg, x) => agg + x, 0, list),\r\n\r\n    /**\r\n     * Computes the product of the numbers of a structure.\r\n     * @function module:list.product\r\n     * @haskellType `product :: (List t, Num a) => t a -> a`\r\n     * @param list {Array|String}\r\n     * @returns {Number}\r\n     */\r\n    product = list => foldl((agg, x) => agg * x, 1, list),\r\n\r\n    /**\r\n     * Returns the largest element in a non-empty structure of elements.\r\n     * @function module:list.maximum\r\n     * @haskellType `maximum :: forall a . Ord a => t a -> a`\r\n     * @param list {Array|String}\r\n     * @returns {*} - Whatever type the array is made of (if any).\r\n     */\r\n    maximum = list => last(sortBy(genericAscOrdering, list)),\r\n\r\n    /**\r\n     * Returns the smallest element in a non-empty structure of elements.\r\n     * @function module:list.minimum\r\n     * @haskellType `minimum :: forall a . Ord a => t a -> a`\r\n     * @param list {Array|String}\r\n     * @returns {*} - Whatever type the array is made of (if any).\r\n     */\r\n    minimum = list => head(sortBy(genericAscOrdering, list)),\r\n\r\n    /**\r\n     * scanl is similar to foldl, but returns a list of successive reduced values from the left:\r\n     * ```\r\n     * scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]\r\n     * ```\r\n     * Also note that:\r\n     * ```\r\n     * last (scanl f z xs) == foldl f z xs.\r\n     * ```\r\n     * @function module:list.scanl\r\n     * @param fn {Function}\r\n     * @param zero {*}\r\n     * @param xs {Array}\r\n     * @returns {Array|*}\r\n     */\r\n    scanl = curry((fn, zero, xs) => {\r\n        if (!xs || !length(xs)) {\r\n            return [];\r\n        }\r\n        const limit = length(xs);\r\n        let ind = 0,\r\n            result = zero,\r\n            out = [];\r\n        while (ind < limit) {\r\n            result = fn(result, xs[ind], ind, xs);\r\n            out.push(result);\r\n            ind++;\r\n        }\r\n        return out;\r\n    }),\r\n\r\n    /**\r\n     * `scanl1` is a variant of `scanl` that has no starting value argument:\r\n     * `shallowCompare(scanl1(fn, [x1, x2, ...]), [x1, fn(x1, x2), ...]) // true`\r\n     * @function module:list.scanl1\r\n     * @param fn {Function}\r\n     * @param xs {Array}\r\n     * @returns {Array|*}\r\n     */\r\n    scanl1 = curry((fn, xs) => {\r\n        if (!xs || !xs.length) {\r\n            return [];\r\n        }\r\n        return scanl(fn, head(xs), tail(xs));\r\n    }),\r\n\r\n    /**\r\n     * Same as `scanl` but from the right (similiar to `foldr`'s relationship to 'foldl').\r\n     * Note also `scanr`'s relationship ot `foldr`:\r\n     * `head (scanr(fn, z, xs)) === foldr(fn, z, xs).\r\n     * @function module:list.scanr\r\n     * @param fn {Function}\r\n     * @param zero {*}\r\n     * @param xs {Array}\r\n     * @returns {Array|*}\r\n     */\r\n    scanr = curry((fn, zero, xs) => {\r\n        if (!xs || !length(xs)) {\r\n            return [];\r\n        }\r\n        const limit = length(xs);\r\n        let ind = limit - 1,\r\n            result = xs[0],\r\n            out = [];\r\n        while (ind > -1) {\r\n            result = fn(result, xs[ind], ind, xs);\r\n            out.push(result);\r\n            ind--;\r\n        }\r\n        return out;\r\n    }),\r\n\r\n    /**\r\n     * Same as `scanr` but takes no zero/accumulator value.\r\n     * @function module:list.scanr1\r\n     * @param fn {Function}\r\n     * @param xs {Array}\r\n     * @returns {Array|*}\r\n     */\r\n    scanr1 = curry((fn, xs) => {\r\n        if (!xs || !xs.length) {\r\n            return [];\r\n        }\r\n        return scanr(fn, last(xs), init(xs));\r\n    }),\r\n\r\n    /**\r\n     * The nub function removes duplicate elements from a list.\r\n     * In particular, it keeps only the first occurrence of each element.\r\n     * (The name nub means `essence'.) It is a special case of nubBy, which\r\n     * allows the programmer to supply their own equality test.\r\n     * ```shallowCompare( nub ([1,2,3,4,3,2,1,2,4,3,5]), [1,2,3,4,5] )```\r\n     * @function module:list.nub\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    nub = list => nubBy((a, b) => a === b, list),\r\n\r\n    /**\r\n     * `remove(x, xs)` removes the first occurrence of `x` from `xs`.\r\n     * For example, `remove('a', 'banana') === 'bnana';`\r\n     * @function module:list.remove\r\n     * @param x {*}\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    remove = curry((x, list) => removeBy((a, b) => a === b, x, list)),\r\n\r\n    /**\r\n     * The sort function implements a stable sorting algorithm.\r\n     * It is a special case of sortBy, which allows the programmer\r\n     * to supply their own comparison function.\r\n     * ```shallowCompare(sort ([1,6,4,3,2,5]), [1,2,3,4,5,6]) // true```\r\n     * @function module:list.sort\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    sort = xs => sortBy(genericAscOrdering, xs),\r\n\r\n    /**\r\n     * Sort a list by comparing the results of a key function applied to each\r\n     * element. sortOn f is equivalent to sortBy (comparing f), but has the\r\n     * performance advantage of only evaluating f once for each element in the\r\n     * input list. This is called the decorate-sort-undecorate paradigm, or\r\n     * Schwartzian transform.\r\n     *\r\n     * Elements are arranged from from lowest to highest, keeping duplicates\r\n     * in the order they appeared in the input.\r\n     *\r\n     * Ex:\r\n     * ```\r\n     * shallowEquals(\r\n     *  sortOn (head, [[2, \"world\"], [4, \"!\"], [1, \"Hello\"]]),\r\n     *  [[1,\"Hello\"],[2,\"world\"],[4,\"!\"]]\r\n     * ) // true\r\n     * ```\r\n     * @function module:list.sortOn\r\n     * @param valueFn {Function}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    sortOn = curry((valueFn, xs) =>\r\n\r\n        // Un-decorate\r\n        map(decorated => decorated[1],\r\n\r\n            // Decorate and sort\r\n            sortBy(\r\n                // Ordering\r\n                ([a0], [b0]) => genericAscOrdering(a0, b0),\r\n\r\n                // Decorate\r\n                map(item => [valueFn(item), item], xs)\r\n            )\r\n        )\r\n    ),\r\n\r\n    /**\r\n     * The sortBy function is the non-overloaded (in haskell terms) version of sort.\r\n     * @haskellExample ```\r\n     *  >>> sortBy (\\(a,_) (b,_) -> compare a b) [(2, \"world\"), (4, \"!\"), (1, \"Hello\")]\r\n     *  [(1,\"Hello\"),(2,\"world\"),(4,\"!\")]\r\n     * ```\r\n     * @function module:list.sortBy\r\n     * @param orderingFn {Function}\r\n     * @param xs {Array|String|*}\r\n     * @returns {Array|String|*}\r\n     */\r\n    sortBy = curry((orderingFn, xs) => sliceCopy(xs).sort(orderingFn || genericAscOrdering)),\r\n\r\n    /**\r\n     * The insert function takes an element and a list and inserts the element\r\n     * into the list at the first position where it is less than or equal to the\r\n     * next element. In particular, if the list is sorted before the call, the\r\n     * result will also be sorted. It is a special case of insertBy, which allows\r\n     * the programmer to supply their own comparison function.\r\n     * @function module:list.insert\r\n     * @param x {*}\r\n     * @param xs {Array|*}\r\n     * @returns {Array}\r\n     */\r\n    insert = curry((x, xs) => {\r\n        if (!xs.length) {\r\n            return of(xs, x);\r\n        }\r\n        const foundIndex = findIndex(item => x <= item, xs);\r\n        return foundIndex === -1 ? concat([xs, of(xs, x)]) :\r\n            concat(intersperse(of(xs, x), splitAt(foundIndex, xs)));\r\n    }),\r\n\r\n    /**\r\n     * A version of `insert` that allows you to specify the ordering of the inserted\r\n     * item;  Before/at, or after\r\n     * @function module:list.insertBy\r\n     * @haskellType `insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]`\r\n     * @note `Ordering` means 'something that is order-able'\r\n     *  operated on by this functions logic.\r\n     * @param orderingFn {Function} - A function that returns `-1`, `0`, or 1`.\r\n     * @param x {*} - Value to insert.\r\n     * @param xs {Array} - List to insert into (note new list is returned)\r\n     * @returns {Array} - New list.\r\n     */\r\n    insertBy = curry((orderingFn, x, xs) => {\r\n        const limit = length(xs);\r\n        if (!limit) {\r\n            return [x];\r\n        }\r\n        let ind = 0;\r\n        for (; ind < limit; ind += 1) {\r\n            if (orderingFn(x, xs[ind]) <= 0) {\r\n                const parts = splitAt(ind, xs);\r\n                return concat([parts[0], [x], parts[1]]);\r\n            }\r\n        }\r\n        return aggregateArray(sliceCopy(xs), x);\r\n    }),\r\n\r\n    /**\r\n     * The nubBy function behaves just like nub, except it uses a user-supplied equality predicate.\r\n     * @function module:list.nubBy\r\n     * @param pred {Function}\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    nubBy = curry((pred, list) => {\r\n        if (!length(list)) {\r\n            return [];\r\n        }\r\n        const limit = length(list);\r\n        let ind = 0,\r\n            currItem,\r\n            out = [],\r\n            anyOp = storedItem => pred(currItem, storedItem);\r\n        for (; ind < limit; ind += 1) {\r\n            currItem = list[ind];\r\n            if (any(anyOp, out)) {\r\n                continue;\r\n            }\r\n            out.push(currItem);\r\n        }\r\n        return out;\r\n    }),\r\n\r\n    /**\r\n     * Behaves the same as `remove`, but takes a user-supplied equality predicate.\r\n     * @function module:list.removeBy\r\n     * @param pred {Function} - Equality predicate `(a, b) => bool`\r\n     * @param x {*}\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    removeBy = curry((pred, x, list) => {\r\n        const foundIndex = findIndex(item => pred(x, item), list);\r\n        if (foundIndex > -1) {\r\n            const parts = splitAt(foundIndex, list);\r\n            return append(parts[0], tail(parts[1]));\r\n        }\r\n        return sliceCopy(list);\r\n    }),\r\n\r\n    /**\r\n     * The `removeFirstsBy` function takes a predicate and two lists and returns the first list with the first\r\n     * occurrence of each element of the second list removed.\r\n     * @function module:list.removeFirstBy\r\n     * @param pred {Function}\r\n     * @param xs1 {Array|String|*}\r\n     * @param xs2 {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    removeFirstsBy = curry((pred, xs1, xs2) =>\r\n        foldl((agg, x) => removeBy(pred, x, agg), xs1, xs2)),\r\n\r\n    /**\r\n     * Returns the union on elements matching boolean check passed in.\r\n     * @function module:list.unionBy\r\n     * @param pred {Function} - `pred :: a -> a -> Bool`\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @returns {Array}\r\n     */\r\n    unionBy = curry((pred, arr1, arr2) =>\r\n        foldl((agg, b) => {\r\n                const alreadyAdded = any(a => pred(a, b), agg);\r\n                return !alreadyAdded ? (agg.push(b), agg) : agg;\r\n            }, sliceCopy(arr1), arr2\r\n        )),\r\n\r\n    /**\r\n     * Creates a union on matching elements from array1.\r\n     * @function module:list.union\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @returns {Array}\r\n     */\r\n    union = curry((arr1, arr2) =>\r\n        append(arr1,\r\n            filter(elm => !includes(elm, arr1), arr2))),\r\n\r\n    /**\r\n     * Performs an intersection on list 1 with  elements from list 2.\r\n     * @function module:list.intersect\r\n     * @param arr1 {Array}\r\n     * @param arr2 {Array}\r\n     * @returns {Array}\r\n     */\r\n    intersect = curry((arr1, arr2) =>\r\n        !arr1 || !arr2 || (!arr1 && !arr2) ? [] :\r\n            filter(elm => includes(elm, arr2), arr1)),\r\n\r\n    /**\r\n     * Returns an intersection by predicate.\r\n     * @function module:list.intersectBy\r\n     * @param pred {Function} - `pred :: a -> b -> Bool`\r\n     * @param list1 {Array}\r\n     * @param list2 {Array}\r\n     * @return {Array}\r\n     */\r\n    intersectBy = curry((pred, list1, list2) =>\r\n        foldl((agg, a) =>\r\n                any(b => pred(a, b), list2) ? (agg.push(a), agg) : agg\r\n            , [], list1)),\r\n\r\n    /**\r\n     * Returns the difference of list 1 from list 2.\r\n     * @note The `difference` operation here is non-associative;  E.g., `a - b` is not equal to `b - a`;\r\n     * @function module:list.difference\r\n     * @param array1 {Array}\r\n     * @param array2 {Array}\r\n     * @returns {Array}\r\n     */\r\n    difference = curry((array1, array2) => { // augment this with max length and min length ordering on op\r\n        if (array1 && !array2) {\r\n            return sliceCopy(array1);\r\n        }\r\n        else if (!array1 && array2 || (!array1 && !array2)) {\r\n            return [];\r\n        }\r\n        return reduce((agg, elm) =>\r\n                !includes(elm, array2) ? (agg.push(elm), agg) : agg\r\n            , [], array1);\r\n    }),\r\n\r\n    /**\r\n     * Returns the complement of list 0 and the reset of the passed in arrays.\r\n     * @function module:list.complement\r\n     * @param arr0 {Array}\r\n     * @param arrays {...Array}\r\n     * @returns {Array}\r\n     */\r\n    complement = curry2((arr0, ...arrays) =>\r\n        reduce((agg, arr) => append(agg, difference(arr, arr0)), [], arrays));\r\n","/**\r\n * @module errorThrowing\r\n * @description Contains error throwing facilities for when a value doesn't match a type.\r\n */\r\nimport {typeOf} from './object/typeOf';\r\nimport {isArray, toTypeRef, toTypeRefName, isOfType} from './object/is';\r\nimport {curry} from './function/curry';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Pretty prints an array of types/type-strings for use by error messages;\r\n     * Outputs \"`SomeTypeName`, ...\" from [SomeType, 'SomeTypeName', etc...]\r\n     * @function module:errorThrowing.typeRefsToStringOrError\r\n     * @param types {Array|TypesArray}\r\n     * @return {String}\r\n     * @private\r\n     */\r\n    typeRefsToStringOrError = types => types.length ?\r\n        types.map(type => `\\`${toTypeRefName(type)}\\``).join(', ') : '',\r\n\r\n    /**\r\n     * Prints a message from an object.  Object signature:\r\n     * {contextName, valueName, value, expectedTypeName, foundTypeName, messageSuffix}\r\n     * @function module:errorThrowing.defaultErrorMessageCall\r\n     * @param tmplContext {Object|TemplateContext} - Object to use in error template.\r\n     * @returns {string}\r\n     * @private\r\n     */\r\n    defaultErrorMessageCall = tmplContext => {\r\n        const {\r\n                contextName, valueName, value, expectedTypeName,\r\n                foundTypeName, messageSuffix\r\n            } = tmplContext,\r\n            isMultiTypeNames = isArray(expectedTypeName),\r\n            typesCopy = isMultiTypeNames ? 'of type' : 'of one of the types',\r\n            typesToMatchCopy = isMultiTypeNames ? typeRefsToStringOrError(expectedTypeName) : expectedTypeName;\r\n        return (contextName ? `\\`${contextName}.` : '`') +\r\n            `${valueName}\\` is not ${typesCopy}: ${typesToMatchCopy}.  ` +\r\n            `Type received: ${foundTypeName}.  Value: ${value};` +\r\n            `${messageSuffix ?  '  ' + messageSuffix + ';' : ''}`;\r\n    },\r\n\r\n    /**\r\n     * Gets the error message thrower seeded with passed in errorMessage template call.\r\n     * @function module:errorThrowing.getErrorIfNotTypeThrower$\r\n     * @param errorMessageCall {Function|ErrorMessageCall}\r\n     * @param typeChecker {Function|TypeChecker} - Function<Type, value>:Boolean\r\n     * @returns {Function|ErrorIfNotType}\r\n     * @private\r\n     */\r\n    _getErrorIfNotTypeThrower = (errorMessageCall, typeChecker = isOfType) =>\r\n        (ValueType, contextName, valueName, value, messageSuffix = null) => {\r\n            const expectedTypeName = toTypeRef(ValueType),\r\n                foundTypeName = typeOf(value);\r\n            if (typeChecker(ValueType, value)) { return value; } // Value matches type\r\n            throw new Error(errorMessageCall(\r\n                {contextName, valueName, value, expectedTypeName, foundTypeName, messageSuffix}\r\n            ));\r\n        },\r\n\r\n    /**\r\n     * Gets the error message thrower seeded with passed in errorMessage template call.\r\n     * @function module:errorThrowing.getErrorIfNotTypesThrower$\r\n     * @param errorMessageCall {Function|ErrorMessageCall}\r\n     * @param typeChecker {Function|TypeChecker} - Function<Type, value>:Boolean\r\n     * @returns {Function|ErrorIfNotTypes}\r\n     * @private\r\n     */\r\n    _getErrorIfNotTypesThrower = (errorMessageCall, typeChecker = isOfType) =>\r\n        (valueTypes, contextName, valueName, value, messageSuffix = null) => {\r\n            const expectedTypeNames = valueTypes.map(toTypeRef),\r\n                matchFound = valueTypes.some(ValueType => typeChecker(ValueType, value)),\r\n                foundTypeName = typeOf(value);\r\n            if (matchFound) { return value; }\r\n            throw new Error(\r\n                errorMessageCall({\r\n                    contextName, valueName, value,\r\n                    expectedTypeName: expectedTypeNames, foundTypeName,\r\n                    messageSuffix\r\n                })\r\n            );\r\n        },\r\n\r\n    /**\r\n     * Checks that passed in `value` is of given `type`.  Throws an error if value\r\n     * is not of given `type`.  This is the un-curried version.  For the curried version\r\n     * see `module:errorThrowing.errorIfNotType`.\r\n     * @function module:errorThrowing.errorIfNotType$\r\n     * @param type {String|Function} - Type's name or type itself.\r\n     * @param contextName {String} - Name of context to attribute errors if thrown.\r\n     * @param valueName {String} - String rep of value.\r\n     * @param value {*}\r\n     * @param [messageSuffix=null] {String} - Optional.\r\n     * @returns {*} - Given `value` if `value` matches passed in type.\r\n     * @private\r\n     */\r\n    _errorIfNotType = _getErrorIfNotTypeThrower(defaultErrorMessageCall),\r\n\r\n    /**\r\n     * Checks that passed in `value` is of one of the given `types`.  Throws an error if value\r\n     *  is not of one of the given `types`.  This is the un-curried version.  For the curried version\r\n     * see `module:errorThrowing.errorIfNotTypes`.\r\n     * @type {Function|module:errorThrowing.errorIfNotTypes}\r\n     * @function module:errorThrowing.errorIfNotTypes$\r\n     * @param types {Array} - Array of one or more types or type names themselves.\r\n     * @param contextName {String} - Name of context to attribute errors if thrown.\r\n     * @param valueName {String} - String rep of value.\r\n     * @param value {*}\r\n     * @returns {*} - Given `value` if `value` matches passed in type.\r\n     * @private\r\n     */\r\n    _errorIfNotTypes = _getErrorIfNotTypesThrower(defaultErrorMessageCall),\r\n\r\n    /**\r\n     * Returns a function that can be used to ensure that values are of a given type.\r\n     *   Also throws informative error messages containing the value types, names, expected type names,\r\n     *   etc.\r\n     * @function module:errorThrowing.getErrorIfNotTypeThrower\r\n     * @param errorMessageCall {Function|ErrorMessageCall} - Template function (takes an info-object and returns a printed string).\r\n     * @returns {Function|ErrorIfNotType} - Returns a function with the same signature as `errorIfNotType` though curried.\r\n     */\r\n    getErrorIfNotTypeThrower = errorMessageCall => curry(_getErrorIfNotTypeThrower(errorMessageCall)),\r\n\r\n    /**\r\n     * Returns a function that can be used to ensure that a value is of one or more given types.\r\n     *   The returned function is used in cases where informative error messages\r\n     *   containing the value types, names, expected type names, are-required/should-be-used etc.\r\n     * @function module:errorThrowing.getErrorIfNotTypesThrower\r\n     * @param errorMessageCall {Function|ErrorMessageCall} - Template function (takes an info-object and returns a printed string).\r\n     * @returns {Function|ErrorIfNotTypes} - Returns a function with the same signature as `errorIfNotTypes` though curried.\r\n     */\r\n    getErrorIfNotTypesThrower = errorMessageCall => curry(_getErrorIfNotTypesThrower(errorMessageCall)),\r\n\r\n    /**\r\n     * Checks that passed in `value` is of given `type`.  Throws an error if value\r\n     * is not of given `type`.  Curried.\r\n     * @function module:errorThrowing.errorIfNotType\r\n     * @param type {String|Function} - Type's name or type itself.\r\n     * @param contextName {String} - Name of context to attribute errors if thrown.\r\n     * @param valueName {String} - String rep of value.\r\n     * @param value {*}\r\n     * @param [messageSuffix=null] {String} - Optional.\r\n     * @returns {*} - Given `value` if `value` matches passed in type.\r\n     * @curried\r\n     */\r\n    errorIfNotType = curry(_errorIfNotType),\r\n\r\n    /**\r\n     * Checks that passed in `value` is of one of the given `types`.  Throws an error if value\r\n     *  is not of one of the given `types`.  Curried.\r\n     * @function module:errorThrowing.errorIfNotTypes\r\n     * @param types {Array} - Array of one or more types or type names themselves.\r\n     * @param contextName {String} - Name of context to attribute errors if thrown.\r\n     * @param valueName {String} - String rep of value.\r\n     * @param value {*}\r\n     * @returns {*} - Given `value` if `value` matches passed in type.\r\n     * @curried\r\n     */\r\n    errorIfNotTypes = curry(_errorIfNotTypes)\r\n;\r\n\r\n/**\r\n * @typedef {*} Any - Synonym for 'any value'.\r\n */\r\n\r\n/**\r\n * @typedef {String|Function} TypeRef\r\n * @description Type reference.  Type itself or Type's name;  E.g., `Type.name`;\r\n */\r\n\r\n/**\r\n * @typedef {Object<value, valueName, expectedTypeName, foundTypeName, messageSuffix>} TemplateContext\r\n * @description Template context used for error message renderers (functions that take a context obj and return a string).\r\n * @property value {*}\r\n * @property valueName {String}\r\n * @property expectedTypeName {String} - Expected name of constructor of `value`;  E.g., usually `SomeConstructor.name`;\r\n * @property foundTypeName {String} - Found types name;  E.g., `FoundConstructor.name`;\r\n * @property [messageSuffix=null] {*} - Message suffix (sometimes an extra hint or instructions for\r\n *  directing user to fix where his/her error has occurred).  Optional.\r\n */\r\n\r\n/**\r\n * @typedef {Array<(String|Function)>} TypesArray\r\n */\r\n\r\n/**\r\n * @typedef {Function} TypeChecker\r\n * @description Checks whether a value is of given type.\r\n * @param Type {TypeRef} - a Type or it's name;  E.g., `Type.name`.\r\n * @param value {*}\r\n * @returns {Boolean}\r\n */\r\n\r\n/**\r\n * @typedef {Function} ErrorMessageCall\r\n * @description Error message template function.\r\n * @param tmplContext {TemplateContext}\r\n * @returns {String}\r\n */\r\n\r\n/**\r\n * @typedef {Function} ErrorIfNotType\r\n * @description Used to ensure value matches passed in type.\r\n * @param type {TypeRef} - Constructor name or constructor.\r\n * @param contextName {String}\r\n * @param valueName {String}\r\n * @param value {*}\r\n * @throws {Error} - If value doesn't match type.\r\n * @returns {*} - What ever value is.\r\n */\r\n\r\n/**\r\n * @typedef {Function} ErrorIfNotTypes\r\n * @description Used to ensure a value matches one of one or more types passed in.\r\n * @param valueTypes {TypesArray} - Array of constructor names or constructors.\r\n * @param contextName {String}\r\n * @param valueName {String}\r\n * @param value {*}\r\n * @throws {Error} - If value doesn't match type.\r\n * @returns {*} - Whatever value is.\r\n */\r\n","/**\r\n * @module string\r\n * @description Contains functions for strings.\r\n */\r\nimport {intercalate, map, filter} from './list';\r\nimport {split} from './jsPlatform/string';\r\nimport {compose} from './function/compose';\r\nimport {join} from './jsPlatform/array';\r\nimport {_errorIfNotType} from './errorThrowing';\r\n\r\nexport {split};\r\n\r\nexport const\r\n\r\n    /**\r\n     * Splits a string on all '\\n', '\\r', '\\n\\r', or '\\r\\n' characters.\r\n     * @function module:string.lines\r\n     * @param str {String}\r\n     * @returns {Array}\r\n     */\r\n    lines = split(/[\\n\\r]/gm),\r\n\r\n    /**\r\n     * Splits a string on all '\\s' and/or all '\\t' characters.\r\n     * @function module:string.words\r\n     * @param str{String}\r\n     * @returns {Array}\r\n     */\r\n    words = split(/[\\s\\t]/gm),\r\n\r\n    /**\r\n     * Intersperse an array of strings with '\\s' and then concats them.\r\n     * @function module:string.unwords\r\n     * @param arr {String}\r\n     * @returns {Array}\r\n     */\r\n    unwords = intercalate(' '),\r\n\r\n    /**\r\n     * Intersperses a '\\n' character into a list of strings and then concats it.\r\n     * @function module:string.unlines\r\n     * @param list {Array|String|*}\r\n     * @returns {Array}\r\n     */\r\n    unlines = intercalate('\\n'),\r\n\r\n    /**\r\n     * Lower cases first character of a non-empty string.\r\n     * @function module:string.lcaseFirst\r\n     * @param xs {String}\r\n     * @returns {string}\r\n     * @throws {Error} - Throws error if receiving anything that is not a string.\r\n     */\r\n    lcaseFirst = xs => {\r\n        _errorIfNotType(String, 'lcaseFirst', 'xs', xs);\r\n        return xs[0].toLowerCase() + xs.substring(1);\r\n    },\r\n\r\n    /**\r\n     * Upper cases first character of a non-empty string.\r\n     * @function module:string.ucaseFirst\r\n     * @param xs {String}\r\n     * @returns {string}\r\n     * @throws {Error} - Throws error if receiving anything that is not a string.\r\n     */\r\n    ucaseFirst = xs => {\r\n        _errorIfNotType(String, 'ucaseFirst', 'xs', xs);\r\n        return xs[0].toUpperCase() + xs.substring(1);\r\n    },\r\n\r\n    /**\r\n     * Camel cases (class case) a string.\r\n     * @function module:string.camelCase\r\n     * @param xs {String}\r\n     * @param [pattern=/[^a-z\\d/i]/] {RegExp} - Pattern to split on.  Optional.\r\n     * @throws {Error} - Throws error if param `xs` is not a string.\r\n     * @returns {string}\r\n     * @curried\r\n     */\r\n    camelCase = (xs, pattern = /[^a-z\\d]/i) => compose(\r\n            join(''),\r\n            map(str => ucaseFirst(str.toLowerCase())),\r\n            filter(x => !!x),\r\n            split(pattern)\r\n        )(_errorIfNotType(String, 'camelCase', 'xs', xs)),\r\n\r\n    /**\r\n     * Class cases a string.  Uses pattern /[^a-z\\d/i]/ to split on.\r\n     * If you require a different pattern use `string.camelCase(str, pattern)`\r\n     * and then upper case first character (`ucaseFirst`).\r\n     * @function module:string.classCase\r\n     * @param xs {String}\r\n     * @returns {string}\r\n     * @throws {Error} - Throws error if `xs` is not a string (via `camelCase` call).\r\n     */\r\n    classCase = compose(ucaseFirst, camelCase)\r\n\r\n;\r\n\r\n/**\r\n * Functional version of `String.prototype.split`.\r\n * @function module:string.split\r\n * @param separator {String|RegExp}\r\n * @param str {String}\r\n * @returns {Array}\r\n */\r\n","/**\r\n * @module fjl\r\n * @description Exports all module methods (object, list, string modules etc.).\r\n * @goal to include everything from haskell's Prelude where it makes sense in order to create\r\n *  a subset of functions which can make the javascript developer more efficient and make his/her\r\n *  code more concise (and functional).\r\n * @motivation preludejs, lodash/fp, RamdaJs, Haskell.\r\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html\r\n * @see http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-List.html\r\n */\r\nexport * from './object';\r\nexport * from './boolean';\r\nexport * from './function';\r\nexport * from './list';\r\nexport * from './string';\r\nexport * from './utils';\r\nexport * from './errorThrowing';\r\n\r\nimport * as _jsPlatform from './jsPlatform';\r\n\r\nexport const jsPlatform = _jsPlatform;\r\n\r\n/**\r\n * @typedef {String|Function|ArrayBufferConstructor|ArrayConstructor|BooleanConstructor|MapConstructor|NumberConstructor|SetConstructor|WeakMapConstructor|WeakSetConstructor} TypeRef\r\n * @description Type reference.  Either actual type or type's name;  E.g., `Type.name`\r\n * Also note: Class cased names are use for values that do not have `name` properties;  Namely: 'Null', 'NaN' and 'Undefined' (for their respective values respectively).\r\n */\r\n"],"names":["returnCurried","executeArity","unmetArityNum","fn","argsToCurry","func","x","executeAsCurriedFunc","Array","from","arguments","a","b","c","d","e","args","unmetArity","concatedArgs","concat","canBeCalled","length","newExpectedArity","curryN","Function","Error","curry","curry2","curry3","curry4","curry5","fPureTakesOne","name","arg","f","fPureTakes2","arg1","arg2","fPureTakes3","arg3","fPureTakes4","arg4","fPureTakes5","arg5","fPureTakesOneOrMore","defineReverse","prototype","reverse","reduceRight","agg","item","push","map","filter","reduce","forEach","some","every","join","apply","call","flipN","flip","flip3","flip4","flip5","instanceOf","instanceConstructor","instance","hasOwnProperty","native","Object","getOwnPropertyNames","key","operation","keys","assign","obj0","objs","topAgg","obj","_Number","Number","_NaN","_Null","_Undefined","typeOf","value","retVal","undefined","constructorName","constructor","isNaN","_String","String","_Object","_Boolean","Boolean","_Symbol","_Map","_Set","_WeakMap","_WeakSet","toTypeRef","type","toTypeRefs","types","toTypeRefName","Type","ref","toTypeRefNames","isFunction","isType","isStrictly","isOfType","isLoosely","isClass","test","substr","isCallable","isArray","isObject","isBoolean","isNumber","isString","isMap","isSet","isWeakMap","isWeakSet","isUndefined","isNull","isSymbol","isUsableImmutablePrimitive","typeOfX","isset","isEmptyList","isEmptyObject","isEmptyCollection","size","isEmpty","isOneOf","typeName","isStrictlyOneOf","isLooselyOneOf","instanceOfOne","isFunctor","lookup","of","copy","out","slice","Symbol","Promise","searchObj","nsString","indexOf","parts","split","limit","ind","parent","node","assignDeep","propDescription","getOwnPropertyDescriptor","get","set","writable","includes","xs","lastIndexOf","isTruthy","isFalsy","alwaysTrue","alwaysFalse","equal","equalAll","i","aggregateArray","sliceFrom","startInd","sliceTo","toInd","sliceCopy","genericAscOrdering","lengths","lists","toShortest","listLengths","smallLen","Math","min","list","reduceUntil","pred","op","result","reduceUntilRight","arr","lastIndex","len","findIndexWhere","predicateFulfilled","findIndexWhereRight","findIndicesWhere","findWhere","elm","objUnion","obj1","obj2","objIntersect","objDifference","objComplement","log","console","bind","error","peek","pop","warn","jsonClone","JSON","parse","stringify","toAssocList","toAssocListDeep","TypeConstraint","fromAssocList","OutType","fromAssocListDeep","toArray","compose","arg0","id","negateF","negateF2","negateF3","negateFN","until","predicate","typeInstance","fnOrError","symbolName","noop","trampoline","fnName","toFunction","normalizeStep","to","step","range","append","listAppend","head","last","tail","init","uncons","unconsr","item0","concatMap","foldableOfA","intersperse","between","lastInd","intercalate","xss","transpose","numLists","ind2","longestListLen","maximum","outLists","outList","subsequences","listLen","pow","entry","j","swapped","ind1","tmp","permutations","repeat","foldl","foldr","foldl1","foldr1","mapAccumL","zero","mapped","tuple","mapAccumR","iterate","lastX","replicate","cycle","unfoldr","resultTuple","findIndex","findIndices","elemIndex","foundInd","elemIndices","take","drop","splitAt","takeWhile","dropWhile","splitPoint","dropWhileEnd","span","breakOnList","at","find","partition","elem","notElem","isPrefixOf","xs1","xs2","limit1","limit2","isSuffixOf","isInfixOf","foundLen","isSubsequenceOf","lenXs1","group","groupBy","equalityOp","prevItem","predOp","inits","tails","stripPrefix","prefix","zip","arr1","arr2","a1","a2","zipN","trimmedLists","zip3","arr3","zip4","arr4","zip5","arr5","zipWith","zipWithN","lenOfTrimmed","zipWith3","xs3","zipWith4","xs4","zipWith5","xs5","unzip","unzipN","lenItem0","any","p","all","and","or","not","sum","product","sortBy","minimum","scanl","scanl1","scanr","scanr1","nub","nubBy","remove","removeBy","sort","sortOn","valueFn","decorated","a0","b0","orderingFn","insert","foundIndex","insertBy","currItem","anyOp","storedItem","removeFirstsBy","unionBy","alreadyAdded","union","intersect","intersectBy","list1","list2","difference","array1","array2","complement","arr0","arrays","typeRefsToStringOrError","defaultErrorMessageCall","tmplContext","contextName","valueName","expectedTypeName","foundTypeName","messageSuffix","isMultiTypeNames","typesCopy","typesToMatchCopy","_getErrorIfNotTypeThrower","errorMessageCall","typeChecker","ValueType","_getErrorIfNotTypesThrower","valueTypes","expectedTypeNames","matchFound","_errorIfNotType","_errorIfNotTypes","getErrorIfNotTypeThrower","getErrorIfNotTypesThrower","errorIfNotType","errorIfNotTypes","lines","words","unwords","unlines","lcaseFirst","toLowerCase","substring","ucaseFirst","toUpperCase","camelCase","pattern","str","classCase","jsPlatform","_jsPlatform"],"mappings":"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"}